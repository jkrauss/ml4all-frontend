(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp(target, name2, {get: all2[name2], enumerable: true});
  };

  // dist/build/workbox-window.prod.es5.js
  var require_workbox_window_prod_es5 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      Workbox: () => f,
      messageSW: () => n
    });
    (function(l, r2) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r2 = l.createElement("script");
      r2.async = 1;
      r2.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r2.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r2);
    })(self.document);
    try {
      self["workbox:window:5.1.4"] && _();
    } catch (n2) {
    }
    function n(n2, t2) {
      return new Promise(function(r2) {
        var e2 = new MessageChannel();
        e2.port1.onmessage = function(n3) {
          r2(n3.data);
        }, n2.postMessage(t2, [e2.port2]);
      });
    }
    function t(n2, t2) {
      for (var r2 = 0; r2 < t2.length; r2++) {
        var e2 = t2[r2];
        e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(n2, e2.key, e2);
      }
    }
    function r(n2, t2) {
      (t2 == null || t2 > n2.length) && (t2 = n2.length);
      for (var r2 = 0, e2 = new Array(t2); r2 < t2; r2++)
        e2[r2] = n2[r2];
      return e2;
    }
    function e(n2, t2) {
      var e2;
      if (typeof Symbol == "undefined" || n2[Symbol.iterator] == null) {
        if (Array.isArray(n2) || (e2 = function(n3, t3) {
          if (n3) {
            if (typeof n3 == "string")
              return r(n3, t3);
            var e3 = Object.prototype.toString.call(n3).slice(8, -1);
            return e3 === "Object" && n3.constructor && (e3 = n3.constructor.name), e3 === "Map" || e3 === "Set" ? Array.from(n3) : e3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3) ? r(n3, t3) : void 0;
          }
        }(n2)) || t2 && n2 && typeof n2.length == "number") {
          e2 && (n2 = e2);
          var i2 = 0;
          return function() {
            return i2 >= n2.length ? {done: true} : {done: false, value: n2[i2++]};
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      return (e2 = n2[Symbol.iterator]()).next.bind(e2);
    }
    try {
      self["workbox:core:5.1.4"] && _();
    } catch (n2) {
    }
    var i = function() {
      var n2 = this;
      this.promise = new Promise(function(t2, r2) {
        n2.resolve = t2, n2.reject = r2;
      });
    };
    function o(n2, t2) {
      var r2 = location.href;
      return new URL(n2, r2).href === new URL(t2, r2).href;
    }
    var u = function(n2, t2) {
      this.type = n2, Object.assign(this, t2);
    };
    function a(n2, t2, r2) {
      return r2 ? t2 ? t2(n2) : n2 : (n2 && n2.then || (n2 = Promise.resolve(n2)), t2 ? n2.then(t2) : n2);
    }
    function c() {
    }
    var f = function(r2) {
      var e2, c2;
      function f2(n2, t2) {
        var e3, c3;
        return t2 === void 0 && (t2 = {}), (e3 = r2.call(this) || this).t = {}, e3.i = 0, e3.o = new i(), e3.u = new i(), e3.s = new i(), e3.v = 0, e3.h = new Set(), e3.l = function() {
          var n3 = e3.m, t3 = n3.installing;
          e3.i > 0 || !o(t3.scriptURL, e3.g) || performance.now() > e3.v + 6e4 ? (e3.p = t3, n3.removeEventListener("updatefound", e3.l)) : (e3.P = t3, e3.h.add(t3), e3.o.resolve(t3)), ++e3.i, t3.addEventListener("statechange", e3.S);
        }, e3.S = function(n3) {
          var t3 = e3.m, r3 = n3.target, i2 = r3.state, o2 = r3 === e3.p, a2 = o2 ? "external" : "", c4 = {sw: r3, originalEvent: n3};
          !o2 && e3.j && (c4.isUpdate = true), e3.dispatchEvent(new u(a2 + i2, c4)), i2 === "installed" ? e3.A = self.setTimeout(function() {
            i2 === "installed" && t3.waiting === r3 && e3.dispatchEvent(new u(a2 + "waiting", c4));
          }, 200) : i2 === "activating" && (clearTimeout(e3.A), o2 || e3.u.resolve(r3));
        }, e3.O = function(n3) {
          var t3 = e3.P;
          t3 === navigator.serviceWorker.controller && (e3.dispatchEvent(new u("controlling", {sw: t3, originalEvent: n3, isUpdate: e3.j})), e3.s.resolve(t3));
        }, e3.U = (c3 = function(n3) {
          var t3 = n3.data, r3 = n3.source;
          return a(e3.getSW(), function() {
            e3.h.has(r3) && e3.dispatchEvent(new u("message", {data: t3, sw: r3, originalEvent: n3}));
          });
        }, function() {
          for (var n3 = [], t3 = 0; t3 < arguments.length; t3++)
            n3[t3] = arguments[t3];
          try {
            return Promise.resolve(c3.apply(this, n3));
          } catch (n4) {
            return Promise.reject(n4);
          }
        }), e3.g = n2, e3.t = t2, navigator.serviceWorker.addEventListener("message", e3.U), e3;
      }
      c2 = r2, (e2 = f2).prototype = Object.create(c2.prototype), e2.prototype.constructor = e2, e2.__proto__ = c2;
      var v, h, m = f2.prototype;
      return m.register = function(n2) {
        var t2 = (n2 === void 0 ? {} : n2).immediate, r3 = t2 !== void 0 && t2;
        try {
          var e3 = this;
          return function(n3, t3) {
            var r4 = n3();
            if (r4 && r4.then)
              return r4.then(t3);
            return t3(r4);
          }(function() {
            if (!r3 && document.readyState !== "complete")
              return s(new Promise(function(n3) {
                return window.addEventListener("load", n3);
              }));
          }, function() {
            return e3.j = Boolean(navigator.serviceWorker.controller), e3.I = e3.M(), a(e3.R(), function(n3) {
              e3.m = n3, e3.I && (e3.P = e3.I, e3.u.resolve(e3.I), e3.s.resolve(e3.I), e3.I.addEventListener("statechange", e3.S, {once: true}));
              var t3 = e3.m.waiting;
              return t3 && o(t3.scriptURL, e3.g) && (e3.P = t3, Promise.resolve().then(function() {
                e3.dispatchEvent(new u("waiting", {sw: t3, wasWaitingBeforeRegister: true}));
              }).then(function() {
              })), e3.P && (e3.o.resolve(e3.P), e3.h.add(e3.P)), e3.m.addEventListener("updatefound", e3.l), navigator.serviceWorker.addEventListener("controllerchange", e3.O, {once: true}), e3.m;
            });
          });
        } catch (n3) {
          return Promise.reject(n3);
        }
      }, m.update = function() {
        try {
          return this.m ? s(this.m.update()) : void 0;
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.getSW = function() {
        try {
          return this.P !== void 0 ? this.P : this.o.promise;
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.messageSW = function(t2) {
        try {
          return a(this.getSW(), function(r3) {
            return n(r3, t2);
          });
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.M = function() {
        var n2 = navigator.serviceWorker.controller;
        return n2 && o(n2.scriptURL, this.g) ? n2 : void 0;
      }, m.R = function() {
        try {
          var n2 = this;
          return function(n3, t2) {
            try {
              var r3 = n3();
            } catch (n4) {
              return t2(n4);
            }
            if (r3 && r3.then)
              return r3.then(void 0, t2);
            return r3;
          }(function() {
            return a(navigator.serviceWorker.register(n2.g, n2.t), function(t2) {
              return n2.v = performance.now(), t2;
            });
          }, function(n3) {
            throw n3;
          });
        } catch (n3) {
          return Promise.reject(n3);
        }
      }, v = f2, (h = [{key: "active", get: function() {
        return this.u.promise;
      }}, {key: "controlling", get: function() {
        return this.s.promise;
      }}]) && t(v.prototype, h), f2;
    }(function() {
      function n2() {
        this.k = new Map();
      }
      var t2 = n2.prototype;
      return t2.addEventListener = function(n3, t3) {
        this.B(n3).add(t3);
      }, t2.removeEventListener = function(n3, t3) {
        this.B(n3).delete(t3);
      }, t2.dispatchEvent = function(n3) {
        n3.target = this;
        for (var t3, r2 = e(this.B(n3.type)); !(t3 = r2()).done; ) {
          (0, t3.value)(n3);
        }
      }, t2.B = function(n3) {
        return this.k.has(n3) || this.k.set(n3, new Set()), this.k.get(n3);
      }, n2;
    }());
    function s(n2, t2) {
      if (!t2)
        return n2 && n2.then ? n2.then(c) : Promise.resolve();
    }
  });

  // dist/build/_fallback.js
  var require_fallback = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Fallback
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var file10 = "src/pages/_fallback.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-viq1pm", ".huge.svelte-viq1pm{font-size:12rem}.e404.svelte-viq1pm{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2ZhbGxiYWNrLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFDRSxLQUFBLGNBQUEsQ0FBQSxBQUNFLFNBQUEsQ0FBQSxLQUFnQixBQUNsQixDQUFBLEFBQ0EsS0FBQSxjQUFBLENBQUEsQUFDRSxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsSUFBQSxDQUFBLEdBQVMsQ0FDVCxHQUFBLENBQUEsR0FBUSxDQUNSLFNBQUEsQ0FBQSxVQUFBLElBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBZ0MsQ0FDaEMsVUFBQSxDQUFBLE1BQWtCLEFBQ3BCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzL3NyYy9wYWdlcy9fZmFsbGJhY2suc3ZlbHRlIl19 */");
    }
    function create_fragment10(ctx) {
      let div2;
      let div0;
      let t1;
      let div1;
      let t2;
      let a;
      let t3;
      let a_href_value;
      const block = {
        c: function create2() {
          div2 = element("div");
          div0 = element("div");
          div0.textContent = "404";
          t1 = space();
          div1 = element("div");
          t2 = text("Seite nicht gefunden. \n  \n  ");
          a = element("a");
          t3 = text("zur\xFCck");
          attr_dev(div0, "class", "huge svelte-viq1pm");
          add_location(div0, file10, 18, 2, 264);
          attr_dev(a, "href", a_href_value = ctx[0]("../"));
          add_location(a, file10, 21, 2, 393);
          attr_dev(div1, "class", "big");
          add_location(div1, file10, 19, 2, 294);
          attr_dev(div2, "class", "e404 svelte-viq1pm");
          add_location(div2, file10, 17, 0, 243);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div2, t1);
          append_dev(div2, div1);
          append_dev(div1, t2);
          append_dev(div1, a);
          append_dev(a, t3);
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 1 && a_href_value !== (a_href_value = ctx2[0]("../"))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let $url;
      validate_store(url, "url");
      component_subscribe($$self, url, ($$value) => $$invalidate(0, $url = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Fallback", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Fallback> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({url, $url});
      return [$url];
    }
    var Fallback = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Fallback",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/dashboard.js
  var require_dashboard = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Dashboard
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    /*!
     * Chart.js v3.7.0
     * https://www.chartjs.org
     * (c) 2021 Chart.js Contributors
     * Released under the MIT License
     */
    var requestAnimFrame = function() {
      if (typeof window === "undefined") {
        return function(callback2) {
          return callback2();
        };
      }
      return window.requestAnimationFrame;
    }();
    function throttled(fn, thisArg, updateFn) {
      const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
      let ticking = false;
      let args = [];
      return function(...rest) {
        args = updateArgs(rest);
        if (!ticking) {
          ticking = true;
          requestAnimFrame.call(window, () => {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        if (delay) {
          clearTimeout(timeout);
          timeout = setTimeout(fn, delay, args);
        } else {
          fn.apply(this, args);
        }
        return delay;
      };
    }
    var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
    var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
    var _textX = (align, left, right, rtl) => {
      const check = rtl ? "left" : "right";
      return align === check ? right : align === "center" ? (left + right) / 2 : left;
    };
    function noop2() {
    }
    var uid = function() {
      let id = 0;
      return function() {
        return id++;
      };
    }();
    function isNullOrUndef(value) {
      return value === null || typeof value === "undefined";
    }
    function isArray2(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }
      const type = Object.prototype.toString.call(value);
      if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
        return true;
      }
      return false;
    }
    function isObject2(value) {
      return value !== null && Object.prototype.toString.call(value) === "[object Object]";
    }
    var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
    function finiteOrDefault(value, defaultValue) {
      return isNumberFinite(value) ? value : defaultValue;
    }
    function valueOrDefault(value, defaultValue) {
      return typeof value === "undefined" ? defaultValue : value;
    }
    var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
    var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
    function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === "function") {
        return fn.apply(thisArg, args);
      }
    }
    function each(loopable, fn, thisArg, reverse) {
      let i, len, keys;
      if (isArray2(loopable)) {
        len = loopable.length;
        if (reverse) {
          for (i = len - 1; i >= 0; i--) {
            fn.call(thisArg, loopable[i], i);
          }
        } else {
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[i], i);
          }
        }
      } else if (isObject2(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
      }
    }
    function _elementsEqual(a0, a1) {
      let i, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }
      for (i = 0, ilen = a0.length; i < ilen; ++i) {
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
          return false;
        }
      }
      return true;
    }
    function clone$1(source2) {
      if (isArray2(source2)) {
        return source2.map(clone$1);
      }
      if (isObject2(source2)) {
        const target = Object.create(null);
        const keys = Object.keys(source2);
        const klen = keys.length;
        let k = 0;
        for (; k < klen; ++k) {
          target[keys[k]] = clone$1(source2[keys[k]]);
        }
        return target;
      }
      return source2;
    }
    function isValidKey(key) {
      return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
    }
    function _merger(key, target, source2, options) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source2[key];
      if (isObject2(tval) && isObject2(sval)) {
        merge2(tval, sval, options);
      } else {
        target[key] = clone$1(sval);
      }
    }
    function merge2(target, source2, options) {
      const sources = isArray2(source2) ? source2 : [source2];
      const ilen = sources.length;
      if (!isObject2(target)) {
        return target;
      }
      options = options || {};
      const merger = options.merger || _merger;
      for (let i = 0; i < ilen; ++i) {
        source2 = sources[i];
        if (!isObject2(source2)) {
          continue;
        }
        const keys = Object.keys(source2);
        for (let k = 0, klen = keys.length; k < klen; ++k) {
          merger(keys[k], target, source2, options);
        }
      }
      return target;
    }
    function mergeIf(target, source2) {
      return merge2(target, source2, {merger: _mergerIf});
    }
    function _mergerIf(key, target, source2) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source2[key];
      if (isObject2(tval) && isObject2(sval)) {
        mergeIf(tval, sval);
      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone$1(sval);
      }
    }
    var emptyString = "";
    var dot = ".";
    function indexOfDotOrLength(key, start) {
      const idx = key.indexOf(dot, start);
      return idx === -1 ? key.length : idx;
    }
    function resolveObjectKey(obj, key) {
      if (key === emptyString) {
        return obj;
      }
      let pos = 0;
      let idx = indexOfDotOrLength(key, pos);
      while (obj && idx > pos) {
        obj = obj[key.substr(pos, idx - pos)];
        pos = idx + 1;
        idx = indexOfDotOrLength(key, pos);
      }
      return obj;
    }
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    var defined = (value) => typeof value !== "undefined";
    var isFunction2 = (value) => typeof value === "function";
    var setsEqual = (a, b) => {
      if (a.size !== b.size) {
        return false;
      }
      for (const item of a) {
        if (!b.has(item)) {
          return false;
        }
      }
      return true;
    };
    function _isClickEvent(e) {
      return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
    }
    var PI = Math.PI;
    var TAU = 2 * PI;
    var PITAU = TAU + PI;
    var INFINITY = Number.POSITIVE_INFINITY;
    var RAD_PER_DEG = PI / 180;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    var log10 = Math.log10;
    var sign = Math.sign;
    function niceNum(range) {
      const roundedRange = Math.round(range);
      range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
      const niceRange = Math.pow(10, Math.floor(log10(range)));
      const fraction = range / niceRange;
      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
      return niceFraction * niceRange;
    }
    function _factorize(value) {
      const result = [];
      const sqrt = Math.sqrt(value);
      let i;
      for (i = 1; i < sqrt; i++) {
        if (value % i === 0) {
          result.push(i);
          result.push(value / i);
        }
      }
      if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
      }
      result.sort((a, b) => a - b).pop();
      return result;
    }
    function isNumber2(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostEquals(x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    }
    function almostWhole(x, epsilon) {
      const rounded = Math.round(x);
      return rounded - epsilon <= x && rounded + epsilon >= x;
    }
    function _setMinAndMaxByKey(array, target, property) {
      let i, ilen, value;
      for (i = 0, ilen = array.length; i < ilen; i++) {
        value = array[i][property];
        if (!isNaN(value)) {
          target.min = Math.min(target.min, value);
          target.max = Math.max(target.max, value);
        }
      }
    }
    function toRadians(degrees) {
      return degrees * (PI / 180);
    }
    function toDegrees(radians) {
      return radians * (180 / PI);
    }
    function _decimalPlaces(x) {
      if (!isNumberFinite(x)) {
        return;
      }
      let e = 1;
      let p = 0;
      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }
      return p;
    }
    function getAngleFromPoint(centrePoint, anglePoint) {
      const distanceFromXCenter = anglePoint.x - centrePoint.x;
      const distanceFromYCenter = anglePoint.y - centrePoint.y;
      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < -0.5 * PI) {
        angle += TAU;
      }
      return {
        angle,
        distance: radialDistanceFromCenter
      };
    }
    function distanceBetweenPoints(pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    }
    function _angleDiff(a, b) {
      return (a - b + PITAU) % TAU - PI;
    }
    function _normalizeAngle(a) {
      return (a % TAU + TAU) % TAU;
    }
    function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
      const a = _normalizeAngle(angle);
      const s = _normalizeAngle(start);
      const e = _normalizeAngle(end);
      const angleToStart = _normalizeAngle(s - a);
      const angleToEnd = _normalizeAngle(e - a);
      const startToAngle = _normalizeAngle(a - s);
      const endToAngle = _normalizeAngle(a - e);
      return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
    }
    function _limitValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    function _int16Range(value) {
      return _limitValue(value, -32768, 32767);
    }
    function _isBetween(value, start, end, epsilon = 1e-6) {
      return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
    }
    var atEdge = (t) => t === 0 || t === 1;
    var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
    var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
    var effects = {
      linear: (t) => t,
      easeInQuad: (t) => t * t,
      easeOutQuad: (t) => -t * (t - 2),
      easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
      easeInCubic: (t) => t * t * t,
      easeOutCubic: (t) => (t -= 1) * t * t + 1,
      easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
      easeInQuart: (t) => t * t * t * t,
      easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
      easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: (t) => t * t * t * t * t,
      easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
      easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
      easeOutSine: (t) => Math.sin(t * HALF_PI),
      easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
      easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
      easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
      easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
      easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
      easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
      easeInOutElastic(t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
      },
      easeInBack(t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack(t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack(t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
      easeOutBounce(t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) {
          return m * t * t;
        }
        if (t < 2 / d) {
          return m * (t -= 1.5 / d) * t + 0.75;
        }
        if (t < 2.5 / d) {
          return m * (t -= 2.25 / d) * t + 0.9375;
        }
        return m * (t -= 2.625 / d) * t + 0.984375;
      },
      easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
    };
    /*!
     * @kurkle/color v0.1.9
     * https://github.com/kurkle/color#readme
     * (c) 2020 Jukka Kurkela
     * Released under the MIT License
     */
    var map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
    var hex = "0123456789ABCDEF";
    var h1 = (b) => hex[b & 15];
    var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
    var eq = (b) => (b & 240) >> 4 === (b & 15);
    function isShort(v) {
      return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    }
    function hexParse(str) {
      var len = str.length;
      var ret;
      if (str[0] === "#") {
        if (len === 4 || len === 5) {
          ret = {
            r: 255 & map[str[1]] * 17,
            g: 255 & map[str[2]] * 17,
            b: 255 & map[str[3]] * 17,
            a: len === 5 ? map[str[4]] * 17 : 255
          };
        } else if (len === 7 || len === 9) {
          ret = {
            r: map[str[1]] << 4 | map[str[2]],
            g: map[str[3]] << 4 | map[str[4]],
            b: map[str[5]] << 4 | map[str[6]],
            a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
          };
        }
      }
      return ret;
    }
    function hexString(v) {
      var f = isShort(v) ? h1 : h2;
      return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
    }
    function round(v) {
      return v + 0.5 | 0;
    }
    var lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
      return lim(round(v * 2.55), 0, 255);
    }
    function n2b(v) {
      return lim(round(v * 255), 0, 255);
    }
    function b2n(v) {
      return lim(round(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
      return lim(round(v * 100), 0, 100);
    }
    var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
      const m = RGB_RE.exec(str);
      let a = 255;
      let r, g, b;
      if (!m) {
        return;
      }
      if (m[7] !== r) {
        const v = +m[7];
        a = 255 & (m[8] ? p2b(v) : v * 255);
      }
      r = +m[1];
      g = +m[3];
      b = +m[5];
      r = 255 & (m[2] ? p2b(r) : r);
      g = 255 & (m[4] ? p2b(g) : g);
      b = 255 & (m[6] ? p2b(b) : b);
      return {
        r,
        g,
        b,
        a
      };
    }
    function rgbString(v) {
      return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
    }
    var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
      const a = s * Math.min(l, 1 - l);
      const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
      const rgb = hsl2rgbn(h, 1, 0.5);
      let i;
      if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
      }
      return rgb;
    }
    function rgb2hsl(v) {
      const range = 255;
      const r = v.r / range;
      const g = v.g / range;
      const b = v.b / range;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;
      let h, s, d;
      if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h = h * 60 + 0.5;
      }
      return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
      return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
    }
    function hsl2rgb(h, s, l) {
      return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
      return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
      return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
      return (h % 360 + 360) % 360;
    }
    function hueParse(str) {
      const m = HUE_RE.exec(str);
      let a = 255;
      let v;
      if (!m) {
        return;
      }
      if (m[5] !== v) {
        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
      }
      const h = hue(+m[2]);
      const p1 = +m[3] / 100;
      const p2 = +m[4] / 100;
      if (m[1] === "hwb") {
        v = hwb2rgb(h, p1, p2);
      } else if (m[1] === "hsv") {
        v = hsv2rgb(h, p1, p2);
      } else {
        v = hsl2rgb(h, p1, p2);
      }
      return {
        r: v[0],
        g: v[1],
        b: v[2],
        a
      };
    }
    function rotate(v, deg) {
      var h = rgb2hsl(v);
      h[0] = hue(h[0] + deg);
      h = hsl2rgb(h);
      v.r = h[0];
      v.g = h[1];
      v.b = h[2];
    }
    function hslString(v) {
      if (!v) {
        return;
      }
      const a = rgb2hsl(v);
      const h = a[0];
      const s = n2p(a[1]);
      const l = n2p(a[2]);
      return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
    }
    var map$1 = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    };
    var names = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
    function unpack() {
      const unpacked = {};
      const keys = Object.keys(names);
      const tkeys = Object.keys(map$1);
      let i, j, k, ok, nk;
      for (i = 0; i < keys.length; i++) {
        ok = nk = keys[i];
        for (j = 0; j < tkeys.length; j++) {
          k = tkeys[j];
          nk = nk.replace(k, map$1[k]);
        }
        k = parseInt(names[ok], 16);
        unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
      }
      return unpacked;
    }
    var names$1;
    function nameParse(str) {
      if (!names$1) {
        names$1 = unpack();
        names$1.transparent = [0, 0, 0, 0];
      }
      const a = names$1[str.toLowerCase()];
      return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
      };
    }
    function modHSL(v, i, ratio) {
      if (v) {
        let tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
      }
    }
    function clone2(v, proto) {
      return v ? Object.assign(proto || {}, v) : v;
    }
    function fromObject(input) {
      var v = {r: 0, g: 0, b: 0, a: 255};
      if (Array.isArray(input)) {
        if (input.length >= 3) {
          v = {r: input[0], g: input[1], b: input[2], a: 255};
          if (input.length > 3) {
            v.a = n2b(input[3]);
          }
        }
      } else {
        v = clone2(input, {r: 0, g: 0, b: 0, a: 1});
        v.a = n2b(v.a);
      }
      return v;
    }
    function functionParse(str) {
      if (str.charAt(0) === "r") {
        return rgbParse(str);
      }
      return hueParse(str);
    }
    var Color = class {
      constructor(input) {
        if (input instanceof Color) {
          return input;
        }
        const type = typeof input;
        let v;
        if (type === "object") {
          v = fromObject(input);
        } else if (type === "string") {
          v = hexParse(input) || nameParse(input) || functionParse(input);
        }
        this._rgb = v;
        this._valid = !!v;
      }
      get valid() {
        return this._valid;
      }
      get rgb() {
        var v = clone2(this._rgb);
        if (v) {
          v.a = b2n(v.a);
        }
        return v;
      }
      set rgb(obj) {
        this._rgb = fromObject(obj);
      }
      rgbString() {
        return this._valid ? rgbString(this._rgb) : this._rgb;
      }
      hexString() {
        return this._valid ? hexString(this._rgb) : this._rgb;
      }
      hslString() {
        return this._valid ? hslString(this._rgb) : this._rgb;
      }
      mix(color2, weight) {
        const me = this;
        if (color2) {
          const c1 = me.rgb;
          const c2 = color2.rgb;
          let w2;
          const p = weight === w2 ? 0.5 : weight;
          const w = 2 * p - 1;
          const a = c1.a - c2.a;
          const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
          w2 = 1 - w1;
          c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
          c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
          c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
          c1.a = p * c1.a + (1 - p) * c2.a;
          me.rgb = c1;
        }
        return me;
      }
      clone() {
        return new Color(this.rgb);
      }
      alpha(a) {
        this._rgb.a = n2b(a);
        return this;
      }
      clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
      }
      greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
      }
      opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
      }
      negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
      }
      lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
      }
      darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
      }
      saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
      }
      desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
      }
      rotate(deg) {
        rotate(this._rgb, deg);
        return this;
      }
    };
    function index_esm(input) {
      return new Color(input);
    }
    var isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
    function color(value) {
      return isPatternOrGradient(value) ? value : index_esm(value);
    }
    function getHoverColor(value) {
      return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
    }
    var overrides = Object.create(null);
    var descriptors = Object.create(null);
    function getScope$1(node, key) {
      if (!key) {
        return node;
      }
      const keys = key.split(".");
      for (let i = 0, n = keys.length; i < n; ++i) {
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
      }
      return node;
    }
    function set(root, scope, values) {
      if (typeof scope === "string") {
        return merge2(getScope$1(root, scope), values);
      }
      return merge2(getScope$1(root, ""), scope);
    }
    var Defaults = class {
      constructor(_descriptors2) {
        this.animation = void 0;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
          "mousemove",
          "mouseout",
          "click",
          "touchstart",
          "touchmove"
        ];
        this.font = {
          family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          size: 12,
          style: "normal",
          lineHeight: 1.2,
          weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options) => getHoverColor(options.color);
        this.indexAxis = "x";
        this.interaction = {
          mode: "nearest",
          intersect: true
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = void 0;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors2);
      }
      set(scope, values) {
        return set(this, scope, values);
      }
      get(scope) {
        return getScope$1(this, scope);
      }
      describe(scope, values) {
        return set(descriptors, scope, values);
      }
      override(scope, values) {
        return set(overrides, scope, values);
      }
      route(scope, name2, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = "_" + name2;
        Object.defineProperties(scopeObject, {
          [privateName]: {
            value: scopeObject[name2],
            writable: true
          },
          [name2]: {
            enumerable: true,
            get() {
              const local = this[privateName];
              const target = targetScopeObject[targetName];
              if (isObject2(local)) {
                return Object.assign({}, target, local);
              }
              return valueOrDefault(local, target);
            },
            set(value) {
              this[privateName] = value;
            }
          }
        });
      }
    };
    var defaults3 = new Defaults({
      _scriptable: (name2) => !name2.startsWith("on"),
      _indexable: (name2) => name2 !== "events",
      hover: {
        _fallback: "interaction"
      },
      interaction: {
        _scriptable: false,
        _indexable: false
      }
    });
    function toFontString(font) {
      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
      }
      return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
    }
    function _measureText(ctx, data, gc, longest, string) {
      let textWidth = data[string];
      if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
      }
      if (textWidth > longest) {
        longest = textWidth;
      }
      return longest;
    }
    function _longestText(ctx, font, arrayOfThings, cache) {
      cache = cache || {};
      let data = cache.data = cache.data || {};
      let gc = cache.garbageCollect = cache.garbageCollect || [];
      if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
      }
      ctx.save();
      ctx.font = font;
      let longest = 0;
      const ilen = arrayOfThings.length;
      let i, j, jlen, thing, nestedThing;
      for (i = 0; i < ilen; i++) {
        thing = arrayOfThings[i];
        if (thing !== void 0 && thing !== null && isArray2(thing) !== true) {
          longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray2(thing)) {
          for (j = 0, jlen = thing.length; j < jlen; j++) {
            nestedThing = thing[j];
            if (nestedThing !== void 0 && nestedThing !== null && !isArray2(nestedThing)) {
              longest = _measureText(ctx, data, gc, longest, nestedThing);
            }
          }
        }
      }
      ctx.restore();
      const gcLen = gc.length / 2;
      if (gcLen > arrayOfThings.length) {
        for (i = 0; i < gcLen; i++) {
          delete data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
      return longest;
    }
    function _alignPixel(chart, pixel, width) {
      const devicePixelRatio = chart.currentDevicePixelRatio;
      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    }
    function clearCanvas(canvas, ctx) {
      ctx = ctx || canvas.getContext("2d");
      ctx.save();
      ctx.resetTransform();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
      let type, xOffset, yOffset, size, cornerRadius;
      const style = options.pointStyle;
      const rotation = options.rotation;
      const radius = options.radius;
      let rad = (rotation || 0) * RAD_PER_DEG;
      if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rad);
          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
          ctx.restore();
          return;
        }
      }
      if (isNaN(radius) || radius <= 0) {
        return;
      }
      ctx.beginPath();
      switch (style) {
        default:
          ctx.arc(x, y, radius, 0, TAU);
          ctx.closePath();
          break;
        case "triangle":
          ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          ctx.closePath();
          break;
        case "rectRounded":
          cornerRadius = radius * 0.516;
          size = radius - cornerRadius;
          xOffset = Math.cos(rad + QUARTER_PI) * size;
          yOffset = Math.sin(rad + QUARTER_PI) * size;
          ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
          ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
          ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
          ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
          ctx.closePath();
          break;
        case "rect":
          if (!rotation) {
            size = Math.SQRT1_2 * radius;
            ctx.rect(x - size, y - size, 2 * size, 2 * size);
            break;
          }
          rad += QUARTER_PI;
        case "rectRot":
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + yOffset, y - xOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          ctx.closePath();
          break;
        case "crossRot":
          rad += QUARTER_PI;
        case "cross":
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;
        case "star":
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          rad += QUARTER_PI;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;
        case "line":
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          break;
        case "dash":
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
          break;
      }
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    function _isPointInArea(point, area, margin) {
      margin = margin || 0.5;
      return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
    }
    function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    }
    function unclipArea(ctx) {
      ctx.restore();
    }
    function _steppedLineTo(ctx, previous, target, flip, mode) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      if (mode === "middle") {
        const midpoint = (previous.x + target.x) / 2;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
      } else if (mode === "after" !== !!flip) {
        ctx.lineTo(previous.x, target.y);
      } else {
        ctx.lineTo(target.x, previous.y);
      }
      ctx.lineTo(target.x, target.y);
    }
    function _bezierCurveTo(ctx, previous, target, flip) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
    }
    function renderText(ctx, text2, x, y, font, opts = {}) {
      const lines = isArray2(text2) ? text2 : [text2];
      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
      let i, line;
      ctx.save();
      ctx.font = font.string;
      setRenderOpts(ctx, opts);
      for (i = 0; i < lines.length; ++i) {
        line = lines[i];
        if (stroke) {
          if (opts.strokeColor) {
            ctx.strokeStyle = opts.strokeColor;
          }
          if (!isNullOrUndef(opts.strokeWidth)) {
            ctx.lineWidth = opts.strokeWidth;
          }
          ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += font.lineHeight;
      }
      ctx.restore();
    }
    function setRenderOpts(ctx, opts) {
      if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
      }
      if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
      }
      if (opts.color) {
        ctx.fillStyle = opts.color;
      }
      if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
      }
      if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
      }
    }
    function decorateText(ctx, x, y, line, opts) {
      if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
      }
    }
    function addRoundedRectPath(ctx, rect) {
      const {x, y, w, h, radius} = rect;
      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
      ctx.lineTo(x, y + h - radius.bottomLeft);
      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
      ctx.lineTo(x + w - radius.bottomRight, y + h);
      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
      ctx.lineTo(x + w, y + radius.topRight);
      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
      ctx.lineTo(x + radius.topLeft, y);
    }
    var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
    var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
    function toLineHeight(value, size) {
      const matches3 = ("" + value).match(LINE_HEIGHT);
      if (!matches3 || matches3[1] === "normal") {
        return size * 1.2;
      }
      value = +matches3[2];
      switch (matches3[3]) {
        case "px":
          return value;
        case "%":
          value /= 100;
          break;
      }
      return size * value;
    }
    var numberOrZero = (v) => +v || 0;
    function _readValueToProps(value, props) {
      const ret = {};
      const objProps = isObject2(props);
      const keys = objProps ? Object.keys(props) : props;
      const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
      for (const prop of keys) {
        ret[prop] = numberOrZero(read(prop));
      }
      return ret;
    }
    function toTRBL(value) {
      return _readValueToProps(value, {top: "y", right: "x", bottom: "y", left: "x"});
    }
    function toTRBLCorners(value) {
      return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
    }
    function toPadding(value) {
      const obj = toTRBL(value);
      obj.width = obj.left + obj.right;
      obj.height = obj.top + obj.bottom;
      return obj;
    }
    function toFont(options, fallback) {
      options = options || {};
      fallback = fallback || defaults3.font;
      let size = valueOrDefault(options.size, fallback.size);
      if (typeof size === "string") {
        size = parseInt(size, 10);
      }
      let style = valueOrDefault(options.style, fallback.style);
      if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = "";
      }
      const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ""
      };
      font.string = toFontString(font);
      return font;
    }
    function resolve(inputs, context, index, info) {
      let cacheable = true;
      let i, ilen, value;
      for (i = 0, ilen = inputs.length; i < ilen; ++i) {
        value = inputs[i];
        if (value === void 0) {
          continue;
        }
        if (context !== void 0 && typeof value === "function") {
          value = value(context);
          cacheable = false;
        }
        if (index !== void 0 && isArray2(value)) {
          value = value[index % value.length];
          cacheable = false;
        }
        if (value !== void 0) {
          if (info && !cacheable) {
            info.cacheable = false;
          }
          return value;
        }
      }
    }
    function _addGrace(minmax, grace, beginAtZero) {
      const {min, max} = minmax;
      const change = toDimension(grace, (max - min) / 2);
      const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
      return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
      };
    }
    function createContext(parentContext, context) {
      return Object.assign(Object.create(parentContext), context);
    }
    function _lookup(table, value, cmp) {
      cmp = cmp || ((index) => table[index] < value);
      let hi = table.length - 1;
      let lo = 0;
      let mid;
      while (hi - lo > 1) {
        mid = lo + hi >> 1;
        if (cmp(mid)) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return {lo, hi};
    }
    var _lookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] < value);
    var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
    function _filterBetween(values, min, max) {
      let start = 0;
      let end = values.length;
      while (start < end && values[start] < min) {
        start++;
      }
      while (end > start && values[end - 1] > max) {
        end--;
      }
      return start > 0 || end < values.length ? values.slice(start, end) : values;
    }
    var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
      }
      Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach((key) => {
        const method = "_onData" + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value(...args) {
            const res = base.apply(this, args);
            array._chartjs.listeners.forEach((object) => {
              if (typeof object[method] === "function") {
                object[method](...args);
              }
            });
            return res;
          }
        });
      });
    }
    function unlistenArrayEvents(array, listener) {
      const stub = array._chartjs;
      if (!stub) {
        return;
      }
      const listeners = stub.listeners;
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
      if (listeners.length > 0) {
        return;
      }
      arrayEvents.forEach((key) => {
        delete array[key];
      });
      delete array._chartjs;
    }
    function _arrayUnique(items) {
      const set2 = new Set();
      let i, ilen;
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        set2.add(items[i]);
      }
      if (set2.size === ilen) {
        return items;
      }
      return Array.from(set2);
    }
    function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
      if (!defined(fallback)) {
        fallback = _resolve("_fallback", scopes);
      }
      const cache = {
        [Symbol.toStringTag]: "Object",
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: rootScopes,
        _fallback: fallback,
        _getTarget: getTarget2,
        override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
      };
      return new Proxy(cache, {
        deleteProperty(target, prop) {
          delete target[prop];
          delete target._keys;
          delete scopes[0][prop];
          return true;
        },
        get(target, prop) {
          return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        getOwnPropertyDescriptor(target, prop) {
          return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        getPrototypeOf() {
          return Reflect.getPrototypeOf(scopes[0]);
        },
        has(target, prop) {
          return getKeysFromAllScopes(target).includes(prop);
        },
        ownKeys(target) {
          return getKeysFromAllScopes(target);
        },
        set(target, prop, value) {
          const storage = target._storage || (target._storage = getTarget2());
          target[prop] = storage[prop] = value;
          delete target._keys;
          return true;
        }
      });
    }
    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
      const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
      };
      return new Proxy(cache, {
        deleteProperty(target, prop) {
          delete target[prop];
          delete proxy[prop];
          return true;
        },
        get(target, prop, receiver) {
          return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
        },
        getOwnPropertyDescriptor(target, prop) {
          return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        getPrototypeOf() {
          return Reflect.getPrototypeOf(proxy);
        },
        has(target, prop) {
          return Reflect.has(proxy, prop);
        },
        ownKeys() {
          return Reflect.ownKeys(proxy);
        },
        set(target, prop, value) {
          proxy[prop] = value;
          delete target[prop];
          return true;
        }
      });
    }
    function _descriptors(proxy, defaults4 = {scriptable: true, indexable: true}) {
      const {_scriptable = defaults4.scriptable, _indexable = defaults4.indexable, _allKeys = defaults4.allKeys} = proxy;
      return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
        isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
      };
    }
    var readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
    var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
    function _cached(target, prop, resolve2) {
      if (Object.prototype.hasOwnProperty.call(target, prop)) {
        return target[prop];
      }
      const value = resolve2();
      target[prop] = value;
      return value;
    }
    function _resolveWithContext(target, prop, receiver) {
      const {_proxy, _context, _subProxy, _descriptors: descriptors2} = target;
      let value = _proxy[prop];
      if (isFunction2(value) && descriptors2.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
      }
      if (isArray2(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors2.isIndexable);
      }
      if (needsSubResolver(prop, value)) {
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
      }
      return value;
    }
    function _resolveScriptable(prop, value, target, receiver) {
      const {_proxy, _context, _subProxy, _stack} = target;
      if (_stack.has(prop)) {
        throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
      }
      _stack.add(prop);
      value = value(_context, _subProxy || receiver);
      _stack.delete(prop);
      if (needsSubResolver(prop, value)) {
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
      }
      return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
      const {_proxy, _context, _subProxy, _descriptors: descriptors2} = target;
      if (defined(_context.index) && isIndexable(prop)) {
        value = value[_context.index % value.length];
      } else if (isObject2(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter((s) => s !== arr);
        value = [];
        for (const item of arr) {
          const resolver = createSubResolver(scopes, _proxy, prop, item);
          value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
        }
      }
      return value;
    }
    function resolveFallback(fallback, prop, value) {
      return isFunction2(fallback) ? fallback(prop, value) : fallback;
    }
    var getScope = (key, parent2) => key === true ? parent2 : typeof key === "string" ? resolveObjectKey(parent2, key) : void 0;
    function addScopes(set2, parentScopes, key, parentFallback, value) {
      for (const parent2 of parentScopes) {
        const scope = getScope(key, parent2);
        if (scope) {
          set2.add(scope);
          const fallback = resolveFallback(scope._fallback, key, value);
          if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
            return fallback;
          }
        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
          return null;
        }
      }
      return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
      const rootScopes = resolver._rootScopes;
      const fallback = resolveFallback(resolver._fallback, prop, value);
      const allScopes = [...parentScopes, ...rootScopes];
      const set2 = new Set();
      set2.add(value);
      let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
      if (key === null) {
        return false;
      }
      if (defined(fallback) && fallback !== prop) {
        key = addScopesFromKey(set2, allScopes, fallback, key, value);
        if (key === null) {
          return false;
        }
      }
      return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
    }
    function addScopesFromKey(set2, allScopes, key, fallback, item) {
      while (key) {
        key = addScopes(set2, allScopes, key, fallback, item);
      }
      return key;
    }
    function subGetTarget(resolver, prop, value) {
      const parent2 = resolver._getTarget();
      if (!(prop in parent2)) {
        parent2[prop] = {};
      }
      const target = parent2[prop];
      if (isArray2(target) && isObject2(value)) {
        return value;
      }
      return target;
    }
    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
      let value;
      for (const prefix of prefixes) {
        value = _resolve(readKey(prefix, prop), scopes);
        if (defined(value)) {
          return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
      }
    }
    function _resolve(key, scopes) {
      for (const scope of scopes) {
        if (!scope) {
          continue;
        }
        const value = scope[key];
        if (defined(value)) {
          return value;
        }
      }
    }
    function getKeysFromAllScopes(target) {
      let keys = target._keys;
      if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
      }
      return keys;
    }
    function resolveKeysFromAllScopes(scopes) {
      const set2 = new Set();
      for (const scope of scopes) {
        for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
          set2.add(key);
        }
      }
      return Array.from(set2);
    }
    var EPSILON = Number.EPSILON || 1e-14;
    var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
    var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
      const previous = firstPoint.skip ? middlePoint : firstPoint;
      const current = middlePoint;
      const next = afterPoint.skip ? middlePoint : afterPoint;
      const d01 = distanceBetweenPoints(current, previous);
      const d12 = distanceBetweenPoints(next, current);
      let s01 = d01 / (d01 + d12);
      let s12 = d12 / (d01 + d12);
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      const fa = t * s01;
      const fb = t * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    }
    function monotoneAdjust(points, deltaK, mK) {
      const pointsLen = points.length;
      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen - 1; ++i) {
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
          continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
          mK[i] = mK[i + 1] = 0;
          continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
          continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
      }
    }
    function monotoneCompute(points, mK, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      let delta, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
          delta = (iPixel - pointBefore[indexAxis]) / 3;
          pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
          pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
          delta = (pointAfter[indexAxis] - iPixel) / 3;
          pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
          pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
      }
    }
    function splineCurveMonotone(points, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      const deltaK = Array(pointsLen).fill(0);
      const mK = Array(pointsLen);
      let i, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        if (pointAfter) {
          const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
          deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
      }
      monotoneAdjust(points, deltaK, mK);
      monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min, max) {
      return Math.max(Math.min(pt, max), min);
    }
    function capBezierPoints(points, area) {
      let i, ilen, point, inArea, inAreaPrev;
      let inAreaNext = _isPointInArea(points[0], area);
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
          continue;
        }
        point = points[i];
        if (inAreaPrev) {
          point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
          point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
          point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
          point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
      }
    }
    function _updateBezierControlPoints(points, options, area, loop2, indexAxis) {
      let i, ilen, point, controlPoints;
      if (options.spanGaps) {
        points = points.filter((pt) => !pt.skip);
      }
      if (options.cubicInterpolationMode === "monotone") {
        splineCurveMonotone(points, indexAxis);
      } else {
        let prev = loop2 ? points[points.length - 1] : points[0];
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          point = points[i];
          controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop2 ? 0 : 1)) % ilen], options.tension);
          point.cp1x = controlPoints.previous.x;
          point.cp1y = controlPoints.previous.y;
          point.cp2x = controlPoints.next.x;
          point.cp2y = controlPoints.next.y;
          prev = point;
        }
      }
      if (options.capBezierPoints) {
        capBezierPoints(points, area);
      }
    }
    function _isDomSupported() {
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function _getParentNode(domNode) {
      let parent2 = domNode.parentNode;
      if (parent2 && parent2.toString() === "[object ShadowRoot]") {
        parent2 = parent2.host;
      }
      return parent2;
    }
    function parseMaxStyle(styleValue, node, parentProperty) {
      let valueInPixels;
      if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) {
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }
      return valueInPixels;
    }
    var getComputedStyle2 = (element2) => window.getComputedStyle(element2, null);
    function getStyle(el, property) {
      return getComputedStyle2(el).getPropertyValue(property);
    }
    var positions = ["top", "right", "bottom", "left"];
    function getPositionedStyle(styles, style, suffix) {
      const result = {};
      suffix = suffix ? "-" + suffix : "";
      for (let i = 0; i < 4; i++) {
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
      }
      result.width = result.left + result.right;
      result.height = result.top + result.bottom;
      return result;
    }
    var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
    function getCanvasPosition(evt, canvas) {
      const e = evt.native || evt;
      const touches = e.touches;
      const source2 = touches && touches.length ? touches[0] : e;
      const {offsetX, offsetY} = source2;
      let box = false;
      let x, y;
      if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
      } else {
        const rect = canvas.getBoundingClientRect();
        x = source2.clientX - rect.left;
        y = source2.clientY - rect.top;
        box = true;
      }
      return {x, y, box};
    }
    function getRelativePosition$1(evt, chart) {
      const {canvas, currentDevicePixelRatio} = chart;
      const style = getComputedStyle2(canvas);
      const borderBox = style.boxSizing === "border-box";
      const paddings = getPositionedStyle(style, "padding");
      const borders = getPositionedStyle(style, "border", "width");
      const {x, y, box} = getCanvasPosition(evt, canvas);
      const xOffset = paddings.left + (box && borders.left);
      const yOffset = paddings.top + (box && borders.top);
      let {width, height} = chart;
      if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
      };
    }
    function getContainerSize(canvas, width, height) {
      let maxWidth, maxHeight;
      if (width === void 0 || height === void 0) {
        const container = _getParentNode(canvas);
        if (!container) {
          width = canvas.clientWidth;
          height = canvas.clientHeight;
        } else {
          const rect = container.getBoundingClientRect();
          const containerStyle = getComputedStyle2(container);
          const containerBorder = getPositionedStyle(containerStyle, "border", "width");
          const containerPadding = getPositionedStyle(containerStyle, "padding");
          width = rect.width - containerPadding.width - containerBorder.width;
          height = rect.height - containerPadding.height - containerBorder.height;
          maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
          maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
        }
      }
      return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
      };
    }
    var round1 = (v) => Math.round(v * 10) / 10;
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
      const style = getComputedStyle2(canvas);
      const margins = getPositionedStyle(style, "margin");
      const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
      const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
      let {width, height} = containerSize;
      if (style.boxSizing === "content-box") {
        const borders = getPositionedStyle(style, "border", "width");
        const paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      width = Math.max(0, width - margins.width);
      height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
      if (width && !height) {
        height = round1(width / 2);
      }
      return {
        width,
        height
      };
    }
    function retinaScale(chart, forceRatio, forceStyle) {
      const pixelRatio = forceRatio || 1;
      const deviceHeight = Math.floor(chart.height * pixelRatio);
      const deviceWidth = Math.floor(chart.width * pixelRatio);
      chart.height = deviceHeight / pixelRatio;
      chart.width = deviceWidth / pixelRatio;
      const canvas = chart.canvas;
      if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
      }
      if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
      }
      return false;
    }
    var supportsEventListenerOptions = function() {
      let passiveSupported = false;
      try {
        const options = {
          get passive() {
            passiveSupported = true;
            return false;
          }
        };
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      } catch (e) {
      }
      return passiveSupported;
    }();
    function readUsedSize(element2, property) {
      const value = getStyle(element2, property);
      const matches3 = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches3 ? +matches3[1] : void 0;
    }
    function _pointInLine(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
      };
    }
    function _steppedInterpolation(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
      };
    }
    function _bezierInterpolation(p1, p2, t, mode) {
      const cp1 = {x: p1.cp2x, y: p1.cp2y};
      const cp2 = {x: p2.cp1x, y: p2.cp1y};
      const a = _pointInLine(p1, cp1, t);
      const b = _pointInLine(cp1, cp2, t);
      const c = _pointInLine(cp2, p2, t);
      const d = _pointInLine(a, b, t);
      const e = _pointInLine(b, c, t);
      return _pointInLine(d, e, t);
    }
    var intlCache = new Map();
    function getNumberFormat(locale, options) {
      options = options || {};
      const cacheKey = locale + JSON.stringify(options);
      let formatter = intlCache.get(cacheKey);
      if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
      }
      return formatter;
    }
    function formatNumber(num, locale, options) {
      return getNumberFormat(locale, options).format(num);
    }
    var getRightToLeftAdapter = function(rectX, width) {
      return {
        x(x) {
          return rectX + rectX + width - x;
        },
        setWidth(w) {
          width = w;
        },
        textAlign(align) {
          if (align === "center") {
            return align;
          }
          return align === "right" ? "left" : "right";
        },
        xPlus(x, value) {
          return x - value;
        },
        leftForLtr(x, itemWidth) {
          return x - itemWidth;
        }
      };
    };
    var getLeftToRightAdapter = function() {
      return {
        x(x) {
          return x;
        },
        setWidth(w) {
        },
        textAlign(align) {
          return align;
        },
        xPlus(x, value) {
          return x + value;
        },
        leftForLtr(x, _itemWidth) {
          return x;
        }
      };
    };
    function getRtlAdapter(rtl, rectX, width) {
      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
      let style, original;
      if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
          style.getPropertyValue("direction"),
          style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
      }
    }
    function restoreTextDirection(ctx, original) {
      if (original !== void 0) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
      }
    }
    function propertyFn(property) {
      if (property === "angle") {
        return {
          between: _angleBetween,
          compare: _angleDiff,
          normalize: _normalizeAngle
        };
      }
      return {
        between: _isBetween,
        compare: (a, b) => a - b,
        normalize: (x) => x
      };
    }
    function normalizeSegment({start, end, count, loop: loop2, style}) {
      return {
        start: start % count,
        end: end % count,
        loop: loop2 && (end - start + 1) % count === 0,
        style
      };
    }
    function getSegment(segment, points, bounds) {
      const {property, start: startBound, end: endBound} = bounds;
      const {between, normalize} = propertyFn(property);
      const count = points.length;
      let {start, end, loop: loop2} = segment;
      let i, ilen;
      if (loop2) {
        start += count;
        end += count;
        for (i = 0, ilen = count; i < ilen; ++i) {
          if (!between(normalize(points[start % count][property]), startBound, endBound)) {
            break;
          }
          start--;
          end--;
        }
        start %= count;
        end %= count;
      }
      if (end < start) {
        end += count;
      }
      return {start, end, loop: loop2, style: segment.style};
    }
    function _boundSegment(segment, points, bounds) {
      if (!bounds) {
        return [segment];
      }
      const {property, start: startBound, end: endBound} = bounds;
      const count = points.length;
      const {compare, between, normalize} = propertyFn(property);
      const {start, end, loop: loop2, style} = getSegment(segment, points, bounds);
      const result = [];
      let inside = false;
      let subStart = null;
      let value, point, prevValue;
      const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
      const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
      const shouldStart = () => inside || startIsBefore();
      const shouldStop = () => !inside || endIsBefore();
      for (let i = start, prev = start; i <= end; ++i) {
        point = points[i % count];
        if (point.skip) {
          continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
          continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
          subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
          result.push(normalizeSegment({start: subStart, end: i, loop: loop2, count, style}));
          subStart = null;
        }
        prev = i;
        prevValue = value;
      }
      if (subStart !== null) {
        result.push(normalizeSegment({start: subStart, end, loop: loop2, count, style}));
      }
      return result;
    }
    function _boundSegments(line, bounds) {
      const result = [];
      const segments = line.segments;
      for (let i = 0; i < segments.length; i++) {
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
          result.push(...sub);
        }
      }
      return result;
    }
    function findStartAndEnd(points, count, loop2, spanGaps) {
      let start = 0;
      let end = count - 1;
      if (loop2 && !spanGaps) {
        while (start < count && !points[start].skip) {
          start++;
        }
      }
      while (start < count && points[start].skip) {
        start++;
      }
      start %= count;
      if (loop2) {
        end += start;
      }
      while (end > start && points[end % count].skip) {
        end--;
      }
      end %= count;
      return {start, end};
    }
    function solidSegments(points, start, max, loop2) {
      const count = points.length;
      const result = [];
      let last = start;
      let prev = points[start];
      let end;
      for (end = start + 1; end <= max; ++end) {
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
          if (!prev.skip) {
            loop2 = false;
            result.push({start: start % count, end: (end - 1) % count, loop: loop2});
            start = last = cur.stop ? end : null;
          }
        } else {
          last = end;
          if (prev.skip) {
            start = end;
          }
        }
        prev = cur;
      }
      if (last !== null) {
        result.push({start: start % count, end: last % count, loop: loop2});
      }
      return result;
    }
    function _computeSegments(line, segmentOptions) {
      const points = line.points;
      const spanGaps = line.options.spanGaps;
      const count = points.length;
      if (!count) {
        return [];
      }
      const loop2 = !!line._loop;
      const {start, end} = findStartAndEnd(points, count, loop2, spanGaps);
      if (spanGaps === true) {
        return splitByStyles(line, [{start, end, loop: loop2}], points, segmentOptions);
      }
      const max = end < start ? end + count : end;
      const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
      return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
    }
    function splitByStyles(line, segments, points, segmentOptions) {
      if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
      }
      return doSplitByStyles(line, segments, points, segmentOptions);
    }
    function doSplitByStyles(line, segments, points, segmentOptions) {
      const chartContext = line._chart.getContext();
      const baseStyle = readStyle(line.options);
      const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
      const count = points.length;
      const result = [];
      let prevStyle = baseStyle;
      let start = segments[0].start;
      let i = start;
      function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
          return;
        }
        s += count;
        while (points[s % count].skip) {
          s -= dir;
        }
        while (points[e % count].skip) {
          e += dir;
        }
        if (s % count !== e % count) {
          result.push({start: s % count, end: e % count, loop: l, style: st});
          prevStyle = st;
          start = e % count;
        }
      }
      for (const segment of segments) {
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for (i = start + 1; i <= segment.end; i++) {
          const pt = points[i % count];
          style = readStyle(segmentOptions.setContext(createContext(chartContext, {
            type: "segment",
            p0: prev,
            p1: pt,
            p0DataIndex: (i - 1) % count,
            p1DataIndex: i % count,
            datasetIndex
          })));
          if (styleChanged(style, prevStyle)) {
            addStyle(start, i - 1, segment.loop, prevStyle);
          }
          prev = pt;
          prevStyle = style;
        }
        if (start < i - 1) {
          addStyle(start, i - 1, segment.loop, prevStyle);
        }
      }
      return result;
    }
    function readStyle(options) {
      return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
      };
    }
    function styleChanged(style, prevStyle) {
      return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
    }
    /*!
     * Chart.js v3.7.0
     * https://www.chartjs.org
     * (c) 2021 Chart.js Contributors
     * Released under the MIT License
     */
    var Animator = class {
      constructor() {
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = void 0;
      }
      _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn) => fn({
          chart,
          initial: anims.initial,
          numSteps,
          currentStep: Math.min(date - anims.start, numSteps)
        }));
      }
      _refresh() {
        if (this._request) {
          return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, () => {
          this._update();
          this._request = null;
          if (this._running) {
            this._refresh();
          }
        });
      }
      _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart) => {
          if (!anims.running || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          let draw2 = false;
          let item;
          for (; i >= 0; --i) {
            item = items[i];
            if (item._active) {
              if (item._total > anims.duration) {
                anims.duration = item._total;
              }
              item.tick(date);
              draw2 = true;
            } else {
              items[i] = items[items.length - 1];
              items.pop();
            }
          }
          if (draw2) {
            chart.draw();
            this._notify(chart, anims, date, "progress");
          }
          if (!items.length) {
            anims.running = false;
            this._notify(chart, anims, date, "complete");
            anims.initial = false;
          }
          remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
          this._running = false;
        }
      }
      _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
          anims = {
            running: false,
            initial: true,
            items: [],
            listeners: {
              complete: [],
              progress: []
            }
          };
          charts.set(chart, anims);
        }
        return anims;
      }
      listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
      }
      add(chart, items) {
        if (!items || !items.length) {
          return;
        }
        this._getAnims(chart).items.push(...items);
      }
      has(chart) {
        return this._getAnims(chart).items.length > 0;
      }
      start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
          return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
        this._refresh();
      }
      running(chart) {
        if (!this._running) {
          return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
          return false;
        }
        return true;
      }
      stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for (; i >= 0; --i) {
          items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), "complete");
      }
      remove(chart) {
        return this._charts.delete(chart);
      }
    };
    var animator = new Animator();
    var transparent = "transparent";
    var interpolators = {
      boolean(from, to, factor) {
        return factor > 0.5 ? to : from;
      },
      color(from, to, factor) {
        const c0 = color(from || transparent);
        const c1 = c0.valid && color(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
      },
      number(from, to, factor) {
        return from + (to - from) * factor;
      }
    };
    var Animation = class {
      constructor(cfg, target, prop, to) {
        const currentValue = target[prop];
        to = resolve([cfg.to, to, currentValue, cfg.from]);
        const from = resolve([cfg.from, currentValue, to]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = void 0;
      }
      active() {
        return this._active;
      }
      update(cfg, to, date) {
        if (this._active) {
          this._notify(false);
          const currentValue = this._target[this._prop];
          const elapsed = date - this._start;
          const remain = this._duration - elapsed;
          this._start = date;
          this._duration = Math.floor(Math.max(remain, cfg.duration));
          this._total += elapsed;
          this._loop = !!cfg.loop;
          this._to = resolve([cfg.to, to, currentValue, cfg.from]);
          this._from = resolve([cfg.from, currentValue, to]);
        }
      }
      cancel() {
        if (this._active) {
          this.tick(Date.now());
          this._active = false;
          this._notify(false);
        }
      }
      tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop2 = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop2 || elapsed < duration);
        if (!this._active) {
          this._target[prop] = to;
          this._notify(true);
          return;
        }
        if (elapsed < 0) {
          this._target[prop] = from;
          return;
        }
        factor = elapsed / duration % 2;
        factor = loop2 && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
      }
      wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej) => {
          promises.push({res, rej});
        });
      }
      _notify(resolved) {
        const method = resolved ? "res" : "rej";
        const promises = this._promises || [];
        for (let i = 0; i < promises.length; i++) {
          promises[i][method]();
        }
      }
    };
    var numbers6 = ["x", "y", "borderWidth", "radius", "tension"];
    var colors = ["color", "borderColor", "backgroundColor"];
    defaults3.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    var animationOptions = Object.keys(defaults3.animation);
    defaults3.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
    });
    defaults3.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers6
      }
    });
    defaults3.describe("animations", {
      _fallback: "animation"
    });
    defaults3.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
    var Animations = class {
      constructor(chart, config) {
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
      }
      configure(config) {
        if (!isObject2(config)) {
          return;
        }
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key) => {
          const cfg = config[key];
          if (!isObject2(cfg)) {
            return;
          }
          const resolved = {};
          for (const option of animationOptions) {
            resolved[option] = cfg[option];
          }
          (isArray2(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
            if (prop === key || !animatedProps.has(prop)) {
              animatedProps.set(prop, resolved);
            }
          });
        });
      }
      _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
          return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
          awaitAll(target.options.$animations, newOptions).then(() => {
            target.options = newOptions;
          }, () => {
          });
        }
        return animations;
      }
      _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for (i = props.length - 1; i >= 0; --i) {
          const prop = props[i];
          if (prop.charAt(0) === "$") {
            continue;
          }
          if (prop === "options") {
            animations.push(...this._animateOptions(target, values));
            continue;
          }
          const value = values[prop];
          let animation = running[prop];
          const cfg = animatedProps.get(prop);
          if (animation) {
            if (cfg && animation.active()) {
              animation.update(cfg, value, date);
              continue;
            } else {
              animation.cancel();
            }
          }
          if (!cfg || !cfg.duration) {
            target[prop] = value;
            continue;
          }
          running[prop] = animation = new Animation(cfg, target, prop, value);
          animations.push(animation);
        }
        return animations;
      }
      update(target, values) {
        if (this._properties.size === 0) {
          Object.assign(target, values);
          return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
          animator.add(this._chart, animations);
          return true;
        }
      }
    };
    function awaitAll(animations, properties) {
      const running = [];
      const keys = Object.keys(properties);
      for (let i = 0; i < keys.length; i++) {
        const anim = animations[keys[i]];
        if (anim && anim.active()) {
          running.push(anim.wait());
        }
      }
      return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
      if (!newOptions) {
        return;
      }
      let options = target.options;
      if (!options) {
        target.options = newOptions;
        return;
      }
      if (options.$shared) {
        target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
      }
      return options;
    }
    function scaleClip(scale, allowedOverflow) {
      const opts = scale && scale.options || {};
      const reverse = opts.reverse;
      const min = opts.min === void 0 ? allowedOverflow : 0;
      const max = opts.max === void 0 ? allowedOverflow : 0;
      return {
        start: reverse ? max : min,
        end: reverse ? min : max
      };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
      if (allowedOverflow === false) {
        return false;
      }
      const x = scaleClip(xScale, allowedOverflow);
      const y = scaleClip(yScale, allowedOverflow);
      return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
      };
    }
    function toClip(value) {
      let t, r, b, l;
      if (isObject2(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
      } else {
        t = r = b = l = value;
      }
      return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
      };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
      const keys = [];
      const metasets = chart._getSortedDatasetMetas(filterVisible);
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        keys.push(metasets[i].index);
      }
      return keys;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
      const keys = stack.keys;
      const singleMode = options.mode === "single";
      let i, ilen, datasetIndex, otherValue;
      if (value === null) {
        return;
      }
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
          if (options.all) {
            continue;
          }
          break;
        }
        otherValue = stack.values[datasetIndex];
        if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
          value += otherValue;
        }
      }
      return value;
    }
    function convertObjectDataToArray(data) {
      const keys = Object.keys(data);
      const adata = new Array(keys.length);
      let i, ilen, key;
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        adata[i] = {
          x: key,
          y: data[key]
        };
      }
      return adata;
    }
    function isStacked(scale, meta) {
      const stacked = scale && scale.options.stacked;
      return stacked || stacked === void 0 && meta.stack !== void 0;
    }
    function getStackKey(indexScale, valueScale, meta) {
      return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
    }
    function getUserBounds(scale) {
      const {min, max, minDefined, maxDefined} = scale.getUserBounds();
      return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
      };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
      const subStack = stacks[stackKey] || (stacks[stackKey] = {});
      return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type) {
      for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) {
          return meta.index;
        }
      }
      return null;
    }
    function updateStacks(controller, parsed) {
      const {chart, _cachedMeta: meta} = controller;
      const stacks = chart._stacks || (chart._stacks = {});
      const {iScale, vScale, index: datasetIndex} = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const key = getStackKey(iScale, vScale, meta);
      const ilen = parsed.length;
      let stack;
      for (let i = 0; i < ilen; ++i) {
        const item = parsed[i];
        const {[iAxis]: index, [vAxis]: value} = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      }
    }
    function getFirstScaleId(chart, axis) {
      const scales = chart.scales;
      return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
    }
    function createDatasetContext(parent2, index) {
      return createContext(parent2, {
        active: false,
        dataset: void 0,
        datasetIndex: index,
        index,
        mode: "default",
        type: "dataset"
      });
    }
    function createDataContext(parent2, index, element2) {
      return createContext(parent2, {
        active: false,
        dataIndex: index,
        parsed: void 0,
        raw: void 0,
        element: element2,
        index,
        mode: "default",
        type: "data"
      });
    }
    function clearStacks(meta, items) {
      const datasetIndex = meta.controller.index;
      const axis = meta.vScale && meta.vScale.axis;
      if (!axis) {
        return;
      }
      items = items || meta._parsed;
      for (const parsed of items) {
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
          return;
        }
        delete stacks[axis][datasetIndex];
      }
    }
    var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
    var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
    var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {keys: getSortedDatasetIndices(chart, true), values: null};
    var DatasetController = class {
      constructor(chart, datasetIndex) {
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = void 0;
        this._parsing = false;
        this._data = void 0;
        this._objectData = void 0;
        this._sharedOptions = void 0;
        this._drawStart = void 0;
        this._drawCount = void 0;
        this.enableOptionSharing = false;
        this.$context = void 0;
        this._syncList = [];
        this.initialize();
      }
      initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
      }
      updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
          clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
      }
      linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
      }
      getDataset() {
        return this.chart.data.datasets[this.index];
      }
      getMeta() {
        return this.chart.getDatasetMeta(this.index);
      }
      getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
      }
      _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
      }
      reset() {
        this._update("reset");
      }
      _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
          clearStacks(meta);
        }
      }
      _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject2(data)) {
          this._data = convertObjectDataToArray(data);
        } else if (_data !== data) {
          if (_data) {
            unlistenArrayEvents(_data, this);
            const meta = this._cachedMeta;
            clearStacks(meta);
            meta._parsed = [];
          }
          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, this);
          }
          this._syncList = [];
          this._data = data;
        }
      }
      addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
          meta.dataset = new this.datasetElementType();
        }
      }
      buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
          stackChanged = true;
          clearStacks(meta);
          meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
          updateStacks(this, meta._parsed);
        }
      }
      configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
      }
      parse(start, count) {
        const {_cachedMeta: meta, _data: data} = this;
        const {iScale, _stacked} = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
          meta._parsed = data;
          meta._sorted = true;
          parsed = data;
        } else {
          if (isArray2(data[start])) {
            parsed = this.parseArrayData(meta, data, start, count);
          } else if (isObject2(data[start])) {
            parsed = this.parseObjectData(meta, data, start, count);
          } else {
            parsed = this.parsePrimitiveData(meta, data, start, count);
          }
          const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
          for (i = 0; i < count; ++i) {
            meta._parsed[i + start] = cur = parsed[i];
            if (sorted) {
              if (isNotInOrderComparedToPrev()) {
                sorted = false;
              }
              prev = cur;
            }
          }
          meta._sorted = sorted;
        }
        if (_stacked) {
          updateStacks(this, parsed);
        }
      }
      parsePrimitiveData(meta, data, start, count) {
        const {iScale, vScale} = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          parsed[i] = {
            [iAxis]: singleScale || iScale.parse(labels[index], index),
            [vAxis]: vScale.parse(data[index], index)
          };
        }
        return parsed;
      }
      parseArrayData(meta, data, start, count) {
        const {xScale, yScale} = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            x: xScale.parse(item[0], index),
            y: yScale.parse(item[1], index)
          };
        }
        return parsed;
      }
      parseObjectData(meta, data, start, count) {
        const {xScale, yScale} = meta;
        const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
            y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
          };
        }
        return parsed;
      }
      getParsed(index) {
        return this._cachedMeta._parsed[index];
      }
      getDataElement(index) {
        return this._cachedMeta.data[index];
      }
      applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
          keys: getSortedDatasetIndices(chart, true),
          values: parsed._stacks[scale.axis]
        };
        return applyStack(stack, value, meta.index, {mode});
      }
      updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
          stack.values = values;
          value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
      }
      getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
        const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
          parsed = _parsed[i];
          const otherValue = parsed[otherScale.axis];
          return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for (i = 0; i < ilen; ++i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          if (sorted) {
            break;
          }
        }
        if (sorted) {
          for (i = ilen - 1; i >= 0; --i) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            break;
          }
        }
        return range;
      }
      getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for (i = 0, ilen = parsed.length; i < ilen; ++i) {
          value = parsed[i][scale.axis];
          if (isNumberFinite(value)) {
            values.push(value);
          }
        }
        return values;
      }
      getMaxOverflow() {
        return false;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
          label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
          value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
        };
      }
      _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || "default");
        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
      }
      update(mode) {
      }
      draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active2 = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) {
          meta.dataset.draw(ctx, area, start, count);
        }
        for (i = start; i < start + count; ++i) {
          const element2 = elements[i];
          if (element2.hidden) {
            continue;
          }
          if (element2.active && drawActiveElementsOnTop) {
            active2.push(element2);
          } else {
            element2.draw(ctx, area);
          }
        }
        for (i = 0; i < active2.length; ++i) {
          active2[i].draw(ctx, area);
        }
      }
      getStyle(index, active2) {
        const mode = active2 ? "active" : "default";
        return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
      }
      getContext(index, active2, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
          const element2 = this._cachedMeta.data[index];
          context = element2.$context || (element2.$context = createDataContext(this.getContext(), index, element2));
          context.parsed = this.getParsed(index);
          context.raw = dataset.data[index];
          context.index = context.dataIndex = index;
        } else {
          context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
          context.dataset = dataset;
          context.index = context.datasetIndex = this.index;
        }
        context.active = !!active2;
        context.mode = mode;
        return context;
      }
      resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
      }
      resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
      }
      _resolveElementOptions(elementType, mode = "default", index) {
        const active2 = mode === "active";
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + "-" + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index);
        if (cached) {
          return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active2 ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names2 = Object.keys(defaults3.elements[elementType]);
        const context = () => this.getContext(index, active2);
        const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
        if (values.$shared) {
          values.$shared = sharing;
          cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
      }
      _resolveAnimations(index, transition, active2) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
          return cached;
        }
        let options;
        if (chart.options.animation !== false) {
          const config = this.chart.config;
          const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          options = config.createResolver(scopes, this.getContext(index, active2, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
          cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
      }
      getSharedOptions(options) {
        if (!options.$shared) {
          return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
      }
      includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
      }
      updateElement(element2, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
          Object.assign(element2, properties);
        } else {
          this._resolveAnimations(index, mode).update(element2, properties);
        }
      }
      updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
          this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
        }
      }
      _setStyle(element2, index, mode, active2) {
        element2.active = active2;
        const options = this.getStyle(index, active2);
        this._resolveAnimations(index, mode, active2).update(element2, {
          options: !active2 && this.getSharedOptions(options) || options
        });
      }
      removeHoverStyle(element2, datasetIndex, index) {
        this._setStyle(element2, index, "active", false);
      }
      setHoverStyle(element2, datasetIndex, index) {
        this._setStyle(element2, index, "active", true);
      }
      _removeDatasetHoverStyle() {
        const element2 = this._cachedMeta.dataset;
        if (element2) {
          this._setStyle(element2, void 0, "active", false);
        }
      }
      _setDatasetHoverStyle() {
        const element2 = this._cachedMeta.dataset;
        if (element2) {
          this._setStyle(element2, void 0, "active", true);
        }
      }
      _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList) {
          this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
          this.parse(0, count);
        }
        if (numData > numMeta) {
          this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
          this._removeElements(numData, numMeta - numData);
        }
      }
      _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr) => {
          arr.length += count;
          for (i = arr.length - 1; i >= end; i--) {
            arr[i] = arr[i - count];
          }
        };
        move(data);
        for (i = start; i < end; ++i) {
          data[i] = new this.dataElementType();
        }
        if (this._parsing) {
          move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
          this.updateElements(data, start, count, "reset");
        }
      }
      updateElements(element2, start, count, mode) {
      }
      _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
          const removed = meta._parsed.splice(start, count);
          if (meta._stacked) {
            clearStacks(meta, removed);
          }
        }
        meta.data.splice(start, count);
      }
      _sync(args) {
        if (this._parsing) {
          this._syncList.push(args);
        } else {
          const [method, arg1, arg2] = args;
          this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([this.index, ...args]);
      }
      _onDataPush() {
        const count = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - count, count]);
      }
      _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
      }
      _onDataShift() {
        this._sync(["_removeElements", 0, 1]);
      }
      _onDataSplice(start, count) {
        if (count) {
          this._sync(["_removeElements", start, count]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
          this._sync(["_insertElements", start, newCount]);
        }
      }
      _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length]);
      }
    };
    DatasetController.defaults = {};
    DatasetController.prototype.datasetElementType = null;
    DatasetController.prototype.dataElementType = null;
    function getAllScaleValues(scale, type) {
      if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
          values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
      }
      return scale._cache.$bar;
    }
    function computeMinSampleSize(meta) {
      const scale = meta.iScale;
      const values = getAllScaleValues(scale, meta.type);
      let min = scale._length;
      let i, ilen, curr, prev;
      const updateMinAndPrev = () => {
        if (curr === 32767 || curr === -32768) {
          return;
        }
        if (defined(prev)) {
          min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
      };
      for (i = 0, ilen = values.length; i < ilen; ++i) {
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
      }
      prev = void 0;
      for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
      }
      return min;
    }
    function computeFitCategoryTraits(index, ruler, options, stackCount) {
      const thickness = options.barThickness;
      let size, ratio;
      if (isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        size = thickness * stackCount;
        ratio = 1;
      }
      return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
      };
    }
    function computeFlexCategoryTraits(index, ruler, options, stackCount) {
      const pixels = ruler.pixels;
      const curr = pixels[index];
      let prev = index > 0 ? pixels[index - 1] : null;
      let next = index < pixels.length - 1 ? pixels[index + 1] : null;
      const percent = options.categoryPercentage;
      if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }
      if (next === null) {
        next = curr + curr - prev;
      }
      const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      const size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
      };
    }
    function parseFloatBar(entry, item, vScale, i) {
      const startValue = vScale.parse(entry[0], i);
      const endValue = vScale.parse(entry[1], i);
      const min = Math.min(startValue, endValue);
      const max = Math.max(startValue, endValue);
      let barStart = min;
      let barEnd = max;
      if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
      }
      item[vScale.axis] = barEnd;
      item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
      };
    }
    function parseValue(entry, item, vScale, i) {
      if (isArray2(entry)) {
        parseFloatBar(entry, item, vScale, i);
      } else {
        item[vScale.axis] = vScale.parse(entry, i);
      }
      return item;
    }
    function parseArrayOrPrimitive(meta, data, start, count) {
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = [];
      let i, ilen, item, entry;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
      }
      return parsed;
    }
    function isFloatBar(custom) {
      return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
    }
    function barSign(size, vScale, actualBase) {
      if (size !== 0) {
        return sign(size);
      }
      return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
    }
    function borderProps(properties) {
      let reverse, start, end, top, bottom;
      if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = "left";
        end = "right";
      } else {
        reverse = properties.base < properties.y;
        start = "bottom";
        end = "top";
      }
      if (reverse) {
        top = "end";
        bottom = "start";
      } else {
        top = "start";
        bottom = "end";
      }
      return {start, end, reverse, top, bottom};
    }
    function setBorderSkipped(properties, options, stack, index) {
      let edge = options.borderSkipped;
      const res = {};
      if (!edge) {
        properties.borderSkipped = res;
        return;
      }
      const {start, end, reverse, top, bottom} = borderProps(properties);
      if (edge === "middle" && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
          edge = top;
        } else if ((stack._bottom || 0) === index) {
          edge = bottom;
        } else {
          res[parseEdge(bottom, start, end, reverse)] = true;
          edge = top;
        }
      }
      res[parseEdge(edge, start, end, reverse)] = true;
      properties.borderSkipped = res;
    }
    function parseEdge(edge, a, b, reverse) {
      if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
      } else {
        edge = startEnd(edge, a, b);
      }
      return edge;
    }
    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }
    function startEnd(v, start, end) {
      return v === "start" ? start : v === "end" ? end : v;
    }
    function setInflateAmount(properties, {inflateAmount}, ratio) {
      properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
    }
    var BarController = class extends DatasetController {
      parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
      }
      parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
      }
      parseObjectData(meta, data, start, count) {
        const {iScale, vScale} = meta;
        const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
        const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          obj = data[i];
          item = {};
          item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
          parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
      }
      updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
          range.min = Math.min(range.min, custom.min);
          range.max = Math.max(range.max, custom.max);
        }
      }
      getMaxOverflow() {
        return 0;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const {iScale, vScale} = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
          label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
          value
        };
      }
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
      }
      update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
      }
      updateElements(bars, start, count, mode) {
        const reset = mode === "reset";
        const {index, _cachedMeta: {vScale}} = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        for (let i = start; i < start + count; i++) {
          const parsed = this.getParsed(i);
          const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);
          const ipixels = this._calculateBarIndexPixels(i, ruler);
          const stack = (parsed._stacks || {})[vScale.axis];
          const properties = {
            horizontal,
            base: vpixels.base,
            enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
            x: horizontal ? vpixels.head : ipixels.center,
            y: horizontal ? ipixels.center : vpixels.head,
            height: horizontal ? ipixels.size : Math.abs(vpixels.size),
            width: horizontal ? Math.abs(vpixels.size) : ipixels.size
          };
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
          }
          const options = properties.options || bars[i].options;
          setBorderSkipped(properties, options, stack, index);
          setInflateAmount(properties, options, ruler.ratio);
          this.updateElement(bars[i], i, properties, mode);
        }
      }
      _getStacks(last, dataIndex) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const metasets = iScale.getMatchingVisibleMetas(this._type);
        const stacked = iScale.options.stacked;
        const ilen = metasets.length;
        const stacks = [];
        let i, item;
        for (i = 0; i < ilen; ++i) {
          item = metasets[i];
          if (!item.controller.options.grouped) {
            continue;
          }
          if (typeof dataIndex !== "undefined") {
            const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
            if (isNullOrUndef(val) || isNaN(val)) {
              continue;
            }
          }
          if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
            stacks.push(item.stack);
          }
          if (item.index === last) {
            break;
          }
        }
        if (!stacks.length) {
          stacks.push(void 0);
        }
        return stacks;
      }
      _getStackCount(index) {
        return this._getStacks(void 0, index).length;
      }
      _getStackIndex(datasetIndex, name2, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name2 !== void 0 ? stacks.indexOf(name2) : -1;
        return index === -1 ? stacks.length - 1 : index;
      }
      _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
          pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
          min,
          pixels,
          start: iScale._startPixel,
          end: iScale._endPixel,
          stackCount: this._getStackCount(),
          scale: iScale,
          grouped: opts.grouped,
          ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
      }
      _calculateBarValuePixels(index) {
        const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
          start = length - value;
          length = value;
        }
        if (floating) {
          value = custom.barStart;
          length = custom.barEnd - custom.barStart;
          if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
            start = 0;
          }
          start += value;
        }
        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
          head = vScale.getPixelForValue(start + length);
        } else {
          head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
          size = barSign(size, vScale, actualBase) * minBarLength;
          if (value === actualBase) {
            base -= size / 2;
          }
          head = base + size;
        }
        if (base === vScale.getPixelForValue(actualBase)) {
          const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
          base += halfGrid;
          size -= halfGrid;
        }
        return {
          size,
          base,
          head,
          center: head + size / 2
        };
      }
      _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
        let center, size;
        if (ruler.grouped) {
          const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
          const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
          const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
          center = range.start + range.chunk * stackIndex + range.chunk / 2;
          size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
          center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
          size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
          base: center - size / 2,
          head: center + size / 2,
          center,
          size
        };
      }
      draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for (; i < ilen; ++i) {
          if (this.getParsed(i)[vScale.axis] !== null) {
            rects[i].draw(this._ctx);
          }
        }
      }
    };
    BarController.id = "bar";
    BarController.defaults = {
      datasetElementType: false,
      dataElementType: "bar",
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      grouped: true,
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "base", "width", "height"]
        }
      }
    };
    BarController.overrides = {
      scales: {
        _index_: {
          type: "category",
          offset: true,
          grid: {
            offset: true
          }
        },
        _value_: {
          type: "linear",
          beginAtZero: true
        }
      }
    };
    var BubbleController = class extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
      }
      parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        }
        return parsed;
      }
      parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          const item = data[start + i];
          parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
      }
      parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          const item = data[start + i];
          parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
      }
      getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const {xScale, yScale} = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
          label: meta.label,
          value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
        };
      }
      update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const {iScale, vScale} = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for (let i = start; i < start + count; i++) {
          const point = points[i];
          const parsed = !reset && this.getParsed(i);
          const properties = {};
          const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
          const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
          properties.skip = isNaN(iPixel) || isNaN(vPixel);
          if (includeOptions) {
            properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
            if (reset) {
              properties.options.radius = 0;
            }
          }
          this.updateElement(point, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) {
          values = Object.assign({}, values, {$shared: false});
        }
        const radius = values.radius;
        if (mode !== "active") {
          values.radius = 0;
        }
        values.radius += valueOrDefault(parsed && parsed._custom, radius);
        return values;
      }
    };
    BubbleController.id = "bubble";
    BubbleController.defaults = {
      datasetElementType: false,
      dataElementType: "point",
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "borderWidth", "radius"]
        }
      }
    };
    BubbleController.overrides = {
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            title() {
              return "";
            }
          }
        }
      }
    };
    function getRatioAndOffset(rotation, circumference, cutout) {
      let ratioX = 1;
      let ratioY = 1;
      let offsetX = 0;
      let offsetY = 0;
      if (circumference < TAU) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(HALF_PI, startY, endY);
        const minX = calcMin(PI, startX, endX);
        const minY = calcMin(PI + HALF_PI, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
      }
      return {ratioX, ratioY, offsetX, offsetY};
    }
    var DoughnutController = class extends DatasetController {
      constructor(chart, datasetIndex) {
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = void 0;
        this.outerRadius = void 0;
        this.offsetX = void 0;
        this.offsetY = void 0;
      }
      linkScales() {
      }
      parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
          meta._parsed = data;
        } else {
          let getter = (i2) => +data[i2];
          if (isObject2(data[start])) {
            const {key = "value"} = this._parsing;
            getter = (i2) => +resolveObjectKey(data[i2], key);
          }
          let i, ilen;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            meta._parsed[i] = getter(i);
          }
        }
      }
      _getRotation() {
        return toRadians(this.options.rotation - 90);
      }
      _getCircumference() {
        return toRadians(this.options.circumference);
      }
      _getRotationExtents() {
        let min = TAU;
        let max = -TAU;
        for (let i = 0; i < this.chart.data.datasets.length; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            const controller = this.chart.getDatasetMeta(i).controller;
            const rotation = controller._getRotation();
            const circumference = controller._getCircumference();
            min = Math.min(min, rotation);
            max = Math.max(max, rotation + circumference);
          }
        }
        return {
          rotation: min,
          circumference: max - min
        };
      }
      update(mode) {
        const chart = this.chart;
        const {chartArea} = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const {circumference, rotation} = this._getRotationExtents();
        const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = toDimension(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
      }
      _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
          return 0;
        }
        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
      }
      updateElements(arcs, start, count, mode) {
        const reset = mode === "reset";
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        let startAngle = this._getRotation();
        let i;
        for (i = 0; i < start; ++i) {
          startAngle += this._circumference(i, reset);
        }
        for (i = start; i < start + count; ++i) {
          const circumference = this._circumference(i, reset);
          const arc = arcs[i];
          const properties = {
            x: centerX + this.offsetX,
            y: centerY + this.offsetY,
            startAngle,
            endAngle: startAngle + circumference,
            circumference,
            outerRadius,
            innerRadius
          };
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
          }
          startAngle += circumference;
          this.updateElement(arc, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for (i = 0; i < metaData.length; i++) {
          const value = meta._parsed[i];
          if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
            total += Math.abs(value);
          }
        }
        return total;
      }
      calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
          return TAU * (Math.abs(value) / total);
        }
        return 0;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index], chart.options.locale);
        return {
          label: labels[index] || "",
          value
        };
      }
      getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;
              controller = meta.controller;
              break;
            }
          }
        }
        if (!arcs) {
          return 0;
        }
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          options = controller.resolveDataElementOptions(i);
          if (options.borderAlign !== "inner") {
            max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
          }
        }
        return max;
      }
      getMaxOffset(arcs) {
        let max = 0;
        for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
          const options = this.resolveDataElementOptions(i);
          max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
      }
      _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for (let i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }
        return ringWeightOffset;
      }
      _getRingWeight(datasetIndex) {
        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
      }
      _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
      }
    };
    DoughnutController.id = "doughnut";
    DoughnutController.defaults = {
      datasetElementType: false,
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: false
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
        }
      },
      cutout: "50%",
      rotation: 0,
      circumference: 360,
      radius: "100%",
      spacing: 0,
      indexAxis: "r"
    };
    DoughnutController.descriptors = {
      _scriptable: (name2) => name2 !== "spacing",
      _indexable: (name2) => name2 !== "spacing"
    };
    DoughnutController.overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const {labels: {pointStyle}} = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    strokeStyle: style.borderColor,
                    lineWidth: style.borderWidth,
                    pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        },
        tooltip: {
          callbacks: {
            title() {
              return "";
            },
            label(tooltipItem) {
              let dataLabel = tooltipItem.label;
              const value = ": " + tooltipItem.formattedValue;
              if (isArray2(dataLabel)) {
                dataLabel = dataLabel.slice();
                dataLabel[0] += value;
              } else {
                dataLabel += value;
              }
              return dataLabel;
            }
          }
        }
      }
    };
    var LineController = class extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
      }
      update(mode) {
        const meta = this._cachedMeta;
        const {dataset: line, data: points = [], _dataset} = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (scaleRangesChanged(meta)) {
          start = 0;
          count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
        this.updateElements(points, start, count, mode);
      }
      updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const {spanGaps, segment} = this.options;
        const maxGapLength = isNumber2(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for (let i = start; i < start + count; ++i) {
          const point = points[i];
          const parsed = this.getParsed(i);
          const properties = directUpdate ? point : {};
          const nullData = isNullOrUndef(parsed[vAxis]);
          const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
          const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
          properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
          properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
          if (segment) {
            properties.parsed = parsed;
            properties.raw = _dataset.data[i];
          }
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          }
          if (!directUpdate) {
            this.updateElement(point, i, properties, mode);
          }
          prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
          return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
      }
      draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
      }
    };
    LineController.id = "line";
    LineController.defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      showLine: true,
      spanGaps: false
    };
    LineController.overrides = {
      scales: {
        _index_: {
          type: "category"
        },
        _value_: {
          type: "linear"
        }
      }
    };
    function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
      const pointCount = points.length;
      let start = 0;
      let count = pointCount;
      if (meta._sorted) {
        const {iScale, _parsed} = meta;
        const axis = iScale.axis;
        const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
        if (minDefined) {
          start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
      }
      return {start, count};
    }
    function scaleRangesChanged(meta) {
      const {xScale, yScale, _scaleRanges} = meta;
      const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
      };
      if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
      }
      const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
      Object.assign(_scaleRanges, newRanges);
      return changed;
    }
    var PolarAreaController = class extends DatasetController {
      constructor(chart, datasetIndex) {
        super(chart, datasetIndex);
        this.innerRadius = void 0;
        this.outerRadius = void 0;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index].r, chart.options.locale);
        return {
          label: labels[index] || "",
          value
        };
      }
      update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
      }
      _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
      }
      updateElements(arcs, start, count, mode) {
        const reset = mode === "reset";
        const chart = this.chart;
        const dataset = this.getDataset();
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for (i = 0; i < start; ++i) {
          angle += this._computeAngle(i, mode, defaultAngle);
        }
        for (i = start; i < start + count; i++) {
          const arc = arcs[i];
          let startAngle = angle;
          let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
          let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
          angle = endAngle;
          if (reset) {
            if (animationOpts.animateScale) {
              outerRadius = 0;
            }
            if (animationOpts.animateRotate) {
              startAngle = endAngle = datasetStartAngle;
            }
          }
          const properties = {
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius,
            startAngle,
            endAngle,
            options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
          };
          this.updateElement(arc, i, properties, mode);
        }
      }
      countVisibleElements() {
        const dataset = this.getDataset();
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element2, index) => {
          if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
            count++;
          }
        });
        return count;
      }
      _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
      }
    };
    PolarAreaController.id = "polarArea";
    PolarAreaController.defaults = {
      dataElementType: "arc",
      animation: {
        animateRotate: true,
        animateScale: true
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
        }
      },
      indexAxis: "r",
      startAngle: 0
    };
    PolarAreaController.overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const {labels: {pointStyle}} = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    strokeStyle: style.borderColor,
                    lineWidth: style.borderWidth,
                    pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        },
        tooltip: {
          callbacks: {
            title() {
              return "";
            },
            label(context) {
              return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
            }
          }
        }
      },
      scales: {
        r: {
          type: "radialLinear",
          angleLines: {
            display: false
          },
          beginAtZero: true,
          grid: {
            circular: true
          },
          pointLabels: {
            display: false
          },
          startAngle: 0
        }
      }
    };
    var PieController = class extends DoughnutController {
    };
    PieController.id = "pie";
    PieController.defaults = {
      cutout: 0,
      rotation: 0,
      circumference: 360,
      radius: "100%"
    };
    var RadarController = class extends DatasetController {
      getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
          label: vScale.getLabels()[index],
          value: "" + vScale.getLabelForValue(parsed[vScale.axis])
        };
      }
      update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== "resize") {
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
            options.borderWidth = 0;
          }
          const properties = {
            _loop: true,
            _fullLoop: labels.length === points.length,
            options
          };
          this.updateElement(line, void 0, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
        const dataset = this.getDataset();
        const scale = this._cachedMeta.rScale;
        const reset = mode === "reset";
        for (let i = start; i < start + count; i++) {
          const point = points[i];
          const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
          const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
          const x = reset ? scale.xCenter : pointPosition.x;
          const y = reset ? scale.yCenter : pointPosition.y;
          const properties = {
            x,
            y,
            angle: pointPosition.angle,
            skip: isNaN(x) || isNaN(y),
            options
          };
          this.updateElement(point, i, properties, mode);
        }
      }
    };
    RadarController.id = "radar";
    RadarController.defaults = {
      datasetElementType: "line",
      dataElementType: "point",
      indexAxis: "r",
      showLine: true,
      elements: {
        line: {
          fill: "start"
        }
      }
    };
    RadarController.overrides = {
      aspectRatio: 1,
      scales: {
        r: {
          type: "radialLinear"
        }
      }
    };
    var ScatterController = class extends LineController {
    };
    ScatterController.id = "scatter";
    ScatterController.defaults = {
      showLine: false,
      fill: false
    };
    ScatterController.overrides = {
      interaction: {
        mode: "point"
      },
      plugins: {
        tooltip: {
          callbacks: {
            title() {
              return "";
            },
            label(item) {
              return "(" + item.label + ", " + item.formattedValue + ")";
            }
          }
        }
      },
      scales: {
        x: {
          type: "linear"
        },
        y: {
          type: "linear"
        }
      }
    };
    function abstract() {
      throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
    }
    var DateAdapter = class {
      constructor(options) {
        this.options = options || {};
      }
      formats() {
        return abstract();
      }
      parse(value, format) {
        return abstract();
      }
      format(timestamp, format) {
        return abstract();
      }
      add(timestamp, amount, unit) {
        return abstract();
      }
      diff(a, b, unit) {
        return abstract();
      }
      startOf(timestamp, unit, weekday) {
        return abstract();
      }
      endOf(timestamp, unit) {
        return abstract();
      }
    };
    DateAdapter.override = function(members) {
      Object.assign(DateAdapter.prototype, members);
    };
    var adapters = {
      _date: DateAdapter
    };
    function getRelativePosition(e, chart) {
      if ("native" in e) {
        return {
          x: e.x,
          y: e.y
        };
      }
      return getRelativePosition$1(e, chart);
    }
    function evaluateAllVisibleItems(chart, handler) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      let index, data, element2;
      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
        ({index, data} = metasets[i]);
        for (let j = 0, jlen = data.length; j < jlen; ++j) {
          element2 = data[j];
          if (!element2.skip) {
            handler(element2, index, j);
          }
        }
      }
    }
    function binarySearch(metaset, axis, value, intersect) {
      const {controller, data, _sorted} = metaset;
      const iScale = controller._cachedMeta.iScale;
      if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
          return lookupMethod(data, axis, value);
        } else if (controller._sharedOptions) {
          const el = data[0];
          const range = typeof el.getRange === "function" && el.getRange(axis);
          if (range) {
            const start = lookupMethod(data, axis, value - range);
            const end = lookupMethod(data, axis, value + range);
            return {lo: start.lo, hi: end.hi};
          }
        }
      }
      return {lo: 0, hi: data.length - 1};
    }
    function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      const value = position[axis];
      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
        const {index, data} = metasets[i];
        const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
        for (let j = lo; j <= hi; ++j) {
          const element2 = data[j];
          if (!element2.skip) {
            handler(element2, index, j);
          }
        }
      }
    }
    function getDistanceMetricForAxis(axis) {
      const useX = axis.indexOf("x") !== -1;
      const useY = axis.indexOf("y") !== -1;
      return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }
    function getIntersectItems(chart, position, axis, useFinalPosition) {
      const items = [];
      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
        return items;
      }
      const evaluationFunc = function(element2, datasetIndex, index) {
        if (element2.inRange(position.x, position.y, useFinalPosition)) {
          items.push({element: element2, datasetIndex, index});
        }
      };
      optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
      return items;
    }
    function getNearestRadialItems(chart, position, axis, useFinalPosition) {
      let items = [];
      function evaluationFunc(element2, datasetIndex, index) {
        const {startAngle, endAngle} = element2.getProps(["startAngle", "endAngle"], useFinalPosition);
        const {angle} = getAngleFromPoint(element2, {x: position.x, y: position.y});
        if (_angleBetween(angle, startAngle, endAngle)) {
          items.push({element: element2, datasetIndex, index});
        }
      }
      optimizedEvaluateItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
      let items = [];
      const distanceMetric = getDistanceMetricForAxis(axis);
      let minDistance = Number.POSITIVE_INFINITY;
      function evaluationFunc(element2, datasetIndex, index) {
        const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange2) {
          return;
        }
        const center = element2.getCenterPoint(useFinalPosition);
        const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
        if (!pointInArea && !inRange2) {
          return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
          items = [{element: element2, datasetIndex, index}];
          minDistance = distance;
        } else if (distance === minDistance) {
          items.push({element: element2, datasetIndex, index});
        }
      }
      optimizedEvaluateItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
        return [];
      }
      return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
    }
    function getAxisItems(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const items = [];
      const axis = options.axis;
      const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
      let intersectsItem = false;
      evaluateAllVisibleItems(chart, (element2, datasetIndex, index) => {
        if (element2[rangeMethod](position[axis], useFinalPosition)) {
          items.push({element: element2, datasetIndex, index});
        }
        if (element2.inRange(position.x, position.y, useFinalPosition)) {
          intersectsItem = true;
        }
      });
      if (options.intersect && !intersectsItem) {
        return [];
      }
      return items;
    }
    var Interaction = {
      modes: {
        index(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "x";
          const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
          const elements = [];
          if (!items.length) {
            return [];
          }
          chart.getSortedVisibleDatasetMetas().forEach((meta) => {
            const index = items[0].index;
            const element2 = meta.data[index];
            if (element2 && !element2.skip) {
              elements.push({element: element2, datasetIndex: meta.index, index});
            }
          });
          return elements;
        },
        dataset(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
          if (items.length > 0) {
            const datasetIndex = items[0].datasetIndex;
            const data = chart.getDatasetMeta(datasetIndex).data;
            items = [];
            for (let i = 0; i < data.length; ++i) {
              items.push({element: data[i], datasetIndex, index: i});
            }
          }
          return items;
        },
        point(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          return getIntersectItems(chart, position, axis, useFinalPosition);
        },
        nearest(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
        },
        x(chart, e, options, useFinalPosition) {
          return getAxisItems(chart, e, {axis: "x", intersect: options.intersect}, useFinalPosition);
        },
        y(chart, e, options, useFinalPosition) {
          return getAxisItems(chart, e, {axis: "y", intersect: options.intersect}, useFinalPosition);
        }
      }
    };
    var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
    function filterByPosition(array, position) {
      return array.filter((v) => v.pos === position);
    }
    function filterDynamicPositionByAxis(array, axis) {
      return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
    }
    function sortByWeight(array, reverse) {
      return array.sort((a, b) => {
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
      });
    }
    function wrapBoxes(boxes) {
      const layoutBoxes = [];
      let i, ilen, box, pos, stack, stackWeight;
      for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
        box = boxes[i];
        ({position: pos, options: {stack, stackWeight = 1}} = box);
        layoutBoxes.push({
          index: i,
          box,
          pos,
          horizontal: box.isHorizontal(),
          weight: box.weight,
          stack: stack && pos + stack,
          stackWeight
        });
      }
      return layoutBoxes;
    }
    function buildStacks(layouts2) {
      const stacks = {};
      for (const wrap of layouts2) {
        const {stack, pos, stackWeight} = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
          continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
        _stack.count++;
        _stack.weight += stackWeight;
      }
      return stacks;
    }
    function setLayoutDims(layouts2, params) {
      const stacks = buildStacks(layouts2);
      const {vBoxMaxWidth, hBoxMaxHeight} = params;
      let i, ilen, layout;
      for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
        layout = layouts2[i];
        const {fullSize} = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
          layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
          layout.height = hBoxMaxHeight;
        } else {
          layout.width = vBoxMaxWidth;
          layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
      }
      return stacks;
    }
    function buildLayoutBoxes(boxes) {
      const layoutBoxes = wrapBoxes(boxes);
      const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
      const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
      const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
      const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
      const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
      return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
      };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
    }
    function updateMaxPadding(maxPadding, boxPadding) {
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea, params, layout, stacks) {
      const {pos, box} = layout;
      const maxPadding = chartArea.maxPadding;
      if (!isObject2(pos)) {
        if (layout.size) {
          chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {size: 0, count: 1};
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
      }
      if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
      }
      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
      const widthChanged = newWidth !== chartArea.w;
      const heightChanged = newHeight !== chartArea.h;
      chartArea.w = newWidth;
      chartArea.h = newHeight;
      return layout.horizontal ? {same: widthChanged, other: heightChanged} : {same: heightChanged, other: widthChanged};
    }
    function handleMaxPadding(chartArea) {
      const maxPadding = chartArea.maxPadding;
      function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
      }
      chartArea.y += updatePos("top");
      chartArea.x += updatePos("left");
      updatePos("right");
      updatePos("bottom");
    }
    function getMargins(horizontal, chartArea) {
      const maxPadding = chartArea.maxPadding;
      function marginForPositions(positions2) {
        const margin = {left: 0, top: 0, right: 0, bottom: 0};
        positions2.forEach((pos) => {
          margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
      }
      return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
    }
    function fitBoxes(boxes, chartArea, params, stacks) {
      const refitBoxes = [];
      let i, ilen, layout, box, refit, changed;
      for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const {same, other} = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
          refitBoxes.push(layout);
        }
      }
      return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
    }
    function setBoxDims(box, left, top, width, height) {
      box.top = top;
      box.left = left;
      box.right = left + width;
      box.bottom = top + height;
      box.width = width;
      box.height = height;
    }
    function placeBoxes(boxes, chartArea, params, stacks) {
      const userPadding = params.padding;
      let {x, y} = chartArea;
      for (const layout of boxes) {
        const box = layout.box;
        const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
          const width = chartArea.w * weight;
          const height = stack.size || box.height;
          if (defined(stack.start)) {
            y = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
          } else {
            setBoxDims(box, chartArea.left + stack.placed, y, width, height);
          }
          stack.start = y;
          stack.placed += width;
          y = box.bottom;
        } else {
          const height = chartArea.h * weight;
          const width = stack.size || box.width;
          if (defined(stack.start)) {
            x = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
          } else {
            setBoxDims(box, x, chartArea.top + stack.placed, width, height);
          }
          stack.start = x;
          stack.placed += height;
          x = box.right;
        }
      }
      chartArea.x = x;
      chartArea.y = y;
    }
    defaults3.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
    var layouts = {
      addBox(chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
          return [{
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }];
        };
        chart.boxes.push(item);
      },
      removeBox(chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },
      configure(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
      },
      update(chart, width, height, minPadding) {
        if (!chart) {
          return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, (box) => {
          if (typeof box.beforeLayout === "function") {
            box.beforeLayout();
          }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
          outerWidth: width,
          outerHeight: height,
          padding,
          availableWidth,
          availableHeight,
          vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
          hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea = Object.assign({
          maxPadding,
          w: availableWidth,
          h: availableHeight,
          x: padding.left,
          y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
          fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
          left: chartArea.left,
          top: chartArea.top,
          right: chartArea.left + chartArea.w,
          bottom: chartArea.top + chartArea.h,
          height: chartArea.h,
          width: chartArea.w
        };
        each(boxes.chartArea, (layout) => {
          const box = layout.box;
          Object.assign(box, chart.chartArea);
          box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});
        });
      }
    };
    var BasePlatform = class {
      acquireContext(canvas, aspectRatio) {
      }
      releaseContext(context) {
        return false;
      }
      addEventListener(chart, type, listener) {
      }
      removeEventListener(chart, type, listener) {
      }
      getDevicePixelRatio() {
        return 1;
      }
      getMaximumSize(element2, width, height, aspectRatio) {
        width = Math.max(0, width || element2.width);
        height = height || element2.height;
        return {
          width,
          height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
      }
      isAttached(canvas) {
        return true;
      }
      updateConfig(config) {
      }
    };
    var BasicPlatform = class extends BasePlatform {
      acquireContext(item) {
        return item && item.getContext && item.getContext("2d") || null;
      }
      updateConfig(config) {
        config.options.animation = false;
      }
    };
    var EXPANDO_KEY = "$chartjs";
    var EVENT_TYPES = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    };
    var isNullOrEmpty = (value) => value === null || value === "";
    function initCanvas(canvas, aspectRatio) {
      const style = canvas.style;
      const renderHeight = canvas.getAttribute("height");
      const renderWidth = canvas.getAttribute("width");
      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      };
      style.display = style.display || "block";
      style.boxSizing = style.boxSizing || "border-box";
      if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, "width");
        if (displayWidth !== void 0) {
          canvas.width = displayWidth;
        }
      }
      if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") {
          canvas.height = canvas.width / (aspectRatio || 2);
        } else {
          const displayHeight = readUsedSize(canvas, "height");
          if (displayHeight !== void 0) {
            canvas.height = displayHeight;
          }
        }
      }
      return canvas;
    }
    var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
    function removeListener(chart, type, listener) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
    function fromNativeEvent(event, chart) {
      const type = EVENT_TYPES[event.type] || event.type;
      const {x, y} = getRelativePosition$1(event, chart);
      return {
        type,
        chart,
        native: event,
        x: x !== void 0 ? x : null,
        y: y !== void 0 ? y : null
      };
    }
    function nodeListContains(nodeList, canvas) {
      for (const node of nodeList) {
        if (node === canvas || node.contains(canvas)) {
          return true;
        }
      }
    }
    function createAttachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.addedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {childList: true, subtree: true});
      return observer;
    }
    function createDetachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.removedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {childList: true, subtree: true});
      return observer;
    }
    var drpListeningCharts = new Map();
    var oldDevicePixelRatio = 0;
    function onWindowResize() {
      const dpr = window.devicePixelRatio;
      if (dpr === oldDevicePixelRatio) {
        return;
      }
      oldDevicePixelRatio = dpr;
      drpListeningCharts.forEach((resize, chart) => {
        if (chart.currentDevicePixelRatio !== dpr) {
          resize();
        }
      });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
      if (!drpListeningCharts.size) {
        window.addEventListener("resize", onWindowResize);
      }
      drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
      drpListeningCharts.delete(chart);
      if (!drpListeningCharts.size) {
        window.removeEventListener("resize", onWindowResize);
      }
    }
    function createResizeObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        return;
      }
      const resize = throttled((width, height) => {
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
          listener();
        }
      }, window);
      const observer = new ResizeObserver((entries) => {
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
          return;
        }
        resize(width, height);
      });
      observer.observe(container);
      listenDevicePixelRatioChanges(chart, resize);
      return observer;
    }
    function releaseObserver(chart, type, observer) {
      if (observer) {
        observer.disconnect();
      }
      if (type === "resize") {
        unlistenDevicePixelRatioChanges(chart);
      }
    }
    function createProxyAndListen(chart, type, listener) {
      const canvas = chart.canvas;
      const proxy = throttled((event) => {
        if (chart.ctx !== null) {
          listener(fromNativeEvent(event, chart));
        }
      }, chart, (args) => {
        const event = args[0];
        return [event, event.offsetX, event.offsetY];
      });
      addListener(canvas, type, proxy);
      return proxy;
    }
    var DomPlatform = class extends BasePlatform {
      acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext("2d");
        if (context && context.canvas === canvas) {
          initCanvas(canvas, aspectRatio);
          return context;
        }
        return null;
      }
      releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
          return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        ["height", "width"].forEach((prop) => {
          const value = initial[prop];
          if (isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key) => {
          canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
      }
      addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
          attach: createAttachObserver,
          detach: createDetachObserver,
          resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
      }
      removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
          return;
        }
        const handlers = {
          attach: releaseObserver,
          detach: releaseObserver,
          resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = void 0;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
      }
      isAttached(canvas) {
        const container = _getParentNode(canvas);
        return !!(container && container.isConnected);
      }
    };
    function _detectPlatform(canvas) {
      if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
      }
      return DomPlatform;
    }
    var Element = class {
      constructor() {
        this.x = void 0;
        this.y = void 0;
        this.active = false;
        this.options = void 0;
        this.$animations = void 0;
      }
      tooltipPosition(useFinalPosition) {
        const {x, y} = this.getProps(["x", "y"], useFinalPosition);
        return {x, y};
      }
      hasValue() {
        return isNumber2(this.x) && isNumber2(this.y);
      }
      getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
          return this;
        }
        const ret = {};
        props.forEach((prop) => {
          ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
      }
    };
    Element.defaults = {};
    Element.defaultRoutes = void 0;
    var formatters = {
      values(value) {
        return isArray2(value) ? value : "" + value;
      },
      numeric(tickValue, index, ticks) {
        if (tickValue === 0) {
          return "0";
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
          const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
          if (maxTick < 1e-4 || maxTick > 1e15) {
            notation = "scientific";
          }
          delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
      },
      logarithmic(tickValue, index, ticks) {
        if (tickValue === 0) {
          return "0";
        }
        const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if (remain === 1 || remain === 2 || remain === 5) {
          return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return "";
      }
    };
    function calculateDelta(tickValue, ticks) {
      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
      }
      return delta;
    }
    var Ticks = {formatters};
    defaults3.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false,
        borderDash: [],
        borderDashOffset: 0,
        borderWidth: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults3.route("scale.ticks", "color", "", "color");
    defaults3.route("scale.grid", "color", "", "borderColor");
    defaults3.route("scale.grid", "borderColor", "", "borderColor");
    defaults3.route("scale.title", "color", "", "color");
    defaults3.describe("scale", {
      _fallback: false,
      _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
      _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash"
    });
    defaults3.describe("scales", {
      _fallback: "scale"
    });
    defaults3.describe("scale.ticks", {
      _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
      _indexable: (name2) => name2 !== "backdropPadding"
    });
    function autoSkip(scale, ticks) {
      const tickOpts = scale.options.ticks;
      const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      const numMajorIndices = majorIndices.length;
      const first = majorIndices[0];
      const last = majorIndices[numMajorIndices - 1];
      const newTicks = [];
      if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
      }
      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
      if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
          skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
      }
      skip(ticks, newTicks, spacing);
      return newTicks;
    }
    function determineMaxTicks(scale) {
      const offset = scale.options.offset;
      const tickLength = scale._tickSize();
      const maxScale = scale._length / tickLength + (offset ? 0 : 1);
      const maxChart = scale._maxLength / tickLength;
      return Math.floor(Math.min(maxScale, maxChart));
    }
    function calculateSpacing(majorIndices, ticks, ticksLimit) {
      const evenMajorSpacing = getEvenSpacing(majorIndices);
      const spacing = ticks.length / ticksLimit;
      if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
      }
      const factors = _factorize(evenMajorSpacing);
      for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
        const factor = factors[i];
        if (factor > spacing) {
          return factor;
        }
      }
      return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
      const result = [];
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (ticks[i].major) {
          result.push(i);
        }
      }
      return result;
    }
    function skipMajors(ticks, newTicks, majorIndices, spacing) {
      let count = 0;
      let next = majorIndices[0];
      let i;
      spacing = Math.ceil(spacing);
      for (i = 0; i < ticks.length; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = majorIndices[count * spacing];
        }
      }
    }
    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
      const start = valueOrDefault(majorStart, 0);
      const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
      let count = 0;
      let length, i, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
      }
      next = start;
      while (next < 0) {
        count++;
        next = Math.round(start + count * spacing);
      }
      for (i = Math.max(start, 0); i < end; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = Math.round(start + count * spacing);
        }
      }
    }
    function getEvenSpacing(arr) {
      const len = arr.length;
      let i, diff;
      if (len < 2) {
        return false;
      }
      for (diff = arr[0], i = 1; i < len; ++i) {
        if (arr[i] - arr[i - 1] !== diff) {
          return false;
        }
      }
      return diff;
    }
    var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
    var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
    function sample(arr, numItems) {
      const result = [];
      const increment = arr.length / numItems;
      const len = arr.length;
      let i = 0;
      for (; i < len; i += increment) {
        result.push(arr[Math.floor(i)]);
      }
      return result;
    }
    function getPixelForGridLine(scale, index, offsetGridLines) {
      const length = scale.ticks.length;
      const validIndex2 = Math.min(index, length - 1);
      const start = scale._startPixel;
      const end = scale._endPixel;
      const epsilon = 1e-6;
      let lineValue = scale.getPixelForTick(validIndex2);
      let offset;
      if (offsetGridLines) {
        if (length === 1) {
          offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
          offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
        }
        lineValue += validIndex2 < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
          return;
        }
      }
      return lineValue;
    }
    function garbageCollect(caches, length) {
      each(caches, (cache) => {
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
          for (i = 0; i < gcLen; ++i) {
            delete cache.data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
      });
    }
    function getTickMarkLength(options) {
      return options.drawTicks ? options.tickLength : 0;
    }
    function getTitleHeight(options, fallback) {
      if (!options.display) {
        return 0;
      }
      const font = toFont(options.font, fallback);
      const padding = toPadding(options.padding);
      const lines = isArray2(options.text) ? options.text.length : 1;
      return lines * font.lineHeight + padding.height;
    }
    function createScaleContext(parent2, scale) {
      return createContext(parent2, {
        scale,
        type: "scale"
      });
    }
    function createTickContext(parent2, index, tick2) {
      return createContext(parent2, {
        tick: tick2,
        index,
        type: "tick"
      });
    }
    function titleAlign(align, position, reverse) {
      let ret = _toLeftRightCenter(align);
      if (reverse && position !== "right" || !reverse && position === "right") {
        ret = reverseAlign(ret);
      }
      return ret;
    }
    function titleArgs(scale, offset, position, align) {
      const {top, left, bottom, right, chart} = scale;
      const {chartArea, scales} = chart;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      const height = bottom - top;
      const width = right - left;
      if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === "center") {
          titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
          titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
      } else {
        if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === "center") {
          titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
          titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = _alignStartEnd(align, bottom, top);
        rotation = position === "left" ? -HALF_PI : HALF_PI;
      }
      return {titleX, titleY, maxWidth, rotation};
    }
    var Scale = class extends Element {
      constructor(cfg) {
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = void 0;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this._margins = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        this.maxWidth = void 0;
        this.maxHeight = void 0;
        this.paddingTop = void 0;
        this.paddingBottom = void 0;
        this.paddingLeft = void 0;
        this.paddingRight = void 0;
        this.axis = void 0;
        this.labelRotation = void 0;
        this.min = void 0;
        this.max = void 0;
        this._range = void 0;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = void 0;
        this._endPixel = void 0;
        this._reversePixels = false;
        this._userMax = void 0;
        this._userMin = void 0;
        this._suggestedMax = void 0;
        this._suggestedMin = void 0;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = void 0;
      }
      init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
      }
      parse(raw, index) {
        return raw;
      }
      getUserBounds() {
        let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
          min: finiteOrDefault(_userMin, _suggestedMin),
          max: finiteOrDefault(_userMax, _suggestedMax),
          minDefined: isNumberFinite(_userMin),
          maxDefined: isNumberFinite(_userMax)
        };
      }
      getMinMax(canStack) {
        let {min, max, minDefined, maxDefined} = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
          return {min, max};
        }
        const metas = this.getMatchingVisibleMetas();
        for (let i = 0, ilen = metas.length; i < ilen; ++i) {
          range = metas[i].controller.getMinMax(this, canStack);
          if (!minDefined) {
            min = Math.min(min, range.min);
          }
          if (!maxDefined) {
            max = Math.max(max, range.max);
          }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
          min: finiteOrDefault(min, finiteOrDefault(max, min)),
          max: finiteOrDefault(max, finiteOrDefault(min, max))
        };
      }
      getPadding() {
        return {
          left: this.paddingLeft || 0,
          top: this.paddingTop || 0,
          right: this.paddingRight || 0,
          bottom: this.paddingBottom || 0
        };
      }
      getTicks() {
        return this.ticks;
      }
      getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      }
      beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
      }
      beforeUpdate() {
        callback(this.options.beforeUpdate, [this]);
      }
      update(maxWidth, maxHeight, margins) {
        const {beginAtZero, grace, ticks: tickOpts} = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
          this.beforeDataLimits();
          this.determineDataLimits();
          this.afterDataLimits();
          this._range = _addGrace(this, grace, beginAtZero);
          this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
          this.ticks = autoSkip(this, this.ticks);
          this._labelSizes = null;
        }
        if (samplingEnabled) {
          this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
      }
      configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
          startPixel = this.left;
          endPixel = this.right;
        } else {
          startPixel = this.top;
          endPixel = this.bottom;
          reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
        callback(this.options.afterUpdate, [this]);
      }
      beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [this]);
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = 0;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = 0;
          this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
      }
      afterSetDimensions() {
        callback(this.options.afterSetDimensions, [this]);
      }
      _callHooks(name2) {
        this.chart.notifyPlugins(name2, this.getContext());
        callback(this.options[name2], [this]);
      }
      beforeDataLimits() {
        this._callHooks("beforeDataLimits");
      }
      determineDataLimits() {
      }
      afterDataLimits() {
        this._callHooks("afterDataLimits");
      }
      beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
      }
      buildTicks() {
        return [];
      }
      afterBuildTicks() {
        this._callHooks("afterBuildTicks");
      }
      beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [this]);
      }
      generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick2;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          tick2 = ticks[i];
          tick2.label = callback(tickOpts.callback, [tick2.value, i, ticks], this);
        }
      }
      afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [this]);
      }
      beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [this]);
      }
      calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = this.ticks.length;
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
          this.labelRotation = minRotation;
          return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
          tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
          maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
          labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
      }
      afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [this]);
      }
      beforeFit() {
        callback(this.options.beforeFit, [this]);
      }
      fit() {
        const minSize = {
          width: 0,
          height: 0
        };
        const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
          const titleHeight = getTitleHeight(titleOpts, chart.options.font);
          if (isHorizontal) {
            minSize.width = this.maxWidth;
            minSize.height = getTickMarkLength(gridOpts) + titleHeight;
          } else {
            minSize.height = this.maxHeight;
            minSize.width = getTickMarkLength(gridOpts) + titleHeight;
          }
          if (tickOpts.display && this.ticks.length) {
            const {first, last, widest, highest} = this._getLabelSizes();
            const tickPadding = tickOpts.padding * 2;
            const angleRadians = toRadians(this.labelRotation);
            const cos = Math.cos(angleRadians);
            const sin = Math.sin(angleRadians);
            if (isHorizontal) {
              const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
              minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
            } else {
              const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
              minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
            }
            this._calculatePadding(first, last, sin, cos);
          }
        }
        this._handleMargins();
        if (isHorizontal) {
          this.width = this._length = chart.width - this._margins.left - this._margins.right;
          this.height = minSize.height;
        } else {
          this.width = minSize.width;
          this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
      }
      _calculatePadding(first, last, sin, cos) {
        const {ticks: {align, padding}, position} = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
          const offsetLeft = this.getPixelForTick(0) - this.left;
          const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
          let paddingLeft = 0;
          let paddingRight = 0;
          if (isRotated) {
            if (labelsBelowTicks) {
              paddingLeft = cos * first.width;
              paddingRight = sin * last.height;
            } else {
              paddingLeft = sin * first.height;
              paddingRight = cos * last.width;
            }
          } else if (align === "start") {
            paddingRight = last.width;
          } else if (align === "end") {
            paddingLeft = first.width;
          } else {
            paddingLeft = first.width / 2;
            paddingRight = last.width / 2;
          }
          this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
          this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
          let paddingTop = last.height / 2;
          let paddingBottom = first.height / 2;
          if (align === "start") {
            paddingTop = 0;
            paddingBottom = first.height;
          } else if (align === "end") {
            paddingTop = last.height;
            paddingBottom = 0;
          }
          this.paddingTop = paddingTop + padding;
          this.paddingBottom = paddingBottom + padding;
        }
      }
      _handleMargins() {
        if (this._margins) {
          this._margins.left = Math.max(this.paddingLeft, this._margins.left);
          this._margins.top = Math.max(this.paddingTop, this._margins.top);
          this._margins.right = Math.max(this.paddingRight, this._margins.right);
          this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
      }
      afterFit() {
        callback(this.options.afterFit, [this]);
      }
      isHorizontal() {
        const {axis, position} = this.options;
        return position === "top" || position === "bottom" || axis === "x";
      }
      isFullSize() {
        return this.options.fullSize;
      }
      _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (isNullOrUndef(ticks[i].label)) {
            ticks.splice(i, 1);
            ilen--;
            i--;
          }
        }
        this.afterTickToLabelConversion();
      }
      _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
          const sampleSize = this.options.ticks.sampleSize;
          let ticks = this.ticks;
          if (sampleSize < ticks.length) {
            ticks = sample(ticks, sampleSize);
          }
          this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
        }
        return labelSizes;
      }
      _computeLabelSizes(ticks, length) {
        const {ctx, _longestTextCache: caches} = this;
        const widths = [];
        const heights = [];
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for (i = 0; i < length; ++i) {
          label = ticks[i].label;
          tickFont = this._resolveTickFontOptions(i);
          ctx.font = fontString = tickFont.string;
          cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
          lineHeight = tickFont.lineHeight;
          width = height = 0;
          if (!isNullOrUndef(label) && !isArray2(label)) {
            width = _measureText(ctx, cache.data, cache.gc, width, label);
            height = lineHeight;
          } else if (isArray2(label)) {
            for (j = 0, jlen = label.length; j < jlen; ++j) {
              nestedLabel = label[j];
              if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
                width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                height += lineHeight;
              }
            }
          }
          widths.push(width);
          heights.push(height);
          widestLabelSize = Math.max(width, widestLabelSize);
          highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
        return {
          first: valueAt(0),
          last: valueAt(length - 1),
          widest: valueAt(widest),
          highest: valueAt(highest),
          widths,
          heights
        };
      }
      getLabelForValue(value) {
        return value;
      }
      getPixelForValue(value, index) {
        return NaN;
      }
      getValueForPixel(pixel) {
      }
      getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index].value);
      }
      getPixelForDecimal(decimal) {
        if (this._reversePixels) {
          decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
      }
      getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
      }
      getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
      }
      getBaseValue() {
        const {min, max} = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      }
      getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
          const tick2 = ticks[index];
          return tick2.$context || (tick2.$context = createTickContext(this.getContext(), index, tick2));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
      }
      _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      }
      _isVisible() {
        const display = this.options.display;
        if (display !== "auto") {
          return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
      }
      _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const {grid, position} = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
          return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === "top") {
          borderValue = alignBorderValue(this.bottom);
          ty1 = this.bottom - tl;
          ty2 = borderValue - axisHalfWidth;
          y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
          y2 = chartArea.bottom;
        } else if (position === "bottom") {
          borderValue = alignBorderValue(this.top);
          y1 = chartArea.top;
          y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
          ty1 = borderValue + axisHalfWidth;
          ty2 = this.top + tl;
        } else if (position === "left") {
          borderValue = alignBorderValue(this.right);
          tx1 = this.right - tl;
          tx2 = borderValue - axisHalfWidth;
          x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
          x2 = chartArea.right;
        } else if (position === "right") {
          borderValue = alignBorderValue(this.left);
          x1 = chartArea.left;
          x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
          tx1 = borderValue + axisHalfWidth;
          tx2 = this.left + tl;
        } else if (axis === "x") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
          } else if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          y1 = chartArea.top;
          y2 = chartArea.bottom;
          ty1 = borderValue + axisHalfWidth;
          ty2 = ty1 + tl;
        } else if (axis === "y") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
          } else if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          tx1 = borderValue - axisHalfWidth;
          tx2 = tx1 - tl;
          x1 = chartArea.left;
          x2 = chartArea.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for (i = 0; i < ticksLength; i += step) {
          const optsAtIndex = grid.setContext(this.getContext(i));
          const lineWidth = optsAtIndex.lineWidth;
          const lineColor = optsAtIndex.color;
          const borderDash = grid.borderDash || [];
          const borderDashOffset = optsAtIndex.borderDashOffset;
          const tickWidth = optsAtIndex.tickWidth;
          const tickColor = optsAtIndex.tickColor;
          const tickBorderDash = optsAtIndex.tickBorderDash || [];
          const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
          lineValue = getPixelForGridLine(this, i, offset);
          if (lineValue === void 0) {
            continue;
          }
          alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
          if (isHorizontal) {
            tx1 = tx2 = x1 = x2 = alignedLineValue;
          } else {
            ty1 = ty2 = y1 = y2 = alignedLineValue;
          }
          items.push({
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2,
            width: lineWidth,
            color: lineColor,
            borderDash,
            borderDashOffset,
            tickWidth,
            tickColor,
            tickBorderDash,
            tickBorderDashOffset
          });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
      }
      _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const {position, ticks: optionTicks} = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const {align, crossAlign, padding, mirror} = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = "middle";
        if (position === "top") {
          y = this.bottom - hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "bottom") {
          y = this.top + hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "left") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (position === "right") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (axis === "x") {
          if (position === "center") {
            y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
          } else if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
          }
          textAlign = this._getXAxisLabelAlignment();
        } else if (axis === "y") {
          if (position === "center") {
            x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
          } else if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            x = this.chart.scales[positionAxisID].getPixelForValue(value);
          }
          textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === "y") {
          if (align === "start") {
            textBaseline = "top";
          } else if (align === "end") {
            textBaseline = "bottom";
          }
        }
        const labelSizes = this._getLabelSizes();
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick2 = ticks[i];
          label = tick2.label;
          const optsAtIndex = optionTicks.setContext(this.getContext(i));
          pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
          font = this._resolveTickFontOptions(i);
          lineHeight = font.lineHeight;
          lineCount = isArray2(label) ? label.length : 1;
          const halfCount = lineCount / 2;
          const color2 = optsAtIndex.color;
          const strokeColor = optsAtIndex.textStrokeColor;
          const strokeWidth = optsAtIndex.textStrokeWidth;
          if (isHorizontal) {
            x = pixel;
            if (position === "top") {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = -lineCount * lineHeight + lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
              } else {
                textOffset = -labelSizes.highest.height + lineHeight / 2;
              }
            } else {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
              } else {
                textOffset = labelSizes.highest.height - lineCount * lineHeight;
              }
            }
            if (mirror) {
              textOffset *= -1;
            }
          } else {
            y = pixel;
            textOffset = (1 - lineCount) * lineHeight / 2;
          }
          let backdrop;
          if (optsAtIndex.showLabelBackdrop) {
            const labelPadding = toPadding(optsAtIndex.backdropPadding);
            const height = labelSizes.heights[i];
            const width = labelSizes.widths[i];
            let top = y + textOffset - labelPadding.top;
            let left = x - labelPadding.left;
            switch (textBaseline) {
              case "middle":
                top -= height / 2;
                break;
              case "bottom":
                top -= height;
                break;
            }
            switch (textAlign) {
              case "center":
                left -= width / 2;
                break;
              case "right":
                left -= width;
                break;
            }
            backdrop = {
              left,
              top,
              width: width + labelPadding.width,
              height: height + labelPadding.height,
              color: optsAtIndex.backdropColor
            };
          }
          items.push({
            rotation,
            label,
            font,
            color: color2,
            strokeColor,
            strokeWidth,
            textOffset,
            textAlign,
            textBaseline,
            translation: [x, y],
            backdrop
          });
        }
        return items;
      }
      _getXAxisLabelAlignment() {
        const {position, ticks} = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
          return position === "top" ? "left" : "right";
        }
        let align = "center";
        if (ticks.align === "start") {
          align = "left";
        } else if (ticks.align === "end") {
          align = "right";
        }
        return align;
      }
      _getYAxisLabelAlignment(tl) {
        const {position, ticks: {crossAlign, mirror, padding}} = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === "left") {
          if (mirror) {
            x = this.right + padding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x += widest;
            }
          } else {
            x = this.right - tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x = this.left;
            }
          }
        } else if (position === "right") {
          if (mirror) {
            x = this.left + padding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x -= widest;
            }
          } else {
            x = this.left + tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x = this.right;
            }
          }
        } else {
          textAlign = "right";
        }
        return {textAlign, x};
      }
      _computeLabelArea() {
        if (this.options.ticks.mirror) {
          return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === "left" || position === "right") {
          return {top: 0, left: this.left, bottom: chart.height, right: this.right};
        }
        if (position === "top" || position === "bottom") {
          return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};
        }
      }
      drawBackground() {
        const {ctx, options: {backgroundColor}, left, top, width, height} = this;
        if (backgroundColor) {
          ctx.save();
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(left, top, width, height);
          ctx.restore();
        }
      }
      getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
          return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex((t) => t.value === value);
        if (index >= 0) {
          const opts = grid.setContext(this.getContext(index));
          return opts.lineWidth;
        }
        return 0;
      }
      drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style) => {
          if (!style.width || !style.color) {
            return;
          }
          ctx.save();
          ctx.lineWidth = style.width;
          ctx.strokeStyle = style.color;
          ctx.setLineDash(style.borderDash || []);
          ctx.lineDashOffset = style.borderDashOffset;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.restore();
        };
        if (grid.display) {
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            if (grid.drawOnChartArea) {
              drawLine({x: item.x1, y: item.y1}, {x: item.x2, y: item.y2}, item);
            }
            if (grid.drawTicks) {
              drawLine({x: item.tx1, y: item.ty1}, {x: item.tx2, y: item.ty2}, {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
              });
            }
          }
        }
      }
      drawBorder() {
        const {chart, ctx, options: {grid}} = this;
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
        if (!axisWidth) {
          return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
          x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
          x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
          y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.borderWidth;
        ctx.strokeStyle = borderOpts.borderColor;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }
      drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
          return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
          clipArea(ctx, area);
        }
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          const tickFont = item.font;
          const label = item.label;
          if (item.backdrop) {
            ctx.fillStyle = item.backdrop.color;
            ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
          }
          let y = item.textOffset;
          renderText(ctx, label, 0, y, tickFont, item);
        }
        if (area) {
          unclipArea(ctx);
        }
      }
      drawTitle() {
        const {ctx, options: {position, title, reverse}} = this;
        if (!title.display) {
          return;
        }
        const font = toFont(title.font);
        const padding = toPadding(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === "bottom" || position === "center" || isObject2(position)) {
          offset += padding.bottom;
          if (isArray2(title.text)) {
            offset += font.lineHeight * (title.text.length - 1);
          }
        } else {
          offset += padding.top;
        }
        const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
        renderText(ctx, title.text, 0, 0, font, {
          color: title.color,
          maxWidth,
          rotation,
          textAlign: titleAlign(align, position, reverse),
          textBaseline: "middle",
          translation: [titleX, titleY]
        });
      }
      draw(chartArea) {
        if (!this._isVisible()) {
          return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
      }
      _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
          return [{
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }];
        }
        return [{
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        }, {
          z: gz + 1,
          draw: () => {
            this.drawBorder();
          }
        }, {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }];
      }
      getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + "AxisID";
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          const meta = metas[i];
          if (meta[axisID] === this.id && (!type || meta.type === type)) {
            result.push(meta);
          }
        }
        return result;
      }
      _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return toFont(opts.font);
      }
      _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
      }
    };
    var TypedRegistry = class {
      constructor(type, scope, override) {
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
      }
      isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
      }
      register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
          parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + "." + id;
        if (!id) {
          throw new Error("class does not have id: " + item);
        }
        if (id in items) {
          return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
          defaults3.override(item.id, item.overrides);
        }
        return scope;
      }
      get(id) {
        return this.items[id];
      }
      unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
          delete items[id];
        }
        if (scope && id in defaults3[scope]) {
          delete defaults3[scope][id];
          if (this.override) {
            delete overrides[id];
          }
        }
      }
    };
    function registerDefaults(item, scope, parentScope) {
      const itemDefaults = merge2(Object.create(null), [
        parentScope ? defaults3.get(parentScope) : {},
        defaults3.get(scope),
        item.defaults
      ]);
      defaults3.set(scope, itemDefaults);
      if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
      }
      if (item.descriptors) {
        defaults3.describe(scope, item.descriptors);
      }
    }
    function routeDefaults(scope, routes2) {
      Object.keys(routes2).forEach((property) => {
        const propertyParts = property.split(".");
        const sourceName = propertyParts.pop();
        const sourceScope = [scope].concat(propertyParts).join(".");
        const parts = routes2[property].split(".");
        const targetName = parts.pop();
        const targetScope = parts.join(".");
        defaults3.route(sourceScope, sourceName, targetScope, targetName);
      });
    }
    function isIChartComponent(proto) {
      return "id" in proto && "defaults" in proto;
    }
    var Registry = class {
      constructor() {
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [this.controllers, this.scales, this.elements];
      }
      add(...args) {
        this._each("register", args);
      }
      remove(...args) {
        this._each("unregister", args);
      }
      addControllers(...args) {
        this._each("register", args, this.controllers);
      }
      addElements(...args) {
        this._each("register", args, this.elements);
      }
      addPlugins(...args) {
        this._each("register", args, this.plugins);
      }
      addScales(...args) {
        this._each("register", args, this.scales);
      }
      getController(id) {
        return this._get(id, this.controllers, "controller");
      }
      getElement(id) {
        return this._get(id, this.elements, "element");
      }
      getPlugin(id) {
        return this._get(id, this.plugins, "plugin");
      }
      getScale(id) {
        return this._get(id, this.scales, "scale");
      }
      removeControllers(...args) {
        this._each("unregister", args, this.controllers);
      }
      removeElements(...args) {
        this._each("unregister", args, this.elements);
      }
      removePlugins(...args) {
        this._each("unregister", args, this.plugins);
      }
      removeScales(...args) {
        this._each("unregister", args, this.scales);
      }
      _each(method, args, typedRegistry) {
        [...args].forEach((arg) => {
          const reg = typedRegistry || this._getRegistryForType(arg);
          if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
            this._exec(method, reg, arg);
          } else {
            each(arg, (item) => {
              const itemReg = typedRegistry || this._getRegistryForType(item);
              this._exec(method, itemReg, item);
            });
          }
        });
      }
      _exec(method, registry2, component) {
        const camelMethod = _capitalize(method);
        callback(component["before" + camelMethod], [], component);
        registry2[method](component);
        callback(component["after" + camelMethod], [], component);
      }
      _getRegistryForType(type) {
        for (let i = 0; i < this._typedRegistries.length; i++) {
          const reg = this._typedRegistries[i];
          if (reg.isForType(type)) {
            return reg;
          }
        }
        return this.plugins;
      }
      _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === void 0) {
          throw new Error('"' + id + '" is not a registered ' + type + ".");
        }
        return item;
      }
    };
    var registry = new Registry();
    var PluginService = class {
      constructor() {
        this._init = [];
      }
      notify(chart, hook, args, filter) {
        if (hook === "beforeInit") {
          this._init = this._createDescriptors(chart, true);
          this._notify(this._init, chart, "install");
        }
        const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors2, chart, hook, args);
        if (hook === "afterDestroy") {
          this._notify(descriptors2, chart, "stop");
          this._notify(this._init, chart, "uninstall");
        }
        return result;
      }
      _notify(descriptors2, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors2) {
          const plugin = descriptor.plugin;
          const method = plugin[hook];
          const params = [chart, args, descriptor.options];
          if (callback(method, params, plugin) === false && args.cancelable) {
            return false;
          }
        }
        return true;
      }
      invalidate() {
        if (!isNullOrUndef(this._cache)) {
          this._oldCache = this._cache;
          this._cache = void 0;
        }
      }
      _descriptors(chart) {
        if (this._cache) {
          return this._cache;
        }
        const descriptors2 = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors2;
      }
      _createDescriptors(chart, all2) {
        const config = chart && chart.config;
        const options = valueOrDefault(config.options && config.options.plugins, {});
        const plugins2 = allPlugins(config);
        return options === false && !all2 ? [] : createDescriptors(chart, plugins2, options, all2);
      }
      _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors2 = this._cache;
        const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
        this._notify(diff(descriptors2, previousDescriptors), chart, "start");
      }
    };
    function allPlugins(config) {
      const plugins2 = [];
      const keys = Object.keys(registry.plugins.items);
      for (let i = 0; i < keys.length; i++) {
        plugins2.push(registry.getPlugin(keys[i]));
      }
      const local = config.plugins || [];
      for (let i = 0; i < local.length; i++) {
        const plugin = local[i];
        if (plugins2.indexOf(plugin) === -1) {
          plugins2.push(plugin);
        }
      }
      return plugins2;
    }
    function getOpts(options, all2) {
      if (!all2 && options === false) {
        return null;
      }
      if (options === true) {
        return {};
      }
      return options;
    }
    function createDescriptors(chart, plugins2, options, all2) {
      const result = [];
      const context = chart.getContext();
      for (let i = 0; i < plugins2.length; i++) {
        const plugin = plugins2[i];
        const id = plugin.id;
        const opts = getOpts(options[id], all2);
        if (opts === null) {
          continue;
        }
        result.push({
          plugin,
          options: pluginOpts(chart.config, plugin, opts, context)
        });
      }
      return result;
    }
    function pluginOpts(config, plugin, opts, context) {
      const keys = config.pluginScopeKeys(plugin);
      const scopes = config.getOptionScopes(opts, keys);
      return config.createResolver(scopes, context, [""], {scriptable: false, indexable: false, allKeys: true});
    }
    function getIndexAxis(type, options) {
      const datasetDefaults = defaults3.datasets[type] || {};
      const datasetOptions = (options.datasets || {})[type] || {};
      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
    }
    function getAxisFromDefaultScaleID(id, indexAxis) {
      let axis = id;
      if (id === "_index_") {
        axis = indexAxis;
      } else if (id === "_value_") {
        axis = indexAxis === "x" ? "y" : "x";
      }
      return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
      return axis === indexAxis ? "_index_" : "_value_";
    }
    function axisFromPosition(position) {
      if (position === "top" || position === "bottom") {
        return "x";
      }
      if (position === "left" || position === "right") {
        return "y";
      }
    }
    function determineAxis(id, scaleOptions) {
      if (id === "x" || id === "y") {
        return id;
      }
      return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
    }
    function mergeScaleConfig(config, options) {
      const chartDefaults = overrides[config.type] || {scales: {}};
      const configScales = options.scales || {};
      const chartIndexAxis = getIndexAxis(config.type, options);
      const firstIDs = Object.create(null);
      const scales = Object.create(null);
      Object.keys(configScales).forEach((id) => {
        const scaleConf = configScales[id];
        if (!isObject2(scaleConf)) {
          return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
          return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        firstIDs[axis] = firstIDs[axis] || id;
        scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
      });
      config.data.datasets.forEach((dataset) => {
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID) => {
          const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
          const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
          scales[id] = scales[id] || Object.create(null);
          mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
        });
      });
      Object.keys(scales).forEach((key) => {
        const scale = scales[key];
        mergeIf(scale, [defaults3.scales[scale.type], defaults3.scale]);
      });
      return scales;
    }
    function initOptions(config) {
      const options = config.options || (config.options = {});
      options.plugins = valueOrDefault(options.plugins, {});
      options.scales = mergeScaleConfig(config, options);
    }
    function initData(data) {
      data = data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      return data;
    }
    function initConfig(config) {
      config = config || {};
      config.data = initData(config.data);
      initOptions(config);
      return config;
    }
    var keyCache = new Map();
    var keysCached = new Set();
    function cachedKeys(cacheKey, generate) {
      let keys = keyCache.get(cacheKey);
      if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
      }
      return keys;
    }
    var addIfFound = (set2, obj, key) => {
      const opts = resolveObjectKey(obj, key);
      if (opts !== void 0) {
        set2.add(opts);
      }
    };
    var Config = class {
      constructor(config) {
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
      }
      get platform() {
        return this._config.platform;
      }
      get type() {
        return this._config.type;
      }
      set type(type) {
        this._config.type = type;
      }
      get data() {
        return this._config.data;
      }
      set data(data) {
        this._config.data = initData(data);
      }
      get options() {
        return this._config.options;
      }
      set options(options) {
        this._config.options = options;
      }
      get plugins() {
        return this._config.plugins;
      }
      update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
      }
      clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
      }
      datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, () => [[
          `datasets.${datasetType}`,
          ""
        ]]);
      }
      datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, () => [
          [
            `datasets.${datasetType}.transitions.${transition}`,
            `transitions.${transition}`
          ],
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]);
      }
      datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, () => [[
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]]);
      }
      pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, () => [[
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]]);
      }
      _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
          cache = new Map();
          _scopeCache.set(mainScope, cache);
        }
        return cache;
      }
      getOptionScopes(mainScope, keyLists, resetCache) {
        const {options, type} = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
          return cached;
        }
        const scopes = new Set();
        keyLists.forEach((keys) => {
          if (mainScope) {
            scopes.add(mainScope);
            keys.forEach((key) => addIfFound(scopes, mainScope, key));
          }
          keys.forEach((key) => addIfFound(scopes, options, key));
          keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
          keys.forEach((key) => addIfFound(scopes, defaults3, key));
          keys.forEach((key) => addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
          array.push(Object.create(null));
        }
        if (keysCached.has(keyLists)) {
          cache.set(keyLists, array);
        }
        return array;
      }
      chartOptionScopes() {
        const {options, type} = this;
        return [
          options,
          overrides[type] || {},
          defaults3.datasets[type] || {},
          {type},
          defaults3,
          descriptors
        ];
      }
      resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
        const result = {$shared: true};
        const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names2)) {
          result.$shared = false;
          context = isFunction2(context) ? context() : context;
          const subResolver = this.createResolver(scopes, context, subPrefixes);
          options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names2) {
          result[prop] = options[prop];
        }
        return result;
      }
      createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
        const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
        return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
      }
    };
    function getResolver(resolverCache, scopes, prefixes) {
      let cache = resolverCache.get(scopes);
      if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
      }
      const cacheKey = prefixes.join();
      let cached = cache.get(cacheKey);
      if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
          resolver,
          subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
        };
        cache.set(cacheKey, cached);
      }
      return cached;
    }
    var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
    function needContext(proxy, names2) {
      const {isScriptable, isIndexable} = _descriptors(proxy);
      for (const prop of names2) {
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray2(value)) {
          return true;
        }
      }
      return false;
    }
    var version2 = "3.7.0";
    var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
    function positionIsHorizontal(position, axis) {
      return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
    }
    function compare2Level(l1, l2) {
      return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
      };
    }
    function onAnimationsComplete(context) {
      const chart = context.chart;
      const animationOptions2 = chart.options.animation;
      chart.notifyPlugins("afterRender");
      callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
    }
    function onAnimationProgress(context) {
      const chart = context.chart;
      const animationOptions2 = chart.options.animation;
      callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
    }
    function getCanvas(item) {
      if (_isDomSupported() && typeof item === "string") {
        item = document.getElementById(item);
      } else if (item && item.length) {
        item = item[0];
      }
      if (item && item.canvas) {
        item = item.canvas;
      }
      return item;
    }
    var instances = {};
    var getChart = (key) => {
      const canvas = getCanvas(key);
      return Object.values(instances).filter((c) => c.canvas === canvas).pop();
    };
    function moveNumericKeys(obj, start, move) {
      const keys = Object.keys(obj);
      for (const key of keys) {
        const intKey = +key;
        if (intKey >= start) {
          const value = obj[key];
          delete obj[key];
          if (move > 0 || intKey > start) {
            obj[intKey + move] = value;
          }
        }
      }
    }
    function determineLastEvent(e, lastEvent, inChartArea, isClick) {
      if (!inChartArea || e.type === "mouseout") {
        return null;
      }
      if (isClick) {
        return lastEvent;
      }
      return e;
    }
    var Chart = class {
      constructor(item, userConfig) {
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
          throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = void 0;
        this.boxes = [];
        this.currentDevicePixelRatio = void 0;
        this.chartArea = void 0;
        this._active = [];
        this._lastEvent = void 0;
        this._listeners = {};
        this._responsiveListeners = void 0;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = void 0;
        this.$context = void 0;
        this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) {
          this.update();
        }
      }
      get aspectRatio() {
        const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
        if (!isNullOrUndef(aspectRatio)) {
          return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
          return _aspectRatio;
        }
        return height ? width / height : null;
      }
      get data() {
        return this.config.data;
      }
      set data(data) {
        this.config.data = data;
      }
      get options() {
        return this._options;
      }
      set options(options) {
        this.config.options = options;
      }
      _initialize() {
        this.notifyPlugins("beforeInit");
        if (this.options.responsive) {
          this.resize();
        } else {
          retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins("afterInit");
        return this;
      }
      clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
      }
      stop() {
        animator.stop(this);
        return this;
      }
      resize(width, height) {
        if (!animator.running(this)) {
          this._resize(width, height);
        } else {
          this._resizeBeforeDraw = {width, height};
        }
      }
      _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? "resize" : "attach";
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
          return;
        }
        this.notifyPlugins("resize", {size: newSize});
        callback(options.onResize, [this, newSize], this);
        if (this.attached) {
          if (this._doResize(mode)) {
            this.render();
          }
        }
      }
      ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID) => {
          axisOptions.id = axisID;
        });
      }
      buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id) => {
          obj[id] = false;
          return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
          items = items.concat(Object.keys(scaleOpts).map((id) => {
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
              options: scaleOptions,
              dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
              dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
          }));
        }
        each(items, (item) => {
          const scaleOptions = item.options;
          const id = scaleOptions.id;
          const axis = determineAxis(id, scaleOptions);
          const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
          if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }
          updated[id] = true;
          let scale = null;
          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
          } else {
            const scaleClass = registry.getScale(scaleType);
            scale = new scaleClass({
              id,
              type: scaleType,
              ctx: this.ctx,
              chart: this
            });
            scales[scale.id] = scale;
          }
          scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id) => {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        each(scales, (scale) => {
          layouts.configure(this, scale, scale.options);
          layouts.addBox(this, scale);
        });
      }
      _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b) => a.index - b.index);
        if (numMeta > numData) {
          for (let i = numData; i < numMeta; ++i) {
            this._destroyDatasetMeta(i);
          }
          metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
      }
      _removeUnreferencedMetasets() {
        const {_metasets: metasets, data: {datasets}} = this;
        if (metasets.length > datasets.length) {
          delete this._stacks;
        }
        metasets.forEach((meta, index) => {
          if (datasets.filter((x) => x === meta._dataset).length === 0) {
            this._destroyDatasetMeta(index);
          }
        });
      }
      buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for (i = 0, ilen = datasets.length; i < ilen; i++) {
          const dataset = datasets[i];
          let meta = this.getDatasetMeta(i);
          const type = dataset.type || this.config.type;
          if (meta.type && meta.type !== type) {
            this._destroyDatasetMeta(i);
            meta = this.getDatasetMeta(i);
          }
          meta.type = type;
          meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
          meta.order = dataset.order || 0;
          meta.index = i;
          meta.label = "" + dataset.label;
          meta.visible = this.isDatasetVisible(i);
          if (meta.controller) {
            meta.controller.updateIndex(i);
            meta.controller.linkScales();
          } else {
            const ControllerClass = registry.getController(type);
            const {datasetElementType, dataElementType} = defaults3.datasets[type];
            Object.assign(ControllerClass.prototype, {
              dataElementType: registry.getElement(dataElementType),
              datasetElementType: datasetElementType && registry.getElement(datasetElementType)
            });
            meta.controller = new ControllerClass(this, i);
            newControllers.push(meta.controller);
          }
        }
        this._updateMetasets();
        return newControllers;
      }
      _resetElements() {
        each(this.data.datasets, (dataset, datasetIndex) => {
          this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
      }
      reset() {
        this._resetElements();
        this.notifyPlugins("reset");
      }
      update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins("beforeUpdate", {mode, cancelable: true}) === false) {
          return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let minPadding = 0;
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
          const {controller} = this.getDatasetMeta(i);
          const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
          controller.buildOrUpdateElements(reset);
          minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
          each(newControllers, (controller) => {
            controller.reset();
          });
        }
        this._updateDatasets(mode);
        this.notifyPlugins("afterUpdate", {mode});
        this._layers.sort(compare2Level("z", "_idx"));
        const {_active, _lastEvent} = this;
        if (_lastEvent) {
          this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
          this._updateHoverStyles(_active, _active, true);
        }
        this.render();
      }
      _updateScales() {
        each(this.scales, (scale) => {
          layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
      }
      _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
          this.unbindEvents();
          this.bindEvents();
        }
      }
      _updateHiddenIndices() {
        const {_hiddenIndices} = this;
        const changes = this._getUniformDataChanges() || [];
        for (const {method, start, count} of changes) {
          const move = method === "_removeElements" ? -count : count;
          moveNumericKeys(_hiddenIndices, start, move);
        }
      }
      _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
          return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
        const changeSet = makeSet(0);
        for (let i = 1; i < datasetCount; i++) {
          if (!setsEqual(changeSet, makeSet(i))) {
            return;
          }
        }
        return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({method: a[1], start: +a[2], count: +a[3]}));
      }
      _updateLayout(minPadding) {
        if (this.notifyPlugins("beforeLayout", {cancelable: true}) === false) {
          return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(this.boxes, (box) => {
          if (noArea && box.position === "chartArea") {
            return;
          }
          if (box.configure) {
            box.configure();
          }
          this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index) => {
          item._idx = index;
        });
        this.notifyPlugins("afterLayout");
      }
      _updateDatasets(mode) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {mode, cancelable: true}) === false) {
          return;
        }
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this.getDatasetMeta(i).controller.configure();
        }
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._updateDataset(i, isFunction2(mode) ? mode({datasetIndex: i}) : mode);
        }
        this.notifyPlugins("afterDatasetsUpdate", {mode});
      }
      _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {meta, index, mode, cancelable: true};
        if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
          return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetUpdate", args);
      }
      render() {
        if (this.notifyPlugins("beforeRender", {cancelable: true}) === false) {
          return;
        }
        if (animator.has(this)) {
          if (this.attached && !animator.running(this)) {
            animator.start(this);
          }
        } else {
          this.draw();
          onAnimationsComplete({chart: this});
        }
      }
      draw() {
        let i;
        if (this._resizeBeforeDraw) {
          const {width, height} = this._resizeBeforeDraw;
          this._resize(width, height);
          this._resizeBeforeDraw = null;
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
          return;
        }
        if (this.notifyPlugins("beforeDraw", {cancelable: true}) === false) {
          return;
        }
        const layers = this._layers;
        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
          layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for (; i < layers.length; ++i) {
          layers[i].draw(this.chartArea);
        }
        this.notifyPlugins("afterDraw");
      }
      _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          const meta = metasets[i];
          if (!filterVisible || meta.visible) {
            result.push(meta);
          }
        }
        return result;
      }
      getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
      }
      _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {cancelable: true}) === false) {
          return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          this._drawDataset(metasets[i]);
        }
        this.notifyPlugins("afterDatasetsDraw");
      }
      _drawDataset(meta) {
        const ctx = this.ctx;
        const clip = meta._clip;
        const useClip = !clip.disabled;
        const area = this.chartArea;
        const args = {
          meta,
          index: meta.index,
          cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
          return;
        }
        if (useClip) {
          clipArea(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? this.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
          });
        }
        meta.controller.draw();
        if (useClip) {
          unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins("afterDatasetDraw", args);
      }
      getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === "function") {
          return method(this, e, options, useFinalPosition);
        }
        return [];
      }
      getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
        if (!meta) {
          meta = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: dataset && dataset.order || 0,
            index: datasetIndex,
            _dataset: dataset,
            _parsed: [],
            _sorted: false
          };
          metasets.push(meta);
        }
        return meta;
      }
      getContext() {
        return this.$context || (this.$context = createContext(null, {chart: this, type: "chart"}));
      }
      getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
          return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
      }
      setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
      }
      toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
      }
      getDataVisibility(index) {
        return !this._hiddenIndices[index];
      }
      _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? "show" : "hide";
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(void 0, mode);
        if (defined(dataIndex)) {
          meta.data[dataIndex].hidden = !visible;
          this.update();
        } else {
          this.setDatasetVisibility(datasetIndex, visible);
          anims.update(meta, {visible});
          this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
        }
      }
      hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
      }
      show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
      }
      _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
          meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
      }
      _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._destroyDatasetMeta(i);
        }
      }
      destroy() {
        this.notifyPlugins("beforeDestroy");
        const {canvas, ctx} = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
          this.unbindEvents();
          clearCanvas(canvas, ctx);
          this.platform.releaseContext(ctx);
          this.canvas = null;
          this.ctx = null;
        }
        this.notifyPlugins("destroy");
        delete instances[this.id];
        this.notifyPlugins("afterDestroy");
      }
      toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
      }
      bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
          this.bindResponsiveEvents();
        } else {
          this.attached = true;
        }
      }
      bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
          platform.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const listener = (e, x, y) => {
          e.offsetX = x;
          e.offsetY = y;
          this._eventHandler(e);
        };
        each(this.options.events, (type) => _add(type, listener));
      }
      bindResponsiveEvents() {
        if (!this._responsiveListeners) {
          this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
          platform.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const _remove = (type, listener2) => {
          if (listeners[type]) {
            platform.removeEventListener(this, type, listener2);
            delete listeners[type];
          }
        };
        const listener = (width, height) => {
          if (this.canvas) {
            this.resize(width, height);
          }
        };
        let detached;
        const attached = () => {
          _remove("attach", attached);
          this.attached = true;
          this.resize();
          _add("resize", listener);
          _add("detach", detached);
        };
        detached = () => {
          this.attached = false;
          _remove("resize", listener);
          this._stop();
          this._resize(0, 0);
          _add("attach", attached);
        };
        if (platform.isAttached(this.canvas)) {
          attached();
        } else {
          detached();
        }
      }
      unbindEvents() {
        each(this._listeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = void 0;
      }
      updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? "set" : "remove";
        let meta, item, i, ilen;
        if (mode === "dataset") {
          meta = this.getDatasetMeta(items[0].datasetIndex);
          meta.controller["_" + prefix + "DatasetHoverStyle"]();
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];
          const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
          if (controller) {
            controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
          }
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active2 = activeElements.map(({datasetIndex, index}) => {
          const meta = this.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error("No dataset found at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index],
            index
          };
        });
        const changed = !_elementsEqual(active2, lastActive);
        if (changed) {
          this._active = active2;
          this._lastEvent = null;
          this._updateHoverStyles(active2, lastActive);
        }
      }
      notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
      }
      _updateHoverStyles(active2, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active2);
        const activated = replay ? active2 : diff(active2, lastActive);
        if (deactivated.length) {
          this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
          this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
      }
      _eventHandler(e, replay) {
        const args = {
          event: e,
          replay,
          cancelable: true,
          inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
        };
        const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
          return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins("afterEvent", args, eventFilter);
        if (changed || args.changed) {
          this.render();
        }
        return this;
      }
      _handleEvent(e, replay, inChartArea) {
        const {_active: lastActive = [], options} = this;
        const useFinalPosition = replay;
        const active2 = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = _isClickEvent(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
          this._lastEvent = null;
          callback(options.onHover, [e, active2, this], this);
          if (isClick) {
            callback(options.onClick, [e, active2, this], this);
          }
        }
        const changed = !_elementsEqual(active2, lastActive);
        if (changed || replay) {
          this._active = active2;
          this._updateHoverStyles(active2, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
      }
      _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
      }
    };
    var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
    var enumerable = true;
    Object.defineProperties(Chart, {
      defaults: {
        enumerable,
        value: defaults3
      },
      instances: {
        enumerable,
        value: instances
      },
      overrides: {
        enumerable,
        value: overrides
      },
      registry: {
        enumerable,
        value: registry
      },
      version: {
        enumerable,
        value: version2
      },
      getChart: {
        enumerable,
        value: getChart
      },
      register: {
        enumerable,
        value: (...items) => {
          registry.add(...items);
          invalidatePlugins();
        }
      },
      unregister: {
        enumerable,
        value: (...items) => {
          registry.remove(...items);
          invalidatePlugins();
        }
      }
    });
    function clipArc(ctx, element2, endAngle) {
      const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element2;
      let angleMargin = pixelMargin / outerRadius;
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
      if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
      } else {
        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
      }
      ctx.closePath();
      ctx.clip();
    }
    function toRadiusCorners(value) {
      return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
    }
    function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
      const o = toRadiusCorners(arc.options.borderRadius);
      const halfThickness = (outerRadius - innerRadius) / 2;
      const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
      const computeOuterLimit = (val) => {
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
      };
      return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: _limitValue(o.innerStart, 0, innerLimit),
        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
      };
    }
    function rThetaToXY(r, theta, x, y) {
      return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
      };
    }
    function pathArc(ctx, element2, offset, spacing, end) {
      const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element2;
      const outerRadius = Math.max(element2.outerRadius + spacing + offset - pixelMargin, 0);
      const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
      let spacingOffset = 0;
      const alpha = end - start;
      if (spacing) {
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
      }
      const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
      const angleOffset = (alpha - beta) / 2;
      const startAngle = start + angleOffset + spacingOffset;
      const endAngle = end - angleOffset - spacingOffset;
      const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
      const outerStartAdjustedRadius = outerRadius - outerStart;
      const outerEndAdjustedRadius = outerRadius - outerEnd;
      const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
      const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
      const innerStartAdjustedRadius = innerRadius + innerStart;
      const innerEndAdjustedRadius = innerRadius + innerEnd;
      const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
      const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
      ctx.closePath();
    }
    function drawArc(ctx, element2, offset, spacing) {
      const {fullCircles, startAngle, circumference} = element2;
      let endAngle = element2.endAngle;
      if (fullCircles) {
        pathArc(ctx, element2, offset, spacing, startAngle + TAU);
        for (let i = 0; i < fullCircles; ++i) {
          ctx.fill();
        }
        if (!isNaN(circumference)) {
          endAngle = startAngle + circumference % TAU;
          if (circumference % TAU === 0) {
            endAngle += TAU;
          }
        }
      }
      pathArc(ctx, element2, offset, spacing, endAngle);
      ctx.fill();
      return endAngle;
    }
    function drawFullCircleBorders(ctx, element2, inner) {
      const {x, y, startAngle, pixelMargin, fullCircles} = element2;
      const outerRadius = Math.max(element2.outerRadius - pixelMargin, 0);
      const innerRadius = element2.innerRadius + pixelMargin;
      let i;
      if (inner) {
        clipArc(ctx, element2, startAngle + TAU);
      }
      ctx.beginPath();
      ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
      for (i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
      for (i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
    }
    function drawBorder(ctx, element2, offset, spacing, endAngle) {
      const {options} = element2;
      const {borderWidth, borderJoinStyle} = options;
      const inner = options.borderAlign === "inner";
      if (!borderWidth) {
        return;
      }
      if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || "round";
      } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || "bevel";
      }
      if (element2.fullCircles) {
        drawFullCircleBorders(ctx, element2, inner);
      }
      if (inner) {
        clipArc(ctx, element2, endAngle);
      }
      pathArc(ctx, element2, offset, spacing, endAngle);
      ctx.stroke();
    }
    var ArcElement = class extends Element {
      constructor(cfg) {
        super();
        this.options = void 0;
        this.circumference = void 0;
        this.startAngle = void 0;
        this.endAngle = void 0;
        this.innerRadius = void 0;
        this.outerRadius = void 0;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps(["x", "y"], useFinalPosition);
        const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
        const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "circumference"
        ], useFinalPosition);
        const rAdjust = this.options.spacing / 2;
        const _circumference = valueOrDefault(circumference, endAngle - startAngle);
        const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
      }
      getCenterPoint(useFinalPosition) {
        const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "circumference"
        ], useFinalPosition);
        const {offset, spacing} = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
          x: x + Math.cos(halfAngle) * halfRadius,
          y: y + Math.sin(halfAngle) * halfRadius
        };
      }
      tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
      }
      draw(ctx) {
        const {options, circumference} = this;
        const offset = (options.offset || 0) / 2;
        const spacing = (options.spacing || 0) / 2;
        this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
          return;
        }
        ctx.save();
        let radiusOffset = 0;
        if (offset) {
          radiusOffset = offset / 2;
          const halfAngle = (this.startAngle + this.endAngle) / 2;
          ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
          if (this.circumference >= PI) {
            radiusOffset = offset;
          }
        }
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        const endAngle = drawArc(ctx, this, radiusOffset, spacing);
        drawBorder(ctx, this, radiusOffset, spacing, endAngle);
        ctx.restore();
      }
    };
    ArcElement.id = "arc";
    ArcElement.defaults = {
      borderAlign: "center",
      borderColor: "#fff",
      borderJoinStyle: void 0,
      borderRadius: 0,
      borderWidth: 2,
      offset: 0,
      spacing: 0,
      angle: void 0
    };
    ArcElement.defaultRoutes = {
      backgroundColor: "backgroundColor"
    };
    function setStyle(ctx, options, style = options) {
      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
    }
    function lineTo(ctx, previous, target) {
      ctx.lineTo(target.x, target.y);
    }
    function getLineMethod(options) {
      if (options.stepped) {
        return _steppedLineTo;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierCurveTo;
      }
      return lineTo;
    }
    function pathVars(points, segment, params = {}) {
      const count = points.length;
      const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
      const {start: segmentStart, end: segmentEnd} = segment;
      const start = Math.max(paramsStart, segmentStart);
      const end = Math.min(paramsEnd, segmentEnd);
      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
      return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
      };
    }
    function pathSegment(ctx, line, segment, params) {
      const {points, options} = line;
      const {count, start, loop: loop2, ilen} = pathVars(points, segment, params);
      const lineMethod = getLineMethod(options);
      let {move = true, reverse} = params || {};
      let i, point, prev;
      for (i = 0; i <= ilen; ++i) {
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
          continue;
        } else if (move) {
          ctx.moveTo(point.x, point.y);
          move = false;
        } else {
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
      }
      if (loop2) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      return !!loop2;
    }
    function fastPathSegment(ctx, line, segment, params) {
      const points = line.points;
      const {count, start, ilen} = pathVars(points, segment, params);
      const {move = true, reverse} = params || {};
      let avgX = 0;
      let countX = 0;
      let i, point, prevX, minY, maxY, lastY;
      const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
      const drawX = () => {
        if (minY !== maxY) {
          ctx.lineTo(avgX, maxY);
          ctx.lineTo(avgX, minY);
          ctx.lineTo(avgX, lastY);
        }
      };
      if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
      }
      for (i = 0; i <= ilen; ++i) {
        point = points[pointIndex(i)];
        if (point.skip) {
          continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
          } else if (y > maxY) {
            maxY = y;
          }
          avgX = (countX * avgX + x) / ++countX;
        } else {
          drawX();
          ctx.lineTo(x, y);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
        }
        lastY = y;
      }
      drawX();
    }
    function _getSegmentMethod(line) {
      const opts = line.options;
      const borderDash = opts.borderDash && opts.borderDash.length;
      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
      return useFastPath ? fastPathSegment : pathSegment;
    }
    function _getInterpolationMethod(options) {
      if (options.stepped) {
        return _steppedInterpolation;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierInterpolation;
      }
      return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start, count) {
      let path = line._path;
      if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) {
          path.closePath();
        }
      }
      setStyle(ctx, line.options);
      ctx.stroke(path);
    }
    function strokePathDirect(ctx, line, start, count) {
      const {segments, options} = line;
      const segmentMethod = _getSegmentMethod(line);
      for (const segment of segments) {
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
          ctx.closePath();
        }
        ctx.stroke();
      }
    }
    var usePath2D = typeof Path2D === "function";
    function draw(ctx, line, start, count) {
      if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
      } else {
        strokePathDirect(ctx, line, start, count);
      }
    }
    var LineElement = class extends Element {
      constructor(cfg) {
        super();
        this.animated = true;
        this.options = void 0;
        this._chart = void 0;
        this._loop = void 0;
        this._fullLoop = void 0;
        this._path = void 0;
        this._points = void 0;
        this._segments = void 0;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
          const loop2 = options.spanGaps ? this._loop : this._fullLoop;
          _updateBezierControlPoints(this._points, options, chartArea, loop2, indexAxis);
          this._pointsUpdated = true;
        }
      }
      set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
      }
      get points() {
        return this._points;
      }
      get segments() {
        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
      }
      first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
      }
      last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
      }
      interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _boundSegments(this, {property, start: value, end: value});
        if (!segments.length) {
          return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for (i = 0, ilen = segments.length; i < ilen; ++i) {
          const {start, end} = segments[i];
          const p1 = points[start];
          const p2 = points[end];
          if (p1 === p2) {
            result.push(p1);
            continue;
          }
          const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
          const interpolated = _interpolate(p1, p2, t, options.stepped);
          interpolated[property] = point[property];
          result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
      }
      pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
      }
      path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop2 = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments) {
          loop2 &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});
        }
        return !!loop2;
      }
      draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
          ctx.save();
          draw(ctx, this, start, count);
          ctx.restore();
        }
        if (this.animated) {
          this._pointsUpdated = false;
          this._path = void 0;
        }
      }
    };
    LineElement.id = "line";
    LineElement.defaults = {
      borderCapStyle: "butt",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: "miter",
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: "default",
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0
    };
    LineElement.defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    LineElement.descriptors = {
      _scriptable: true,
      _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
    };
    function inRange$1(el, pos, axis, useFinalPosition) {
      const options = el.options;
      const {[axis]: value} = el.getProps([axis], useFinalPosition);
      return Math.abs(pos - value) < options.radius + options.hitRadius;
    }
    var PointElement = class extends Element {
      constructor(cfg) {
        super();
        this.options = void 0;
        this.parsed = void 0;
        this.skip = void 0;
        this.stop = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const {x, y} = this.getProps(["x", "y"], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, "x", useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, "y", useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const {x, y} = this.getProps(["x", "y"], useFinalPosition);
        return {x, y};
      }
      size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
      }
      draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
          return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        drawPoint(ctx, options, this.x, this.y);
      }
      getRange() {
        const options = this.options || {};
        return options.radius + options.hitRadius;
      }
    };
    PointElement.id = "point";
    PointElement.defaults = {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: "circle",
      radius: 3,
      rotation: 0
    };
    PointElement.defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    function getBarBounds(bar, useFinalPosition) {
      const {x, y, base, width, height} = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
      let left, right, top, bottom, half;
      if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
      } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
      }
      return {left, top, right, bottom};
    }
    function skipOrLimit(skip2, value, min, max) {
      return skip2 ? 0 : _limitValue(value, min, max);
    }
    function parseBorderWidth(bar, maxW, maxH) {
      const value = bar.options.borderWidth;
      const skip2 = bar.borderSkipped;
      const o = toTRBL(value);
      return {
        t: skipOrLimit(skip2.top, o.top, 0, maxH),
        r: skipOrLimit(skip2.right, o.right, 0, maxW),
        b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip2.left, o.left, 0, maxW)
      };
    }
    function parseBorderRadius(bar, maxW, maxH) {
      const {enableBorderRadius} = bar.getProps(["enableBorderRadius"]);
      const value = bar.options.borderRadius;
      const o = toTRBLCorners(value);
      const maxR = Math.min(maxW, maxH);
      const skip2 = bar.borderSkipped;
      const enableBorder = enableBorderRadius || isObject2(value);
      return {
        topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
      };
    }
    function boundingRects(bar) {
      const bounds = getBarBounds(bar);
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      const border = parseBorderWidth(bar, width / 2, height / 2);
      const radius = parseBorderRadius(bar, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height,
          radius
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b,
          radius: {
            topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
            topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
            bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
            bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
          }
        }
      };
    }
    function inRange(bar, x, y, useFinalPosition) {
      const skipX = x === null;
      const skipY = y === null;
      const skipBoth = skipX && skipY;
      const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
      return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
    }
    function hasRadius(radius) {
      return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
    }
    function addNormalRectPath(ctx, rect) {
      ctx.rect(rect.x, rect.y, rect.w, rect.h);
    }
    function inflateRect(rect, amount, refRect = {}) {
      const x = rect.x !== refRect.x ? -amount : 0;
      const y = rect.y !== refRect.y ? -amount : 0;
      const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
      const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
      return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
      };
    }
    var BarElement = class extends Element {
      constructor(cfg) {
        super();
        this.options = void 0;
        this.horizontal = void 0;
        this.base = void 0;
        this.width = void 0;
        this.height = void 0;
        this.inflateAmount = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      draw(ctx) {
        const {inflateAmount, options: {borderColor, backgroundColor}} = this;
        const {inner, outer} = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
          ctx.beginPath();
          addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
          ctx.clip();
          addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
          ctx.fillStyle = borderColor;
          ctx.fill("evenodd");
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const {x, y, base, horizontal} = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
        return {
          x: horizontal ? (x + base) / 2 : x,
          y: horizontal ? y : (y + base) / 2
        };
      }
      getRange(axis) {
        return axis === "x" ? this.width / 2 : this.height / 2;
      }
    };
    BarElement.id = "bar";
    BarElement.defaults = {
      borderSkipped: "start",
      borderWidth: 0,
      borderRadius: 0,
      inflateAmount: "auto",
      pointStyle: void 0
    };
    BarElement.defaultRoutes = {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    };
    function lttbDecimation(data, start, count, availableWidth, options) {
      const samples = options.samples || availableWidth;
      if (samples >= count) {
        return data.slice(start, start + count);
      }
      const decimated = [];
      const bucketWidth = (count - 2) / (samples - 2);
      let sampledIndex = 0;
      const endIndex = start + count - 1;
      let a = start;
      let i, maxAreaPoint, maxArea, area, nextA;
      decimated[sampledIndex++] = data[a];
      for (i = 0; i < samples - 2; i++) {
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for (j = avgRangeStart; j < avgRangeEnd; j++) {
          avgX += data[j].x;
          avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const {x: pointAx, y: pointAy} = data[a];
        maxArea = area = -1;
        for (j = rangeOffs; j < rangeTo; j++) {
          area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
          if (area > maxArea) {
            maxArea = area;
            maxAreaPoint = data[j];
            nextA = j;
          }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
      }
      decimated[sampledIndex++] = data[endIndex];
      return decimated;
    }
    function minMaxDecimation(data, start, count, availableWidth) {
      let avgX = 0;
      let countX = 0;
      let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
      const decimated = [];
      const endIndex = start + count - 1;
      const xMin = data[start].x;
      const xMax = data[endIndex].x;
      const dx = xMax - xMin;
      for (i = start; i < start + count; ++i) {
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
            minIndex = i;
          } else if (y > maxY) {
            maxY = y;
            maxIndex = i;
          }
          avgX = (countX * avgX + point.x) / ++countX;
        } else {
          const lastIndex = i - 1;
          if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
            const intermediateIndex1 = Math.min(minIndex, maxIndex);
            const intermediateIndex2 = Math.max(minIndex, maxIndex);
            if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
              decimated.push({
                ...data[intermediateIndex1],
                x: avgX
              });
            }
            if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
              decimated.push({
                ...data[intermediateIndex2],
                x: avgX
              });
            }
          }
          if (i > 0 && lastIndex !== startIndex) {
            decimated.push(data[lastIndex]);
          }
          decimated.push(point);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
          minIndex = maxIndex = startIndex = i;
        }
      }
      return decimated;
    }
    function cleanDecimatedDataset(dataset) {
      if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, "data", {value: data});
      }
    }
    function cleanDecimatedData(chart) {
      chart.data.datasets.forEach((dataset) => {
        cleanDecimatedDataset(dataset);
      });
    }
    function getStartAndCountOfVisiblePointsSimplified(meta, points) {
      const pointCount = points.length;
      let start = 0;
      let count;
      const {iScale} = meta;
      const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
      return {start, count};
    }
    var plugin_decimation = {
      id: "decimation",
      defaults: {
        algorithm: "min-max",
        enabled: false
      },
      beforeElementsUpdate: (chart, args, options) => {
        if (!options.enabled) {
          cleanDecimatedData(chart);
          return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex) => {
          const {_data, indexAxis} = dataset;
          const meta = chart.getDatasetMeta(datasetIndex);
          const data = _data || dataset.data;
          if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
            return;
          }
          if (meta.type !== "line") {
            return;
          }
          const xAxis = chart.scales[meta.xAxisID];
          if (xAxis.type !== "linear" && xAxis.type !== "time") {
            return;
          }
          if (chart.options.parsing) {
            return;
          }
          let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
          const threshold = options.threshold || 4 * availableWidth;
          if (count <= threshold) {
            cleanDecimatedDataset(dataset);
            return;
          }
          if (isNullOrUndef(_data)) {
            dataset._data = data;
            delete dataset.data;
            Object.defineProperty(dataset, "data", {
              configurable: true,
              enumerable: true,
              get: function() {
                return this._decimated;
              },
              set: function(d) {
                this._data = d;
              }
            });
          }
          let decimated;
          switch (options.algorithm) {
            case "lttb":
              decimated = lttbDecimation(data, start, count, availableWidth, options);
              break;
            case "min-max":
              decimated = minMaxDecimation(data, start, count, availableWidth);
              break;
            default:
              throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
          }
          dataset._decimated = decimated;
        });
      },
      destroy(chart) {
        cleanDecimatedData(chart);
      }
    };
    function getLineByIndex(chart, index) {
      const meta = chart.getDatasetMeta(index);
      const visible = meta && chart.isDatasetVisible(index);
      return visible ? meta.dataset : null;
    }
    function parseFillOption(line) {
      const options = line.options;
      const fillOption = options.fill;
      let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
      if (fill === void 0) {
        fill = !!options.backgroundColor;
      }
      if (fill === false || fill === null) {
        return false;
      }
      if (fill === true) {
        return "origin";
      }
      return fill;
    }
    function decodeFill(line, index, count) {
      const fill = parseFillOption(line);
      if (isObject2(fill)) {
        return isNaN(fill.value) ? false : fill;
      }
      let target = parseFloat(fill);
      if (isNumberFinite(target) && Math.floor(target) === target) {
        if (fill[0] === "-" || fill[0] === "+") {
          target = index + target;
        }
        if (target === index || target < 0 || target >= count) {
          return false;
        }
        return target;
      }
      return ["origin", "start", "end", "stack", "shape"].indexOf(fill) >= 0 && fill;
    }
    function computeLinearBoundary(source2) {
      const {scale = {}, fill} = source2;
      let target = null;
      let horizontal;
      if (fill === "start") {
        target = scale.bottom;
      } else if (fill === "end") {
        target = scale.top;
      } else if (isObject2(fill)) {
        target = scale.getPixelForValue(fill.value);
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }
      if (isNumberFinite(target)) {
        horizontal = scale.isHorizontal();
        return {
          x: horizontal ? target : null,
          y: horizontal ? null : target
        };
      }
      return null;
    }
    var simpleArc = class {
      constructor(opts) {
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
      }
      pathSegment(ctx, bounds, opts) {
        const {x, y, radius} = this;
        bounds = bounds || {start: 0, end: TAU};
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
      }
      interpolate(point) {
        const {x, y, radius} = this;
        const angle = point.angle;
        return {
          x: x + Math.cos(angle) * radius,
          y: y + Math.sin(angle) * radius,
          angle
        };
      }
    };
    function computeCircularBoundary(source2) {
      const {scale, fill} = source2;
      const options = scale.options;
      const length = scale.getLabels().length;
      const target = [];
      const start = options.reverse ? scale.max : scale.min;
      const end = options.reverse ? scale.min : scale.max;
      let i, center, value;
      if (fill === "start") {
        value = start;
      } else if (fill === "end") {
        value = end;
      } else if (isObject2(fill)) {
        value = fill.value;
      } else {
        value = scale.getBaseValue();
      }
      if (options.grid.circular) {
        center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
          x: center.x,
          y: center.y,
          radius: scale.getDistanceFromCenterForValue(value)
        });
      }
      for (i = 0; i < length; ++i) {
        target.push(scale.getPointPositionForValue(i, value));
      }
      return target;
    }
    function computeBoundary(source2) {
      const scale = source2.scale || {};
      if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source2);
      }
      return computeLinearBoundary(source2);
    }
    function findSegmentEnd(start, end, points) {
      for (; end > start; end--) {
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
          break;
        }
      }
      return end;
    }
    function pointsFromSegments(boundary, line) {
      const {x = null, y = null} = boundary || {};
      const linePoints = line.points;
      const points = [];
      line.segments.forEach(({start, end}) => {
        end = findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
          points.push({x: first.x, y});
          points.push({x: last.x, y});
        } else if (x !== null) {
          points.push({x, y: first.y});
          points.push({x, y: last.y});
        }
      });
      return points;
    }
    function buildStackLine(source2) {
      const {scale, index, line} = source2;
      const points = [];
      const segments = line.segments;
      const sourcePoints = line.points;
      const linesBelow = getLinesBelow(scale, index);
      linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        for (let j = segment.start; j <= segment.end; j++) {
          addPointsBelow(points, sourcePoints[j], linesBelow);
        }
      }
      return new LineElement({points, options: {}});
    }
    function getLinesBelow(scale, index) {
      const below = [];
      const metas = scale.getMatchingVisibleMetas("line");
      for (let i = 0; i < metas.length; i++) {
        const meta = metas[i];
        if (meta.index === index) {
          break;
        }
        if (!meta.hidden) {
          below.unshift(meta.dataset);
        }
      }
      return below;
    }
    function addPointsBelow(points, sourcePoint, linesBelow) {
      const postponed = [];
      for (let j = 0; j < linesBelow.length; j++) {
        const line = linesBelow[j];
        const {first, last, point} = findPoint(line, sourcePoint, "x");
        if (!point || first && last) {
          continue;
        }
        if (first) {
          postponed.unshift(point);
        } else {
          points.push(point);
          if (!last) {
            break;
          }
        }
      }
      points.push(...postponed);
    }
    function findPoint(line, sourcePoint, property) {
      const point = line.interpolate(sourcePoint, property);
      if (!point) {
        return {};
      }
      const pointValue = point[property];
      const segments = line.segments;
      const linePoints = line.points;
      let first = false;
      let last = false;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (_isBetween(pointValue, firstValue, lastValue)) {
          first = pointValue === firstValue;
          last = pointValue === lastValue;
          break;
        }
      }
      return {first, last, point};
    }
    function getTarget(source2) {
      const {chart, fill, line} = source2;
      if (isNumberFinite(fill)) {
        return getLineByIndex(chart, fill);
      }
      if (fill === "stack") {
        return buildStackLine(source2);
      }
      if (fill === "shape") {
        return true;
      }
      const boundary = computeBoundary(source2);
      if (boundary instanceof simpleArc) {
        return boundary;
      }
      return createBoundaryLine(boundary, line);
    }
    function createBoundaryLine(boundary, line) {
      let points = [];
      let _loop = false;
      if (isArray2(boundary)) {
        _loop = true;
        points = boundary;
      } else {
        points = pointsFromSegments(boundary, line);
      }
      return points.length ? new LineElement({
        points,
        options: {tension: 0},
        _loop,
        _fullLoop: _loop
      }) : null;
    }
    function resolveTarget(sources, index, propagate) {
      const source2 = sources[index];
      let fill = source2.fill;
      const visited = [index];
      let target;
      if (!propagate) {
        return fill;
      }
      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isNumberFinite(fill)) {
          return fill;
        }
        target = sources[fill];
        if (!target) {
          return false;
        }
        if (target.visible) {
          return fill;
        }
        visited.push(fill);
        fill = target.fill;
      }
      return false;
    }
    function _clip(ctx, target, clipY) {
      ctx.beginPath();
      target.path(ctx);
      ctx.lineTo(target.last().x, clipY);
      ctx.lineTo(target.first().x, clipY);
      ctx.closePath();
      ctx.clip();
    }
    function getBounds(property, first, last, loop2) {
      if (loop2) {
        return;
      }
      let start = first[property];
      let end = last[property];
      if (property === "angle") {
        start = _normalizeAngle(start);
        end = _normalizeAngle(end);
      }
      return {property, start, end};
    }
    function _getEdge(a, b, prop, fn) {
      if (a && b) {
        return fn(a[prop], b[prop]);
      }
      return a ? a[prop] : b ? b[prop] : 0;
    }
    function _segments(line, target, property) {
      const segments = line.segments;
      const points = line.points;
      const tpoints = target.points;
      const parts = [];
      for (const segment of segments) {
        let {start, end} = segment;
        end = findSegmentEnd(start, end, points);
        const bounds = getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
          parts.push({
            source: segment,
            target: bounds,
            start: points[start],
            end: points[end]
          });
          continue;
        }
        const targetSegments = _boundSegments(target, bounds);
        for (const tgt of targetSegments) {
          const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
          const fillSources = _boundSegment(segment, points, subBounds);
          for (const fillSource of fillSources) {
            parts.push({
              source: fillSource,
              target: tgt,
              start: {
                [property]: _getEdge(bounds, subBounds, "start", Math.max)
              },
              end: {
                [property]: _getEdge(bounds, subBounds, "end", Math.min)
              }
            });
          }
        }
      }
      return parts;
    }
    function clipBounds(ctx, scale, bounds) {
      const {top, bottom} = scale.chart.chartArea;
      const {property, start, end} = bounds || {};
      if (property === "x") {
        ctx.beginPath();
        ctx.rect(start, top, end - start, bottom - top);
        ctx.clip();
      }
    }
    function interpolatedLineTo(ctx, target, point, property) {
      const interpolatedPoint = target.interpolate(point, property);
      if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
      }
    }
    function _fill(ctx, cfg) {
      const {line, target, property, color: color2, scale} = cfg;
      const segments = _segments(line, target, property);
      for (const {source: src, target: tgt, start, end} of segments) {
        const {style: {backgroundColor = color2} = {}} = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, notShape && getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop2;
        if (notShape) {
          if (lineLoop) {
            ctx.closePath();
          } else {
            interpolatedLineTo(ctx, target, end, property);
          }
          const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
          loop2 = lineLoop && targetLoop;
          if (!loop2) {
            interpolatedLineTo(ctx, target, start, property);
          }
        }
        ctx.closePath();
        ctx.fill(loop2 ? "evenodd" : "nonzero");
        ctx.restore();
      }
    }
    function doFill(ctx, cfg) {
      const {line, target, above, below, area, scale} = cfg;
      const property = line._loop ? "angle" : cfg.axis;
      ctx.save();
      if (property === "x" && below !== above) {
        _clip(ctx, target, area.top);
        _fill(ctx, {line, target, color: above, scale, property});
        ctx.restore();
        ctx.save();
        _clip(ctx, target, area.bottom);
      }
      _fill(ctx, {line, target, color: below, scale, property});
      ctx.restore();
    }
    function drawfill(ctx, source2, area) {
      const target = getTarget(source2);
      const {line, scale, axis} = source2;
      const lineOpts = line.options;
      const fillOption = lineOpts.fill;
      const color2 = lineOpts.backgroundColor;
      const {above = color2, below = color2} = fillOption || {};
      if (target && line.points.length) {
        clipArea(ctx, area);
        doFill(ctx, {line, target, above, below, area, scale, axis});
        unclipArea(ctx);
      }
    }
    var plugin_filler = {
      id: "filler",
      afterDatasetsUpdate(chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source2;
        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          line = meta.dataset;
          source2 = null;
          if (line && line.options && line instanceof LineElement) {
            source2 = {
              visible: chart.isDatasetVisible(i),
              index: i,
              fill: decodeFill(line, i, count),
              chart,
              axis: meta.controller.options.indexAxis,
              scale: meta.vScale,
              line
            };
          }
          meta.$filler = source2;
          sources.push(source2);
        }
        for (i = 0; i < count; ++i) {
          source2 = sources[i];
          if (!source2 || source2.fill === false) {
            continue;
          }
          source2.fill = resolveTarget(sources, i, options.propagate);
        }
      },
      beforeDraw(chart, _args, options) {
        const draw2 = options.drawTime === "beforeDraw";
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source2 = metasets[i].$filler;
          if (!source2) {
            continue;
          }
          source2.line.updateControlPoints(area, source2.axis);
          if (draw2) {
            drawfill(chart.ctx, source2, area);
          }
        }
      },
      beforeDatasetsDraw(chart, _args, options) {
        if (options.drawTime !== "beforeDatasetsDraw") {
          return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source2 = metasets[i].$filler;
          if (source2) {
            drawfill(chart.ctx, source2, chart.chartArea);
          }
        }
      },
      beforeDatasetDraw(chart, args, options) {
        const source2 = args.meta.$filler;
        if (!source2 || source2.fill === false || options.drawTime !== "beforeDatasetDraw") {
          return;
        }
        drawfill(chart.ctx, source2, chart.chartArea);
      },
      defaults: {
        propagate: true,
        drawTime: "beforeDatasetDraw"
      }
    };
    var getBoxSize = (labelOpts, fontSize) => {
      let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
      if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = Math.min(boxWidth, fontSize);
      }
      return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
      };
    };
    var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
    var Legend = class extends Element {
      constructor(config) {
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = void 0;
        this.columnSizes = void 0;
        this.lineWidths = void 0;
        this.maxHeight = void 0;
        this.maxWidth = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.height = void 0;
        this.width = void 0;
        this._margins = void 0;
        this.position = void 0;
        this.weight = void 0;
        this.fullSize = void 0;
      }
      update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = this._margins.left;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = this._margins.top;
          this.bottom = this.height;
        }
      }
      buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
        if (labelOpts.filter) {
          legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
          legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
          legendItems.reverse();
        }
        this.legendItems = legendItems;
      }
      fit() {
        const {options, ctx} = this;
        if (!options.display) {
          this.width = this.height = 0;
          return;
        }
        const labelOpts = options.labels;
        const labelFont = toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
          width = this.maxWidth;
          height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
          height = this.maxHeight;
          width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
      }
      _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const {ctx, maxWidth, options: {labels: {padding}}} = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [0];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i) => {
          const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
          if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
            totalHeight += lineHeight;
            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
            top += lineHeight;
            row++;
          }
          hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
          lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
      }
      _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
        const {ctx, maxHeight, options: {labels: {padding}}} = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i) => {
          const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
          if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
            totalWidth += currentColWidth + padding;
            columnSizes.push({width: currentColWidth, height: currentColHeight});
            left += currentColWidth + padding;
            col++;
            currentColWidth = currentColHeight = 0;
          }
          hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
          currentColWidth = Math.max(currentColWidth, itemWidth);
          currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        return totalWidth;
      }
      adjustHitBoxes() {
        if (!this.options.display) {
          return;
        }
        const titleHeight = this._computeTitleHeight();
        const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
          let row = 0;
          let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          for (const hitbox of hitboxes) {
            if (row !== hitbox.row) {
              row = hitbox.row;
              left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            }
            hitbox.top += this.top + titleHeight + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
            left += hitbox.width + padding;
          }
        } else {
          let col = 0;
          let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          for (const hitbox of hitboxes) {
            if (hitbox.col !== col) {
              col = hitbox.col;
              top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            }
            hitbox.top = top;
            hitbox.left += this.left + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
            top += hitbox.height + padding;
          }
        }
      }
      isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom";
      }
      draw() {
        if (this.options.display) {
          const ctx = this.ctx;
          clipArea(ctx, this);
          this._draw();
          unclipArea(ctx);
        }
      }
      _draw() {
        const {options: opts, columnSizes, lineWidths, ctx} = this;
        const {align, labels: labelOpts} = opts;
        const defaultColor = defaults3.color;
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = toFont(labelOpts.font);
        const {color: fontColor, padding} = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign("left");
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
          if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
            return;
          }
          ctx.save();
          const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
          ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
          ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
          ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
          ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
          ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
          if (labelOpts.usePointStyle) {
            const drawOptions = {
              radius: boxWidth * Math.SQRT2 / 2,
              pointStyle: legendItem.pointStyle,
              rotation: legendItem.rotation,
              borderWidth: lineWidth
            };
            const centerX = rtlHelper.xPlus(x, boxWidth / 2);
            const centerY = y + halfFontSize;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
            const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
            const borderRadius = toTRBLCorners(legendItem.borderRadius);
            ctx.beginPath();
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              addRoundedRectPath(ctx, {
                x: xBoxLeft,
                y: yBoxTop,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
            } else {
              ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
            }
            ctx.fill();
            if (lineWidth !== 0) {
              ctx.stroke();
            }
          }
          ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
          renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
            strikethrough: legendItem.hidden,
            textAlign: rtlHelper.textAlign(legendItem.textAlign)
          });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
          cursor = {
            x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
            y: this.top + padding + titleHeight,
            line: 0
          };
        } else {
          cursor = {
            x: this.left + padding,
            y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
            line: 0
          };
        }
        overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i) => {
          ctx.strokeStyle = legendItem.fontColor || fontColor;
          ctx.fillStyle = legendItem.fontColor || fontColor;
          const textWidth = ctx.measureText(legendItem.text).width;
          const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
          const width = boxWidth + halfFontSize + textWidth;
          let x = cursor.x;
          let y = cursor.y;
          rtlHelper.setWidth(this.width);
          if (isHorizontal) {
            if (i > 0 && x + width + padding > this.right) {
              y = cursor.y += lineHeight;
              cursor.line++;
              x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
            }
          } else if (i > 0 && y + lineHeight > this.bottom) {
            x = cursor.x = x + columnSizes[cursor.line].width + padding;
            cursor.line++;
            y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
          }
          const realX = rtlHelper.x(x);
          drawLegendBox(realX, y, legendItem);
          x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
          fillText(rtlHelper.x(x), y, legendItem);
          if (isHorizontal) {
            cursor.x += width + padding;
          } else {
            cursor.y += lineHeight;
          }
        });
        restoreTextDirection(this.ctx, opts.textDirection);
      }
      drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        if (!titleOpts.display) {
          return;
        }
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
          maxWidth = Math.max(...this.lineWidths);
          y = this.top + topPaddingPlusHalfFontSize;
          left = _alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
          const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
          y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = _alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
        ctx.textBaseline = "middle";
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        renderText(ctx, titleOpts.text, x, y, titleFont);
      }
      _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
      }
      _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
          lh = this.legendHitBoxes;
          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];
            if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
              return this.legendItems[i];
            }
          }
        }
        return null;
      }
      handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
          return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === "mousemove") {
          const previous = this._hoveredItem;
          const sameItem = itemsEqual(previous, hoveredItem);
          if (previous && !sameItem) {
            callback(opts.onLeave, [e, previous, this], this);
          }
          this._hoveredItem = hoveredItem;
          if (hoveredItem && !sameItem) {
            callback(opts.onHover, [e, hoveredItem, this], this);
          }
        } else if (hoveredItem) {
          callback(opts.onClick, [e, hoveredItem, this], this);
        }
      }
    };
    function isListened(type, opts) {
      if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
        return true;
      }
      if (opts.onClick && (type === "click" || type === "mouseup")) {
        return true;
      }
      return false;
    }
    var plugin_legend = {
      id: "legend",
      _element: Legend,
      start(chart, _args, options) {
        const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
      },
      stop(chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
      },
      beforeUpdate(chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
      },
      afterUpdate(chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
      },
      afterEvent(chart, args) {
        if (!args.replay) {
          chart.legend.handleEvent(args.event);
        }
      },
      defaults: {
        display: true,
        position: "top",
        align: "center",
        fullSize: true,
        reverse: false,
        weight: 1e3,
        onClick(e, legendItem, legend) {
          const index = legendItem.datasetIndex;
          const ci = legend.chart;
          if (ci.isDatasetVisible(index)) {
            ci.hide(index);
            legendItem.hidden = true;
          } else {
            ci.show(index);
            legendItem.hidden = false;
          }
        },
        onHover: null,
        onLeave: null,
        labels: {
          color: (ctx) => ctx.chart.options.color,
          boxWidth: 40,
          padding: 10,
          generateLabels(chart) {
            const datasets = chart.data.datasets;
            const {labels: {usePointStyle, pointStyle, textAlign, color: color2}} = chart.legend.options;
            return chart._getSortedDatasetMetas().map((meta) => {
              const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
              const borderWidth = toPadding(style.borderWidth);
              return {
                text: datasets[meta.index].label,
                fillStyle: style.backgroundColor,
                fontColor: color2,
                hidden: !meta.visible,
                lineCap: style.borderCapStyle,
                lineDash: style.borderDash,
                lineDashOffset: style.borderDashOffset,
                lineJoin: style.borderJoinStyle,
                lineWidth: (borderWidth.width + borderWidth.height) / 4,
                strokeStyle: style.borderColor,
                pointStyle: pointStyle || style.pointStyle,
                rotation: style.rotation,
                textAlign: textAlign || style.textAlign,
                borderRadius: 0,
                datasetIndex: meta.index
              };
            }, this);
          }
        },
        title: {
          color: (ctx) => ctx.chart.options.color,
          display: false,
          position: "center",
          text: ""
        }
      },
      descriptors: {
        _scriptable: (name2) => !name2.startsWith("on"),
        labels: {
          _scriptable: (name2) => !["generateLabels", "filter", "sort"].includes(name2)
        }
      }
    };
    var positioners = {
      average(items) {
        if (!items.length) {
          return false;
        }
        let i, len;
        let x = 0;
        let y = 0;
        let count = 0;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }
        return {
          x: x / count,
          y: y / count
        };
      },
      nearest(items, eventPosition) {
        if (!items.length) {
          return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const center = el.getCenterPoint();
            const d = distanceBetweenPoints(eventPosition, center);
            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }
        if (nearestElement) {
          const tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }
        return {
          x,
          y
        };
      }
    };
    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (isArray2(toPush)) {
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }
      return base;
    }
    function splitNewlines(str) {
      if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
        return str.split("\n");
      }
      return str;
    }
    function createTooltipItem(chart, item) {
      const {element: element2, datasetIndex, index} = item;
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      const {label, value} = controller.getLabelAndValue(index);
      return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element: element2
      };
    }
    function getTooltipSize(tooltip, options) {
      const ctx = tooltip.chart.ctx;
      const {body, footer, title} = tooltip;
      const {boxWidth, boxHeight} = options;
      const bodyFont = toFont(options.bodyFont);
      const titleFont = toFont(options.titleFont);
      const footerFont = toFont(options.footerFont);
      const titleLineCount = title.length;
      const footerLineCount = footer.length;
      const bodyLineItemCount = body.length;
      const padding = toPadding(options.padding);
      let height = padding.height;
      let width = 0;
      let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
      if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
      }
      if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
      }
      if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
      }
      let widthPadding = 0;
      const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.save();
      ctx.font = titleFont.string;
      each(tooltip.title, maxLineWidth);
      ctx.font = bodyFont.string;
      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
      widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
      each(body, (bodyItem) => {
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = footerFont.string;
      each(tooltip.footer, maxLineWidth);
      ctx.restore();
      width += padding.width;
      return {width, height};
    }
    function determineYAlign(chart, size) {
      const {y, height} = size;
      if (y < height / 2) {
        return "top";
      } else if (y > chart.height - height / 2) {
        return "bottom";
      }
      return "center";
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
      const {x, width} = size;
      const caret = options.caretSize + options.caretPadding;
      if (xAlign === "left" && x + width + caret > chart.width) {
        return true;
      }
      if (xAlign === "right" && x - width - caret < 0) {
        return true;
      }
    }
    function determineXAlign(chart, options, size, yAlign) {
      const {x, width} = size;
      const {width: chartWidth, chartArea: {left, right}} = chart;
      let xAlign = "center";
      if (yAlign === "center") {
        xAlign = x <= (left + right) / 2 ? "left" : "right";
      } else if (x <= width / 2) {
        xAlign = "left";
      } else if (x >= chartWidth - width / 2) {
        xAlign = "right";
      }
      if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = "center";
      }
      return xAlign;
    }
    function determineAlignment(chart, options, size) {
      const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
      return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
      };
    }
    function alignX(size, xAlign) {
      let {x, width} = size;
      if (xAlign === "right") {
        x -= width;
      } else if (xAlign === "center") {
        x -= width / 2;
      }
      return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
      let {y, height} = size;
      if (yAlign === "top") {
        y += paddingAndSize;
      } else if (yAlign === "bottom") {
        y -= height + paddingAndSize;
      } else {
        y -= height / 2;
      }
      return y;
    }
    function getBackgroundPoint(options, size, alignment, chart) {
      const {caretSize, caretPadding, cornerRadius} = options;
      const {xAlign, yAlign} = alignment;
      const paddingAndSize = caretSize + caretPadding;
      const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
      let x = alignX(size, xAlign);
      const y = alignY(size, yAlign, paddingAndSize);
      if (yAlign === "center") {
        if (xAlign === "left") {
          x += paddingAndSize;
        } else if (xAlign === "right") {
          x -= paddingAndSize;
        }
      } else if (xAlign === "left") {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x += Math.max(topRight, bottomRight) + caretSize;
      }
      return {
        x: _limitValue(x, 0, chart.width - size.width),
        y: _limitValue(y, 0, chart.height - size.height)
      };
    }
    function getAlignedX(tooltip, align, options) {
      const padding = toPadding(options.padding);
      return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
    }
    function getBeforeAfterBodyLines(callback2) {
      return pushOrConcat([], splitNewlines(callback2));
    }
    function createTooltipContext(parent2, tooltip, tooltipItems) {
      return createContext(parent2, {
        tooltip,
        tooltipItems,
        type: "tooltip"
      });
    }
    function overrideCallbacks(callbacks, context) {
      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
      return override ? callbacks.override(override) : callbacks;
    }
    var Tooltip = class extends Element {
      constructor(config) {
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = void 0;
        this._size = void 0;
        this._cachedAnimations = void 0;
        this._tooltipItems = [];
        this.$animations = void 0;
        this.$context = void 0;
        this.chart = config.chart || config._chart;
        this._chart = this.chart;
        this.options = config.options;
        this.dataPoints = void 0;
        this.title = void 0;
        this.beforeBody = void 0;
        this.body = void 0;
        this.afterBody = void 0;
        this.footer = void 0;
        this.xAlign = void 0;
        this.yAlign = void 0;
        this.x = void 0;
        this.y = void 0;
        this.height = void 0;
        this.width = void 0;
        this.caretX = void 0;
        this.caretY = void 0;
        this.labelColors = void 0;
        this.labelPointStyles = void 0;
        this.labelTextColors = void 0;
      }
      initialize(options) {
        this.options = options;
        this._cachedAnimations = void 0;
        this.$context = void 0;
      }
      _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
          return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
          this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
      }
      getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
      }
      getTitle(context, options) {
        const {callbacks} = options;
        const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
        const title = callbacks.title.apply(this, [context]);
        const afterTitle = callbacks.afterTitle.apply(this, [context]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      }
      getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
      }
      getBody(tooltipItems, options) {
        const {callbacks} = options;
        const bodyItems = [];
        each(tooltipItems, (context) => {
          const bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          const scoped = overrideCallbacks(callbacks, context);
          pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
          pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
          pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      }
      getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
      }
      getFooter(tooltipItems, options) {
        const {callbacks} = options;
        const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
        const footer = callbacks.footer.apply(this, [tooltipItems]);
        const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      }
      _createItems(options) {
        const active2 = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for (i = 0, len = active2.length; i < len; ++i) {
          tooltipItems.push(createTooltipItem(this.chart, active2[i]));
        }
        if (options.filter) {
          tooltipItems = tooltipItems.filter((element2, index, array) => options.filter(element2, index, array, data));
        }
        if (options.itemSort) {
          tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
        }
        each(tooltipItems, (context) => {
          const scoped = overrideCallbacks(options.callbacks, context);
          labelColors.push(scoped.labelColor.call(this, context));
          labelPointStyles.push(scoped.labelPointStyle.call(this, context));
          labelTextColors.push(scoped.labelTextColor.call(this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
      }
      update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active2 = this._active;
        let properties;
        let tooltipItems = [];
        if (!active2.length) {
          if (this.opacity !== 0) {
            properties = {
              opacity: 0
            };
          }
        } else {
          const position = positioners[options.position].call(this, active2, this._eventPosition);
          tooltipItems = this._createItems(options);
          this.title = this.getTitle(tooltipItems, options);
          this.beforeBody = this.getBeforeBody(tooltipItems, options);
          this.body = this.getBody(tooltipItems, options);
          this.afterBody = this.getAfterBody(tooltipItems, options);
          this.footer = this.getFooter(tooltipItems, options);
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, size);
          const alignment = determineAlignment(this.chart, options, positionAndSize);
          const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          properties = {
            opacity: 1,
            x: backgroundPoint.x,
            y: backgroundPoint.y,
            width: size.width,
            height: size.height,
            caretX: position.x,
            caretY: position.y
          };
        }
        this._tooltipItems = tooltipItems;
        this.$context = void 0;
        if (properties) {
          this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
          options.external.call(this, {chart: this.chart, tooltip: this, replay});
        }
      }
      drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      }
      getCaretPosition(tooltipPoint, size, options) {
        const {xAlign, yAlign} = this;
        const {caretSize, cornerRadius} = options;
        const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
        const {x: ptX, y: ptY} = tooltipPoint;
        const {width, height} = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === "center") {
          y2 = ptY + height / 2;
          if (xAlign === "left") {
            x1 = ptX;
            x2 = x1 - caretSize;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
          x3 = x1;
        } else {
          if (xAlign === "left") {
            x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
          } else {
            x2 = this.caretX;
          }
          if (yAlign === "top") {
            y1 = ptY;
            y2 = y1 - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            x1 = x2 + caretSize;
            x3 = x2 - caretSize;
          }
          y3 = y1;
        }
        return {x1, x2, x3, y1, y2, y3};
      }
      drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.titleAlign, options);
          ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
          ctx.textBaseline = "middle";
          titleFont = toFont(options.titleFont);
          titleSpacing = options.titleSpacing;
          ctx.fillStyle = options.titleColor;
          ctx.font = titleFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
            pt.y += titleFont.lineHeight + titleSpacing;
            if (i + 1 === length) {
              pt.y += options.titleMarginBottom - titleSpacing;
            }
          }
        }
      }
      _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColors = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const {boxHeight, boxWidth, boxPadding} = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, "left", options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
          const drawOptions = {
            radius: Math.min(boxWidth, boxHeight) / 2,
            pointStyle: labelPointStyle.pointStyle,
            rotation: labelPointStyle.rotation,
            borderWidth: 1
          };
          const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
          const centerY = colorY + boxHeight / 2;
          ctx.strokeStyle = options.multiKeyBackground;
          ctx.fillStyle = options.multiKeyBackground;
          drawPoint(ctx, drawOptions, centerX, centerY);
          ctx.strokeStyle = labelColors.borderColor;
          ctx.fillStyle = labelColors.backgroundColor;
          drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
          ctx.lineWidth = labelColors.borderWidth || 1;
          ctx.strokeStyle = labelColors.borderColor;
          ctx.setLineDash(labelColors.borderDash || []);
          ctx.lineDashOffset = labelColors.borderDashOffset || 0;
          const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
          const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
          const borderRadius = toTRBLCorners(labelColors.borderRadius);
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            ctx.beginPath();
            ctx.fillStyle = options.multiKeyBackground;
            addRoundedRectPath(ctx, {
              x: outerX,
              y: colorY,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = labelColors.backgroundColor;
            ctx.beginPath();
            addRoundedRectPath(ctx, {
              x: innerX,
              y: colorY + 1,
              w: boxWidth - 2,
              h: boxHeight - 2,
              radius: borderRadius
            });
            ctx.fill();
          } else {
            ctx.fillStyle = options.multiKeyBackground;
            ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
            ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
            ctx.fillStyle = labelColors.backgroundColor;
            ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
          }
        }
        ctx.fillStyle = this.labelTextColors[i];
      }
      drawBody(pt, ctx, options) {
        const {body} = this;
        const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
          pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for (i = 0, ilen = body.length; i < ilen; ++i) {
          bodyItem = body[i];
          textColor = this.labelTextColors[i];
          ctx.fillStyle = textColor;
          each(bodyItem.before, fillLineOfText);
          lines = bodyItem.lines;
          if (displayColors && lines.length) {
            this._drawColorBox(ctx, pt, i, rtlHelper, options);
            bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
          }
          for (j = 0, jlen = lines.length; j < jlen; ++j) {
            fillLineOfText(lines[j]);
            bodyLineHeight = bodyFont.lineHeight;
          }
          each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
      }
      drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.footerAlign, options);
          pt.y += options.footerMarginTop;
          ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
          ctx.textBaseline = "middle";
          footerFont = toFont(options.footerFont);
          ctx.fillStyle = options.footerColor;
          ctx.font = footerFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
            pt.y += footerFont.lineHeight + options.footerSpacing;
          }
        }
      }
      drawBackground(pt, ctx, tooltipSize, options) {
        const {xAlign, yAlign} = this;
        const {x, y} = pt;
        const {width, height} = tooltipSize;
        const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === "top") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === "center" && xAlign === "right") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === "bottom") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === "center" && xAlign === "left") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }
      _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
          const position = positioners[options.position].call(this, this._active, this._eventPosition);
          if (!position) {
            return;
          }
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, this._size);
          const alignment = determineAlignment(chart, options, positionAndSize);
          const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
          if (animX._to !== point.x || animY._to !== point.y) {
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            this.width = size.width;
            this.height = size.height;
            this.caretX = position.x;
            this.caretY = position.y;
            this._resolveAnimations().update(this, point);
          }
        }
      }
      draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
          return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
          width: this.width,
          height: this.height
        };
        const pt = {
          x: this.x,
          y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity;
          this.drawBackground(pt, ctx, tooltipSize, options);
          overrideTextDirection(ctx, options.textDirection);
          pt.y += padding.top;
          this.drawTitle(pt, ctx, options);
          this.drawBody(pt, ctx, options);
          this.drawFooter(pt, ctx, options);
          restoreTextDirection(ctx, options.textDirection);
          ctx.restore();
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active2 = activeElements.map(({datasetIndex, index}) => {
          const meta = this.chart.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error("Cannot find a dataset at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index],
            index
          };
        });
        const changed = !_elementsEqual(lastActive, active2);
        const positionChanged = this._positionChanged(active2, eventPosition);
        if (changed || positionChanged) {
          this._active = active2;
          this._eventPosition = eventPosition;
          this._ignoreReplayEvents = true;
          this.update(true);
        }
      }
      handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
          return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active2 = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active2, e);
        const changed = replay || !_elementsEqual(active2, lastActive) || positionChanged;
        if (changed) {
          this._active = active2;
          if (options.enabled || options.external) {
            this._eventPosition = {
              x: e.x,
              y: e.y
            };
            this.update(true, replay);
          }
        }
        return changed;
      }
      _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive;
        }
        const active2 = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
          active2.reverse();
        }
        return active2;
      }
      _positionChanged(active2, e) {
        const {caretX, caretY, options} = this;
        const position = positioners[options.position].call(this, active2, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
      }
    };
    Tooltip.positioners = positioners;
    var plugin_tooltip = {
      id: "tooltip",
      _element: Tooltip,
      positioners,
      afterInit(chart, _args, options) {
        if (options) {
          chart.tooltip = new Tooltip({chart, options});
        }
      },
      beforeUpdate(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      reset(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      afterDraw(chart) {
        const tooltip = chart.tooltip;
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
          return;
        }
        if (tooltip) {
          tooltip.draw(chart.ctx);
        }
        chart.notifyPlugins("afterTooltipDraw", args);
      },
      afterEvent(chart, args) {
        if (chart.tooltip) {
          const useFinalPosition = args.replay;
          if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
            args.changed = true;
          }
        }
      },
      defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
          weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
          weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts) => opts.bodyFont.size,
        boxWidth: (ctx, opts) => opts.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
          duration: 400,
          easing: "easeOutQuart"
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "width", "height", "caretX", "caretY"]
          },
          opacity: {
            easing: "linear",
            duration: 200
          }
        },
        callbacks: {
          beforeTitle: noop2,
          title(tooltipItems) {
            if (tooltipItems.length > 0) {
              const item = tooltipItems[0];
              const labels = item.chart.data.labels;
              const labelCount = labels ? labels.length : 0;
              if (this && this.options && this.options.mode === "dataset") {
                return item.dataset.label || "";
              } else if (item.label) {
                return item.label;
              } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
              }
            }
            return "";
          },
          afterTitle: noop2,
          beforeBody: noop2,
          beforeLabel: noop2,
          label(tooltipItem) {
            if (this && this.options && this.options.mode === "dataset") {
              return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
            }
            let label = tooltipItem.dataset.label || "";
            if (label) {
              label += ": ";
            }
            const value = tooltipItem.formattedValue;
            if (!isNullOrUndef(value)) {
              label += value;
            }
            return label;
          },
          labelColor(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              borderColor: options.borderColor,
              backgroundColor: options.backgroundColor,
              borderWidth: options.borderWidth,
              borderDash: options.borderDash,
              borderDashOffset: options.borderDashOffset,
              borderRadius: 0
            };
          },
          labelTextColor() {
            return this.options.bodyColor;
          },
          labelPointStyle(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              pointStyle: options.pointStyle,
              rotation: options.rotation
            };
          },
          afterLabel: noop2,
          afterBody: noop2,
          beforeFooter: noop2,
          footer: noop2,
          afterFooter: noop2
        }
      },
      defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
      },
      descriptors: {
        _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
        _indexable: false,
        callbacks: {
          _scriptable: false,
          _indexable: false
        },
        animation: {
          _fallback: false
        },
        animations: {
          _fallback: "animation"
        }
      },
      additionalOptionScopes: ["interaction"]
    };
    var addIfString = (labels, raw, index, addedLabels) => {
      if (typeof raw === "string") {
        index = labels.push(raw) - 1;
        addedLabels.unshift({index, label: raw});
      } else if (isNaN(raw)) {
        index = null;
      }
      return index;
    };
    function findOrAddLabel(labels, raw, index, addedLabels) {
      const first = labels.indexOf(raw);
      if (first === -1) {
        return addIfString(labels, raw, index, addedLabels);
      }
      const last = labels.lastIndexOf(raw);
      return first !== last ? index : first;
    }
    var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
    var CategoryScale = class extends Scale {
      constructor(cfg) {
        super(cfg);
        this._startValue = void 0;
        this._valueRange = 0;
        this._addedLabels = [];
      }
      init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
          const labels = this.getLabels();
          for (const {index, label} of added) {
            if (labels[index] === label) {
              labels.splice(index, 1);
            }
          }
          this._addedLabels = [];
        }
        super.init(scaleOptions);
      }
      parse(raw, index) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
      }
      determineDataLimits() {
        const {minDefined, maxDefined} = this.getUserBounds();
        let {min, max} = this.getMinMax(true);
        if (this.options.bounds === "ticks") {
          if (!minDefined) {
            min = 0;
          }
          if (!maxDefined) {
            max = this.getLabels().length - 1;
          }
        }
        this.min = min;
        this.max = max;
      }
      buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for (let value = min; value <= max; value++) {
          ticks.push({value});
        }
        return ticks;
      }
      getLabelForValue(value) {
        const labels = this.getLabels();
        if (value >= 0 && value < labels.length) {
          return labels[value];
        }
        return value;
      }
      configure() {
        super.configure();
        if (!this.isHorizontal()) {
          this._reversePixels = !this._reversePixels;
        }
      }
      getPixelForValue(value) {
        if (typeof value !== "number") {
          value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index].value);
      }
      getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
      }
      getBasePixel() {
        return this.bottom;
      }
    };
    CategoryScale.id = "category";
    CategoryScale.defaults = {
      ticks: {
        callback: CategoryScale.prototype.getLabelForValue
      }
    };
    function generateTicks$1(generationOptions, dataRange) {
      const ticks = [];
      const MIN_SPACING = 1e-14;
      const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
      const unit = step || 1;
      const maxSpaces = maxTicks - 1;
      const {min: rmin, max: rmax} = dataRange;
      const minDefined = !isNullOrUndef(min);
      const maxDefined = !isNullOrUndef(max);
      const countDefined = !isNullOrUndef(count);
      const minSpacing = (rmax - rmin) / (maxDigits + 1);
      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
      let factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [{value: rmin}, {value: rmax}];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxSpaces) {
        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
      }
      if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }
      if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
      } else {
        niceMin = rmin;
        niceMax = rmax;
      }
      if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
      } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
      } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
          numSpaces = Math.round(numSpaces);
        } else {
          numSpaces = Math.ceil(numSpaces);
        }
      }
      const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      let j = 0;
      if (minDefined) {
        if (includeBounds && niceMin !== min) {
          ticks.push({value: min});
          if (niceMin < min) {
            j++;
          }
          if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
            j++;
          }
        } else if (niceMin < min) {
          j++;
        }
      }
      for (; j < numSpaces; ++j) {
        ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
      }
      if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
          ticks[ticks.length - 1].value = max;
        } else {
          ticks.push({value: max});
        }
      } else if (!maxDefined || niceMax === max) {
        ticks.push({value: niceMax});
      }
      return ticks;
    }
    function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
      const rad = toRadians(minRotation);
      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
      const length = 0.75 * minSpacing * ("" + value).length;
      return Math.min(minSpacing / ratio, length);
    }
    var LinearScaleBase = class extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._endValue = void 0;
        this._valueRange = 0;
      }
      parse(raw, index) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
          return null;
        }
        return +raw;
      }
      handleTickRangeOptions() {
        const {beginAtZero} = this.options;
        const {minDefined, maxDefined} = this.getUserBounds();
        let {min, max} = this;
        const setMin = (v) => min = minDefined ? min : v;
        const setMax = (v) => max = maxDefined ? max : v;
        if (beginAtZero) {
          const minSign = sign(min);
          const maxSign = sign(max);
          if (minSign < 0 && maxSign < 0) {
            setMax(0);
          } else if (minSign > 0 && maxSign > 0) {
            setMin(0);
          }
        }
        if (min === max) {
          let offset = 1;
          if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
            offset = Math.abs(max * 0.05);
          }
          setMax(max + offset);
          if (!beginAtZero) {
            setMin(min - offset);
          }
        }
        this.min = min;
        this.max = max;
      }
      getTickLimit() {
        const tickOpts = this.options.ticks;
        let {maxTicksLimit, stepSize} = tickOpts;
        let maxTicks;
        if (stepSize) {
          maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
          if (maxTicks > 1e3) {
            console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
            maxTicks = 1e3;
          }
        } else {
          maxTicks = this.computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
      }
      computeTickLimit() {
        return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
          maxTicks,
          bounds: opts.bounds,
          min: opts.min,
          max: opts.max,
          precision: tickOpts.precision,
          step: tickOpts.stepSize,
          count: tickOpts.count,
          maxDigits: this._maxDigits(),
          horizontal: this.isHorizontal(),
          minRotation: tickOpts.minRotation || 0,
          includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === "ticks") {
          _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
          const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
          start -= offset;
          end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
      }
      getLabelForValue(value) {
        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
      }
    };
    var LinearScale = class extends LinearScaleBase {
      determineDataLimits() {
        const {min, max} = this.getMinMax(true);
        this.min = isNumberFinite(min) ? min : 0;
        this.max = isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
      }
      getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      }
    };
    LinearScale.id = "linear";
    LinearScale.defaults = {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    };
    function isMajor(tickVal) {
      const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
      return remain === 1;
    }
    function generateTicks(generationOptions, dataRange) {
      const endExp = Math.floor(log10(dataRange.max));
      const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      const ticks = [];
      let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
      let exp = Math.floor(log10(tickVal));
      let significand = Math.floor(tickVal / Math.pow(10, exp));
      let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
      do {
        ticks.push({value: tickVal, major: isMajor(tickVal)});
        ++significand;
        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }
        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);
      const lastTick = finiteOrDefault(generationOptions.max, tickVal);
      ticks.push({value: lastTick, major: isMajor(tickVal)});
      return ticks;
    }
    var LogarithmicScale = class extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._valueRange = 0;
      }
      parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
        if (value === 0) {
          this._zero = true;
          return void 0;
        }
        return isNumberFinite(value) && value > 0 ? value : null;
      }
      determineDataLimits() {
        const {min, max} = this.getMinMax(true);
        this.min = isNumberFinite(min) ? Math.max(0, min) : null;
        this.max = isNumberFinite(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
          this._zero = true;
        }
        this.handleTickRangeOptions();
      }
      handleTickRangeOptions() {
        const {minDefined, maxDefined} = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v) => min = minDefined ? min : v;
        const setMax = (v) => max = maxDefined ? max : v;
        const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
        if (min === max) {
          if (min <= 0) {
            setMin(1);
            setMax(10);
          } else {
            setMin(exp(min, -1));
            setMax(exp(max, 1));
          }
        }
        if (min <= 0) {
          setMin(exp(max, -1));
        }
        if (max <= 0) {
          setMax(exp(min, 1));
        }
        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
          setMin(exp(min, -1));
        }
        this.min = min;
        this.max = max;
      }
      buildTicks() {
        const opts = this.options;
        const generationOptions = {
          min: this._userMin,
          max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === "ticks") {
          _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      getLabelForValue(value) {
        return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
      }
      configure() {
        const start = this.min;
        super.configure();
        this._startValue = log10(start);
        this._valueRange = log10(this.max) - log10(start);
      }
      getPixelForValue(value) {
        if (value === void 0 || value === 0) {
          value = this.min;
        }
        if (value === null || isNaN(value)) {
          return NaN;
        }
        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
      }
    };
    LogarithmicScale.id = "logarithmic";
    LogarithmicScale.defaults = {
      ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
          enabled: true
        }
      }
    };
    function getTickBackdropHeight(opts) {
      const tickOpts = opts.ticks;
      if (tickOpts.display && opts.display) {
        const padding = toPadding(tickOpts.backdropPadding);
        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults3.font.size) + padding.height;
      }
      return 0;
    }
    function measureLabelSize(ctx, font, label) {
      label = isArray2(label) ? label : [label];
      return {
        w: _longestText(ctx, font.string, label),
        h: label.length * font.lineHeight
      };
    }
    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }
      return {
        start: pos,
        end: pos + size
      };
    }
    function fitWithPointLabels(scale) {
      const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
      };
      const limits = Object.assign({}, orig);
      const labelSizes = [];
      const padding = [];
      const valueCount = scale._pointLabels.length;
      const pointLabelOpts = scale.options.pointLabels;
      const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
      for (let i = 0; i < valueCount; i++) {
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = toFont(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round(toDegrees(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
      }
      scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
      scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
    }
    function updateLimits(limits, orig, angle, hLimits, vLimits) {
      const sin = Math.abs(Math.sin(angle));
      const cos = Math.abs(Math.cos(angle));
      let x = 0;
      let y = 0;
      if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
      } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
      }
      if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
      } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
      }
    }
    function buildPointLabelItems(scale, labelSizes, padding) {
      const items = [];
      const valueCount = scale._pointLabels.length;
      const opts = scale.options;
      const extra = getTickBackdropHeight(opts) / 2;
      const outerDistance = scale.drawingArea;
      const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
      for (let i = 0; i < valueCount; i++) {
        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
        const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
        const size = labelSizes[i];
        const y = yForAngle(pointLabelPosition.y, size.h, angle);
        const textAlign = getTextAlignForAngle(angle);
        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
        items.push({
          x: pointLabelPosition.x,
          y,
          textAlign,
          left,
          top: y,
          right: left + size.w,
          bottom: y + size.h
        });
      }
      return items;
    }
    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return "center";
      } else if (angle < 180) {
        return "left";
      }
      return "right";
    }
    function leftForTextAlign(x, w, align) {
      if (align === "right") {
        x -= w;
      } else if (align === "center") {
        x -= w / 2;
      }
      return x;
    }
    function yForAngle(y, h, angle) {
      if (angle === 90 || angle === 270) {
        y -= h / 2;
      } else if (angle > 270 || angle < 90) {
        y -= h;
      }
      return y;
    }
    function drawPointLabels(scale, labelCount) {
      const {ctx, options: {pointLabels}} = scale;
      for (let i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        const plFont = toFont(optsAtIndex.font);
        const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
        const {backdropColor} = optsAtIndex;
        if (!isNullOrUndef(backdropColor)) {
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillStyle = backdropColor;
          ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
        }
        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
          color: optsAtIndex.color,
          textAlign,
          textBaseline: "middle"
        });
      }
    }
    function pathRadiusLine(scale, radius, circular, labelCount) {
      const {ctx} = scale;
      if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
      } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for (let i = 1; i < labelCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }
    }
    function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
      const ctx = scale.ctx;
      const circular = gridLineOpts.circular;
      const {color: color2, lineWidth} = gridLineOpts;
      if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
        return;
      }
      ctx.save();
      ctx.strokeStyle = color2;
      ctx.lineWidth = lineWidth;
      ctx.setLineDash(gridLineOpts.borderDash);
      ctx.lineDashOffset = gridLineOpts.borderDashOffset;
      ctx.beginPath();
      pathRadiusLine(scale, radius, circular, labelCount);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
    function createPointLabelContext(parent2, index, label) {
      return createContext(parent2, {
        label,
        index,
        type: "pointLabel"
      });
    }
    var RadialLinearScale = class extends LinearScaleBase {
      constructor(cfg) {
        super(cfg);
        this.xCenter = void 0;
        this.yCenter = void 0;
        this.drawingArea = void 0;
        this._pointLabels = [];
        this._pointLabelItems = [];
      }
      setDimensions() {
        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
      }
      determineDataLimits() {
        const {min, max} = this.getMinMax(false);
        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      }
      generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index) => {
          const label = callback(this.options.pointLabels.callback, [value, index], this);
          return label || label === 0 ? label : "";
        }).filter((v, i) => this.chart.getDataVisibility(i));
      }
      fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(this);
        } else {
          this.setCenterPoint(0, 0, 0, 0);
        }
      }
      setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
      }
      getIndexAngle(index) {
        const angleMultiplier = TAU / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
      }
      getDistanceFromCenterForValue(value) {
        if (isNullOrUndef(value)) {
          return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
          return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
      }
      getValueForDistanceFromCenter(distance) {
        if (isNullOrUndef(distance)) {
          return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
      }
      getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
          const pointLabel = pointLabels[index];
          return createPointLabelContext(this.getContext(), index, pointLabel);
        }
      }
      getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
        return {
          x: Math.cos(angle) * distanceFromCenter + this.xCenter,
          y: Math.sin(angle) * distanceFromCenter + this.yCenter,
          angle
        };
      }
      getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      }
      getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
      }
      getPointLabelPosition(index) {
        const {left, top, right, bottom} = this._pointLabelItems[index];
        return {
          left,
          top,
          right,
          bottom
        };
      }
      drawBackground() {
        const {backgroundColor, grid: {circular}} = this.options;
        if (backgroundColor) {
          const ctx = this.ctx;
          ctx.save();
          ctx.beginPath();
          pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
          ctx.closePath();
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
        }
      }
      drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const {angleLines, grid} = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) {
          drawPointLabels(this, labelCount);
        }
        if (grid.display) {
          this.ticks.forEach((tick2, index) => {
            if (index !== 0) {
              offset = this.getDistanceFromCenterForValue(tick2.value);
              const optsAtIndex = grid.setContext(this.getContext(index - 1));
              drawRadiusLine(this, optsAtIndex, offset, labelCount);
            }
          });
        }
        if (angleLines.display) {
          ctx.save();
          for (i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
            const {color: color2, lineWidth} = optsAtIndex;
            if (!lineWidth || !color2) {
              continue;
            }
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = color2;
            ctx.setLineDash(optsAtIndex.borderDash);
            ctx.lineDashOffset = optsAtIndex.borderDashOffset;
            offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
            position = this.getPointPosition(i, offset);
            ctx.beginPath();
            ctx.moveTo(this.xCenter, this.yCenter);
            ctx.lineTo(position.x, position.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      drawBorder() {
      }
      drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
          return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        this.ticks.forEach((tick2, index) => {
          if (index === 0 && !opts.reverse) {
            return;
          }
          const optsAtIndex = tickOpts.setContext(this.getContext(index));
          const tickFont = toFont(optsAtIndex.font);
          offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
          if (optsAtIndex.showLabelBackdrop) {
            ctx.font = tickFont.string;
            width = ctx.measureText(tick2.label).width;
            ctx.fillStyle = optsAtIndex.backdropColor;
            const padding = toPadding(optsAtIndex.backdropPadding);
            ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
          }
          renderText(ctx, tick2.label, 0, -offset, tickFont, {
            color: optsAtIndex.color
          });
        });
        ctx.restore();
      }
      drawTitle() {
      }
    };
    RadialLinearScale.id = "radialLinear";
    RadialLinearScale.defaults = {
      display: true,
      animate: true,
      position: "chartArea",
      angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0
      },
      grid: {
        circular: false
      },
      startAngle: 0,
      ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric
      },
      pointLabels: {
        backdropColor: void 0,
        backdropPadding: 2,
        display: true,
        font: {
          size: 10
        },
        callback(label) {
          return label;
        },
        padding: 5,
        centerPointLabels: false
      }
    };
    RadialLinearScale.defaultRoutes = {
      "angleLines.color": "borderColor",
      "pointLabels.color": "color",
      "ticks.color": "color"
    };
    RadialLinearScale.descriptors = {
      angleLines: {
        _fallback: "grid"
      }
    };
    var INTERVALS = {
      millisecond: {common: true, size: 1, steps: 1e3},
      second: {common: true, size: 1e3, steps: 60},
      minute: {common: true, size: 6e4, steps: 60},
      hour: {common: true, size: 36e5, steps: 24},
      day: {common: true, size: 864e5, steps: 30},
      week: {common: false, size: 6048e5, steps: 4},
      month: {common: true, size: 2628e6, steps: 12},
      quarter: {common: false, size: 7884e6, steps: 4},
      year: {common: true, size: 3154e7}
    };
    var UNITS = Object.keys(INTERVALS);
    function sorter(a, b) {
      return a - b;
    }
    function parse(scale, input) {
      if (isNullOrUndef(input)) {
        return null;
      }
      const adapter = scale._adapter;
      const {parser, round: round2, isoWeekday} = scale._parseOpts;
      let value = input;
      if (typeof parser === "function") {
        value = parser(value);
      }
      if (!isNumberFinite(value)) {
        value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
      }
      if (value === null) {
        return null;
      }
      if (round2) {
        value = round2 === "week" && (isNumber2(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
      }
      return +value;
    }
    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      const ilen = UNITS.length;
      for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }
      return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
      for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
          return unit;
        }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
      for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    function addTick(ticks, time, timestamps) {
      if (!timestamps) {
        ticks[time] = true;
      } else if (timestamps.length) {
        const {lo, hi} = _lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
      }
    }
    function setMajorTicks(scale, ticks, map2, majorUnit) {
      const adapter = scale._adapter;
      const first = +adapter.startOf(ticks[0].value, majorUnit);
      const last = ticks[ticks.length - 1].value;
      let major, index;
      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index = map2[major];
        if (index >= 0) {
          ticks[index].major = true;
        }
      }
      return ticks;
    }
    function ticksFromTimestamps(scale, values, majorUnit) {
      const ticks = [];
      const map2 = {};
      const ilen = values.length;
      let i, value;
      for (i = 0; i < ilen; ++i) {
        value = values[i];
        map2[value] = i;
        ticks.push({
          value,
          major: false
        });
      }
      return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
    }
    var TimeScale = class extends Scale {
      constructor(props) {
        super(props);
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
        this._unit = "day";
        this._majorUnit = void 0;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = void 0;
      }
      init(scaleOpts, opts) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
          parser: time.parser,
          round: time.round,
          isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
      }
      parse(raw, index) {
        if (raw === void 0) {
          return null;
        }
        return parse(this, raw);
      }
      beforeLayout() {
        super.beforeLayout();
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
      }
      determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || "day";
        let {min, max, minDefined, maxDefined} = this.getUserBounds();
        function _applyBounds(bounds) {
          if (!minDefined && !isNaN(bounds.min)) {
            min = Math.min(min, bounds.min);
          }
          if (!maxDefined && !isNaN(bounds.max)) {
            max = Math.max(max, bounds.max);
          }
        }
        if (!minDefined || !maxDefined) {
          _applyBounds(this._getLabelBounds());
          if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
            _applyBounds(this.getMinMax(false));
          }
        }
        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
      }
      _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
          min = arr[0];
          max = arr[arr.length - 1];
        }
        return {min, max};
      }
      buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === "ticks" && timestamps.length) {
          this.min = this._userMin || timestamps[0];
          this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _filterBetween(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
          ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
      }
      initOffsets(timestamps) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
          first = this.getDecimalForValue(timestamps[0]);
          if (timestamps.length === 1) {
            start = 1 - first;
          } else {
            start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
          }
          last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
          if (timestamps.length === 1) {
            end = last;
          } else {
            end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
          }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _limitValue(start, 0, limit);
        end = _limitValue(end, 0, limit);
        this._offsets = {start, end, factor: 1 / (start + 1 + end)};
      }
      _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = valueOrDefault(timeOpts.stepSize, 1);
        const weekday = minor === "week" ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber2(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
          first = +adapter.startOf(first, "isoWeek", weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? "day" : minor);
        if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
          throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
        }
        const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
        for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
          addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === "ticks" || count === 1) {
          addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
      }
      getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
          return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
      }
      _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick2 = ticks[index];
        const major = majorUnit && majorFormat && tick2 && tick2.major;
        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
        const formatter = options.ticks.callback;
        return formatter ? callback(formatter, [label, index, ticks], this) : label;
      }
      generateTickLabels(ticks) {
        let i, ilen, tick2;
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick2 = ticks[i];
          tick2.label = this._tickFormatFunction(tick2.value, i, ticks);
        }
      }
      getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
      }
      getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
      }
      _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
          w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
          h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
      }
      _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
      }
      getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
          return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
      }
      getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const labels = this.getLabels();
        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          timestamps.push(parse(this, labels[i]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
      }
      normalize(values) {
        return _arrayUnique(values.sort(sorter));
      }
    };
    TimeScale.id = "time";
    TimeScale.defaults = {
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        source: "auto",
        major: {
          enabled: false
        }
      }
    };
    function interpolate(table, val, reverse) {
      let lo = 0;
      let hi = table.length - 1;
      let prevSource, nextSource, prevTarget, nextTarget;
      if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
          ({lo, hi} = _lookupByKey(table, "pos", val));
        }
        ({pos: prevSource, time: prevTarget} = table[lo]);
        ({pos: nextSource, time: nextTarget} = table[hi]);
      } else {
        if (val >= table[lo].time && val <= table[hi].time) {
          ({lo, hi} = _lookupByKey(table, "time", val));
        }
        ({time: prevSource, pos: prevTarget} = table[lo]);
        ({time: nextSource, pos: nextTarget} = table[hi]);
      }
      const span = nextSource - prevSource;
      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
    }
    var TimeSeriesScale = class extends TimeScale {
      constructor(props) {
        super(props);
        this._table = [];
        this._minPos = void 0;
        this._tableRange = void 0;
      }
      initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
      }
      buildLookupTable(timestamps) {
        const {min, max} = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          curr = timestamps[i];
          if (curr >= min && curr <= max) {
            items.push(curr);
          }
        }
        if (items.length < 2) {
          return [
            {time: min, pos: 0},
            {time: max, pos: 1}
          ];
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          next = items[i + 1];
          prev = items[i - 1];
          curr = items[i];
          if (Math.round((next + prev) / 2) !== curr) {
            table.push({time: curr, pos: i / (ilen - 1)});
          }
        }
        return table;
      }
      _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
          return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
          timestamps = this.normalize(data.concat(label));
        } else {
          timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
      }
      getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
      }
    };
    TimeSeriesScale.id = "timeseries";
    TimeSeriesScale.defaults = TimeScale.defaults;
    var file$18 = "src/components/components/Donut.svelte";
    function create_fragment$18(ctx) {
      let canvas;
      const block = {
        c: function create2() {
          canvas = element("canvas");
          attr_dev(canvas, "id", ctx[0]);
          add_location(canvas, file$18, 2, 4, 6);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, canvas, anchor);
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 1) {
            attr_dev(canvas, "id", ctx2[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(canvas);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Donut", slots, []);
      Chart.register(ArcElement, LineElement, BarElement, PointElement, BarController, BubbleController, DoughnutController, LineController, PieController, PolarAreaController, RadarController, ScatterController, CategoryScale, LinearScale, LogarithmicScale, RadialLinearScale, TimeScale, TimeSeriesScale, plugin_decimation, plugin_filler, plugin_legend, plugin_tooltip);
      let {data} = $$props;
      let {labels} = $$props;
      let {id} = $$props;
      var ctx;
      var myChart;
      function createChart() {
        ctx = document.getElementById(id);
        if (myChart)
          myChart.destroy();
        myChart = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels,
            datasets: [
              {
                label: "My First Dataset",
                data,
                backgroundColor: ["#30974e", "#FFA400"],
                hoverOffset: 4
              }
            ]
          }
        });
      }
      afterUpdate(createChart);
      const writable_props = ["data", "labels", "id"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Donut> was created with unknown prop '${key}'`);
      });
      $$self.$$set = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(1, data = $$props2.data);
        if ("labels" in $$props2)
          $$invalidate(2, labels = $$props2.labels);
        if ("id" in $$props2)
          $$invalidate(0, id = $$props2.id);
      };
      $$self.$capture_state = () => ({
        onMount,
        afterUpdate,
        Chart,
        ArcElement,
        LineElement,
        BarElement,
        PointElement,
        BarController,
        BubbleController,
        DoughnutController,
        LineController,
        PieController,
        PolarAreaController,
        RadarController,
        ScatterController,
        CategoryScale,
        LinearScale,
        LogarithmicScale,
        RadialLinearScale,
        TimeScale,
        TimeSeriesScale,
        Decimation: plugin_decimation,
        Filler: plugin_filler,
        Legend: plugin_legend,
        Tooltip: plugin_tooltip,
        data,
        labels,
        id,
        ctx,
        myChart,
        createChart
      });
      $$self.$inject_state = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(1, data = $$props2.data);
        if ("labels" in $$props2)
          $$invalidate(2, labels = $$props2.labels);
        if ("id" in $$props2)
          $$invalidate(0, id = $$props2.id);
        if ("ctx" in $$props2)
          ctx = $$props2.ctx;
        if ("myChart" in $$props2)
          myChart = $$props2.myChart;
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [id, data, labels];
    }
    var Donut = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {data: 1, labels: 2, id: 0});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Donut",
          options,
          id: create_fragment$18.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[1] === void 0 && !("data" in props)) {
          console.warn("<Donut> was created without expected prop 'data'");
        }
        if (ctx[2] === void 0 && !("labels" in props)) {
          console.warn("<Donut> was created without expected prop 'labels'");
        }
        if (ctx[0] === void 0 && !("id" in props)) {
          console.warn("<Donut> was created without expected prop 'id'");
        }
      }
      get data() {
        throw new Error("<Donut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set data(value) {
        throw new Error("<Donut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get labels() {
        throw new Error("<Donut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set labels(value) {
        throw new Error("<Donut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<Donut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<Donut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var file10 = "src/pages/dashboard.svelte";
    function create_default_slot_22(ctx) {
      let h12;
      const block = {
        c: function create2() {
          h12 = element("h1");
          h12.textContent = "Dashboard";
          attr_dev(h12, "class", "text-2xl my-6");
          add_location(h12, file10, 29, 8, 800);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h12, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h12);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: "(30:1) <Title>",
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let input0;
      let t0;
      let input1;
      let t1;
      let div2;
      let div0;
      let donut0;
      let t2;
      let div1;
      let donut1;
      let t3;
      let br;
      let t4;
      let div3;
      let slider;
      let updating_value;
      let current;
      let mounted;
      let dispose;
      donut0 = new Donut({
        props: {
          data: ctx[0],
          labels: ctx[2],
          id: ctx[3]
        },
        $$inline: true
      });
      donut1 = new Donut({
        props: {
          data: ctx[0],
          labels: ctx[2],
          id: ctx[4]
        },
        $$inline: true
      });
      function slider_value_binding(value) {
        ctx[7](value);
      }
      let slider_props = {
        min: -2,
        max: 2,
        step: 1,
        discrete: true,
        tickMarks: true,
        "input$aria-label": "Tick mark slider"
      };
      if (ctx[1] !== void 0) {
        slider_props.value = ctx[1];
      }
      slider = new Slider({props: slider_props, $$inline: true});
      binding_callbacks.push(() => bind3(slider, "value", slider_value_binding));
      const block = {
        c: function create2() {
          input0 = element("input");
          t0 = space();
          input1 = element("input");
          t1 = space();
          div2 = element("div");
          div0 = element("div");
          create_component(donut0.$$.fragment);
          t2 = space();
          div1 = element("div");
          create_component(donut1.$$.fragment);
          t3 = space();
          br = element("br");
          t4 = space();
          div3 = element("div");
          create_component(slider.$$.fragment);
          attr_dev(input0, "type", "number");
          add_location(input0, file10, 31, 2, 862);
          attr_dev(input1, "type", "number");
          add_location(input1, file10, 32, 2, 907);
          attr_dev(div0, "class", "chart-container");
          set_style(div0, "width", "45%");
          set_style(div0, "max-width", "350px");
          set_style(div0, "position", "relative");
          set_style(div0, "float", "left");
          add_location(div0, file10, 34, 3, 961);
          attr_dev(div1, "class", "chart-container");
          set_style(div1, "width", "45%");
          set_style(div1, "max-width", "350px");
          set_style(div1, "position", "relative");
          set_style(div1, "float", "right");
          add_location(div1, file10, 37, 3, 1112);
          add_location(div2, file10, 33, 2, 952);
          set_style(br, "clear", "both");
          add_location(br, file10, 41, 2, 1271);
          set_style(div3, "padding", "0px 25%");
          add_location(div3, file10, 42, 2, 1302);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input0, anchor);
          set_input_value(input0, ctx[0][0]);
          insert_dev(target, t0, anchor);
          insert_dev(target, input1, anchor);
          set_input_value(input1, ctx[0][1]);
          insert_dev(target, t1, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          mount_component(donut0, div0, null);
          append_dev(div2, t2);
          append_dev(div2, div1);
          mount_component(donut1, div1, null);
          insert_dev(target, t3, anchor);
          insert_dev(target, br, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, div3, anchor);
          mount_component(slider, div3, null);
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(input0, "input", ctx[5]),
              listen_dev(input1, "input", ctx[6])
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1 && to_number(input0.value) !== ctx2[0][0]) {
            set_input_value(input0, ctx2[0][0]);
          }
          if (dirty & 1 && to_number(input1.value) !== ctx2[0][1]) {
            set_input_value(input1, ctx2[0][1]);
          }
          const donut0_changes = {};
          if (dirty & 1)
            donut0_changes.data = ctx2[0];
          donut0.$set(donut0_changes);
          const donut1_changes = {};
          if (dirty & 1)
            donut1_changes.data = ctx2[0];
          donut1.$set(donut1_changes);
          const slider_changes = {};
          if (!updating_value && dirty & 2) {
            updating_value = true;
            slider_changes.value = ctx2[1];
            add_flush_callback(() => updating_value = false);
          }
          slider.$set(slider_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(donut0.$$.fragment, local);
          transition_in(donut1.$$.fragment, local);
          transition_in(slider.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(donut0.$$.fragment, local);
          transition_out(donut1.$$.fragment, local);
          transition_out(slider.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input0);
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(input1);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(div2);
          destroy_component(donut0);
          destroy_component(donut1);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(br);
          if (detaching)
            detach_dev(t4);
          if (detaching)
            detach_dev(div3);
          destroy_component(slider);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(31:1) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 256) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 259) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: '(29:0) <Paper elevation={1} class=\\"md:w-10/12 w-full mx-auto\\">',
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let div;
      let paper;
      let div_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          class: "md:w-10/12 w-full mx-auto",
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          create_component(paper.$$.fragment);
          add_location(div, file10, 26, 0, 721);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(paper, div, null);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const paper_changes = {};
          if (dirty & 259) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!div_intro) {
            add_render_callback(() => {
              div_intro = create_in_transition(div, fade, {});
              div_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Dashboard", slots, []);
      let data = [90, 10];
      let labels = ["Einsparung", "Verbleibende Retoure"];
      let id1 = "donut_save";
      let id2 = "donut_stock";
      let value = 0;
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Dashboard> was created with unknown prop '${key}'`);
      });
      function input0_input_handler() {
        data[0] = to_number(this.value);
        $$invalidate(0, data);
      }
      function input1_input_handler() {
        data[1] = to_number(this.value);
        $$invalidate(0, data);
      }
      function slider_value_binding(value$1) {
        value = value$1;
        $$invalidate(1, value);
      }
      $$self.$capture_state = () => ({
        Paper,
        Title,
        Content,
        Button: Button_1,
        Label: CommonLabel,
        goto,
        redirect,
        user,
        Donut,
        fade,
        Slider,
        onMount,
        data,
        labels,
        id1,
        id2,
        value
      });
      $$self.$inject_state = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(0, data = $$props2.data);
        if ("labels" in $$props2)
          $$invalidate(2, labels = $$props2.labels);
        if ("id1" in $$props2)
          $$invalidate(3, id1 = $$props2.id1);
        if ("id2" in $$props2)
          $$invalidate(4, id2 = $$props2.id2);
        if ("value" in $$props2)
          $$invalidate(1, value = $$props2.value);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        data,
        value,
        labels,
        id1,
        id2,
        input0_input_handler,
        input1_input_handler,
        slider_value_binding
      ];
    }
    var Dashboard = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Dashboard",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/help.js
  var require_help = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Help
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var {Object: Object_12} = globals;
    var file10 = "src/pages/help.svelte";
    function create_default_slot_42(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Hilfe";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file10, 21, 8, 581);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(22:1) <Title>",
        ctx
      });
      return block;
    }
    function create_if_block7(ctx) {
      let button;
      let t;
      let br;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[2]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
          t = space();
          br = element("br");
          add_location(br, file10, 36, 2, 1102);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, br, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 16) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
          if (detaching)
            detach_dev(t);
          if (detaching)
            detach_dev(br);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block7.name,
        type: "if",
        source: "(29:2) {#if !($user && Object.keys($user).length)}",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Jetzt registrieren");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(35:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 16) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: '(30:2) <Button    variant=\\"raised\\"    style=\\"background: var(--mdc-theme-callout)\\"    on:click={() => $goto(\\"/signup\\")}   >',
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let t0;
      let br0;
      let t1;
      let br1;
      let t2;
      let br2;
      let t3;
      let show_if = !(ctx[0] && Object.keys(ctx[0]).length);
      let t4;
      let h2;
      let t6;
      let br3;
      let br4;
      let t7;
      let ul;
      let li0;
      let t8;
      let p0;
      let t10;
      let br5;
      let t11;
      let li1;
      let t12;
      let br6;
      let t13;
      let p1;
      let t15;
      let br7;
      let t16;
      let li2;
      let t17;
      let p2;
      let t18;
      let br8;
      let t19;
      let br9;
      let t20;
      let br10;
      let t21;
      let t22;
      let br11;
      let t23;
      let li3;
      let t24;
      let p3;
      let t25;
      let br12;
      let t26;
      let t27;
      let br13;
      let t28;
      let li4;
      let t29;
      let p4;
      let t30;
      let br14;
      let t31;
      let br15;
      let t32;
      let t33;
      let br16;
      let current;
      let if_block = show_if && create_if_block7(ctx);
      const block = {
        c: function create2() {
          t0 = text("Willkommen bei foodsight - der App die es ganz leicht macht, den Einkauf\n		perfekt zu planen. ");
          br0 = element("br");
          t1 = text("\n		Foodsight sagt genau voraus, wieviel von welchem Produkt Du verkaufen wirst\n		- morgen, \xFCbermorgen und in den n\xE4chsten 7 Tagen. ");
          br1 = element("br");
          t2 = space();
          br2 = element("br");
          t3 = space();
          if (if_block)
            if_block.c();
          t4 = space();
          h2 = element("h2");
          h2.textContent = "Funktionen";
          t6 = text("\n		Im Men\xFC rechts oben findest Du folgende Optionen:");
          br3 = element("br");
          br4 = element("br");
          t7 = space();
          ul = element("ul");
          li0 = element("li");
          t8 = text("\u2022 Login / Logout\n				");
          p0 = element("p");
          p0.textContent = "Solange Du nicht angemeldet bist, l\xE4uft die App im\n					Demo-Modus mit Beispieldaten";
          t10 = space();
          br5 = element("br");
          t11 = space();
          li1 = element("li");
          t12 = text("\u2022 Hilfe");
          br6 = element("br");
          t13 = space();
          p1 = element("p");
          p1.textContent = "Diese Einf\xFChrung";
          t15 = space();
          br7 = element("br");
          t16 = space();
          li2 = element("li");
          t17 = text("\u2022 Planung\n				");
          p2 = element("p");
          t18 = text("Schau dir den erwarteten Absatz an und plane Deine\n					Bestellmengen.");
          br8 = element("br");
          t19 = text("\n					Du bekommst einen Bereich von-bis angezeigt, in dem Dein Absatz\n					liegen wird. Der eingetragene Bestellvorschlag ist der wahrscheinlichste\n					Wert. ");
          br9 = element("br");
          t20 = text("\n					Mit dieser Information kannst Du ganz einfach Deine Einkaufsplanung\n					erstellen.");
          br10 = element("br");
          t21 = text('\n					Wenn Du fertig bist, klicke unten auf "Bestellen". Du kannst\n					Deine Bestell-Liste in drei Formaten abrufen - als Excel, csv\n					oder pdf.');
          t22 = space();
          br11 = element("br");
          t23 = space();
          li3 = element("li");
          t24 = text("\u2022 Einstellungen\n				");
          p3 = element("p");
          t25 = text("Im oberen Teil siehst Du auf welcher Basis Deine Abs\xE4tze\n					vorhergesagt werden. Bitte lass uns wissen, wenn etwas nicht\n					stimmt.");
          br12 = element("br");
          t26 = text("\n					Unten kannst Du einstellen, welche Planung Du gerade machen m\xF6chtest:\n					Morgen, \xFCbermorgen oder n\xE4chste 7 Tage.");
          t27 = space();
          br13 = element("br");
          t28 = space();
          li4 = element("li");
          t29 = text("\u2022 Idee/Problem\n				");
          p4 = element("p");
          t30 = text("Foodsight ist ganz neu. Wenn Dir irgendwas auff\xE4llt, was\n					besser sein k\xF6nnte oder Du Ideen hast - bitte lass es uns\n					wissen!");
          br14 = element("br");
          t31 = text("\n					Du kannst auf jeder Seite den Briefumschlag oben im Men\xFC dr\xFCcken,\n					ein Bildschirmfoto machen und Dein Anliegen beschreiben.\n					");
          br15 = element("br");
          t32 = text("\n					Absenden - wir k\xFCmmern uns darum.");
          t33 = space();
          br16 = element("br");
          add_location(br0, file10, 24, 21, 733);
          add_location(br1, file10, 26, 52, 870);
          add_location(br2, file10, 27, 2, 879);
          attr_dev(h2, "class", "text-xl my-6");
          add_location(h2, file10, 38, 2, 1119);
          add_location(br3, file10, 39, 51, 1211);
          add_location(br4, file10, 39, 57, 1217);
          set_style(p0, "margin-left", "50px");
          add_location(p0, file10, 43, 4, 1264);
          add_location(li0, file10, 41, 3, 1234);
          add_location(br5, file10, 48, 3, 1405);
          add_location(br6, file10, 50, 11, 1431);
          set_style(p1, "margin-left", "50px");
          add_location(p1, file10, 51, 4, 1442);
          add_location(li1, file10, 49, 3, 1415);
          add_location(br7, file10, 53, 3, 1504);
          add_location(br8, file10, 58, 19, 1642);
          add_location(br9, file10, 61, 11, 1807);
          add_location(br10, file10, 63, 15, 1902);
          set_style(p2, "margin-left", "50px");
          add_location(p2, file10, 56, 4, 1537);
          add_location(li2, file10, 54, 3, 1514);
          add_location(br11, file10, 69, 3, 2078);
          add_location(br12, file10, 75, 12, 2287);
          set_style(p3, "margin-left", "50px");
          add_location(p3, file10, 72, 4, 2117);
          add_location(li3, file10, 70, 3, 2088);
          add_location(br13, file10, 80, 3, 2435);
          add_location(br14, file10, 86, 12, 2640);
          add_location(br15, file10, 89, 5, 2785);
          set_style(p4, "margin-left", "50px");
          add_location(p4, file10, 83, 4, 2473);
          add_location(li4, file10, 81, 3, 2445);
          add_location(br16, file10, 93, 3, 2852);
          add_location(ul, file10, 40, 2, 1226);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, br0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, br1, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, br2, anchor);
          insert_dev(target, t3, anchor);
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, h2, anchor);
          insert_dev(target, t6, anchor);
          insert_dev(target, br3, anchor);
          insert_dev(target, br4, anchor);
          insert_dev(target, t7, anchor);
          insert_dev(target, ul, anchor);
          append_dev(ul, li0);
          append_dev(li0, t8);
          append_dev(li0, p0);
          append_dev(ul, t10);
          append_dev(ul, br5);
          append_dev(ul, t11);
          append_dev(ul, li1);
          append_dev(li1, t12);
          append_dev(li1, br6);
          append_dev(li1, t13);
          append_dev(li1, p1);
          append_dev(ul, t15);
          append_dev(ul, br7);
          append_dev(ul, t16);
          append_dev(ul, li2);
          append_dev(li2, t17);
          append_dev(li2, p2);
          append_dev(p2, t18);
          append_dev(p2, br8);
          append_dev(p2, t19);
          append_dev(p2, br9);
          append_dev(p2, t20);
          append_dev(p2, br10);
          append_dev(p2, t21);
          append_dev(ul, t22);
          append_dev(ul, br11);
          append_dev(ul, t23);
          append_dev(ul, li3);
          append_dev(li3, t24);
          append_dev(li3, p3);
          append_dev(p3, t25);
          append_dev(p3, br12);
          append_dev(p3, t26);
          append_dev(ul, t27);
          append_dev(ul, br13);
          append_dev(ul, t28);
          append_dev(ul, li4);
          append_dev(li4, t29);
          append_dev(li4, p4);
          append_dev(p4, t30);
          append_dev(p4, br14);
          append_dev(p4, t31);
          append_dev(p4, br15);
          append_dev(p4, t32);
          append_dev(ul, t33);
          append_dev(ul, br16);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1)
            show_if = !(ctx2[0] && Object.keys(ctx2[0]).length);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block7(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t4.parentNode, t4);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(br0);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(br1);
          if (detaching)
            detach_dev(t2);
          if (detaching)
            detach_dev(br2);
          if (detaching)
            detach_dev(t3);
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(t4);
          if (detaching)
            detach_dev(h2);
          if (detaching)
            detach_dev(t6);
          if (detaching)
            detach_dev(br3);
          if (detaching)
            detach_dev(br4);
          if (detaching)
            detach_dev(t7);
          if (detaching)
            detach_dev(ul);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(23:1) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_42]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 16) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 19) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: '(21:0) <Paper elevation={1} class=\\"md:w-10/12 w-full mx-auto\\">',
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let div;
      let paper;
      let div_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          class: "md:w-10/12 w-full mx-auto",
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          create_component(paper.$$.fragment);
          add_location(div, file10, 19, 0, 503);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(paper, div, null);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const paper_changes = {};
          if (dirty & 19) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!div_intro) {
            add_render_callback(() => {
              div_intro = create_in_transition(div, fade, {});
              div_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let $redirect;
      let $user;
      let $goto;
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(3, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(0, $user = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(1, $goto = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Help", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Help> was created with unknown prop '${key}'`);
      });
      const click_handler = () => $goto("/signup");
      $$self.$capture_state = () => ({
        Paper,
        Title,
        Content,
        Button: Button_1,
        Label: CommonLabel,
        goto,
        user,
        fade,
        redirect,
        onMount,
        $redirect,
        $user,
        $goto
      });
      return [$user, $goto, click_handler];
    }
    var Help = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Help",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/index2.js
  var require_index2 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Pages
    });
    (function(l2, r2) {
      if (!l2 || l2.getElementById("livereloadscript"))
        return;
      r2 = l2.createElement("script");
      r2.async = 1;
      r2.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r2.id = "livereloadscript";
      l2.getElementsByTagName("head")[0].appendChild(r2);
    })(self.document);
    var file$26 = "node_modules/@smui/button/Group.svelte";
    function create_fragment$28(ctx) {
      let div;
      let div_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let div_levels = [
        {
          class: div_class_value = classMap({
            [ctx[1]]: true,
            "smui-button__group": true,
            "smui-button__group--raised": ctx[2] === "raised"
          })
        },
        ctx[5]
      ];
      let div_data = {};
      for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
        div_data = assign(div_data, div_levels[i2]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (default_slot) {
            default_slot.m(div, null);
          }
          ctx[9](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
              action_destroyer(ctx[4].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 6 && div_class_value !== (div_class_value = classMap({
              [ctx2[1]]: true,
              "smui-button__group": true,
              "smui-button__group--raised": ctx2[2] === "raised"
            }))) && {class: div_class_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "variant", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Group", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {variant = "text"} = $$props;
      let element2;
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(3, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("variant" in $$new_props)
          $$invalidate(2, variant = $$new_props.variant);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        variant,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("variant" in $$props)
          $$invalidate(2, variant = $$new_props.variant);
        if ("element" in $$props)
          $$invalidate(3, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        variant,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var Group = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$28, safe_not_equal, {
          use: 0,
          class: 1,
          variant: 2,
          getElement: 6
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Group",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function GroupItem(node, {
      addClass = (className) => node.classList.add(className),
      removeClass = (className) => node.classList.remove(className)
    } = {}) {
      addClass("smui-button__group-item");
      return {
        destroy() {
          removeClass("smui-button__group-item");
        }
      };
    }
    var file$18 = "node_modules/@smui/list/Graphic.svelte";
    function create_fragment$18(ctx) {
      let span;
      let span_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let span_levels = [
        {
          class: span_class_value = classMap({
            [ctx[1]]: true,
            "mdc-deprecated-list-item__graphic": true,
            "mdc-menu__selection-group-icon": ctx[4]
          })
        },
        ctx[5]
      ];
      let span_data = {};
      for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
        span_data = assign(span_data, span_levels[i2]);
      }
      const block = {
        c: function create2() {
          span = element("span");
          if (default_slot)
            default_slot.c();
          set_attributes(span, span_data);
          add_location(span, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          if (default_slot) {
            default_slot.m(span, null);
          }
          ctx[9](span);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, span, ctx[0])),
              action_destroyer(ctx[3].call(null, span))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(span, span_data = get_spread_update(span_levels, [
            (!current || dirty & 2 && span_class_value !== (span_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-deprecated-list-item__graphic": true,
              "mdc-menu__selection-group-icon": ctx2[4]
            }))) && {class: span_class_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Graphic", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let element2;
      let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
      function getElement() {
        return element2;
      }
      function span_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        element: element2,
        menuSelectionGroup,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("menuSelectionGroup" in $$props)
          $$invalidate(4, menuSelectionGroup = $$new_props.menuSelectionGroup);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        element2,
        forwardEvents,
        menuSelectionGroup,
        $$restProps,
        getElement,
        $$scope,
        slots,
        span_binding
      ];
    }
    var Graphic = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {use: 0, class: 1, getElement: 6});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Graphic",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    classAdderBuilder({
      class: "mdc-menu__selection-group-icon",
      component: Graphic
    });
    var lib = {};
    var search;
    Object.defineProperty(lib, "__esModule", {value: true});
    var t = function(t2) {
      return function(r2) {
        return t2 == null ? void 0 : t2[r2];
      };
    }({\u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s"});
    var r = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
    var e = typeof r == "object" && r && r.Object === Object && r;
    var n = typeof self == "object" && self && self.Object === Object && self;
    var o = e || n || Function("return this")();
    var a = o.Symbol;
    var i = function(t2, r2) {
      for (var e2 = -1, n2 = t2 == null ? 0 : t2.length, o2 = Array(n2); ++e2 < n2; )
        o2[e2] = r2(t2[e2], e2, t2);
      return o2;
    };
    var u = Array.isArray;
    var c = Object.prototype;
    var s = c.hasOwnProperty;
    var f = c.toString;
    var l = a ? a.toStringTag : void 0;
    var p = function(t2) {
      var r2 = s.call(t2, l), e2 = t2[l];
      try {
        t2[l] = void 0;
        var n2 = true;
      } catch (t3) {
      }
      var o2 = f.call(t2);
      return n2 && (r2 ? t2[l] = e2 : delete t2[l]), o2;
    };
    var v = Object.prototype.toString;
    var h = function(t2) {
      return v.call(t2);
    };
    var y = a ? a.toStringTag : void 0;
    var d = function(t2) {
      return t2 == null ? t2 === void 0 ? "[object Undefined]" : "[object Null]" : y && y in Object(t2) ? p(t2) : h(t2);
    };
    var _2 = function(t2) {
      return t2 != null && typeof t2 == "object";
    };
    var g = function(t2) {
      return typeof t2 == "symbol" || _2(t2) && d(t2) == "[object Symbol]";
    };
    var b = a ? a.prototype : void 0;
    var O = b ? b.toString : void 0;
    var j = function t2(r2) {
      if (typeof r2 == "string")
        return r2;
      if (u(r2))
        return i(r2, t2) + "";
      if (g(r2))
        return O ? O.call(r2) : "";
      var e2 = r2 + "";
      return e2 == "0" && 1 / r2 == -1 / 0 ? "-0" : e2;
    };
    var m = function(t2) {
      return t2 == null ? "" : j(t2);
    };
    var x = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var w = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g");
    var A2 = function(r2) {
      return (r2 = m(r2)) && r2.replace(x, t).replace(w, "");
    };
    var S = /[\\^$.*+?()[\]{}|]/g;
    var z = RegExp(S.source);
    var E = function(t2) {
      return (t2 = m(t2)) && z.test(t2) ? t2.replace(S, "\\$&") : t2;
    };
    var $ = function(t2) {
      var r2 = typeof t2;
      return t2 != null && (r2 == "object" || r2 == "function");
    };
    var I2;
    var N = function(t2) {
      if (!$(t2))
        return false;
      var r2 = d(t2);
      return r2 == "[object Function]" || r2 == "[object GeneratorFunction]" || r2 == "[object AsyncFunction]" || r2 == "[object Proxy]";
    };
    var T = o["__core-js_shared__"];
    var U = (I2 = /[^.]+$/.exec(T && T.keys && T.keys.IE_PROTO || "")) ? "Symbol(src)_1." + I2 : "";
    var C = function(t2) {
      return !!U && U in t2;
    };
    var L = Function.prototype.toString;
    var P = function(t2) {
      if (t2 != null) {
        try {
          return L.call(t2);
        } catch (t3) {
        }
        try {
          return t2 + "";
        } catch (t3) {
        }
      }
      return "";
    };
    var R = /^\[object .+?Constructor\]$/;
    var F = Function.prototype;
    var k = Object.prototype;
    var G = F.toString;
    var D = k.hasOwnProperty;
    var M = RegExp("^" + G.call(D).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var J = function(t2) {
      return !(!$(t2) || C(t2)) && (N(t2) ? M : R).test(P(t2));
    };
    var Y = function(t2, r2) {
      return t2 == null ? void 0 : t2[r2];
    };
    var Z = function(t2, r2) {
      var e2 = Y(t2, r2);
      return J(e2) ? e2 : void 0;
    };
    var H = Z(Object, "create");
    var K = function() {
      this.__data__ = H ? H(null) : {}, this.size = 0;
    };
    var W = function(t2) {
      var r2 = this.has(t2) && delete this.__data__[t2];
      return this.size -= r2 ? 1 : 0, r2;
    };
    var q = Object.prototype.hasOwnProperty;
    var B = function(t2) {
      var r2 = this.__data__;
      if (H) {
        var e2 = r2[t2];
        return e2 === "__lodash_hash_undefined__" ? void 0 : e2;
      }
      return q.call(r2, t2) ? r2[t2] : void 0;
    };
    var Q = Object.prototype.hasOwnProperty;
    var V = function(t2) {
      var r2 = this.__data__;
      return H ? r2[t2] !== void 0 : Q.call(r2, t2);
    };
    var X = function(t2, r2) {
      var e2 = this.__data__;
      return this.size += this.has(t2) ? 0 : 1, e2[t2] = H && r2 === void 0 ? "__lodash_hash_undefined__" : r2, this;
    };
    function tt(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    tt.prototype.clear = K, tt.prototype.delete = W, tt.prototype.get = B, tt.prototype.has = V, tt.prototype.set = X;
    var rt = tt;
    var et = function() {
      this.__data__ = [], this.size = 0;
    };
    var nt = function(t2, r2) {
      return t2 === r2 || t2 != t2 && r2 != r2;
    };
    var ot = function(t2, r2) {
      for (var e2 = t2.length; e2--; )
        if (nt(t2[e2][0], r2))
          return e2;
      return -1;
    };
    var at = Array.prototype.splice;
    var it = function(t2) {
      var r2 = this.__data__, e2 = ot(r2, t2);
      return !(e2 < 0) && (e2 == r2.length - 1 ? r2.pop() : at.call(r2, e2, 1), --this.size, true);
    };
    var ut = function(t2) {
      var r2 = this.__data__, e2 = ot(r2, t2);
      return e2 < 0 ? void 0 : r2[e2][1];
    };
    var ct = function(t2) {
      return ot(this.__data__, t2) > -1;
    };
    var st = function(t2, r2) {
      var e2 = this.__data__, n2 = ot(e2, t2);
      return n2 < 0 ? (++this.size, e2.push([t2, r2])) : e2[n2][1] = r2, this;
    };
    function ft(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    ft.prototype.clear = et, ft.prototype.delete = it, ft.prototype.get = ut, ft.prototype.has = ct, ft.prototype.set = st;
    var lt = ft;
    var pt = Z(o, "Map");
    var vt = function() {
      this.size = 0, this.__data__ = {hash: new rt(), map: new (pt || lt)(), string: new rt()};
    };
    var ht = function(t2) {
      var r2 = typeof t2;
      return r2 == "string" || r2 == "number" || r2 == "symbol" || r2 == "boolean" ? t2 !== "__proto__" : t2 === null;
    };
    var yt = function(t2, r2) {
      var e2 = t2.__data__;
      return ht(r2) ? e2[typeof r2 == "string" ? "string" : "hash"] : e2.map;
    };
    var dt = function(t2) {
      var r2 = yt(this, t2).delete(t2);
      return this.size -= r2 ? 1 : 0, r2;
    };
    var _t = function(t2) {
      return yt(this, t2).get(t2);
    };
    var gt = function(t2) {
      return yt(this, t2).has(t2);
    };
    var bt = function(t2, r2) {
      var e2 = yt(this, t2), n2 = e2.size;
      return e2.set(t2, r2), this.size += e2.size == n2 ? 0 : 1, this;
    };
    function Ot(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    Ot.prototype.clear = vt, Ot.prototype.delete = dt, Ot.prototype.get = _t, Ot.prototype.has = gt, Ot.prototype.set = bt;
    var jt = Ot;
    function mt(t2, r2) {
      if (typeof t2 != "function" || r2 != null && typeof r2 != "function")
        throw new TypeError("Expected a function");
      var e2 = function() {
        var n2 = arguments, o2 = r2 ? r2.apply(this, n2) : n2[0], a2 = e2.cache;
        if (a2.has(o2))
          return a2.get(o2);
        var i2 = t2.apply(this, n2);
        return e2.cache = a2.set(o2, i2) || a2, i2;
      };
      return e2.cache = new (mt.Cache || jt)(), e2;
    }
    mt.Cache = jt;
    var xt = mt;
    var wt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var At = /^\w*$/;
    var St = function(t2, r2) {
      if (u(t2))
        return false;
      var e2 = typeof t2;
      return !(e2 != "number" && e2 != "symbol" && e2 != "boolean" && t2 != null && !g(t2)) || (At.test(t2) || !wt.test(t2) || r2 != null && t2 in Object(r2));
    };
    var zt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var Et = /\\(\\)?/g;
    var $t = function(t2) {
      var r2 = xt(t2, function(t3) {
        return e2.size === 500 && e2.clear(), t3;
      }), e2 = r2.cache;
      return r2;
    }(function(t2) {
      var r2 = [];
      return t2.charCodeAt(0) === 46 && r2.push(""), t2.replace(zt, function(t3, e2, n2, o2) {
        r2.push(n2 ? o2.replace(Et, "$1") : e2 || t3);
      }), r2;
    });
    var It = function(t2, r2) {
      return u(t2) ? t2 : St(t2, r2) ? [t2] : $t(m(t2));
    };
    var Nt = function(t2) {
      if (typeof t2 == "string" || g(t2))
        return t2;
      var r2 = t2 + "";
      return r2 == "0" && 1 / t2 == -1 / 0 ? "-0" : r2;
    };
    var Tt = function(t2, r2) {
      for (var e2 = 0, n2 = (r2 = It(r2, t2)).length; t2 != null && e2 < n2; )
        t2 = t2[Nt(r2[e2++])];
      return e2 && e2 == n2 ? t2 : void 0;
    };
    var Ut = function(t2, r2, e2) {
      var n2 = t2 == null ? void 0 : Tt(t2, r2);
      return n2 === void 0 ? e2 : n2;
    };
    var Ct = /\s/;
    var Lt = function(t2) {
      for (var r2 = t2.length; r2-- && Ct.test(t2.charAt(r2)); )
        ;
      return r2;
    };
    var Pt = /^\s+/;
    var Rt = function(t2) {
      return t2 ? t2.slice(0, Lt(t2) + 1).replace(Pt, "") : t2;
    };
    var Ft = /^[-+]0x[0-9a-f]+$/i;
    var kt = /^0b[01]+$/i;
    var Gt = /^0o[0-7]+$/i;
    var Dt = parseInt;
    var Mt = function(t2) {
      if (typeof t2 == "number")
        return t2;
      if (g(t2))
        return NaN;
      if ($(t2)) {
        var r2 = typeof t2.valueOf == "function" ? t2.valueOf() : t2;
        t2 = $(r2) ? r2 + "" : r2;
      }
      if (typeof t2 != "string")
        return t2 === 0 ? t2 : +t2;
      t2 = Rt(t2);
      var e2 = kt.test(t2);
      return e2 || Gt.test(t2) ? Dt(t2.slice(2), e2 ? 2 : 8) : Ft.test(t2) ? NaN : +t2;
    };
    var Jt = function(t2) {
      return t2 ? (t2 = Mt(t2)) === 1 / 0 || t2 === -1 / 0 ? 17976931348623157e292 * (t2 < 0 ? -1 : 1) : t2 == t2 ? t2 : 0 : t2 === 0 ? t2 : 0;
    };
    var Yt = function(t2) {
      var r2 = Jt(t2), e2 = r2 % 1;
      return r2 == r2 ? e2 ? r2 - e2 : r2 : 0;
    };
    var Zt = o.isFinite;
    var Ht = Math.min;
    var Kt = function(t2) {
      var r2 = Math[t2];
      return function(t3, e2) {
        if (t3 = Mt(t3), (e2 = e2 == null ? 0 : Ht(Yt(e2), 292)) && Zt(t3)) {
          var n2 = (m(t3) + "e").split("e"), o2 = r2(n2[0] + "e" + (+n2[1] + e2));
          return +((n2 = (m(o2) + "e").split("e"))[0] + "e" + (+n2[1] - e2));
        }
        return r2(t3);
      };
    }("round");
    function Wt(t2) {
      return A2(t2).replace(/[\u0300-\u036f]/g, "").toLocaleLowerCase().trim();
    }
    function qt(t2) {
      return Wt(E(t2)).match(/[\p{L}\d]+/gimu) || [];
    }
    var Bt = xt((t2, r2) => {
      if (!t2 || t2.length === 0 || !r2 || r2.length === 0)
        return [];
      const e2 = /\[(.*)]/;
      return t2.map((t3) => r2.map((r3) => {
        const n2 = Ut(e2.exec(r3), "1"), o2 = Ut(t3, r3.replace(e2, ""));
        return n2 || o2 != null && typeof o2 != "function" ? n2 ? o2.map((t4) => Ut(t4, n2)) : Array.isArray(o2) || typeof o2 == "object" ? JSON.stringify(o2) : o2 : "";
      }).reduce((t4, r3) => t4 + r3, "")).map((t3) => Wt(t3));
    });
    var Qt = Bt;
    var Vt = (t2, r2, e2) => {
      if (!t2)
        return 0;
      const n2 = e2.replace(/[^\p{L}\d]+/gimu, ""), o2 = r2.sort((t3, r3) => r3.length - t3.length).reduce((t3, r3) => t3.replace(new RegExp(r3, "gm"), ""), n2);
      return Kt(1 - o2.length / n2.length, 4);
    };
    lib.convertToSearchableStrings = Bt, lib.getScore = Vt, lib.indexDocuments = Qt, lib.normalize = Wt, search = lib.search = function(t2, r2, e2, n2 = {}) {
      if (!e2)
        return t2;
      const o2 = qt(e2);
      return Bt(t2, r2).map((r3, e3) => {
        const a2 = o2.filter((t3) => r3.indexOf(t3) > -1).length === o2.length;
        if (n2.withScore) {
          const n3 = Vt(a2, o2, r3);
          return {element: t2[e3], score: n3};
        }
        return a2 ? t2[e3] : null;
      }).filter((t3) => t3);
    }, lib.tokenize = qt;
    var {Object: Object_12, console: console_12} = globals;
    var file10 = "src/pages/index.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-6o1wow", "th,td{text-align:center;width:20000px}input{padding-top:0.5rem;padding-bottom:0.5rem;padding-left:1rem;padding-right:1rem;border-radius:0.25rem}:root{--table-head-bg:var(--mdc-theme-primary);--table-head-color:var(--mdc-theme-on-primary);--table-body-odd-bg:var(--mdc-theme-background);--table-body-odd-color:var(--mdc-theme-text-primary-on-background);--table-body-even-bg:var(--mdc-theme-2nd-background);--table-body-even-color:var(--mdc-theme-text-primary-on-background)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUFBLEVBQUEsQUFBQSxDQUFBLEVBQUEsQUFBQSxDQUFBLEFBQUEsVUFBQSxDQUFBLE1BQUEsQ0NJRSxLQUFBLENBQUEsT0FBQSxBQ0FGLENBQUEsQUZKQSxLQUFBLEFBQUEsQ0FBQSxBQUFBLFdBQUEsQ0FBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE1BQUEsQ0FBQSxZQUFBLENBQUEsSUFBQSxDQUFBLGFBQUEsQ0FBQSxJQUFBLENBQUEsYUFBQSxDQUFBLE9BQUEsQUVXQSxDQUFBLEFEQUMsS0FBQSxBQUFBLENBQUEsQUFDQyxlQUFBLENBQUEsd0JBQXlDLENBQ3pDLGtCQUFBLENBQUEsMkJBQStDLENBQy9DLG1CQUFBLENBQUEsMkJBQWdELENBQ2hELHNCQUFBLENBQUEsMkNBQW1FLENBQ25FLG9CQUFBLENBQUEsK0JBQXFELENBQ3JELHVCQUFBLENBQUEsMkNBQW9FLEFBQ3JFLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzLyUzQ25vJTIwc291cmNlJTNFIiwic3JjL3BhZ2VzL3NyYy9wYWdlcy9pbmRleC5zdmVsdGUiLCJzcmMvcGFnZXMvaW5kZXguc3ZlbHRlIl19 */");
    }
    function get_each_context3(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[35] = list[i2];
      child_ctx[36] = list;
      child_ctx[37] = i2;
      return child_ctx;
    }
    function get_each_context_1(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[38] = list[i2];
      child_ctx[39] = list;
      child_ctx[40] = i2;
      return child_ctx;
    }
    function get_each_context_2(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[41] = list[i2];
      return child_ctx;
    }
    function create_default_slot_24(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Vorhersage und Planung";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file10, 273, 9, 7448);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_24.name,
        type: "slot",
        source: "(274:2) <Title>",
        ctx
      });
      return block;
    }
    function create_catch_block(ctx) {
      let t_value = ctx[44] + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 64 && t_value !== (t_value = ctx2[44] + ""))
            set_data_dev(t2, t_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_catch_block.name,
        type: "catch",
        source: "(529:4) {:catch error}",
        ctx
      });
      return block;
    }
    function create_then_block(ctx) {
      let div;
      let dataChanger_action;
      let autoCache_action;
      let t2;
      let show_if = Object.keys(ctx[0]).length;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block = show_if && create_if_block7(ctx);
      const block = {
        c: function create2() {
          div = element("div");
          t2 = space();
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
          add_location(div, file10, 294, 5, 8033);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          insert_dev(target, t2, anchor);
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(dataChanger_action = ctx[13].call(null, div, ctx[34])),
              action_destroyer(autoCache_action = ctx[14].call(null, div, ctx[0]))
            ];
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dataChanger_action && is_function(dataChanger_action.update) && dirty[0] & 64)
            dataChanger_action.update.call(null, ctx[34]);
          if (autoCache_action && is_function(autoCache_action.update) && dirty[0] & 1)
            autoCache_action.update.call(null, ctx[0]);
          if (dirty[0] & 1)
            show_if = Object.keys(ctx[0]).length;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty[0] & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block7(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t2);
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_then_block.name,
        type: "then",
        source: "(293:4) {:then returnVal}",
        ctx
      });
      return block;
    }
    function create_if_block7(ctx) {
      let section_1;
      let table;
      let thead;
      let t0;
      let tbody;
      let table_intro;
      let t1;
      let div1;
      let group0;
      let t2;
      let div0;
      let group1;
      let div1_intro;
      let current;
      let each_value_2 = ctx[0].head;
      validate_each_argument(each_value_2);
      let each_blocks_1 = [];
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        each_blocks_1[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
      }
      let each_value = ctx[0].body;
      validate_each_argument(each_value);
      let each_blocks = [];
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
      }
      const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
        each_blocks[i2] = null;
      });
      let each1_else = null;
      if (!each_value.length) {
        each1_else = create_else_block_13(ctx);
      }
      group0 = new Group({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      group1 = new Group({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_25]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section_1 = element("section");
          table = element("table");
          thead = element("thead");
          for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
            each_blocks_1[i2].c();
          }
          t0 = space();
          tbody = element("tbody");
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].c();
          }
          if (each1_else) {
            each1_else.c();
          }
          t1 = space();
          div1 = element("div");
          create_component(group0.$$.fragment);
          t2 = space();
          div0 = element("div");
          create_component(group1.$$.fragment);
          attr_dev(thead, "class", "border-b border-black");
          add_location(thead, file10, 304, 8, 8328);
          add_location(tbody, file10, 356, 8, 9900);
          attr_dev(table, "class", "w-full");
          add_location(table, file10, 302, 7, 8259);
          attr_dev(section_1, "class", "overflow-y-auto p-2");
          add_location(section_1, file10, 298, 6, 8173);
          attr_dev(div0, "class", "md:ml-auto ");
          add_location(div0, file10, 468, 7, 13223);
          attr_dev(div1, "class", "w-full flex flex-col md:flex-row gap-2");
          add_location(div1, file10, 420, 6, 11951);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section_1, anchor);
          append_dev(section_1, table);
          append_dev(table, thead);
          for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
            each_blocks_1[i2].m(thead, null);
          }
          append_dev(table, t0);
          append_dev(table, tbody);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].m(tbody, null);
          }
          if (each1_else) {
            each1_else.m(tbody, null);
          }
          ctx[23](section_1);
          insert_dev(target, t1, anchor);
          insert_dev(target, div1, anchor);
          mount_component(group0, div1, null);
          append_dev(div1, t2);
          append_dev(div1, div0);
          mount_component(group1, div0, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1053) {
            each_value_2 = ctx2[0].head;
            validate_each_argument(each_value_2);
            let i2;
            for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
              const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
              if (each_blocks_1[i2]) {
                each_blocks_1[i2].p(child_ctx, dirty);
              } else {
                each_blocks_1[i2] = create_each_block_2(child_ctx);
                each_blocks_1[i2].c();
                each_blocks_1[i2].m(thead, null);
              }
            }
            for (; i2 < each_blocks_1.length; i2 += 1) {
              each_blocks_1[i2].d(1);
            }
            each_blocks_1.length = each_value_2.length;
          }
          if (dirty[0] & 2695) {
            each_value = ctx2[0].body;
            validate_each_argument(each_value);
            let i2;
            for (i2 = 0; i2 < each_value.length; i2 += 1) {
              const child_ctx = get_each_context3(ctx2, each_value, i2);
              if (each_blocks[i2]) {
                each_blocks[i2].p(child_ctx, dirty);
                transition_in(each_blocks[i2], 1);
              } else {
                each_blocks[i2] = create_each_block3(child_ctx);
                each_blocks[i2].c();
                transition_in(each_blocks[i2], 1);
                each_blocks[i2].m(tbody, null);
              }
            }
            group_outros();
            for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
              out(i2);
            }
            check_outros();
            if (!each_value.length && each1_else) {
              each1_else.p(ctx2, dirty);
            } else if (!each_value.length) {
              each1_else = create_else_block_13(ctx2);
              each1_else.c();
              each1_else.m(tbody, null);
            } else if (each1_else) {
              each1_else.d(1);
              each1_else = null;
            }
          }
          const group0_changes = {};
          if (dirty[0] & 33 | dirty[1] & 16384) {
            group0_changes.$$scope = {dirty, ctx: ctx2};
          }
          group0.$set(group0_changes);
          const group1_changes = {};
          if (dirty[0] & 641 | dirty[1] & 16384) {
            group1_changes.$$scope = {dirty, ctx: ctx2};
          }
          group1.$set(group1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i2 = 0; i2 < each_value.length; i2 += 1) {
            transition_in(each_blocks[i2]);
          }
          if (!table_intro) {
            add_render_callback(() => {
              table_intro = create_in_transition(table, blur, {});
              table_intro.start();
            });
          }
          transition_in(group0.$$.fragment, local);
          transition_in(group1.$$.fragment, local);
          if (!div1_intro) {
            add_render_callback(() => {
              div1_intro = create_in_transition(div1, fade, {});
              div1_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            transition_out(each_blocks[i2]);
          }
          transition_out(group0.$$.fragment, local);
          transition_out(group1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section_1);
          destroy_each(each_blocks_1, detaching);
          destroy_each(each_blocks, detaching);
          if (each1_else)
            each1_else.d();
          ctx[23](null);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(div1);
          destroy_component(group0);
          destroy_component(group1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block7.name,
        type: "if",
        source: "(298:5) {#if Object.keys(data).length}",
        ctx
      });
      return block;
    }
    function create_if_block_92(ctx) {
      let th;
      let div1;
      let t0_value = (ctx[10].find(func_22)?.text || ctx[41]) + "";
      let t0;
      let t1;
      let div0;
      let span0;
      let t3;
      let span1;
      let t5;
      let mounted;
      let dispose;
      function func_22(...args) {
        return ctx[20](ctx[41], ...args);
      }
      function click_handler() {
        return ctx[21](ctx[41]);
      }
      const block = {
        c: function create2() {
          th = element("th");
          div1 = element("div");
          t0 = text(t0_value);
          t1 = space();
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "arrow_drop_up";
          t3 = space();
          span1 = element("span");
          span1.textContent = "arrow_drop_down";
          t5 = space();
          attr_dev(span0, "class", `material-icons absolute right-0 top-0 `);
          toggle_class(span0, "text-gray-200", ctx[3].col == ctx[41] && !ctx[3].ascending);
          toggle_class(span0, "text-gray-500", ctx[3].col != ctx[41] || ctx[3].ascending);
          add_location(span0, file10, 326, 14, 9037);
          attr_dev(span1, "class", "material-icons absolute right-0 bottom-0");
          toggle_class(span1, "text-gray-200", ctx[3].col == ctx[41] && ctx[3].ascending);
          toggle_class(span1, "text-gray-500", ctx[3].col != ctx[41] || !ctx[3].ascending);
          add_location(span1, file10, 337, 14, 9403);
          attr_dev(div0, "class", "absolute -right-1 top-0 bottom-0");
          add_location(div0, file10, 323, 13, 8948);
          attr_dev(div1, "class", "relative h-10 flex justify-center items-center px-[1.25rem] whitespace-nowrap");
          add_location(div1, file10, 316, 12, 8705);
          set_style(th, "background", "var(--table-head-bg)");
          set_style(th, "color", "var(--table-head-color)");
          add_location(th, file10, 307, 11, 8456);
        },
        m: function mount(target, anchor) {
          insert_dev(target, th, anchor);
          append_dev(th, div1);
          append_dev(div1, t0);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(div0, t3);
          append_dev(div0, span1);
          append_dev(th, t5);
          if (!mounted) {
            dispose = listen_dev(th, "click", click_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 1 && t0_value !== (t0_value = (ctx[10].find(func_22)?.text || ctx[41]) + ""))
            set_data_dev(t0, t0_value);
          if (dirty[0] & 9) {
            toggle_class(span0, "text-gray-200", ctx[3].col == ctx[41] && !ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span0, "text-gray-500", ctx[3].col != ctx[41] || ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span1, "text-gray-200", ctx[3].col == ctx[41] && ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span1, "text-gray-500", ctx[3].col != ctx[41] || !ctx[3].ascending);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(th);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_92.name,
        type: "if",
        source: "(307:10) {#if tableWhitelist.includes(col)}",
        ctx
      });
      return block;
    }
    function create_each_block_2(ctx) {
      let show_if = ctx[2].includes(ctx[41]);
      let if_block_anchor;
      let if_block = show_if && create_if_block_92(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 5)
            show_if = ctx2[2].includes(ctx2[41]);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block_92(ctx2);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(306:9) {#each data.head as col}",
        ctx
      });
      return block;
    }
    function create_else_block_13(ctx) {
      let div1;
      let div0;
      let t0;
      let t1;
      let t2;
      let t3;
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          t0 = text('Keine Daten zum Suchbegriff "');
          t1 = text(ctx[1]);
          t2 = text('"\n												gefunden');
          t3 = space();
          attr_dev(div0, "class", "absolute top-0 left-0 -right-full bottom-0 flex justify-center items-center");
          add_location(div0, file10, 409, 11, 11648);
          attr_dev(div1, "class", "h-96 relative");
          add_location(div1, file10, 408, 10, 11609);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, t0);
          append_dev(div0, t1);
          append_dev(div0, t2);
          append_dev(div1, t3);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2)
            set_data_dev(t1, ctx2[1]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_13.name,
        type: "else",
        source: "(407:9) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_53(ctx) {
      let tr;
      let t2;
      let current;
      let each_value_1 = Object.keys(ctx[35]);
      validate_each_argument(each_value_1);
      let each_blocks = [];
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
      }
      const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
        each_blocks[i2] = null;
      });
      const block = {
        c: function create2() {
          tr = element("tr");
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].c();
          }
          t2 = space();
          attr_dev(tr, "style", `background: ${ctx[37] % 2 ? "var(--table-body-odd-bg)" : "var(--table-body-even-bg)"};
									color: ${ctx[37] % 2 ? "var(--table-body-odd-color)" : "var(--table-body-even-color)"}`);
          add_location(tr, file10, 360, 11, 10090);
        },
        m: function mount(target, anchor) {
          insert_dev(target, tr, anchor);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].m(tr, null);
          }
          append_dev(tr, t2);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2053) {
            each_value_1 = Object.keys(ctx2[35]);
            validate_each_argument(each_value_1);
            let i2;
            for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
              const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
              if (each_blocks[i2]) {
                each_blocks[i2].p(child_ctx, dirty);
                transition_in(each_blocks[i2], 1);
              } else {
                each_blocks[i2] = create_each_block_1(child_ctx);
                each_blocks[i2].c();
                transition_in(each_blocks[i2], 1);
                each_blocks[i2].m(tr, t2);
              }
            }
            group_outros();
            for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
              out(i2);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
            transition_in(each_blocks[i2]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            transition_out(each_blocks[i2]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(tr);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_53.name,
        type: "if",
        source: "(360:10) {#if i < pageLength * currentPage && i >= pageLength * (currentPage - 1)}",
        ctx
      });
      return block;
    }
    function create_if_block_62(ctx) {
      let td;
      let show_if;
      let current_block_type_index;
      let if_block;
      let current;
      function func6(...args) {
        return ctx[17](ctx[38], ...args);
      }
      const if_block_creators = [create_if_block_72, create_else_block4];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (dirty[0] & 1)
          show_if = !!ctx2[11].find(func6);
        if (show_if)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx, [-1, -1]);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          td = element("td");
          if_block.c();
          attr_dev(td, "class", "whitespace-nowrap");
          add_location(td, file10, 375, 14, 10562);
        },
        m: function mount(target, anchor) {
          insert_dev(target, td, anchor);
          if_blocks[current_block_type_index].m(td, null);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx, dirty);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(td, null);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(td);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_62.name,
        type: "if",
        source: "(375:13) {#if tableWhitelist.includes(field)}",
        ctx
      });
      return block;
    }
    function create_else_block4(ctx) {
      let t_value = ctx[35][ctx[38]] + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1 && t_value !== (t_value = ctx2[35][ctx2[38]] + ""))
            set_data_dev(t2, t_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block4.name,
        type: "else",
        source: "(398:15) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_72(ctx) {
      let show_if = ctx[11].find(func_14).type == "number";
      let if_block_anchor;
      let current;
      function func_14(...args) {
        return ctx[18](ctx[38], ...args);
      }
      let if_block = show_if && create_if_block_82(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 1)
            show_if = ctx[11].find(func_14).type == "number";
          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty[0] & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_82(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_72.name,
        type: "if",
        source: "(381:15) {#if dataTypes.find((item) => item.key === field)}",
        ctx
      });
      return block;
    }
    function create_if_block_82(ctx) {
      let textfield;
      let updating_value;
      let current;
      function textfield_value_binding(value) {
        ctx[22](value, ctx[35], ctx[38]);
      }
      let textfield_props = {
        class: "shaped-outlined",
        variant: "outlined",
        type: "number"
      };
      if (ctx[35][ctx[38]] !== void 0) {
        textfield_props.value = ctx[35][ctx[38]];
      }
      textfield = new Textfield({props: textfield_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield, "value", textfield_value_binding));
      const block = {
        c: function create2() {
          create_component(textfield.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(textfield, target, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          const textfield_changes = {};
          if (!updating_value && dirty[0] & 1) {
            updating_value = true;
            textfield_changes.value = ctx[35][ctx[38]];
            add_flush_callback(() => updating_value = false);
          }
          textfield.$set(textfield_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(textfield, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_82.name,
        type: "if",
        source: '(382:16) {#if dataTypes.find((item) => item.key === field).type == \\"number\\"}',
        ctx
      });
      return block;
    }
    function create_each_block_1(ctx) {
      let show_if = ctx[2].includes(ctx[38]);
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block_62(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 5)
            show_if = ctx2[2].includes(ctx2[38]);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 5) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_62(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(373:12) {#each Object.keys(item) as field}",
        ctx
      });
      return block;
    }
    function create_each_block3(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[37] < ctx[9] * ctx[7] && ctx[37] >= ctx[9] * (ctx[7] - 1) && create_if_block_53(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[37] < ctx2[9] * ctx2[7] && ctx2[37] >= ctx2[9] * (ctx2[7] - 1)) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 640) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_53(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block3.name,
        type: "each",
        source: "(358:9) {#each data.body as item, i}",
        ctx
      });
      return block;
    }
    function create_default_slot_23(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("Bestellung abschliessen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_23.name,
        type: "slot",
        source: "(433:9) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_23]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: `(427:8) <Button          on:click={() => order(\\"xlsx\\", data.body)}          variant=\\"raised\\"          style=\\"background: {'var(--mdc-theme-callout)'}\\"          class=\\"whitespace-nowrap\\"         >`,
        ctx
      });
      return block;
    }
    function create_default_slot_21(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("arrow_drop_down");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_21.name,
        type: "slot",
        source: '(441:10) <Icon            class=\\"material-icons\\"            style=\\"margin: 0;\\"            >',
        ctx
      });
      return block;
    }
    function create_default_slot_20(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          class: "material-icons",
          style: "margin: 0;",
          $$slots: {default: [create_default_slot_21]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const icon_changes = {};
          if (dirty[1] & 16384) {
            icon_changes.$$scope = {dirty, ctx: ctx2};
          }
          icon.$set(icon_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_20.name,
        type: "slot",
        source: `(436:9) <Button           on:click={() => orderMenu.setOpen(true)}           variant=\\"raised\\"           style=\\"padding: 0; min-width: 36px; background: {'var(--mdc-theme-callout)'}\\"          >`,
        ctx
      });
      return block;
    }
    function create_default_slot_19(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("excel");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_19.name,
        type: "slot",
        source: "(456:12) <Text>",
        ctx
      });
      return block;
    }
    function create_default_slot_18(ctx) {
      let text_1;
      let current;
      text_1 = new Text({
        props: {
          $$slots: {default: [create_default_slot_19]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(text_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(text_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const text_1_changes = {};
          if (dirty[1] & 16384) {
            text_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          text_1.$set(text_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(text_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(text_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(text_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_18.name,
        type: "slot",
        source: '(452:11) <Item             on:SMUI:action={() =>              order(\\"xlsx\\", data.body)}            >',
        ctx
      });
      return block;
    }
    function create_default_slot_17(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("csv");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_17.name,
        type: "slot",
        source: "(462:12) <Text>",
        ctx
      });
      return block;
    }
    function create_default_slot_16(ctx) {
      let text_1;
      let current;
      text_1 = new Text({
        props: {
          $$slots: {default: [create_default_slot_17]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(text_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(text_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const text_1_changes = {};
          if (dirty[1] & 16384) {
            text_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          text_1.$set(text_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(text_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(text_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(text_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_16.name,
        type: "slot",
        source: '(458:11) <Item             on:SMUI:action={() =>              order(\\"csv\\", data.body)}            >',
        ctx
      });
      return block;
    }
    function create_default_slot_15(ctx) {
      let item0;
      let t2;
      let item1;
      let current;
      item0 = new Item({
        props: {
          $$slots: {default: [create_default_slot_18]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      item0.$on("SMUI:action", ctx[26]);
      item1 = new Item({
        props: {
          $$slots: {default: [create_default_slot_16]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      item1.$on("SMUI:action", ctx[27]);
      const block = {
        c: function create2() {
          create_component(item0.$$.fragment);
          t2 = space();
          create_component(item1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(item0, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(item1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const item0_changes = {};
          if (dirty[1] & 16384) {
            item0_changes.$$scope = {dirty, ctx: ctx2};
          }
          item0.$set(item0_changes);
          const item1_changes = {};
          if (dirty[1] & 16384) {
            item1_changes.$$scope = {dirty, ctx: ctx2};
          }
          item1.$set(item1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(item0.$$.fragment, local);
          transition_in(item1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(item0.$$.fragment, local);
          transition_out(item1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(item0, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(item1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_15.name,
        type: "slot",
        source: "(451:10) <List>",
        ctx
      });
      return block;
    }
    function create_default_slot_14(ctx) {
      let list;
      let current;
      list = new List({
        props: {
          $$slots: {default: [create_default_slot_15]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(list.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_changes = {};
          if (dirty[0] & 1 | dirty[1] & 16384) {
            list_changes.$$scope = {dirty, ctx: ctx2};
          }
          list.$set(list_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_14.name,
        type: "slot",
        source: '(447:9) <Menu           bind:this={orderMenu}           anchorCorner=\\"TOP_LEFT\\"          >',
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let button0;
      let t0;
      let div;
      let button1;
      let t1;
      let menu;
      let current;
      let mounted;
      let dispose;
      button0 = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          class: "whitespace-nowrap",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button0.$on("click", ctx[24]);
      button1 = new Button_1({
        props: {
          variant: "raised",
          style: "padding: 0; min-width: 36px; background: var(--mdc-theme-callout)",
          $$slots: {default: [create_default_slot_20]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button1.$on("click", ctx[25]);
      let menu_props = {
        anchorCorner: "TOP_LEFT",
        $$slots: {default: [create_default_slot_14]},
        $$scope: {ctx}
      };
      menu = new Menu({props: menu_props, $$inline: true});
      ctx[28](menu);
      const block = {
        c: function create2() {
          create_component(button0.$$.fragment);
          t0 = space();
          div = element("div");
          create_component(button1.$$.fragment);
          t1 = space();
          create_component(menu.$$.fragment);
          add_location(div, file10, 434, 8, 12346);
        },
        m: function mount(target, anchor) {
          mount_component(button0, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          mount_component(button1, div, null);
          append_dev(div, t1);
          mount_component(menu, div, null);
          current = true;
          if (!mounted) {
            dispose = action_destroyer(GroupItem.call(null, div));
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          const button0_changes = {};
          if (dirty[1] & 16384) {
            button0_changes.$$scope = {dirty, ctx: ctx2};
          }
          button0.$set(button0_changes);
          const button1_changes = {};
          if (dirty[1] & 16384) {
            button1_changes.$$scope = {dirty, ctx: ctx2};
          }
          button1.$set(button1_changes);
          const menu_changes = {};
          if (dirty[0] & 1 | dirty[1] & 16384) {
            menu_changes.$$scope = {dirty, ctx: ctx2};
          }
          menu.$set(menu_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(menu.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(menu.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button0, detaching);
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(div);
          destroy_component(button1);
          ctx[28](null);
          destroy_component(menu);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(426:7) <Group>",
        ctx
      });
      return block;
    }
    function create_if_block_43(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[29]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_43.name,
        type: "if",
        source: "(471:9) {#if currentPage > 1}",
        ctx
      });
      return block;
    }
    function create_default_slot_122(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "arrow_back_ios_new";
          attr_dev(span, "class", "material-icons text-sm");
          add_location(span, file10, 476, 13, 13444);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: "(476:11) <Label             >",
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: '(472:10) <Button            on:click={() => currentPage--}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_if_block_33(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[30]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_33.name,
        type: "if",
        source: "(485:9) {#if currentPage - 1 > 0}",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let t_value = ctx[7] - 1 + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128 && t_value !== (t_value = ctx2[7] - 1 + ""))
            set_data_dev(t2, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: "(491:11) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: '(486:10) <Button            on:click={() =>             (currentPage = currentPage - 1)}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text(ctx[7]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128)
            set_data_dev(t2, ctx2[7]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(499:10) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(495:9) <Button           on:click={() => {}}           variant=\\"raised\\"          >',
        ctx
      });
      return block;
    }
    function create_if_block_24(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[31]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_24.name,
        type: "if",
        source: "(501:9) {#if currentPage + 1 <= Math.floor(data.body.length / pageLength) + 1}",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t_value = ctx[7] + 1 + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128 && t_value !== (t_value = ctx2[7] + 1 + ""))
            set_data_dev(t2, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: "(508:11) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: '(502:10) <Button            on:click={() => {             currentPage = currentPage + 1;            }}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_if_block_14(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[32]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_14.name,
        type: "if",
        source: "(511:9) {#if data.body.length > pageLength * currentPage}",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "arrow_forward_ios";
          attr_dev(span, "class", "material-icons p-0 text-sm flex justify-center item");
          add_location(span, file10, 517, 13, 14513);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(517:11) <Label             >",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_42]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: '(511:58) <Button            on:click={() => {             currentPage++;            }}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_default_slot_25(ctx) {
      let t0;
      let t1;
      let button;
      let t2;
      let show_if = ctx[7] + 1 <= Math.floor(ctx[0].body.length / ctx[9]) + 1;
      let t3;
      let if_block3_anchor;
      let current;
      let if_block0 = ctx[7] > 1 && create_if_block_43(ctx);
      let if_block1 = ctx[7] - 1 > 0 && create_if_block_33(ctx);
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", click_handler_5);
      let if_block2 = show_if && create_if_block_24(ctx);
      let if_block3 = ctx[0].body.length > ctx[9] * ctx[7] && create_if_block_14(ctx);
      const block = {
        c: function create2() {
          if (if_block0)
            if_block0.c();
          t0 = space();
          if (if_block1)
            if_block1.c();
          t1 = space();
          create_component(button.$$.fragment);
          t2 = space();
          if (if_block2)
            if_block2.c();
          t3 = space();
          if (if_block3)
            if_block3.c();
          if_block3_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(button, target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block2)
            if_block2.m(target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block3)
            if_block3.m(target, anchor);
          insert_dev(target, if_block3_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[7] > 1) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_43(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (ctx2[7] - 1 > 0) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_33(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t1.parentNode, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
          if (dirty[0] & 641)
            show_if = ctx2[7] + 1 <= Math.floor(ctx2[0].body.length / ctx2[9]) + 1;
          if (show_if) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & 641) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_24(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t3.parentNode, t3);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (ctx2[0].body.length > ctx2[9] * ctx2[7]) {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & 641) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_14(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(button.$$.fragment, local);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(button.$$.fragment, local);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t0);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(button, detaching);
          if (detaching)
            detach_dev(t2);
          if (if_block2)
            if_block2.d(detaching);
          if (detaching)
            detach_dev(t3);
          if (if_block3)
            if_block3.d(detaching);
          if (detaching)
            detach_dev(if_block3_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_25.name,
        type: "slot",
        source: '(470:8) <Group variant=\\"raised\\">',
        ctx
      });
      return block;
    }
    function create_pending_block(ctx) {
      let div;
      let span;
      let t1;
      const block = {
        c: function create2() {
          div = element("div");
          span = element("span");
          span.textContent = "autorenew";
          t1 = text(" Loading");
          attr_dev(span, "class", "material-icons animate-spin");
          add_location(span, file10, 288, 6, 7866);
          attr_dev(div, "class", "w-full flex flex-col justify-center items-center h-96");
          add_location(div, file10, 285, 5, 7780);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_pending_block.name,
        type: "pending",
        source: '(284:24)       <!-- on load -->      <div       class=\\"w-full flex flex-col justify-center items-center h-96\\"      >       <span class=\\"material-icons animate-spin\\">        autorenew       </span> Loading      </div>     {:then returnVal}',
        ctx
      });
      return block;
    }
    function create_default_slot_110(ctx) {
      let div;
      let input;
      let t2;
      let promise2;
      let current;
      let mounted;
      let dispose;
      let info = {
        ctx,
        current: null,
        token: null,
        hasCatch: true,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        value: 34,
        error: 44,
        blocks: [, , ,]
      };
      handle_promise(promise2 = ctx[6], info);
      const block = {
        c: function create2() {
          div = element("div");
          input = element("input");
          t2 = space();
          info.block.c();
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "Suche...");
          attr_dev(input, "class", "p-2 rounded-md w-full");
          add_location(input, file10, 276, 4, 7570);
          attr_dev(div, "class", "flex flex-col gap-4 w-full");
          add_location(div, file10, 275, 3, 7525);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input);
          set_input_value(input, ctx[1]);
          append_dev(div, t2);
          info.block.m(div, info.anchor = null);
          info.mount = () => div;
          info.anchor = null;
          current = true;
          if (!mounted) {
            dispose = listen_dev(input, "input", ctx[19]);
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 2 && input.value !== ctx[1]) {
            set_input_value(input, ctx[1]);
          }
          info.ctx = ctx;
          if (dirty[0] & 64 && promise2 !== (promise2 = ctx[6]) && handle_promise(promise2, info))
            ;
          else {
            update_await_block_branch(info, ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(info.block);
          current = true;
        },
        o: function outro(local) {
          for (let i2 = 0; i2 < 3; i2 += 1) {
            const block2 = info.blocks[i2];
            transition_out(block2);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          info.block.d();
          info.token = null;
          info = null;
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_110.name,
        type: "slot",
        source: "(275:2) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let title;
      let t2;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_24]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_110]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t2 = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty[1] & 16384) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty[0] & 1023 | dirty[1] & 16384) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: "(273:1) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let section_1;
      let paper;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section_1 = element("section");
          create_component(paper.$$.fragment);
          attr_dev(section_1, "class", "flex flex-col gap-4 md:w-10/12 w-full mx-auto");
          add_location(section_1, file10, 271, 0, 7352);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section_1, anchor);
          mount_component(paper, section_1, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const paper_changes = {};
          if (dirty[0] & 1023 | dirty[1] & 16384) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section_1);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var click_handler_5 = () => {
    };
    function instance7($$self, $$props, $$invalidate) {
      let pageLength;
      let sort;
      let $userSettings;
      let $user;
      let $redirect;
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(15, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(16, $user = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(33, $redirect = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Pages", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      let data = {body: [], head: []};
      let orderMenu;
      let searchInputText;
      let tableWhitelist = ["id", "product"];
      let labels = [
        {key: "id", text: "ID"},
        {key: "product", text: "Produkt"},
        {
          key: "tomorrow_order_range",
          text: "Vorschlag Morgen"
        },
        {
          key: "tomorrow_order_qty",
          text: "Bestellung Morgen"
        },
        {
          key: "day_after_order_range",
          text: "Vorschlag \xDCbermorgen"
        },
        {
          key: "day_after_order_qty",
          text: "Bestellung \xDCbermorgen"
        },
        {
          key: "next7_order_range",
          text: "Vorschlag Woche"
        },
        {
          key: "next7_order_qty",
          text: "Bestellung Woche"
        }
      ];
      let dataTypes = [
        {
          key: "day_after_order_qty",
          type: "number"
        },
        {
          key: "tomorrow_order_qty",
          type: "number"
        },
        {key: "next7_order_qty", type: "number"}
      ];
      let dataPromise = new Promise(() => {
      });
      let sortBy = {col: "id", ascending: true};
      let currentPage = 1;
      let section;
      async function order(option, data2) {
        let orderUrl = `${backendURL}/api/order`;
        let resType;
        let filename = `Foodsight_Bestellung.${option}`;
        if (option === "xlsx") {
          resType = "arraybuffer";
        } else if (option === "csv") {
          resType = "text";
        }
        let orderOption;
        if ($userSettings?.tomorrow) {
          orderOption = "tomorrow";
        } else if ($userSettings?.day_after_tomorrow) {
          orderOption = "day_after_tomorrow";
        } else if ($userSettings?.next_seven_days) {
          orderOption = "next_seven_days";
        }
        axios({
          url: orderUrl,
          method: "POST",
          responseType: resType,
          data: {option, order_option: orderOption, data: data2}
        }).then((response) => {
          const url2 = window.URL.createObjectURL(new Blob([response.data]));
          const link = document.createElement("a");
          link.href = url2;
          link.setAttribute("download", filename);
          document.body.appendChild(link);
          link.click();
        });
      }
      function dataChanger(node, returnVal) {
        $$invalidate(0, data = returnVal);
      }
      function autoCache(node, data2) {
        return {
          update(data3) {
            if (!Object.keys($userSettings))
              return;
            let dataUrl;
            if ($user && Object.keys($user).length) {
              dataUrl = `${backendURL}/api/forecast/?store=${$userSettings.store}`;
            }
            localStorage.setItem(dataUrl, JSON.stringify({user: $user, data: data3}));
          }
        };
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console_12.warn(`<Pages> was created with unknown prop '${key}'`);
      });
      const func6 = (field, item) => item.key === field;
      const func_14 = (field, item) => item.key === field;
      function input_input_handler() {
        searchInputText = this.value;
        $$invalidate(1, searchInputText);
      }
      const func_22 = (col, item) => item.key === col;
      const click_handler = (col) => {
        $$invalidate(0, data.body = sort(data.body, col), data);
      };
      function textfield_value_binding(value, item, field) {
        if ($$self.$$.not_equal(item[field], value)) {
          item[field] = value;
          $$invalidate(0, data);
        }
      }
      function section_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          section = $$value;
          $$invalidate(8, section);
        });
      }
      const click_handler_1 = () => order("xlsx", data.body);
      const click_handler_2 = () => orderMenu.setOpen(true);
      const SMUI_action_handler = () => order("xlsx", data.body);
      const SMUI_action_handler_1 = () => order("csv", data.body);
      function menu_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          orderMenu = $$value;
          $$invalidate(5, orderMenu);
        });
      }
      const click_handler_3 = () => $$invalidate(7, currentPage--, currentPage);
      const click_handler_4 = () => $$invalidate(7, currentPage = currentPage - 1);
      const click_handler_6 = () => {
        $$invalidate(7, currentPage = currentPage + 1);
      };
      const click_handler_7 = () => {
        $$invalidate(7, currentPage++, currentPage);
      };
      $$self.$capture_state = () => ({
        axios,
        Paper,
        Title,
        Content,
        user,
        userSettings,
        backendURL,
        Menu,
        Button: Button_1,
        Group,
        GroupItem,
        Label: CommonLabel,
        Icon: CommonIcon,
        List,
        Item,
        Text,
        search,
        blur,
        fade,
        Textfield,
        redirect,
        onMount,
        data,
        orderMenu,
        searchInputText,
        tableWhitelist,
        labels,
        dataTypes,
        dataPromise,
        sortBy,
        currentPage,
        section,
        order,
        dataChanger,
        autoCache,
        sort,
        pageLength,
        $userSettings,
        $user,
        $redirect
      });
      $$self.$inject_state = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(0, data = $$props2.data);
        if ("orderMenu" in $$props2)
          $$invalidate(5, orderMenu = $$props2.orderMenu);
        if ("searchInputText" in $$props2)
          $$invalidate(1, searchInputText = $$props2.searchInputText);
        if ("tableWhitelist" in $$props2)
          $$invalidate(2, tableWhitelist = $$props2.tableWhitelist);
        if ("labels" in $$props2)
          $$invalidate(10, labels = $$props2.labels);
        if ("dataTypes" in $$props2)
          $$invalidate(11, dataTypes = $$props2.dataTypes);
        if ("dataPromise" in $$props2)
          $$invalidate(6, dataPromise = $$props2.dataPromise);
        if ("sortBy" in $$props2)
          $$invalidate(3, sortBy = $$props2.sortBy);
        if ("currentPage" in $$props2)
          $$invalidate(7, currentPage = $$props2.currentPage);
        if ("section" in $$props2)
          $$invalidate(8, section = $$props2.section);
        if ("sort" in $$props2)
          $$invalidate(4, sort = $$props2.sort);
        if ("pageLength" in $$props2)
          $$invalidate(9, pageLength = $$props2.pageLength);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 32768) {
          $$invalidate(9, pageLength = $userSettings?.rows_per_page || 10);
        }
        if ($$self.$$.dirty[0] & 98306) {
          $$invalidate(6, dataPromise = new Promise(async (res, rej) => {
            if (!$userSettings || !Object.keys($userSettings).length || !$userSettings.store) {
              rej("userSettings Not Defined");
              return;
            }
            let dataUrl;
            let keys = [];
            try {
              if ($user && Object.keys($user).length) {
                dataUrl = `${backendURL}/api/forecast/?store=${$userSettings.store}`;
              } else {
                dataUrl = `tableDataStore${$userSettings.store}.json`;
              }
              let result;
              if (localStorage.getItem(dataUrl) && JSON.stringify(JSON.parse(localStorage.getItem(dataUrl)).user) === JSON.stringify($user) && new Date(JSON.parse(localStorage.getItem(dataUrl)).data.timestamp).getUTCDate() === new Date().getUTCDate()) {
                let searchedData = search(JSON.parse(localStorage.getItem(dataUrl)).data.body, ["id", "product"], searchInputText);
                res({
                  body: searchedData,
                  head: JSON.parse(localStorage.getItem(dataUrl)).data.head,
                  timestamp: JSON.parse(localStorage.getItem(dataUrl)).data.timestamp
                });
              } else {
                result = await axios.get(dataUrl);
                result.data.forEach((val) => {
                  Object.keys(val).forEach((ob) => {
                    if (!keys.includes(ob)) {
                      keys.push(ob);
                    }
                  });
                });
                localStorage.setItem(dataUrl, JSON.stringify({
                  user: $user,
                  data: {
                    body: result.data,
                    head: keys,
                    timestamp: Date.now()
                  }
                }));
                let cachedStores = JSON.parse(localStorage.getItem("cachedStores")) || [];
                localStorage.setItem("cachedStores", JSON.stringify([...cachedStores, dataUrl]));
                let searchedData = search(result.data, ["id", "product"], searchInputText);
                res({
                  body: searchedData,
                  head: keys,
                  timestamp: Date.now()
                });
              }
            } catch (er) {
              console.log(er);
            }
          }));
        }
        if ($$self.$$.dirty[0] & 65536) {
          {
            let cachedStores = JSON.parse(localStorage.getItem("cachedStores")) || [];
            if (cachedStores.length) {
              cachedStores.forEach((key) => {
                let item = JSON.parse(localStorage.getItem(key));
                if (JSON.stringify(item?.user) != JSON.stringify($user)) {
                  localStorage.removeItem(key);
                  cachedStores = cachedStores.filter((item2) => {
                    return item2 != key;
                  });
                }
              });
              localStorage.setItem("cachedStores", JSON.stringify([...new Set(cachedStores)]));
            }
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.next_seven_days) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "next7_order_range", "next7_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["next7_order_range", "next7_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.day_after_tomorrow) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "day_after_order_range", "day_after_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["day_after_order_range", "day_after_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.tomorrow) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "tomorrow_order_range", "tomorrow_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["tomorrow_order_range", "tomorrow_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 8) {
          $$invalidate(4, sort = (data2, column) => {
            if (sortBy.col == column) {
              $$invalidate(3, sortBy.ascending = !sortBy.ascending, sortBy);
            } else {
              $$invalidate(3, sortBy.col = column, sortBy);
              $$invalidate(3, sortBy.ascending = true, sortBy);
            }
            let sortModifier = sortBy.ascending ? 1 : -1;
            let sort2 = (a2, b2) => a2[column] < b2[column] ? -1 * sortModifier : a2[column] > b2[column] ? 1 * sortModifier : 0;
            return data2.sort(sort2);
          });
        }
      };
      return [
        data,
        searchInputText,
        tableWhitelist,
        sortBy,
        sort,
        orderMenu,
        dataPromise,
        currentPage,
        section,
        pageLength,
        labels,
        dataTypes,
        order,
        dataChanger,
        autoCache,
        $userSettings,
        $user,
        func6,
        func_14,
        input_input_handler,
        func_22,
        click_handler,
        textfield_value_binding,
        section_1_binding,
        click_handler_1,
        click_handler_2,
        SMUI_action_handler,
        SMUI_action_handler_1,
        menu_binding,
        click_handler_3,
        click_handler_4,
        click_handler_6,
        click_handler_7
      ];
    }
    var Pages = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {}, add_css2, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Pages",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/settings.js
  var require_settings = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Settings
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var file$43 = "node_modules/@smui/common/Hr.svelte";
    function create_fragment$64(ctx) {
      let hr;
      let useActions_action;
      let t;
      let current;
      let mounted;
      let dispose;
      let hr_levels = [ctx[3]];
      let hr_data = {};
      for (let i = 0; i < hr_levels.length; i += 1) {
        hr_data = assign(hr_data, hr_levels[i]);
      }
      const default_slot_template = ctx[6].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
      const block = {
        c: function create2() {
          hr = element("hr");
          t = space();
          if (default_slot)
            default_slot.c();
          set_attributes(hr, hr_data);
          add_location(hr, file$43, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, hr, anchor);
          ctx[7](hr);
          insert_dev(target, t, anchor);
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, hr, ctx[0])),
              action_destroyer(ctx[2].call(null, hr))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          set_attributes(hr, hr_data = get_spread_update(hr_levels, [dirty & 8 && ctx2[3]]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 32)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(hr);
          ctx[7](null);
          if (detaching)
            detach_dev(t);
          if (default_slot)
            default_slot.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$64.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$35($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Hr", slots, ["default"]);
      let {use: use2 = []} = $$props;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let element2 = null;
      function getElement() {
        return element2;
      }
      function hr_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(1, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("$$scope" in $$new_props)
          $$invalidate(5, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder,
        useActions,
        use: use2,
        forwardEvents,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("element" in $$props)
          $$invalidate(1, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        hr_binding
      ];
    }
    var Hr = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$35, create_fragment$64, safe_not_equal, {use: 0, getElement: 4});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Hr",
          options,
          id: create_fragment$64.name
        });
      }
      get use() {
        throw new Error("<Hr>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Hr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[4];
      }
      set getElement(value) {
        throw new Error("<Hr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function create_fragment$54(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
        {
          use: [ctx[9], ...ctx[0]]
        },
        {
          class: classMap({
            [ctx[1]]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": ctx[2],
            "mdc-deprecated-list-divider--inset": ctx[3],
            "mdc-deprecated-list-divider--inset-leading": ctx[4],
            "mdc-deprecated-list-divider--inset-trailing": ctx[5],
            "mdc-deprecated-list-divider--inset-padding": ctx[6]
          })
        },
        {role: "separator"},
        ctx[10]
      ];
      var switch_value = ctx[7];
      function switch_props(ctx2) {
        let switch_instance_props = {};
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }
        return {
          props: switch_instance_props,
          $$inline: true
        };
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props());
        ctx[12](switch_instance);
      }
      const block = {
        c: function create2() {
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }
          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const switch_instance_changes = dirty & 1663 ? get_spread_update(switch_instance_spread_levels, [
            dirty & 513 && {
              use: [ctx2[9], ...ctx2[0]]
            },
            dirty & 126 && {
              class: classMap({
                [ctx2[1]]: true,
                "mdc-deprecated-list-divider": true,
                "mdc-deprecated-list-divider--padded": ctx2[2],
                "mdc-deprecated-list-divider--inset": ctx2[3],
                "mdc-deprecated-list-divider--inset-leading": ctx2[4],
                "mdc-deprecated-list-divider--inset-trailing": ctx2[5],
                "mdc-deprecated-list-divider--inset-padding": ctx2[6]
              })
            },
            switch_instance_spread_levels[2],
            dirty & 1024 && get_spread_object(ctx2[10])
          ]) : {};
          if (switch_value !== (switch_value = ctx2[7])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              ctx2[12](switch_instance);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[12](null);
          if (detaching)
            detach_dev(switch_instance_anchor);
          if (switch_instance)
            destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$54.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "padded",
        "inset",
        "insetLeading",
        "insetTrailing",
        "insetPadding",
        "component",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Separator", slots, []);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {padded = false} = $$props;
      let {inset = false} = $$props;
      let {insetLeading = false} = $$props;
      let {insetTrailing = false} = $$props;
      let {insetPadding = false} = $$props;
      let element2;
      let nav = getContext("SMUI:list:item:nav");
      let context = getContext("SMUI:separator:context");
      let {component = nav || context !== "list" ? Hr : Li} = $$props;
      function getElement() {
        return element2.getElement();
      }
      function switch_instance_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(8, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("padded" in $$new_props)
          $$invalidate(2, padded = $$new_props.padded);
        if ("inset" in $$new_props)
          $$invalidate(3, inset = $$new_props.inset);
        if ("insetLeading" in $$new_props)
          $$invalidate(4, insetLeading = $$new_props.insetLeading);
        if ("insetTrailing" in $$new_props)
          $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
        if ("insetPadding" in $$new_props)
          $$invalidate(6, insetPadding = $$new_props.insetPadding);
        if ("component" in $$new_props)
          $$invalidate(7, component = $$new_props.component);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        Li,
        Hr,
        forwardEvents,
        use: use2,
        className,
        padded,
        inset,
        insetLeading,
        insetTrailing,
        insetPadding,
        element: element2,
        nav,
        context,
        component,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("padded" in $$props)
          $$invalidate(2, padded = $$new_props.padded);
        if ("inset" in $$props)
          $$invalidate(3, inset = $$new_props.inset);
        if ("insetLeading" in $$props)
          $$invalidate(4, insetLeading = $$new_props.insetLeading);
        if ("insetTrailing" in $$props)
          $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
        if ("insetPadding" in $$props)
          $$invalidate(6, insetPadding = $$new_props.insetPadding);
        if ("element" in $$props)
          $$invalidate(8, element2 = $$new_props.element);
        if ("nav" in $$props)
          nav = $$new_props.nav;
        if ("context" in $$props)
          context = $$new_props.context;
        if ("component" in $$props)
          $$invalidate(7, component = $$new_props.component);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        padded,
        inset,
        insetLeading,
        insetTrailing,
        insetPadding,
        component,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        switch_instance_binding
      ];
    }
    var Separator = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$54, safe_not_equal, {
          use: 0,
          class: 1,
          padded: 2,
          inset: 3,
          insetLeading: 4,
          insetTrailing: 5,
          insetPadding: 6,
          component: 7,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Separator",
          options,
          id: create_fragment$54.name
        });
      }
      get use() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get padded() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set padded(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get inset() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set inset(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetLeading() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetLeading(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetTrailing() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetTrailing(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetPadding() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetPadding(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get component() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set component(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$23 = {
      CHECKED: "mdc-switch--checked",
      DISABLED: "mdc-switch--disabled"
    };
    var strings$22 = {
      ARIA_CHECKED_ATTR: "aria-checked",
      NATIVE_CONTROL_SELECTOR: ".mdc-switch__native-control",
      RIPPLE_SURFACE_SELECTOR: ".mdc-switch__thumb-underlay"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSwitchFoundation = function(_super) {
      __extends(MDCSwitchFoundation2, _super);
      function MDCSwitchFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSwitchFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCSwitchFoundation2, "strings", {
        get: function() {
          return strings$22;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSwitchFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$23;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSwitchFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            setNativeControlChecked: function() {
              return void 0;
            },
            setNativeControlDisabled: function() {
              return void 0;
            },
            setNativeControlAttr: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSwitchFoundation2.prototype.setChecked = function(checked) {
        this.adapter.setNativeControlChecked(checked);
        this.updateAriaChecked_(checked);
        this.updateCheckedStyling_(checked);
      };
      MDCSwitchFoundation2.prototype.setDisabled = function(disabled) {
        this.adapter.setNativeControlDisabled(disabled);
        if (disabled) {
          this.adapter.addClass(cssClasses$23.DISABLED);
        } else {
          this.adapter.removeClass(cssClasses$23.DISABLED);
        }
      };
      MDCSwitchFoundation2.prototype.handleChange = function(evt) {
        var nativeControl = evt.target;
        this.updateAriaChecked_(nativeControl.checked);
        this.updateCheckedStyling_(nativeControl.checked);
      };
      MDCSwitchFoundation2.prototype.updateCheckedStyling_ = function(checked) {
        if (checked) {
          this.adapter.addClass(cssClasses$23.CHECKED);
        } else {
          this.adapter.removeClass(cssClasses$23.CHECKED);
        }
      };
      MDCSwitchFoundation2.prototype.updateAriaChecked_ = function(checked) {
        this.adapter.setNativeControlAttr(strings$22.ARIA_CHECKED_ATTR, "" + !!checked);
      };
      return MDCSwitchFoundation2;
    }(MDCFoundation);
    var file$33 = "node_modules/@smui/switch/Switch.svelte";
    function create_fragment$44(ctx) {
      let div3;
      let div0;
      let t0;
      let div2;
      let div1;
      let t1;
      let input;
      let input_class_value;
      let input_aria_checked_value;
      let input_value_value;
      let useActions_action;
      let div2_class_value;
      let Ripple_action;
      let div3_class_value;
      let useActions_action_1;
      let mounted;
      let dispose;
      let input_levels = [
        {
          class: input_class_value = classMap({
            [ctx[7]]: true,
            "mdc-switch__native-control": true
          })
        },
        {type: "checkbox"},
        {role: "switch"},
        ctx[17],
        {disabled: ctx[0]},
        {
          "aria-checked": input_aria_checked_value = ctx[8] ? "true" : "false"
        },
        {
          __value: input_value_value = ctx[5] === ctx[16] ? ctx[4] : ctx[5]
        },
        ctx[13],
        prefixFilter2(ctx[20], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      let div3_levels = [
        {
          class: div3_class_value = classMap({
            [ctx[2]]: true,
            "mdc-switch": true,
            "mdc-switch--disabled": ctx[0],
            "mdc-switch--checked": ctx[8],
            "smui-switch--color-primary": ctx[3] === "primary",
            ...ctx[11]
          })
        },
        exclude2(ctx[20], ["input$"])
      ];
      let div3_data = {};
      for (let i = 0; i < div3_levels.length; i += 1) {
        div3_data = assign(div3_data, div3_levels[i]);
      }
      const block = {
        c: function create2() {
          div3 = element("div");
          div0 = element("div");
          t0 = space();
          div2 = element("div");
          div1 = element("div");
          t1 = space();
          input = element("input");
          attr_dev(div0, "class", "mdc-switch__track");
          add_location(div0, file$33, 14, 2, 346);
          attr_dev(div1, "class", "mdc-switch__thumb");
          add_location(div1, file$33, 30, 4, 761);
          set_attributes(input, input_data);
          add_location(input, file$33, 31, 4, 799);
          attr_dev(div2, "class", div2_class_value = classMap({
            "mdc-switch__thumb-underlay": true,
            ...ctx[12]
          }));
          add_location(div2, file$33, 15, 2, 382);
          set_attributes(div3, div3_data);
          add_location(div3, file$33, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div3, t0);
          append_dev(div3, div2);
          append_dev(div2, div1);
          append_dev(div2, t1);
          append_dev(div2, input);
          if (input.autofocus)
            input.focus();
          ctx[31](input);
          input.checked = ctx[8];
          ctx[33](div3);
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, input, ctx[6])),
              listen_dev(input, "change", ctx[32]),
              listen_dev(input, "blur", ctx[29], false, false, false),
              listen_dev(input, "focus", ctx[30], false, false, false),
              action_destroyer(Ripple_action = Ripple.call(null, div2, {
                unbounded: true,
                color: ctx[3],
                active: ctx[14],
                addClass: ctx[18],
                removeClass: ctx[19],
                eventTarget: ctx[10]
              })),
              action_destroyer(useActions_action_1 = useActions.call(null, div3, ctx[1])),
              action_destroyer(ctx[15].call(null, div3))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            dirty[0] & 128 && input_class_value !== (input_class_value = classMap({
              [ctx2[7]]: true,
              "mdc-switch__native-control": true
            })) && {class: input_class_value},
            {type: "checkbox"},
            {role: "switch"},
            ctx2[17],
            dirty[0] & 1 && {disabled: ctx2[0]},
            dirty[0] & 256 && input_aria_checked_value !== (input_aria_checked_value = ctx2[8] ? "true" : "false") && {"aria-checked": input_aria_checked_value},
            dirty[0] & 48 && input_value_value !== (input_value_value = ctx2[5] === ctx2[16] ? ctx2[4] : ctx2[5]) && {__value: input_value_value},
            dirty[0] & 8192 && ctx2[13],
            dirty[0] & 1048576 && prefixFilter2(ctx2[20], "input$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 64)
            useActions_action.update.call(null, ctx2[6]);
          if (dirty[0] & 256) {
            input.checked = ctx2[8];
          }
          if (dirty[0] & 4096 && div2_class_value !== (div2_class_value = classMap({
            "mdc-switch__thumb-underlay": true,
            ...ctx2[12]
          }))) {
            attr_dev(div2, "class", div2_class_value);
          }
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 17416)
            Ripple_action.update.call(null, {
              unbounded: true,
              color: ctx2[3],
              active: ctx2[14],
              addClass: ctx2[18],
              removeClass: ctx2[19],
              eventTarget: ctx2[10]
            });
          set_attributes(div3, div3_data = get_spread_update(div3_levels, [
            dirty[0] & 2317 && div3_class_value !== (div3_class_value = classMap({
              [ctx2[2]]: true,
              "mdc-switch": true,
              "mdc-switch--disabled": ctx2[0],
              "mdc-switch--checked": ctx2[8],
              "smui-switch--color-primary": ctx2[3] === "primary",
              ...ctx2[11]
            })) && {class: div3_class_value},
            dirty[0] & 1048576 && exclude2(ctx2[20], ["input$"])
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 2)
            useActions_action_1.update.call(null, ctx2[1]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div3);
          ctx[31](null);
          ctx[33](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$44.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance_1$23($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "disabled",
        "color",
        "group",
        "checked",
        "value",
        "valueKey",
        "input$use",
        "input$class",
        "getId",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Switch", slots, []);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {disabled = false} = $$props;
      let {color = "secondary"} = $$props;
      let {group = uninitializedValue} = $$props;
      let {checked = uninitializedValue} = $$props;
      let {value = null} = $$props;
      let {valueKey = uninitializedValue} = $$props;
      let {input$use = []} = $$props;
      let {input$class = ""} = $$props;
      let element2;
      let instance8;
      let checkbox;
      let internalClasses = {};
      let thumbUnderlayClasses = {};
      let nativeControlAttrs = {};
      let rippleActive = false;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      let nativeChecked = group === uninitializedValue ? checked === uninitializedValue ? false : checked : group.indexOf(value) !== -1;
      let previousChecked = checked;
      let previousGroup = group === uninitializedValue ? [] : [...group];
      let previousNativeChecked = nativeChecked;
      onMount(() => {
        $$invalidate(25, instance8 = new MDCSwitchFoundation({
          addClass,
          removeClass,
          setNativeControlChecked: (checked2) => $$invalidate(8, nativeChecked = checked2),
          setNativeControlDisabled: (disabledValue) => $$invalidate(0, disabled = disabledValue),
          setNativeControlAttr: addNativeControlAttr
        }));
        const accessor = {
          get element() {
            return getElement();
          },
          get checked() {
            return nativeChecked;
          },
          set checked(checked2) {
            if (nativeChecked !== value) {
              $$invalidate(8, nativeChecked = value);
            }
          },
          activateRipple() {
            if (!disabled) {
              $$invalidate(14, rippleActive = true);
            }
          },
          deactivateRipple() {
            $$invalidate(14, rippleActive = false);
          }
        };
        dispatch(element2, "SMUI:generic:input:mount", accessor);
        instance8.init();
        return () => {
          dispatch(element2, "SMUI:generic:input:unmount", accessor);
          instance8.destroy();
        };
      });
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = false, internalClasses);
        }
      }
      function addThumbUnderlayClass(className2) {
        if (!thumbUnderlayClasses[className2]) {
          $$invalidate(12, thumbUnderlayClasses[className2] = true, thumbUnderlayClasses);
        }
      }
      function removeThumbUnderlayClass(className2) {
        if (!(className2 in thumbUnderlayClasses) || thumbUnderlayClasses[className2]) {
          $$invalidate(12, thumbUnderlayClasses[className2] = false, thumbUnderlayClasses);
        }
      }
      function addNativeControlAttr(name2, value2) {
        if (nativeControlAttrs[name2] !== value2) {
          $$invalidate(13, nativeControlAttrs[name2] = value2, nativeControlAttrs);
        }
      }
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element2;
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          checkbox = $$value;
          $$invalidate(10, checkbox);
        });
      }
      function input_change_handler() {
        nativeChecked = this.checked;
        $$invalidate(8, nativeChecked), $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance8);
      }
      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(9, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("disabled" in $$new_props)
          $$invalidate(0, disabled = $$new_props.disabled);
        if ("color" in $$new_props)
          $$invalidate(3, color = $$new_props.color);
        if ("group" in $$new_props)
          $$invalidate(21, group = $$new_props.group);
        if ("checked" in $$new_props)
          $$invalidate(22, checked = $$new_props.checked);
        if ("value" in $$new_props)
          $$invalidate(4, value = $$new_props.value);
        if ("valueKey" in $$new_props)
          $$invalidate(5, valueKey = $$new_props.valueKey);
        if ("input$use" in $$new_props)
          $$invalidate(6, input$use = $$new_props.input$use);
        if ("input$class" in $$new_props)
          $$invalidate(7, input$class = $$new_props.input$class);
      };
      $$self.$capture_state = () => ({
        MDCSwitchFoundation,
        onMount,
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        exclude: exclude2,
        prefixFilter: prefixFilter2,
        useActions,
        dispatch,
        Ripple,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        disabled,
        color,
        group,
        checked,
        value,
        valueKey,
        input$use,
        input$class,
        element: element2,
        instance: instance8,
        checkbox,
        internalClasses,
        thumbUnderlayClasses,
        nativeControlAttrs,
        rippleActive,
        inputProps,
        nativeChecked,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        addClass,
        removeClass,
        addThumbUnderlayClass,
        removeThumbUnderlayClass,
        addNativeControlAttr,
        getId,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(16, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("disabled" in $$props)
          $$invalidate(0, disabled = $$new_props.disabled);
        if ("color" in $$props)
          $$invalidate(3, color = $$new_props.color);
        if ("group" in $$props)
          $$invalidate(21, group = $$new_props.group);
        if ("checked" in $$props)
          $$invalidate(22, checked = $$new_props.checked);
        if ("value" in $$props)
          $$invalidate(4, value = $$new_props.value);
        if ("valueKey" in $$props)
          $$invalidate(5, valueKey = $$new_props.valueKey);
        if ("input$use" in $$props)
          $$invalidate(6, input$use = $$new_props.input$use);
        if ("input$class" in $$props)
          $$invalidate(7, input$class = $$new_props.input$class);
        if ("element" in $$props)
          $$invalidate(9, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(25, instance8 = $$new_props.instance);
        if ("checkbox" in $$props)
          $$invalidate(10, checkbox = $$new_props.checkbox);
        if ("internalClasses" in $$props)
          $$invalidate(11, internalClasses = $$new_props.internalClasses);
        if ("thumbUnderlayClasses" in $$props)
          $$invalidate(12, thumbUnderlayClasses = $$new_props.thumbUnderlayClasses);
        if ("nativeControlAttrs" in $$props)
          $$invalidate(13, nativeControlAttrs = $$new_props.nativeControlAttrs);
        if ("rippleActive" in $$props)
          $$invalidate(14, rippleActive = $$new_props.rippleActive);
        if ("inputProps" in $$props)
          $$invalidate(17, inputProps = $$new_props.inputProps);
        if ("nativeChecked" in $$props)
          $$invalidate(8, nativeChecked = $$new_props.nativeChecked);
        if ("previousChecked" in $$props)
          $$invalidate(26, previousChecked = $$new_props.previousChecked);
        if ("previousGroup" in $$props)
          $$invalidate(27, previousGroup = $$new_props.previousGroup);
        if ("previousNativeChecked" in $$props)
          $$invalidate(28, previousNativeChecked = $$new_props.previousNativeChecked);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 509608208) {
          {
            let callHandleChange = false;
            if (group !== uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                const idx = group.indexOf(value);
                if (nativeChecked && idx === -1) {
                  group.push(value);
                  $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(8, nativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance8);
                } else if (!nativeChecked && idx !== -1) {
                  group.splice(idx, 1);
                  $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(8, nativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance8);
                }
                callHandleChange = true;
              } else {
                const idxPrev = previousGroup.indexOf(value);
                const idx = group.indexOf(value);
                if (idxPrev > -1 && idx === -1) {
                  $$invalidate(8, nativeChecked = false);
                  callHandleChange = true;
                } else if (idx > -1 && idxPrev === -1) {
                  $$invalidate(8, nativeChecked = true);
                  callHandleChange = true;
                }
              }
            }
            if (checked === uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                callHandleChange = true;
              }
            } else if (checked !== nativeChecked) {
              if (checked === previousChecked) {
                $$invalidate(22, checked = nativeChecked);
              } else {
                $$invalidate(8, nativeChecked = checked);
              }
              callHandleChange = true;
            }
            $$invalidate(26, previousChecked = checked);
            $$invalidate(27, previousGroup = group === uninitializedValue ? [] : [...group]);
            $$invalidate(28, previousNativeChecked = nativeChecked);
            if (callHandleChange && instance8) {
              instance8.handleChange({target: {checked: nativeChecked}});
            }
          }
        }
      };
      return [
        disabled,
        use2,
        className,
        color,
        value,
        valueKey,
        input$use,
        input$class,
        nativeChecked,
        element2,
        checkbox,
        internalClasses,
        thumbUnderlayClasses,
        nativeControlAttrs,
        rippleActive,
        forwardEvents,
        uninitializedValue,
        inputProps,
        addThumbUnderlayClass,
        removeThumbUnderlayClass,
        $$restProps,
        group,
        checked,
        getId,
        getElement,
        instance8,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        blur_handler,
        focus_handler,
        input_binding,
        input_change_handler,
        div3_binding
      ];
    }
    var Switch = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$23, create_fragment$44, safe_not_equal, {
          use: 1,
          class: 2,
          disabled: 0,
          color: 3,
          group: 21,
          checked: 22,
          value: 4,
          valueKey: 5,
          input$use: 6,
          input$class: 7,
          getId: 23,
          getElement: 24
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Switch",
          options,
          id: create_fragment$44.name
        });
      }
      get use() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get group() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set group(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get checked() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set checked(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get valueKey() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set valueKey(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$use() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$use(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$class() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$class(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getId() {
        return this.$$.ctx[23];
      }
      set getId(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[24];
      }
      set getElement(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$14 = {
      ACTIVATED: "mdc-select--activated",
      DISABLED: "mdc-select--disabled",
      FOCUSED: "mdc-select--focused",
      INVALID: "mdc-select--invalid",
      MENU_INVALID: "mdc-select__menu--invalid",
      OUTLINED: "mdc-select--outlined",
      REQUIRED: "mdc-select--required",
      ROOT: "mdc-select",
      WITH_LEADING_ICON: "mdc-select--with-leading-icon"
    };
    var strings$12 = {
      ARIA_CONTROLS: "aria-controls",
      ARIA_DESCRIBEDBY: "aria-describedby",
      ARIA_SELECTED_ATTR: "aria-selected",
      CHANGE_EVENT: "MDCSelect:change",
      HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
      LABEL_SELECTOR: ".mdc-floating-label",
      LEADING_ICON_SELECTOR: ".mdc-select__icon",
      LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
      MENU_SELECTOR: ".mdc-select__menu",
      OUTLINE_SELECTOR: ".mdc-notched-outline",
      SELECTED_TEXT_SELECTOR: ".mdc-select__selected-text",
      SELECT_ANCHOR_SELECTOR: ".mdc-select__anchor",
      VALUE_ATTR: "data-value"
    };
    var numbers6 = {
      LABEL_SCALE: 0.75,
      UNSET_INDEX: -1,
      CLICK_DEBOUNCE_TIMEOUT_MS: 330
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectFoundation = function(_super) {
      __extends(MDCSelectFoundation2, _super);
      function MDCSelectFoundation2(adapter, foundationMap) {
        if (foundationMap === void 0) {
          foundationMap = {};
        }
        var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation2.defaultAdapter), adapter)) || this;
        _this.disabled = false;
        _this.isMenuOpen = false;
        _this.useDefaultValidation = true;
        _this.customValidity = true;
        _this.lastSelectedIndex = numbers6.UNSET_INDEX;
        _this.clickDebounceTimeout = 0;
        _this.recentlyClicked = false;
        _this.leadingIcon = foundationMap.leadingIcon;
        _this.helperText = foundationMap.helperText;
        return _this;
      }
      Object.defineProperty(MDCSelectFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$14;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "numbers", {
        get: function() {
          return numbers6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            activateBottomLine: function() {
              return void 0;
            },
            deactivateBottomLine: function() {
              return void 0;
            },
            getSelectedIndex: function() {
              return -1;
            },
            setSelectedIndex: function() {
              return void 0;
            },
            hasLabel: function() {
              return false;
            },
            floatLabel: function() {
              return void 0;
            },
            getLabelWidth: function() {
              return 0;
            },
            setLabelRequired: function() {
              return void 0;
            },
            hasOutline: function() {
              return false;
            },
            notchOutline: function() {
              return void 0;
            },
            closeOutline: function() {
              return void 0;
            },
            setRippleCenter: function() {
              return void 0;
            },
            notifyChange: function() {
              return void 0;
            },
            setSelectedText: function() {
              return void 0;
            },
            isSelectAnchorFocused: function() {
              return false;
            },
            getSelectAnchorAttr: function() {
              return "";
            },
            setSelectAnchorAttr: function() {
              return void 0;
            },
            removeSelectAnchorAttr: function() {
              return void 0;
            },
            addMenuClass: function() {
              return void 0;
            },
            removeMenuClass: function() {
              return void 0;
            },
            openMenu: function() {
              return void 0;
            },
            closeMenu: function() {
              return void 0;
            },
            getAnchorElement: function() {
              return null;
            },
            setMenuAnchorElement: function() {
              return void 0;
            },
            setMenuAnchorCorner: function() {
              return void 0;
            },
            setMenuWrapFocus: function() {
              return void 0;
            },
            focusMenuItemAtIndex: function() {
              return void 0;
            },
            getMenuItemCount: function() {
              return 0;
            },
            getMenuItemValues: function() {
              return [];
            },
            getMenuItemTextAtIndex: function() {
              return "";
            },
            isTypeaheadInProgress: function() {
              return false;
            },
            typeaheadMatchItem: function() {
              return -1;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSelectFoundation2.prototype.getSelectedIndex = function() {
        return this.adapter.getSelectedIndex();
      };
      MDCSelectFoundation2.prototype.setSelectedIndex = function(index, closeMenu, skipNotify) {
        if (closeMenu === void 0) {
          closeMenu = false;
        }
        if (skipNotify === void 0) {
          skipNotify = false;
        }
        if (index >= this.adapter.getMenuItemCount()) {
          return;
        }
        if (index === numbers6.UNSET_INDEX) {
          this.adapter.setSelectedText("");
        } else {
          this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
        }
        this.adapter.setSelectedIndex(index);
        if (closeMenu) {
          this.adapter.closeMenu();
        }
        if (!skipNotify && this.lastSelectedIndex !== index) {
          this.handleChange();
        }
        this.lastSelectedIndex = index;
      };
      MDCSelectFoundation2.prototype.setValue = function(value, skipNotify) {
        if (skipNotify === void 0) {
          skipNotify = false;
        }
        var index = this.adapter.getMenuItemValues().indexOf(value);
        this.setSelectedIndex(index, false, skipNotify);
      };
      MDCSelectFoundation2.prototype.getValue = function() {
        var index = this.adapter.getSelectedIndex();
        var menuItemValues = this.adapter.getMenuItemValues();
        return index !== numbers6.UNSET_INDEX ? menuItemValues[index] : "";
      };
      MDCSelectFoundation2.prototype.getDisabled = function() {
        return this.disabled;
      };
      MDCSelectFoundation2.prototype.setDisabled = function(isDisabled) {
        this.disabled = isDisabled;
        if (this.disabled) {
          this.adapter.addClass(cssClasses$14.DISABLED);
          this.adapter.closeMenu();
        } else {
          this.adapter.removeClass(cssClasses$14.DISABLED);
        }
        if (this.leadingIcon) {
          this.leadingIcon.setDisabled(this.disabled);
        }
        if (this.disabled) {
          this.adapter.removeSelectAnchorAttr("tabindex");
        } else {
          this.adapter.setSelectAnchorAttr("tabindex", "0");
        }
        this.adapter.setSelectAnchorAttr("aria-disabled", this.disabled.toString());
      };
      MDCSelectFoundation2.prototype.openMenu = function() {
        this.adapter.addClass(cssClasses$14.ACTIVATED);
        this.adapter.openMenu();
        this.isMenuOpen = true;
        this.adapter.setSelectAnchorAttr("aria-expanded", "true");
      };
      MDCSelectFoundation2.prototype.setHelperTextContent = function(content) {
        if (this.helperText) {
          this.helperText.setContent(content);
        }
      };
      MDCSelectFoundation2.prototype.layout = function() {
        if (this.adapter.hasLabel()) {
          var optionHasValue = this.getValue().length > 0;
          var isFocused = this.adapter.hasClass(cssClasses$14.FOCUSED);
          var shouldFloatAndNotch = optionHasValue || isFocused;
          var isRequired = this.adapter.hasClass(cssClasses$14.REQUIRED);
          this.notchOutline(shouldFloatAndNotch);
          this.adapter.floatLabel(shouldFloatAndNotch);
          this.adapter.setLabelRequired(isRequired);
        }
      };
      MDCSelectFoundation2.prototype.layoutOptions = function() {
        var menuItemValues = this.adapter.getMenuItemValues();
        var selectedIndex = menuItemValues.indexOf(this.getValue());
        this.setSelectedIndex(selectedIndex, false, true);
      };
      MDCSelectFoundation2.prototype.handleMenuOpened = function() {
        if (this.adapter.getMenuItemValues().length === 0) {
          return;
        }
        var selectedIndex = this.getSelectedIndex();
        var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
        this.adapter.focusMenuItemAtIndex(focusItemIndex);
      };
      MDCSelectFoundation2.prototype.handleMenuClosing = function() {
        this.adapter.setSelectAnchorAttr("aria-expanded", "false");
      };
      MDCSelectFoundation2.prototype.handleMenuClosed = function() {
        this.adapter.removeClass(cssClasses$14.ACTIVATED);
        this.isMenuOpen = false;
        if (!this.adapter.isSelectAnchorFocused()) {
          this.blur();
        }
      };
      MDCSelectFoundation2.prototype.handleChange = function() {
        this.layout();
        this.adapter.notifyChange(this.getValue());
        var isRequired = this.adapter.hasClass(cssClasses$14.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
          this.setValid(this.isValid());
        }
      };
      MDCSelectFoundation2.prototype.handleMenuItemAction = function(index) {
        this.setSelectedIndex(index, true);
      };
      MDCSelectFoundation2.prototype.handleFocus = function() {
        this.adapter.addClass(cssClasses$14.FOCUSED);
        this.layout();
        this.adapter.activateBottomLine();
      };
      MDCSelectFoundation2.prototype.handleBlur = function() {
        if (this.isMenuOpen) {
          return;
        }
        this.blur();
      };
      MDCSelectFoundation2.prototype.handleClick = function(normalizedX) {
        if (this.disabled || this.recentlyClicked) {
          return;
        }
        this.setClickDebounceTimeout();
        if (this.isMenuOpen) {
          this.adapter.closeMenu();
          return;
        }
        this.adapter.setRippleCenter(normalizedX);
        this.openMenu();
      };
      MDCSelectFoundation2.prototype.handleKeydown = function(event) {
        if (this.isMenuOpen || !this.adapter.hasClass(cssClasses$14.FOCUSED)) {
          return;
        }
        var isEnter = normalizeKey(event) === KEY.ENTER;
        var isSpace = normalizeKey(event) === KEY.SPACEBAR;
        var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
        var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
        var isModifier = event.ctrlKey || event.metaKey;
        if (!isModifier && (!isSpace && event.key && event.key.length === 1 || isSpace && this.adapter.isTypeaheadInProgress())) {
          var key = isSpace ? " " : event.key;
          var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
          if (typeaheadNextIndex >= 0) {
            this.setSelectedIndex(typeaheadNextIndex);
          }
          event.preventDefault();
          return;
        }
        if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
          return;
        }
        if (arrowUp && this.getSelectedIndex() > 0) {
          this.setSelectedIndex(this.getSelectedIndex() - 1);
        } else if (arrowDown && this.getSelectedIndex() < this.adapter.getMenuItemCount() - 1) {
          this.setSelectedIndex(this.getSelectedIndex() + 1);
        }
        this.openMenu();
        event.preventDefault();
      };
      MDCSelectFoundation2.prototype.notchOutline = function(openNotch) {
        if (!this.adapter.hasOutline()) {
          return;
        }
        var isFocused = this.adapter.hasClass(cssClasses$14.FOCUSED);
        if (openNotch) {
          var labelScale = numbers6.LABEL_SCALE;
          var labelWidth = this.adapter.getLabelWidth() * labelScale;
          this.adapter.notchOutline(labelWidth);
        } else if (!isFocused) {
          this.adapter.closeOutline();
        }
      };
      MDCSelectFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
        if (this.leadingIcon) {
          this.leadingIcon.setAriaLabel(label);
        }
      };
      MDCSelectFoundation2.prototype.setLeadingIconContent = function(content) {
        if (this.leadingIcon) {
          this.leadingIcon.setContent(content);
        }
      };
      MDCSelectFoundation2.prototype.setUseDefaultValidation = function(useDefaultValidation) {
        this.useDefaultValidation = useDefaultValidation;
      };
      MDCSelectFoundation2.prototype.setValid = function(isValid) {
        if (!this.useDefaultValidation) {
          this.customValidity = isValid;
        }
        this.adapter.setSelectAnchorAttr("aria-invalid", (!isValid).toString());
        if (isValid) {
          this.adapter.removeClass(cssClasses$14.INVALID);
          this.adapter.removeMenuClass(cssClasses$14.MENU_INVALID);
        } else {
          this.adapter.addClass(cssClasses$14.INVALID);
          this.adapter.addMenuClass(cssClasses$14.MENU_INVALID);
        }
        this.syncHelperTextValidity(isValid);
      };
      MDCSelectFoundation2.prototype.isValid = function() {
        if (this.useDefaultValidation && this.adapter.hasClass(cssClasses$14.REQUIRED) && !this.adapter.hasClass(cssClasses$14.DISABLED)) {
          return this.getSelectedIndex() !== numbers6.UNSET_INDEX && (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
        }
        return this.customValidity;
      };
      MDCSelectFoundation2.prototype.setRequired = function(isRequired) {
        if (isRequired) {
          this.adapter.addClass(cssClasses$14.REQUIRED);
        } else {
          this.adapter.removeClass(cssClasses$14.REQUIRED);
        }
        this.adapter.setSelectAnchorAttr("aria-required", isRequired.toString());
        this.adapter.setLabelRequired(isRequired);
      };
      MDCSelectFoundation2.prototype.getRequired = function() {
        return this.adapter.getSelectAnchorAttr("aria-required") === "true";
      };
      MDCSelectFoundation2.prototype.init = function() {
        var anchorEl = this.adapter.getAnchorElement();
        if (anchorEl) {
          this.adapter.setMenuAnchorElement(anchorEl);
          this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
        }
        this.adapter.setMenuWrapFocus(false);
        this.setDisabled(this.adapter.hasClass(cssClasses$14.DISABLED));
        this.syncHelperTextValidity(!this.adapter.hasClass(cssClasses$14.INVALID));
        this.layout();
        this.layoutOptions();
      };
      MDCSelectFoundation2.prototype.blur = function() {
        this.adapter.removeClass(cssClasses$14.FOCUSED);
        this.layout();
        this.adapter.deactivateBottomLine();
        var isRequired = this.adapter.hasClass(cssClasses$14.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
          this.setValid(this.isValid());
        }
      };
      MDCSelectFoundation2.prototype.syncHelperTextValidity = function(isValid) {
        if (!this.helperText) {
          return;
        }
        this.helperText.setValidity(isValid);
        var helperTextVisible = this.helperText.isVisible();
        var helperTextId = this.helperText.getId();
        if (helperTextVisible && helperTextId) {
          this.adapter.setSelectAnchorAttr(strings$12.ARIA_DESCRIBEDBY, helperTextId);
        } else {
          this.adapter.removeSelectAnchorAttr(strings$12.ARIA_DESCRIBEDBY);
        }
      };
      MDCSelectFoundation2.prototype.setClickDebounceTimeout = function() {
        var _this = this;
        clearTimeout(this.clickDebounceTimeout);
        this.clickDebounceTimeout = setTimeout(function() {
          _this.recentlyClicked = false;
        }, numbers6.CLICK_DEBOUNCE_TIMEOUT_MS);
        this.recentlyClicked = true;
      };
      return MDCSelectFoundation2;
    }(MDCFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings7 = {
      ARIA_HIDDEN: "aria-hidden",
      ROLE: "role"
    };
    var cssClasses7 = {
      HELPER_TEXT_VALIDATION_MSG: "mdc-select-helper-text--validation-msg",
      HELPER_TEXT_VALIDATION_MSG_PERSISTENT: "mdc-select-helper-text--validation-msg-persistent"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectHelperTextFoundation = function(_super) {
      __extends(MDCSelectHelperTextFoundation2, _super);
      function MDCSelectHelperTextFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCSelectHelperTextFoundation2, "cssClasses", {
        get: function() {
          return cssClasses7;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectHelperTextFoundation2, "strings", {
        get: function() {
          return strings7;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectHelperTextFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            setAttr: function() {
              return void 0;
            },
            getAttr: function() {
              return null;
            },
            removeAttr: function() {
              return void 0;
            },
            setContent: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSelectHelperTextFoundation2.prototype.getId = function() {
        return this.adapter.getAttr("id");
      };
      MDCSelectHelperTextFoundation2.prototype.isVisible = function() {
        return this.adapter.getAttr(strings7.ARIA_HIDDEN) !== "true";
      };
      MDCSelectHelperTextFoundation2.prototype.setContent = function(content) {
        this.adapter.setContent(content);
      };
      MDCSelectHelperTextFoundation2.prototype.setValidation = function(isValidation) {
        if (isValidation) {
          this.adapter.addClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter.removeClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG);
        }
      };
      MDCSelectHelperTextFoundation2.prototype.setValidationMsgPersistent = function(isPersistent) {
        if (isPersistent) {
          this.adapter.addClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        } else {
          this.adapter.removeClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        }
      };
      MDCSelectHelperTextFoundation2.prototype.setValidity = function(selectIsValid) {
        var isValidationMsg = this.adapter.hasClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG);
        if (!isValidationMsg) {
          return;
        }
        var isPersistentValidationMsg = this.adapter.hasClass(cssClasses7.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        var msgShouldDisplay = !selectIsValid || isPersistentValidationMsg;
        if (msgShouldDisplay) {
          this.showToScreenReader();
          if (!selectIsValid) {
            this.adapter.setAttr(strings7.ROLE, "alert");
          } else {
            this.adapter.removeAttr(strings7.ROLE);
          }
          return;
        }
        this.adapter.removeAttr(strings7.ROLE);
        this.hide();
      };
      MDCSelectHelperTextFoundation2.prototype.showToScreenReader = function() {
        this.adapter.removeAttr(strings7.ARIA_HIDDEN);
      };
      MDCSelectHelperTextFoundation2.prototype.hide = function() {
        this.adapter.setAttr(strings7.ARIA_HIDDEN, "true");
      };
      return MDCSelectHelperTextFoundation2;
    }(MDCFoundation);
    function Anchor(node, {
      addClass = (className) => node.classList.add(className),
      removeClass = (className) => node.classList.remove(className)
    } = {}) {
      addClass("mdc-menu-surface--anchor");
      return {
        destroy() {
          removeClass("mdc-menu-surface--anchor");
        }
      };
    }
    var file$26 = "node_modules/@smui/select/helper-text/HelperText.svelte";
    function create_else_block$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[8]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 256)
            set_data_dev(t, ctx2[8]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(17:31) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$2(ctx) {
      let current;
      const default_slot_template = ctx[13].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 4096)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(17:2) {#if content == null}",
        ctx
      });
      return block;
    }
    function create_fragment$35(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let div_class_value;
      let div_aria_hidden_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$2, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[8] == null)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div_levels = [
        {
          class: div_class_value = classMap({
            [ctx[1]]: true,
            "mdc-select-helper-text": true,
            "mdc-select-helper-text--validation-msg": ctx[4],
            "mdc-select-helper-text--validation-msg-persistent": ctx[3],
            ...ctx[6]
          })
        },
        {
          "aria-hidden": div_aria_hidden_value = ctx[3] ? null : "true"
        },
        {id: ctx[2]},
        ctx[7],
        ctx[10]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if_block.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          ctx[14](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
              action_destroyer(ctx[9].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 90 && div_class_value !== (div_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-select-helper-text": true,
              "mdc-select-helper-text--validation-msg": ctx2[4],
              "mdc-select-helper-text--validation-msg-persistent": ctx2[3],
              ...ctx2[6]
            }))) && {class: div_class_value},
            (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? null : "true")) && {"aria-hidden": div_aria_hidden_value},
            (!current || dirty & 4) && {id: ctx2[2]},
            dirty & 128 && ctx2[7],
            dirty & 1024 && ctx2[10]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if_blocks[current_block_type_index].d();
          ctx[14](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$35.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter$1 = 0;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("HelperText", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {id = "SMUI-select-helper-text-" + counter$1++} = $$props;
      let {persistent = false} = $$props;
      let {validationMsg = false} = $$props;
      let element2;
      let instance8;
      let internalClasses = {};
      let internalAttrs = {};
      let content = null;
      onMount(() => {
        instance8 = new MDCSelectHelperTextFoundation({
          addClass,
          removeClass,
          hasClass,
          getAttr,
          setAttr: addAttr,
          removeAttr,
          setContent: (value) => {
            $$invalidate(8, content = value);
          }
        });
        if (id.startsWith("SMUI-select-helper-text-")) {
          dispatch(getElement(), "SMUI:select:helper-text:id", id);
        }
        dispatch(getElement(), "SMUI:select:helper-text:mount", instance8);
        instance8.init();
        return () => {
          dispatch(getElement(), "SMUI:select:helper-text:unmount", instance8);
          instance8.destroy();
        };
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = false, internalClasses);
        }
      }
      function getAttr(name2) {
        return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
      }
      function addAttr(name2, value) {
        if (internalAttrs[name2] !== value) {
          $$invalidate(7, internalAttrs[name2] = value, internalAttrs);
        }
      }
      function removeAttr(name2) {
        if (!(name2 in internalAttrs) || internalAttrs[name2] != null) {
          $$invalidate(7, internalAttrs[name2] = void 0, internalAttrs);
        }
      }
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(5, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("id" in $$new_props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$new_props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$new_props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("$$scope" in $$new_props)
          $$invalidate(12, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter$1,
        MDCSelectHelperTextFoundation,
        onMount,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        dispatch,
        forwardEvents,
        use: use2,
        className,
        id,
        persistent,
        validationMsg,
        element: element2,
        instance: instance8,
        internalClasses,
        internalAttrs,
        content,
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("id" in $$props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("element" in $$props)
          $$invalidate(5, element2 = $$new_props.element);
        if ("instance" in $$props)
          instance8 = $$new_props.instance;
        if ("internalClasses" in $$props)
          $$invalidate(6, internalClasses = $$new_props.internalClasses);
        if ("internalAttrs" in $$props)
          $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
        if ("content" in $$props)
          $$invalidate(8, content = $$new_props.content);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        id,
        persistent,
        validationMsg,
        element2,
        internalClasses,
        internalAttrs,
        content,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var HelperText = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$35, safe_not_equal, {
          use: 0,
          class: 1,
          id: 2,
          persistent: 3,
          validationMsg: 4,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HelperText",
          options,
          id: create_fragment$35.name
        });
      }
      get use() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get validationMsg() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set validationMsg(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var file$18 = "node_modules/@smui/select/Select.svelte";
    var get_helperText_slot_changes = (dirty) => ({});
    var get_helperText_slot_context = (ctx) => ({});
    var get_leadingIcon_slot_changes2 = (dirty) => ({});
    var get_leadingIcon_slot_context2 = (ctx) => ({});
    var get_label_slot_changes_12 = (dirty) => ({});
    var get_label_slot_context_12 = (ctx) => ({});
    var get_label_slot_changes3 = (dirty) => ({});
    var get_label_slot_context3 = (ctx) => ({});
    function create_if_block_62(ctx) {
      let input;
      let input_levels = [
        {type: "hidden"},
        {required: ctx[10]},
        {disabled: ctx[6]},
        {value: ctx[0]},
        prefixFilter2(ctx[53], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      const block = {
        c: function create2() {
          input = element("input");
          set_attributes(input, input_data);
          add_location(input, file$18, 52, 4, 1508);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);
          if (input.autofocus)
            input.focus();
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            {type: "hidden"},
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[0] & 64 && {disabled: ctx2[6]},
            dirty[0] & 1 && {value: ctx2[0]},
            dirty[1] & 4194304 && prefixFilter2(ctx2[53], "input$")
          ]));
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_62.name,
        type: "if",
        source: "(52:2) {#if hiddenInput}",
        ctx
      });
      return block;
    }
    function create_if_block_53(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          attr_dev(span, "class", "mdc-select__ripple");
          add_location(span, file$18, 86, 6, 2430);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_53.name,
        type: "if",
        source: "(86:4) {#if variant === 'filled'}",
        ctx
      });
      return block;
    }
    function create_if_block_4$1(ctx) {
      let floatinglabel;
      let current;
      const floatinglabel_spread_levels = [
        {id: ctx[11] + "-smui-label"},
        {
          floatAbove: ctx[43] !== ""
        },
        {required: ctx[10]},
        prefixFilter2(ctx[53], "label$")
      ];
      let floatinglabel_props = {
        $$slots: {default: [create_default_slot_5$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
        floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
      }
      floatinglabel = new FloatingLabel({
        props: floatinglabel_props,
        $$inline: true
      });
      ctx[64](floatinglabel);
      const block = {
        c: function create2() {
          create_component(floatinglabel.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(floatinglabel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 4198400 ? get_spread_update(floatinglabel_spread_levels, [
            dirty[0] & 2048 && {id: ctx2[11] + "-smui-label"},
            dirty[1] & 4096 && {
              floatAbove: ctx2[43] !== ""
            },
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter2(ctx2[53], "label$"))
          ]) : {};
          if (dirty[0] & 512 | dirty[2] & 33554432) {
            floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
          }
          floatinglabel.$set(floatinglabel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(floatinglabel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(floatinglabel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[64](null);
          destroy_component(floatinglabel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$1.name,
        type: "if",
        source: "(89:4) {#if variant !== 'outlined' && !noLabel && (label != null || $$slots.label)}",
        ctx
      });
      return block;
    }
    function create_default_slot_5$1(ctx) {
      let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
      let t;
      let current;
      const label_slot_template = ctx[61].label;
      const label_slot = create_slot(label_slot_template, ctx, ctx[87], get_label_slot_context3);
      const block = {
        c: function create2() {
          t = text(t_value);
          if (label_slot)
            label_slot.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          if (label_slot) {
            label_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
            set_data_dev(t, t_value);
          if (label_slot) {
            if (label_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(label_slot, label_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(label_slot_template, ctx2[87], dirty, get_label_slot_changes3), get_label_slot_context3);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
          if (label_slot)
            label_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: "(90:6) <FloatingLabel         bind:this={floatingLabel}         id={inputId + '-smui-label'}         floatAbove={$selectedTextStore !== ''}         {required}         {...prefixFilter($$restProps, 'label$')}         >",
        ctx
      });
      return block;
    }
    function create_if_block_2$1(ctx) {
      let notchedoutline;
      let current;
      const notchedoutline_spread_levels = [
        {
          noLabel: ctx[8] || ctx[9] == null && !ctx[52].label
        },
        prefixFilter2(ctx[53], "outline$")
      ];
      let notchedoutline_props = {
        $$slots: {default: [create_default_slot_3$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
        notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
      }
      notchedoutline = new NotchedOutline({
        props: notchedoutline_props,
        $$inline: true
      });
      ctx[66](notchedoutline);
      const block = {
        c: function create2() {
          create_component(notchedoutline.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(notchedoutline, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const notchedoutline_changes = dirty[0] & 768 | dirty[1] & 6291456 ? get_spread_update(notchedoutline_spread_levels, [
            dirty[0] & 768 | dirty[1] & 2097152 && {
              noLabel: ctx2[8] || ctx2[9] == null && !ctx2[52].label
            },
            dirty[1] & 4194304 && get_spread_object(prefixFilter2(ctx2[53], "outline$"))
          ]) : {};
          if (dirty[0] & 3840 | dirty[1] & 6296064 | dirty[2] & 33554432) {
            notchedoutline_changes.$$scope = {dirty, ctx: ctx2};
          }
          notchedoutline.$set(notchedoutline_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(notchedoutline.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(notchedoutline.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[66](null);
          destroy_component(notchedoutline, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$1.name,
        type: "if",
        source: "(99:4) {#if variant === 'outlined'}",
        ctx
      });
      return block;
    }
    function create_if_block_3$1(ctx) {
      let floatinglabel;
      let current;
      const floatinglabel_spread_levels = [
        {id: ctx[11] + "-smui-label"},
        {
          floatAbove: ctx[43] !== ""
        },
        {required: ctx[10]},
        prefixFilter2(ctx[53], "label$")
      ];
      let floatinglabel_props = {
        $$slots: {default: [create_default_slot_4$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
        floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
      }
      floatinglabel = new FloatingLabel({
        props: floatinglabel_props,
        $$inline: true
      });
      ctx[65](floatinglabel);
      const block = {
        c: function create2() {
          create_component(floatinglabel.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(floatinglabel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 4198400 ? get_spread_update(floatinglabel_spread_levels, [
            dirty[0] & 2048 && {id: ctx2[11] + "-smui-label"},
            dirty[1] & 4096 && {
              floatAbove: ctx2[43] !== ""
            },
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter2(ctx2[53], "label$"))
          ]) : {};
          if (dirty[0] & 512 | dirty[2] & 33554432) {
            floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
          }
          floatinglabel.$set(floatinglabel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(floatinglabel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(floatinglabel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[65](null);
          destroy_component(floatinglabel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$1.name,
        type: "if",
        source: "(105:8) {#if !noLabel && (label != null || $$slots.label)}",
        ctx
      });
      return block;
    }
    function create_default_slot_4$1(ctx) {
      let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
      let t;
      let current;
      const label_slot_template = ctx[61].label;
      const label_slot = create_slot(label_slot_template, ctx, ctx[87], get_label_slot_context_12);
      const block = {
        c: function create2() {
          t = text(t_value);
          if (label_slot)
            label_slot.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          if (label_slot) {
            label_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
            set_data_dev(t, t_value);
          if (label_slot) {
            if (label_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(label_slot, label_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(label_slot_template, ctx2[87], dirty, get_label_slot_changes_12), get_label_slot_context_12);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
          if (label_slot)
            label_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: "(106:10) <FloatingLabel             bind:this={floatingLabel}             id={inputId + '-smui-label'}             floatAbove={$selectedTextStore !== ''}             {required}             {...prefixFilter($$restProps, 'label$')}             >",
        ctx
      });
      return block;
    }
    function create_default_slot_3$1(ctx) {
      let if_block_anchor;
      let current;
      let if_block = !ctx[8] && (ctx[9] != null || ctx[52].label) && create_if_block_3$1(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (!ctx2[8] && (ctx2[9] != null || ctx2[52].label)) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 768 | dirty[1] & 2097152) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_3$1(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(100:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
        ctx
      });
      return block;
    }
    function create_if_block_1$1(ctx) {
      let lineripple;
      let current;
      const lineripple_spread_levels = [prefixFilter2(ctx[53], "ripple$")];
      let lineripple_props = {};
      for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
        lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
      }
      lineripple = new LineRipple({props: lineripple_props, $$inline: true});
      ctx[68](lineripple);
      const block = {
        c: function create2() {
          create_component(lineripple.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(lineripple, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const lineripple_changes = dirty[1] & 4194304 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter2(ctx2[53], "ripple$"))]) : {};
          lineripple.$set(lineripple_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(lineripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(lineripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[68](null);
          destroy_component(lineripple, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(169:4) {#if variant !== 'outlined' && ripple}",
        ctx
      });
      return block;
    }
    function create_default_slot_2$1(ctx) {
      let current;
      const default_slot_template = ctx[61].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[87], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(default_slot_template, ctx2[87], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: `(195:4) <List       role=\\"listbox\\"       {wrapFocus}       bind:selectedIndex       on:SMUI:list:mount={(event) => (list = event.detail)}       {...prefixFilter($$restProps, 'list$')}>`,
        ctx
      });
      return block;
    }
    function create_default_slot_1$1(ctx) {
      let list_1;
      let updating_selectedIndex;
      let current;
      const list_1_spread_levels = [
        {role: "listbox"},
        {wrapFocus: ctx[36]},
        prefixFilter2(ctx[53], "list$")
      ];
      function list_1_selectedIndex_binding(value) {
        ctx[74](value);
      }
      let list_1_props = {
        $$slots: {default: [create_default_slot_2$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < list_1_spread_levels.length; i += 1) {
        list_1_props = assign(list_1_props, list_1_spread_levels[i]);
      }
      if (ctx[24] !== void 0) {
        list_1_props.selectedIndex = ctx[24];
      }
      list_1 = new List({props: list_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(list_1, "selectedIndex", list_1_selectedIndex_binding));
      list_1.$on("SMUI:list:mount", ctx[75]);
      const block = {
        c: function create2() {
          create_component(list_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_1_changes = dirty[1] & 4194336 ? get_spread_update(list_1_spread_levels, [
            list_1_spread_levels[0],
            dirty[1] & 32 && {wrapFocus: ctx2[36]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter2(ctx2[53], "list$"))
          ]) : {};
          if (dirty[2] & 33554432) {
            list_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_selectedIndex && dirty[0] & 16777216) {
            updating_selectedIndex = true;
            list_1_changes.selectedIndex = ctx2[24];
            add_flush_callback(() => updating_selectedIndex = false);
          }
          list_1.$set(list_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(177:2) <Menu     class={classMap({       [menu$class]: true,       'mdc-select__menu': true,       ...menuClasses,     })}     fullWidth     anchor={false}     {anchorElement}     {anchorCorner}     bind:open={menuOpen}     on:MDCMenu:selected={(event) =>       instance && instance.handleMenuItemAction(event.detail.index)}     on:MDCMenuSurface:closing={() => instance && instance.handleMenuClosing()}     on:MDCMenuSurface:closed={() => instance && instance.handleMenuClosed()}     on:MDCMenuSurface:opened={() => instance && instance.handleMenuOpened()}     {...prefixFilter($$restProps, 'menu$')}   >",
        ctx
      });
      return block;
    }
    function create_if_block$13(ctx) {
      let helpertext;
      let current;
      const helpertext_spread_levels = [prefixFilter2(ctx[53], "helperText$")];
      let helpertext_props = {
        $$slots: {default: [create_default_slot$22]},
        $$scope: {ctx}
      };
      for (let i = 0; i < helpertext_spread_levels.length; i += 1) {
        helpertext_props = assign(helpertext_props, helpertext_spread_levels[i]);
      }
      helpertext = new HelperText({props: helpertext_props, $$inline: true});
      helpertext.$on("SMUI:select:helper-text:id", ctx[84]);
      helpertext.$on("SMUI:select:helper-text:mount", ctx[85]);
      helpertext.$on("SMUI:select:helper-text:unmount", ctx[86]);
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = dirty[1] & 4194304 ? get_spread_update(helpertext_spread_levels, [get_spread_object(prefixFilter2(ctx2[53], "helperText$"))]) : {};
          if (dirty[2] & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$13.name,
        type: "if",
        source: "(204:0) {#if $$slots.helperText}",
        ctx
      });
      return block;
    }
    function create_default_slot$22(ctx) {
      let current;
      const helperText_slot_template = ctx[61].helperText;
      const helperText_slot = create_slot(helperText_slot_template, ctx, ctx[87], get_helperText_slot_context);
      const block = {
        c: function create2() {
          if (helperText_slot)
            helperText_slot.c();
        },
        m: function mount(target, anchor) {
          if (helperText_slot) {
            helperText_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (helperText_slot) {
            if (helperText_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(helperText_slot, helperText_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(helperText_slot_template, ctx2[87], dirty, get_helperText_slot_changes), get_helperText_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helperText_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helperText_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (helperText_slot)
            helperText_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$22.name,
        type: "slot",
        source: "(205:2) <HelperText     on:SMUI:select:helper-text:id={(event) => (helperId = event.detail)}     on:SMUI:select:helper-text:mount={(event) => (helperText = event.detail)}     on:SMUI:select:helper-text:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     {...prefixFilter($$restProps, 'helperText$')}     >",
        ctx
      });
      return block;
    }
    function create_fragment$28(ctx) {
      let div1;
      let t0;
      let div0;
      let t1;
      let t2;
      let t3;
      let t4;
      let span1;
      let span0;
      let t5;
      let span0_id_value;
      let span0_class_value;
      let span0_aria_labelledby_value;
      let useActions_action;
      let span1_class_value;
      let useActions_action_1;
      let t6;
      let span2;
      let svg;
      let polygon0;
      let polygon1;
      let span2_class_value;
      let useActions_action_2;
      let t7;
      let div0_class_value;
      let div0_aria_required_value;
      let div0_aria_disabled_value;
      let useActions_action_3;
      let t8;
      let menu;
      let updating_open;
      let div1_class_value;
      let div1_style_value;
      let Ripple_action;
      let useActions_action_4;
      let t9;
      let if_block5_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block0 = ctx[12] && create_if_block_62(ctx);
      let if_block1 = ctx[7] === "filled" && create_if_block_53(ctx);
      let if_block2 = ctx[7] !== "outlined" && !ctx[8] && (ctx[9] != null || ctx[52].label) && create_if_block_4$1(ctx);
      let if_block3 = ctx[7] === "outlined" && create_if_block_2$1(ctx);
      const leadingIcon_slot_template = ctx[61].leadingIcon;
      const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[87], get_leadingIcon_slot_context2);
      let span0_levels = [
        {
          id: span0_id_value = ctx[11] + "-smui-selected-text"
        },
        {
          class: span0_class_value = classMap({
            [ctx[18]]: true,
            "mdc-select__selected-text": true
          })
        },
        {role: "button"},
        {"aria-haspopup": "listbox"},
        {
          "aria-labelledby": span0_aria_labelledby_value = ctx[11] + "-smui-label"
        },
        prefixFilter2(ctx[53], "selectedText$")
      ];
      let span0_data = {};
      for (let i = 0; i < span0_levels.length; i += 1) {
        span0_data = assign(span0_data, span0_levels[i]);
      }
      let span1_levels = [
        {
          class: span1_class_value = classMap({
            [ctx[16]]: true,
            "mdc-select__selected-text-container": true
          })
        },
        prefixFilter2(ctx[53], "selectedTextContainer$")
      ];
      let span1_data = {};
      for (let i = 0; i < span1_levels.length; i += 1) {
        span1_data = assign(span1_data, span1_levels[i]);
      }
      let span2_levels = [
        {
          class: span2_class_value = classMap({
            [ctx[20]]: true,
            "mdc-select__dropdown-icon": true
          })
        },
        prefixFilter2(ctx[53], "dropdownIcon$")
      ];
      let span2_data = {};
      for (let i = 0; i < span2_levels.length; i += 1) {
        span2_data = assign(span2_data, span2_levels[i]);
      }
      let if_block4 = ctx[7] !== "outlined" && ctx[5] && create_if_block_1$1(ctx);
      let div0_levels = [
        {
          class: div0_class_value = classMap({
            [ctx[14]]: true,
            "mdc-select__anchor": true
          })
        },
        {
          "aria-required": div0_aria_required_value = ctx[10] ? "true" : null
        },
        {
          "aria-disabled": div0_aria_disabled_value = ctx[6] ? "true" : null
        },
        {"aria-controls": ctx[31]},
        {"aria-describedby": ctx[31]},
        ctx[29],
        prefixFilter2(ctx[53], "anchor$")
      ];
      let div0_data = {};
      for (let i = 0; i < div0_levels.length; i += 1) {
        div0_data = assign(div0_data, div0_levels[i]);
      }
      const menu_spread_levels = [
        {
          class: classMap({
            [ctx[21]]: true,
            "mdc-select__menu": true,
            ...ctx[33]
          })
        },
        {fullWidth: true},
        {anchor: false},
        {anchorElement: ctx[34]},
        {anchorCorner: ctx[35]},
        prefixFilter2(ctx[53], "menu$")
      ];
      function menu_open_binding(value) {
        ctx[76](value);
      }
      let menu_props = {
        $$slots: {default: [create_default_slot_1$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < menu_spread_levels.length; i += 1) {
        menu_props = assign(menu_props, menu_spread_levels[i]);
      }
      if (ctx[32] !== void 0) {
        menu_props.open = ctx[32];
      }
      menu = new Menu({props: menu_props, $$inline: true});
      binding_callbacks.push(() => bind3(menu, "open", menu_open_binding));
      menu.$on("MDCMenu:selected", ctx[77]);
      menu.$on("MDCMenuSurface:closing", ctx[78]);
      menu.$on("MDCMenuSurface:closed", ctx[79]);
      menu.$on("MDCMenuSurface:opened", ctx[80]);
      let div1_levels = [
        {
          class: div1_class_value = classMap({
            [ctx[3]]: true,
            "mdc-select": true,
            "mdc-select--required": ctx[10],
            "mdc-select--disabled": ctx[6],
            "mdc-select--filled": ctx[7] === "filled",
            "mdc-select--outlined": ctx[7] === "outlined",
            "smui-select--standard": ctx[7] === "standard",
            "mdc-select--with-leading-icon": ctx[22] === ctx[45] ? ctx[52].leadingIcon : ctx[22],
            "mdc-select--no-label": ctx[8] || ctx[9] == null && !ctx[52].label,
            "mdc-select--invalid": ctx[1] !== ctx[45] && ctx[1],
            "mdc-select--activated": ctx[32],
            "mdc-data-table__pagination-rows-per-page-select": ctx[46] === "data-table:pagination",
            ...ctx[26]
          })
        },
        {
          style: div1_style_value = Object.entries(ctx[27]).map(func6).concat([ctx[4]]).join(" ")
        },
        exclude2(ctx[53], [
          "input$",
          "anchor$",
          "label$",
          "outline$",
          "selectedTextContainer$",
          "selectedText$",
          "dropdownIcon$",
          "ripple$",
          "menu$",
          "list$",
          "helperText$"
        ])
      ];
      let div1_data = {};
      for (let i = 0; i < div1_levels.length; i += 1) {
        div1_data = assign(div1_data, div1_levels[i]);
      }
      let if_block5 = ctx[52].helperText && create_if_block$13(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          div0 = element("div");
          if (if_block1)
            if_block1.c();
          t1 = space();
          if (if_block2)
            if_block2.c();
          t2 = space();
          if (if_block3)
            if_block3.c();
          t3 = space();
          if (leadingIcon_slot)
            leadingIcon_slot.c();
          t4 = space();
          span1 = element("span");
          span0 = element("span");
          t5 = text(ctx[43]);
          t6 = space();
          span2 = element("span");
          svg = svg_element("svg");
          polygon0 = svg_element("polygon");
          polygon1 = svg_element("polygon");
          t7 = space();
          if (if_block4)
            if_block4.c();
          t8 = space();
          create_component(menu.$$.fragment);
          t9 = space();
          if (if_block5)
            if_block5.c();
          if_block5_anchor = empty();
          set_attributes(span0, span0_data);
          add_location(span0, file$18, 125, 6, 3794);
          set_attributes(span1, span1_data);
          add_location(span1, file$18, 117, 4, 3532);
          attr_dev(polygon0, "class", "mdc-select__dropdown-icon-inactive");
          attr_dev(polygon0, "stroke", "none");
          attr_dev(polygon0, "fill-rule", "evenodd");
          attr_dev(polygon0, "points", "7 10 12 15 17 10");
          add_location(polygon0, file$18, 154, 8, 4616);
          attr_dev(polygon1, "class", "mdc-select__dropdown-icon-active");
          attr_dev(polygon1, "stroke", "none");
          attr_dev(polygon1, "fill-rule", "evenodd");
          attr_dev(polygon1, "points", "7 15 12 10 17 15");
          add_location(polygon1, file$18, 160, 8, 4787);
          attr_dev(svg, "class", "mdc-select__dropdown-icon-graphic");
          attr_dev(svg, "viewBox", "7 10 10 5");
          attr_dev(svg, "focusable", "false");
          add_location(svg, file$18, 149, 6, 4491);
          set_attributes(span2, span2_data);
          add_location(span2, file$18, 141, 4, 4266);
          set_attributes(div0, div0_data);
          add_location(div0, file$18, 60, 2, 1647);
          set_attributes(div1, div1_data);
          add_location(div1, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          if (if_block0)
            if_block0.m(div1, null);
          append_dev(div1, t0);
          append_dev(div1, div0);
          if (if_block1)
            if_block1.m(div0, null);
          append_dev(div0, t1);
          if (if_block2)
            if_block2.m(div0, null);
          append_dev(div0, t2);
          if (if_block3)
            if_block3.m(div0, null);
          append_dev(div0, t3);
          if (leadingIcon_slot) {
            leadingIcon_slot.m(div0, null);
          }
          append_dev(div0, t4);
          append_dev(div0, span1);
          append_dev(span1, span0);
          append_dev(span0, t5);
          ctx[67](span0);
          append_dev(div0, t6);
          append_dev(div0, span2);
          append_dev(span2, svg);
          append_dev(svg, polygon0);
          append_dev(svg, polygon1);
          append_dev(div0, t7);
          if (if_block4)
            if_block4.m(div0, null);
          ctx[69](div0);
          append_dev(div1, t8);
          mount_component(menu, div1, null);
          ctx[81](div1);
          insert_dev(target, t9, anchor);
          if (if_block5)
            if_block5.m(target, anchor);
          insert_dev(target, if_block5_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, span0, ctx[17])),
              action_destroyer(useActions_action_1 = useActions.call(null, span1, ctx[15])),
              action_destroyer(useActions_action_2 = useActions.call(null, span2, ctx[19])),
              action_destroyer(useActions_action_3 = useActions.call(null, div0, ctx[13])),
              listen_dev(div0, "focus", ctx[70], false, false, false),
              listen_dev(div0, "blur", ctx[71], false, false, false),
              listen_dev(div0, "click", ctx[72], false, false, false),
              listen_dev(div0, "keydown", ctx[73], false, false, false),
              listen_dev(div0, "focus", ctx[62], false, false, false),
              listen_dev(div0, "blur", ctx[63], false, false, false),
              action_destroyer(Ripple_action = Ripple.call(null, div1, {
                ripple: ctx[7] === "filled",
                unbounded: false,
                addClass: ctx[49],
                removeClass: ctx[50],
                addStyle: ctx[51]
              })),
              action_destroyer(Anchor.call(null, div1, {
                addClass: ctx[49],
                removeClass: ctx[50]
              })),
              action_destroyer(useActions_action_4 = useActions.call(null, div1, ctx[2])),
              action_destroyer(ctx[44].call(null, div1)),
              listen_dev(div1, "SMUI:select:leading-icon:mount", ctx[82], false, false, false),
              listen_dev(div1, "SMUI:select:leading-icon:unmount", ctx[83], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[12]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_62(ctx2);
              if_block0.c();
              if_block0.m(div1, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (ctx2[7] === "filled") {
            if (if_block1)
              ;
            else {
              if_block1 = create_if_block_53(ctx2);
              if_block1.c();
              if_block1.m(div0, t1);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (ctx2[7] !== "outlined" && !ctx2[8] && (ctx2[9] != null || ctx2[52].label)) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & 896 | dirty[1] & 2097152) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_4$1(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div0, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (ctx2[7] === "outlined") {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_2$1(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div0, t3);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if (leadingIcon_slot) {
            if (leadingIcon_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(leadingIcon_slot_template, ctx2[87], dirty, get_leadingIcon_slot_changes2), get_leadingIcon_slot_context2);
            }
          }
          if (!current || dirty[1] & 4096)
            set_data_dev(t5, ctx2[43]);
          set_attributes(span0, span0_data = get_spread_update(span0_levels, [
            (!current || dirty[0] & 2048 && span0_id_value !== (span0_id_value = ctx2[11] + "-smui-selected-text")) && {id: span0_id_value},
            (!current || dirty[0] & 262144 && span0_class_value !== (span0_class_value = classMap({
              [ctx2[18]]: true,
              "mdc-select__selected-text": true
            }))) && {class: span0_class_value},
            {role: "button"},
            {"aria-haspopup": "listbox"},
            (!current || dirty[0] & 2048 && span0_aria_labelledby_value !== (span0_aria_labelledby_value = ctx2[11] + "-smui-label")) && {
              "aria-labelledby": span0_aria_labelledby_value
            },
            dirty[1] & 4194304 && prefixFilter2(ctx2[53], "selectedText$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 131072)
            useActions_action.update.call(null, ctx2[17]);
          set_attributes(span1, span1_data = get_spread_update(span1_levels, [
            (!current || dirty[0] & 65536 && span1_class_value !== (span1_class_value = classMap({
              [ctx2[16]]: true,
              "mdc-select__selected-text-container": true
            }))) && {class: span1_class_value},
            dirty[1] & 4194304 && prefixFilter2(ctx2[53], "selectedTextContainer$")
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 32768)
            useActions_action_1.update.call(null, ctx2[15]);
          set_attributes(span2, span2_data = get_spread_update(span2_levels, [
            (!current || dirty[0] & 1048576 && span2_class_value !== (span2_class_value = classMap({
              [ctx2[20]]: true,
              "mdc-select__dropdown-icon": true
            }))) && {class: span2_class_value},
            dirty[1] & 4194304 && prefixFilter2(ctx2[53], "dropdownIcon$")
          ]));
          if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & 524288)
            useActions_action_2.update.call(null, ctx2[19]);
          if (ctx2[7] !== "outlined" && ctx2[5]) {
            if (if_block4) {
              if_block4.p(ctx2, dirty);
              if (dirty[0] & 160) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_1$1(ctx2);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div0, null);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
          set_attributes(div0, div0_data = get_spread_update(div0_levels, [
            (!current || dirty[0] & 16384 && div0_class_value !== (div0_class_value = classMap({
              [ctx2[14]]: true,
              "mdc-select__anchor": true
            }))) && {class: div0_class_value},
            (!current || dirty[0] & 1024 && div0_aria_required_value !== (div0_aria_required_value = ctx2[10] ? "true" : null)) && {
              "aria-required": div0_aria_required_value
            },
            (!current || dirty[0] & 64 && div0_aria_disabled_value !== (div0_aria_disabled_value = ctx2[6] ? "true" : null)) && {
              "aria-disabled": div0_aria_disabled_value
            },
            (!current || dirty[1] & 1) && {"aria-controls": ctx2[31]},
            (!current || dirty[1] & 1) && {"aria-describedby": ctx2[31]},
            dirty[0] & 536870912 && ctx2[29],
            dirty[1] & 4194304 && prefixFilter2(ctx2[53], "anchor$")
          ]));
          if (useActions_action_3 && is_function(useActions_action_3.update) && dirty[0] & 8192)
            useActions_action_3.update.call(null, ctx2[13]);
          const menu_changes = dirty[0] & 2097152 | dirty[1] & 4194332 ? get_spread_update(menu_spread_levels, [
            dirty[0] & 2097152 | dirty[1] & 4 && {
              class: classMap({
                [ctx2[21]]: true,
                "mdc-select__menu": true,
                ...ctx2[33]
              })
            },
            menu_spread_levels[1],
            menu_spread_levels[2],
            dirty[1] & 8 && {anchorElement: ctx2[34]},
            dirty[1] & 16 && {anchorCorner: ctx2[35]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter2(ctx2[53], "menu$"))
          ]) : {};
          if (dirty[0] & 16777216 | dirty[1] & 4194400 | dirty[2] & 33554432) {
            menu_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_open && dirty[1] & 2) {
            updating_open = true;
            menu_changes.open = ctx2[32];
            add_flush_callback(() => updating_open = false);
          }
          menu.$set(menu_changes);
          set_attributes(div1, div1_data = get_spread_update(div1_levels, [
            (!current || dirty[0] & 71305162 | dirty[1] & 2097154 && div1_class_value !== (div1_class_value = classMap({
              [ctx2[3]]: true,
              "mdc-select": true,
              "mdc-select--required": ctx2[10],
              "mdc-select--disabled": ctx2[6],
              "mdc-select--filled": ctx2[7] === "filled",
              "mdc-select--outlined": ctx2[7] === "outlined",
              "smui-select--standard": ctx2[7] === "standard",
              "mdc-select--with-leading-icon": ctx2[22] === ctx2[45] ? ctx2[52].leadingIcon : ctx2[22],
              "mdc-select--no-label": ctx2[8] || ctx2[9] == null && !ctx2[52].label,
              "mdc-select--invalid": ctx2[1] !== ctx2[45] && ctx2[1],
              "mdc-select--activated": ctx2[32],
              "mdc-data-table__pagination-rows-per-page-select": ctx2[46] === "data-table:pagination",
              ...ctx2[26]
            }))) && {class: div1_class_value},
            (!current || dirty[0] & 134217744 && div1_style_value !== (div1_style_value = Object.entries(ctx2[27]).map(func6).concat([ctx2[4]]).join(" "))) && {style: div1_style_value},
            dirty[1] & 4194304 && exclude2(ctx2[53], [
              "input$",
              "anchor$",
              "label$",
              "outline$",
              "selectedTextContainer$",
              "selectedText$",
              "dropdownIcon$",
              "ripple$",
              "menu$",
              "list$",
              "helperText$"
            ])
          ]));
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 128)
            Ripple_action.update.call(null, {
              ripple: ctx2[7] === "filled",
              unbounded: false,
              addClass: ctx2[49],
              removeClass: ctx2[50],
              addStyle: ctx2[51]
            });
          if (useActions_action_4 && is_function(useActions_action_4.update) && dirty[0] & 4)
            useActions_action_4.update.call(null, ctx2[2]);
          if (ctx2[52].helperText) {
            if (if_block5) {
              if_block5.p(ctx2, dirty);
              if (dirty[1] & 2097152) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block$13(ctx2);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(leadingIcon_slot, local);
          transition_in(if_block4);
          transition_in(menu.$$.fragment, local);
          transition_in(if_block5);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(leadingIcon_slot, local);
          transition_out(if_block4);
          transition_out(menu.$$.fragment, local);
          transition_out(if_block5);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
          if (if_block2)
            if_block2.d();
          if (if_block3)
            if_block3.d();
          if (leadingIcon_slot)
            leadingIcon_slot.d(detaching);
          ctx[67](null);
          if (if_block4)
            if_block4.d();
          ctx[69](null);
          destroy_component(menu);
          ctx[81](null);
          if (detaching)
            detach_dev(t9);
          if (if_block5)
            if_block5.d(detaching);
          if (detaching)
            detach_dev(if_block5_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    function getNormalizedXCoordinate(evt) {
      const targetClientRect = evt.target.getBoundingClientRect();
      const xCoordinate = isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
      return xCoordinate - targetClientRect.left;
    }
    function isTouchEvent(evt) {
      return !!evt.touches;
    }
    var func6 = ([name2, value]) => `${name2}: ${value};`;
    function instance_16($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "ripple",
        "disabled",
        "variant",
        "noLabel",
        "label",
        "value",
        "key",
        "dirty",
        "invalid",
        "updateInvalid",
        "required",
        "inputId",
        "hiddenInput",
        "anchor$use",
        "anchor$class",
        "selectedTextContainer$use",
        "selectedTextContainer$class",
        "selectedText$use",
        "selectedText$class",
        "dropdownIcon$use",
        "dropdownIcon$class",
        "menu$class",
        "withLeadingIcon",
        "focus",
        "layout",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $selectedTextStore;
      let $valueStore;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Select", slots, ["label", "leadingIcon", "default", "helperText"]);
      const $$slots = compute_slots(slots);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      const uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {ripple = true} = $$props;
      let {disabled = false} = $$props;
      let {variant = "standard"} = $$props;
      let {noLabel = false} = $$props;
      let {label = null} = $$props;
      let {value = ""} = $$props;
      let {key = (item) => item} = $$props;
      let {dirty = false} = $$props;
      let {invalid = uninitializedValue} = $$props;
      let {updateInvalid = invalid === uninitializedValue} = $$props;
      let {required = false} = $$props;
      let {inputId = "SMUI-select-" + counter3++} = $$props;
      let {hiddenInput = false} = $$props;
      let {anchor$use = []} = $$props;
      let {anchor$class = ""} = $$props;
      let {selectedTextContainer$use = []} = $$props;
      let {selectedTextContainer$class = ""} = $$props;
      let {selectedText$use = []} = $$props;
      let {selectedText$class = ""} = $$props;
      let {dropdownIcon$use = []} = $$props;
      let {dropdownIcon$class = ""} = $$props;
      let {menu$class = ""} = $$props;
      let {withLeadingIcon = uninitializedValue} = $$props;
      let element2;
      let instance8;
      let internalClasses = {};
      let internalStyles = {};
      let selectAnchor;
      let selectAnchorAttrs = {};
      let selectText;
      let selectedIndex = -1;
      let helperId;
      let addLayoutListener = getContext("SMUI:addLayoutListener");
      let removeLayoutListener;
      let menuOpen = false;
      let menuClasses = {};
      let anchorElement;
      let anchorCorner;
      let wrapFocus = false;
      let list;
      let context = getContext("SMUI:select:context");
      let leadingIcon;
      let helperText;
      let floatingLabel;
      let lineRipple;
      let notchedOutline;
      setContext("SMUI:list:role", "");
      setContext("SMUI:list:nav", false);
      const selectedTextStore = writable("");
      validate_store(selectedTextStore, "selectedTextStore");
      component_subscribe($$self, selectedTextStore, (value2) => $$invalidate(43, $selectedTextStore = value2));
      setContext("SMUI:select:selectedText", selectedTextStore);
      const valueStore = writable(value);
      validate_store(valueStore, "valueStore");
      component_subscribe($$self, valueStore, (value2) => $$invalidate(89, $valueStore = value2));
      setContext("SMUI:select:value", valueStore);
      let previousSelectedIndex = selectedIndex;
      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }
      onMount(() => {
        $$invalidate(23, instance8 = new MDCSelectFoundation({
          getMenuItemAttr: (menuItem, attr2) => menuItem.getAttribute(attr2),
          setSelectedText: (text2) => {
            set_store_value(selectedTextStore, $selectedTextStore = text2, $selectedTextStore);
          },
          isSelectAnchorFocused: () => document.activeElement === selectAnchor,
          getSelectAnchorAttr,
          setSelectAnchorAttr: addSelectAnchorAttr,
          removeSelectAnchorAttr,
          addMenuClass,
          removeMenuClass,
          openMenu: () => {
            $$invalidate(32, menuOpen = true);
          },
          closeMenu: () => {
            $$invalidate(32, menuOpen = false);
          },
          getAnchorElement: () => selectAnchor,
          setMenuAnchorElement: (value2) => {
            $$invalidate(34, anchorElement = value2);
          },
          setMenuAnchorCorner: (value2) => {
            $$invalidate(35, anchorCorner = value2);
          },
          setMenuWrapFocus: (value2) => {
            $$invalidate(36, wrapFocus = value2);
          },
          getSelectedIndex: () => selectedIndex,
          setSelectedIndex: (index) => {
            $$invalidate(60, previousSelectedIndex = index);
            $$invalidate(24, selectedIndex = index);
            $$invalidate(0, value = getMenuItemValues()[selectedIndex]);
          },
          focusMenuItemAtIndex: (index) => {
            list.focusItemAtIndex(index);
          },
          getMenuItemCount: () => list.items.length,
          getMenuItemValues: () => getMenuItemValues().map(key),
          getMenuItemTextAtIndex: (index) => list.getPrimaryTextAtIndex(index),
          isTypeaheadInProgress: () => list.typeaheadInProgress,
          typeaheadMatchItem: (nextChar, startingIndex) => list.typeaheadMatchItem(nextChar, startingIndex),
          addClass,
          removeClass,
          hasClass,
          setRippleCenter: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
          activateBottomLine: () => lineRipple && lineRipple.activate(),
          deactivateBottomLine: () => lineRipple && lineRipple.deactivate(),
          notifyChange: (_selectedValue) => {
            $$invalidate(54, dirty = true);
            if (updateInvalid) {
              $$invalidate(1, invalid = !instance8.isValid());
            }
            dispatch(getElement(), "MDCSelect:change", {value, index: selectedIndex});
          },
          hasOutline: () => !!notchedOutline,
          notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth),
          closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
          hasLabel: () => !!floatingLabel,
          floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
          getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
          setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired)
        }, {
          get helperText() {
            return helperText;
          },
          get leadingIcon() {
            return leadingIcon;
          }
        }));
        $$invalidate(24, selectedIndex = getMenuItemValues().indexOf(value));
        instance8.init();
        return () => {
          instance8.destroy();
        };
      });
      onDestroy(() => {
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(26, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(26, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name2, value2) {
        if (internalStyles[name2] != value2) {
          if (value2 === "" || value2 == null) {
            delete internalStyles[name2];
            $$invalidate(27, internalStyles);
          } else {
            $$invalidate(27, internalStyles[name2] = value2, internalStyles);
          }
        }
      }
      function addMenuClass(className2) {
        if (!menuClasses[className2]) {
          $$invalidate(33, menuClasses[className2] = true, menuClasses);
        }
      }
      function removeMenuClass(className2) {
        if (!(className2 in menuClasses) || menuClasses[className2]) {
          $$invalidate(33, menuClasses[className2] = false, menuClasses);
        }
      }
      function getSelectAnchorAttr(name2) {
        return name2 in selectAnchorAttrs ? selectAnchorAttrs[name2] : getElement().getAttribute(name2);
      }
      function addSelectAnchorAttr(name2, value2) {
        if (selectAnchorAttrs[name2] !== value2) {
          $$invalidate(29, selectAnchorAttrs[name2] = value2, selectAnchorAttrs);
        }
      }
      function removeSelectAnchorAttr(name2) {
        if (!(name2 in selectAnchorAttrs) || selectAnchorAttrs[name2] != null) {
          $$invalidate(29, selectAnchorAttrs[name2] = void 0, selectAnchorAttrs);
        }
      }
      function getMenuItemValues() {
        return list.getOrderedList().map((accessor) => accessor.getValue());
      }
      function focus() {
        selectAnchor.focus();
      }
      function layout() {
        instance8.layout();
      }
      function getElement() {
        return element2;
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function floatinglabel_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          floatingLabel = $$value;
          $$invalidate(40, floatingLabel);
        });
      }
      function floatinglabel_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          floatingLabel = $$value;
          $$invalidate(40, floatingLabel);
        });
      }
      function notchedoutline_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          notchedOutline = $$value;
          $$invalidate(42, notchedOutline);
        });
      }
      function span0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          selectText = $$value;
          $$invalidate(30, selectText);
        });
      }
      function lineripple_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          lineRipple = $$value;
          $$invalidate(41, lineRipple);
        });
      }
      function div0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          selectAnchor = $$value;
          $$invalidate(28, selectAnchor);
        });
      }
      const focus_handler_1 = () => instance8 && instance8.handleFocus();
      const blur_handler_1 = () => instance8 && instance8.handleBlur();
      const click_handler = (event) => {
        selectAnchor.focus();
        if (instance8) {
          instance8.handleClick(getNormalizedXCoordinate(event));
        }
      };
      const keydown_handler = (event) => instance8 && instance8.handleKeydown(event);
      function list_1_selectedIndex_binding(value2) {
        selectedIndex = value2;
        $$invalidate(24, selectedIndex);
      }
      const SMUI_list_mount_handler = (event) => $$invalidate(37, list = event.detail);
      function menu_open_binding(value2) {
        menuOpen = value2;
        $$invalidate(32, menuOpen);
      }
      const MDCMenu_selected_handler = (event) => instance8 && instance8.handleMenuItemAction(event.detail.index);
      const MDCMenuSurface_closing_handler = () => instance8 && instance8.handleMenuClosing();
      const MDCMenuSurface_closed_handler = () => instance8 && instance8.handleMenuClosed();
      const MDCMenuSurface_opened_handler = () => instance8 && instance8.handleMenuOpened();
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(25, element2);
        });
      }
      const SMUI_select_leading_icon_mount_handler = (event) => $$invalidate(38, leadingIcon = event.detail);
      const SMUI_select_leading_icon_unmount_handler = () => $$invalidate(38, leadingIcon = void 0);
      const SMUI_select_helper_text_id_handler = (event) => $$invalidate(31, helperId = event.detail);
      const SMUI_select_helper_text_mount_handler = (event) => $$invalidate(39, helperText = event.detail);
      const SMUI_select_helper_text_unmount_handler = () => {
        $$invalidate(31, helperId = void 0);
        $$invalidate(39, helperText = void 0);
      };
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(3, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(4, style = $$new_props.style);
        if ("ripple" in $$new_props)
          $$invalidate(5, ripple = $$new_props.ripple);
        if ("disabled" in $$new_props)
          $$invalidate(6, disabled = $$new_props.disabled);
        if ("variant" in $$new_props)
          $$invalidate(7, variant = $$new_props.variant);
        if ("noLabel" in $$new_props)
          $$invalidate(8, noLabel = $$new_props.noLabel);
        if ("label" in $$new_props)
          $$invalidate(9, label = $$new_props.label);
        if ("value" in $$new_props)
          $$invalidate(0, value = $$new_props.value);
        if ("key" in $$new_props)
          $$invalidate(55, key = $$new_props.key);
        if ("dirty" in $$new_props)
          $$invalidate(54, dirty = $$new_props.dirty);
        if ("invalid" in $$new_props)
          $$invalidate(1, invalid = $$new_props.invalid);
        if ("updateInvalid" in $$new_props)
          $$invalidate(56, updateInvalid = $$new_props.updateInvalid);
        if ("required" in $$new_props)
          $$invalidate(10, required = $$new_props.required);
        if ("inputId" in $$new_props)
          $$invalidate(11, inputId = $$new_props.inputId);
        if ("hiddenInput" in $$new_props)
          $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
        if ("anchor$use" in $$new_props)
          $$invalidate(13, anchor$use = $$new_props.anchor$use);
        if ("anchor$class" in $$new_props)
          $$invalidate(14, anchor$class = $$new_props.anchor$class);
        if ("selectedTextContainer$use" in $$new_props)
          $$invalidate(15, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
        if ("selectedTextContainer$class" in $$new_props)
          $$invalidate(16, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
        if ("selectedText$use" in $$new_props)
          $$invalidate(17, selectedText$use = $$new_props.selectedText$use);
        if ("selectedText$class" in $$new_props)
          $$invalidate(18, selectedText$class = $$new_props.selectedText$class);
        if ("dropdownIcon$use" in $$new_props)
          $$invalidate(19, dropdownIcon$use = $$new_props.dropdownIcon$use);
        if ("dropdownIcon$class" in $$new_props)
          $$invalidate(20, dropdownIcon$class = $$new_props.dropdownIcon$class);
        if ("menu$class" in $$new_props)
          $$invalidate(21, menu$class = $$new_props.menu$class);
        if ("withLeadingIcon" in $$new_props)
          $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
        if ("$$scope" in $$new_props)
          $$invalidate(87, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCSelectFoundation,
        onMount,
        onDestroy,
        getContext,
        setContext,
        writable,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        exclude: exclude2,
        prefixFilter: prefixFilter2,
        useActions,
        dispatch,
        Ripple,
        Anchor,
        Menu,
        List,
        FloatingLabel,
        LineRipple,
        NotchedOutline,
        HelperText,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        ripple,
        disabled,
        variant,
        noLabel,
        label,
        value,
        key,
        dirty,
        invalid,
        updateInvalid,
        required,
        inputId,
        hiddenInput,
        anchor$use,
        anchor$class,
        selectedTextContainer$use,
        selectedTextContainer$class,
        selectedText$use,
        selectedText$class,
        dropdownIcon$use,
        dropdownIcon$class,
        menu$class,
        withLeadingIcon,
        element: element2,
        instance: instance8,
        internalClasses,
        internalStyles,
        selectAnchor,
        selectAnchorAttrs,
        selectText,
        selectedIndex,
        helperId,
        addLayoutListener,
        removeLayoutListener,
        menuOpen,
        menuClasses,
        anchorElement,
        anchorCorner,
        wrapFocus,
        list,
        context,
        leadingIcon,
        helperText,
        floatingLabel,
        lineRipple,
        notchedOutline,
        selectedTextStore,
        valueStore,
        previousSelectedIndex,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        addMenuClass,
        removeMenuClass,
        getSelectAnchorAttr,
        addSelectAnchorAttr,
        removeSelectAnchorAttr,
        getMenuItemValues,
        getNormalizedXCoordinate,
        isTouchEvent,
        focus,
        layout,
        getElement,
        $selectedTextStore,
        $valueStore
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(3, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(4, style = $$new_props.style);
        if ("ripple" in $$props)
          $$invalidate(5, ripple = $$new_props.ripple);
        if ("disabled" in $$props)
          $$invalidate(6, disabled = $$new_props.disabled);
        if ("variant" in $$props)
          $$invalidate(7, variant = $$new_props.variant);
        if ("noLabel" in $$props)
          $$invalidate(8, noLabel = $$new_props.noLabel);
        if ("label" in $$props)
          $$invalidate(9, label = $$new_props.label);
        if ("value" in $$props)
          $$invalidate(0, value = $$new_props.value);
        if ("key" in $$props)
          $$invalidate(55, key = $$new_props.key);
        if ("dirty" in $$props)
          $$invalidate(54, dirty = $$new_props.dirty);
        if ("invalid" in $$props)
          $$invalidate(1, invalid = $$new_props.invalid);
        if ("updateInvalid" in $$props)
          $$invalidate(56, updateInvalid = $$new_props.updateInvalid);
        if ("required" in $$props)
          $$invalidate(10, required = $$new_props.required);
        if ("inputId" in $$props)
          $$invalidate(11, inputId = $$new_props.inputId);
        if ("hiddenInput" in $$props)
          $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
        if ("anchor$use" in $$props)
          $$invalidate(13, anchor$use = $$new_props.anchor$use);
        if ("anchor$class" in $$props)
          $$invalidate(14, anchor$class = $$new_props.anchor$class);
        if ("selectedTextContainer$use" in $$props)
          $$invalidate(15, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
        if ("selectedTextContainer$class" in $$props)
          $$invalidate(16, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
        if ("selectedText$use" in $$props)
          $$invalidate(17, selectedText$use = $$new_props.selectedText$use);
        if ("selectedText$class" in $$props)
          $$invalidate(18, selectedText$class = $$new_props.selectedText$class);
        if ("dropdownIcon$use" in $$props)
          $$invalidate(19, dropdownIcon$use = $$new_props.dropdownIcon$use);
        if ("dropdownIcon$class" in $$props)
          $$invalidate(20, dropdownIcon$class = $$new_props.dropdownIcon$class);
        if ("menu$class" in $$props)
          $$invalidate(21, menu$class = $$new_props.menu$class);
        if ("withLeadingIcon" in $$props)
          $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
        if ("element" in $$props)
          $$invalidate(25, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(23, instance8 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(26, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(27, internalStyles = $$new_props.internalStyles);
        if ("selectAnchor" in $$props)
          $$invalidate(28, selectAnchor = $$new_props.selectAnchor);
        if ("selectAnchorAttrs" in $$props)
          $$invalidate(29, selectAnchorAttrs = $$new_props.selectAnchorAttrs);
        if ("selectText" in $$props)
          $$invalidate(30, selectText = $$new_props.selectText);
        if ("selectedIndex" in $$props)
          $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
        if ("helperId" in $$props)
          $$invalidate(31, helperId = $$new_props.helperId);
        if ("addLayoutListener" in $$props)
          addLayoutListener = $$new_props.addLayoutListener;
        if ("removeLayoutListener" in $$props)
          removeLayoutListener = $$new_props.removeLayoutListener;
        if ("menuOpen" in $$props)
          $$invalidate(32, menuOpen = $$new_props.menuOpen);
        if ("menuClasses" in $$props)
          $$invalidate(33, menuClasses = $$new_props.menuClasses);
        if ("anchorElement" in $$props)
          $$invalidate(34, anchorElement = $$new_props.anchorElement);
        if ("anchorCorner" in $$props)
          $$invalidate(35, anchorCorner = $$new_props.anchorCorner);
        if ("wrapFocus" in $$props)
          $$invalidate(36, wrapFocus = $$new_props.wrapFocus);
        if ("list" in $$props)
          $$invalidate(37, list = $$new_props.list);
        if ("context" in $$props)
          $$invalidate(46, context = $$new_props.context);
        if ("leadingIcon" in $$props)
          $$invalidate(38, leadingIcon = $$new_props.leadingIcon);
        if ("helperText" in $$props)
          $$invalidate(39, helperText = $$new_props.helperText);
        if ("floatingLabel" in $$props)
          $$invalidate(40, floatingLabel = $$new_props.floatingLabel);
        if ("lineRipple" in $$props)
          $$invalidate(41, lineRipple = $$new_props.lineRipple);
        if ("notchedOutline" in $$props)
          $$invalidate(42, notchedOutline = $$new_props.notchedOutline);
        if ("previousSelectedIndex" in $$props)
          $$invalidate(60, previousSelectedIndex = $$new_props.previousSelectedIndex);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 25165825 | $$self.$$.dirty[1] & 536870912) {
          if (previousSelectedIndex !== selectedIndex) {
            $$invalidate(60, previousSelectedIndex = selectedIndex);
            if (instance8) {
              instance8.setSelectedIndex(selectedIndex, false, true);
            } else {
              const values = getMenuItemValues();
              if (value !== values[selectedIndex]) {
                $$invalidate(0, value = values[selectedIndex]);
              }
            }
          }
        }
        if ($$self.$$.dirty[0] & 1) {
          set_store_value(valueStore, $valueStore = value, $valueStore);
        }
        if ($$self.$$.dirty[0] & 8388609 | $$self.$$.dirty[1] & 16777216) {
          if (instance8 && instance8.getValue() !== key(value)) {
            instance8.setValue(key(value));
          }
        }
        if ($$self.$$.dirty[0] & 8388672) {
          if (instance8 && instance8.getDisabled() !== disabled) {
            instance8.setDisabled(disabled);
          }
        }
        if ($$self.$$.dirty[0] & 8388610 | $$self.$$.dirty[1] & 41943040) {
          if (instance8 && dirty && instance8.isValid() !== !invalid) {
            if (updateInvalid) {
              $$invalidate(1, invalid = !instance8.isValid());
            } else {
              instance8.setValid(!invalid);
            }
          }
        }
        if ($$self.$$.dirty[0] & 8389632) {
          if (instance8 && instance8.getRequired() !== required) {
            instance8.setRequired(required);
          }
        }
      };
      return [
        value,
        invalid,
        use2,
        className,
        style,
        ripple,
        disabled,
        variant,
        noLabel,
        label,
        required,
        inputId,
        hiddenInput,
        anchor$use,
        anchor$class,
        selectedTextContainer$use,
        selectedTextContainer$class,
        selectedText$use,
        selectedText$class,
        dropdownIcon$use,
        dropdownIcon$class,
        menu$class,
        withLeadingIcon,
        instance8,
        selectedIndex,
        element2,
        internalClasses,
        internalStyles,
        selectAnchor,
        selectAnchorAttrs,
        selectText,
        helperId,
        menuOpen,
        menuClasses,
        anchorElement,
        anchorCorner,
        wrapFocus,
        list,
        leadingIcon,
        helperText,
        floatingLabel,
        lineRipple,
        notchedOutline,
        $selectedTextStore,
        forwardEvents,
        uninitializedValue,
        context,
        selectedTextStore,
        valueStore,
        addClass,
        removeClass,
        addStyle,
        $$slots,
        $$restProps,
        dirty,
        key,
        updateInvalid,
        focus,
        layout,
        getElement,
        previousSelectedIndex,
        slots,
        focus_handler,
        blur_handler,
        floatinglabel_binding,
        floatinglabel_binding_1,
        notchedoutline_binding,
        span0_binding,
        lineripple_binding,
        div0_binding,
        focus_handler_1,
        blur_handler_1,
        click_handler,
        keydown_handler,
        list_1_selectedIndex_binding,
        SMUI_list_mount_handler,
        menu_open_binding,
        MDCMenu_selected_handler,
        MDCMenuSurface_closing_handler,
        MDCMenuSurface_closed_handler,
        MDCMenuSurface_opened_handler,
        div1_binding,
        SMUI_select_leading_icon_mount_handler,
        SMUI_select_leading_icon_unmount_handler,
        SMUI_select_helper_text_id_handler,
        SMUI_select_helper_text_mount_handler,
        SMUI_select_helper_text_unmount_handler,
        $$scope
      ];
    }
    var Select = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_16, create_fragment$28, safe_not_equal, {
          use: 2,
          class: 3,
          style: 4,
          ripple: 5,
          disabled: 6,
          variant: 7,
          noLabel: 8,
          label: 9,
          value: 0,
          key: 55,
          dirty: 54,
          invalid: 1,
          updateInvalid: 56,
          required: 10,
          inputId: 11,
          hiddenInput: 12,
          anchor$use: 13,
          anchor$class: 14,
          selectedTextContainer$use: 15,
          selectedTextContainer$class: 16,
          selectedText$use: 17,
          selectedText$class: 18,
          dropdownIcon$use: 19,
          dropdownIcon$class: 20,
          menu$class: 21,
          withLeadingIcon: 22,
          focus: 57,
          layout: 58,
          getElement: 59
        }, null, [-1, -1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Select",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ripple() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ripple(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get noLabel() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set noLabel(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get label() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set label(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get key() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set key(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dirty() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dirty(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get invalid() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set invalid(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get updateInvalid() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set updateInvalid(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get required() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set required(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get inputId() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set inputId(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get hiddenInput() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set hiddenInput(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get anchor$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set anchor$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get anchor$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set anchor$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedTextContainer$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedTextContainer$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedTextContainer$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedTextContainer$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedText$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedText$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedText$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedText$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dropdownIcon$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dropdownIcon$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dropdownIcon$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dropdownIcon$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get menu$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set menu$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get withLeadingIcon() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set withLeadingIcon(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get focus() {
        return this.$$.ctx[57];
      }
      set focus(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get layout() {
        return this.$$.ctx[58];
      }
      set layout(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[59];
      }
      set getElement(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function create_default_slot$14(ctx) {
      let current;
      const default_slot_template = ctx[11].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 8192)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$14.name,
        type: "slot",
        source: "(1:0) <Item   bind:this={element}   use={[forwardEvents, ...use]}   data-value={value}   {value}   {selected}   {...$$restProps}>",
        ctx
      });
      return block;
    }
    function create_fragment$18(ctx) {
      let item;
      let current;
      const item_spread_levels = [
        {
          use: [ctx[4], ...ctx[0]]
        },
        {"data-value": ctx[1]},
        {value: ctx[1]},
        {selected: ctx[3]},
        ctx[7]
      ];
      let item_props = {
        $$slots: {default: [create_default_slot$14]},
        $$scope: {ctx}
      };
      for (let i = 0; i < item_spread_levels.length; i += 1) {
        item_props = assign(item_props, item_spread_levels[i]);
      }
      item = new Item({props: item_props, $$inline: true});
      ctx[12](item);
      const block = {
        c: function create2() {
          create_component(item.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(item, target, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const item_changes = dirty & 155 ? get_spread_update(item_spread_levels, [
            dirty & 17 && {
              use: [ctx2[4], ...ctx2[0]]
            },
            dirty & 2 && {"data-value": ctx2[1]},
            dirty & 2 && {value: ctx2[1]},
            dirty & 8 && {selected: ctx2[3]},
            dirty & 128 && get_spread_object(ctx2[7])
          ]) : {};
          if (dirty & 8192) {
            item_changes.$$scope = {dirty, ctx: ctx2};
          }
          item.$set(item_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(item.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(item.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[12](null);
          destroy_component(item, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      let selected;
      const omit_props_names = ["use", "class", "value", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $selectedText;
      let $selectedValue;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Option", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      const className = "";
      let {value = ""} = $$props;
      let element2;
      const selectedText = getContext("SMUI:select:selectedText");
      validate_store(selectedText, "selectedText");
      component_subscribe($$self, selectedText, (value2) => $$invalidate(14, $selectedText = value2));
      const selectedValue = getContext("SMUI:select:value");
      validate_store(selectedValue, "selectedValue");
      component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
      setContext("SMUI:list:item:role", "option");
      onMount(setSelectedText);
      onDestroy(setSelectedText);
      function setSelectedText() {
        if (selected && element2) {
          set_store_value(selectedText, $selectedText = element2.getPrimaryText(), $selectedText);
        }
      }
      function getElement() {
        return element2.getElement();
      }
      function item_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("value" in $$new_props)
          $$invalidate(1, value = $$new_props.value);
        if ("$$scope" in $$new_props)
          $$invalidate(13, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        onMount,
        onDestroy,
        getContext,
        setContext,
        get_current_component,
        forwardEventsBuilder,
        Item,
        forwardEvents,
        use: use2,
        className,
        value,
        element: element2,
        selectedText,
        selectedValue,
        setSelectedText,
        getElement,
        selected,
        $selectedText,
        $selectedValue
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("value" in $$props)
          $$invalidate(1, value = $$new_props.value);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("selected" in $$props)
          $$invalidate(3, selected = $$new_props.selected);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1026) {
          $$invalidate(3, selected = value != null && value !== "" && $selectedValue === value);
        }
      };
      return [
        use2,
        value,
        element2,
        selected,
        forwardEvents,
        selectedText,
        selectedValue,
        $$restProps,
        className,
        getElement,
        $selectedValue,
        slots,
        item_binding,
        $$scope
      ];
    }
    var Option = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {
          use: 0,
          class: 8,
          value: 1,
          getElement: 9
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Option",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        return this.$$.ctx[8];
      }
      set class(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[9];
      }
      set getElement(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_12, console: console_12} = globals;
    var file10 = "src/pages/settings.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-19l48d9", '.file.svelte-19l48d9.svelte-19l48d9{opacity:0;width:0.1px;height:0.1px;position:absolute}input.svelte-19l48d9:hover+label.svelte-19l48d9,input.svelte-19l48d9:focus+label.svelte-19l48d9{transform:scale(1.015);filter:brightness(104%)}.file-input.svelte-19l48d9 label.svelte-19l48d9{display:block;position:relative;width:fit-content;background:"var(--mdc-theme-callout)";box-shadow:0 2px 4px rgba(0, 0, 0, 0.4);display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform .2s ease-out}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dGluZ3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNDLEtBQUEsOEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLENBQ1YsS0FBQSxDQUFBLEtBQVksQ0FDWixNQUFBLENBQUEsS0FBYSxDQUNiLFFBQUEsQ0FBQSxRQUFrQixBQUNuQixDQUFBLEFBQ0Esb0JBQUEsTUFBQSxDQUFBLG9CQUFBLGlEQUVDLFNBQUEsQ0FBQSxNQUFBLEtBQUEsQ0FBdUIsQ0FDdkIsTUFBQSxDQUFBLFdBQUEsSUFBQSxDQUF3QixBQUN6QixDQUFBLEFBQ0EsMEJBQUEsQ0FBQSxLQUFBLGVBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxLQUFjLENBQ2QsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEtBQUEsQ0FBQSxXQUFrQixDQUNsQixVQUFBLENBQUEsMEJBQXNDLENBQ3RDLFVBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBd0MsQ0FDeEMsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsZUFBQSxDQUFBLE1BQXVCLENBQ3ZCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsVUFBQSxDQUFBLFNBQUEsQ0FBQSxHQUFBLENBQUEsUUFBa0MsQUFDbkMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJzcmMvcGFnZXMvc3JjL3BhZ2VzL3NldHRpbmdzLnN2ZWx0ZSJdfQ== */');
    }
    function get_each_context3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[14] = list[i];
      return child_ctx;
    }
    function create_if_block7(ctx) {
      let section;
      let paper;
      let section_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section = element("section");
          create_component(paper.$$.fragment);
          attr_dev(section, "class", "flex flex-col gap-4 md:w-10/12 w-full mx-auto ");
          add_location(section, file10, 103, 0, 2495);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          mount_component(paper, section, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const paper_changes = {};
          if (dirty & 131075) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!section_intro) {
            add_render_callback(() => {
              section_intro = create_in_transition(section, fade, {});
              section_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block7.name,
        type: "if",
        source: "(103:0) {#if Object.keys($userSettings).length > 0}",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Einstellungen";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file10, 105, 9, 2600);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: "(106:2) <Title>",
        ctx
      });
      return block;
    }
    function create_if_block_24(ctx) {
      let div1;
      let h2;
      let t1;
      let div0;
      let p;
      let t2_value = ctx[1]?.register_plugin_name + "";
      let t2;
      let t3;
      let br0;
      let t4;
      let t5;
      let br1;
      let if_block = ctx[1]?.register_plugin === "plugins.manual.manual" && create_if_block_33(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          h2 = element("h2");
          h2.textContent = "Kassensystem";
          t1 = space();
          div0 = element("div");
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          br0 = element("br");
          t4 = space();
          if (if_block)
            if_block.c();
          t5 = space();
          br1 = element("br");
          add_location(h2, file10, 114, 6, 2905);
          add_location(p, file10, 116, 7, 2946);
          add_location(br0, file10, 117, 7, 2998);
          add_location(br1, file10, 138, 7, 3745);
          add_location(div0, file10, 115, 6, 2933);
          attr_dev(div1, "class", "flex justify-between");
          add_location(div1, file10, 113, 5, 2864);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h2);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div0, p);
          append_dev(p, t2);
          append_dev(div0, t3);
          append_dev(div0, br0);
          append_dev(div0, t4);
          if (if_block)
            if_block.m(div0, null);
          append_dev(div0, t5);
          append_dev(div0, br1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 2 && t2_value !== (t2_value = ctx2[1]?.register_plugin_name + ""))
            set_data_dev(t2, t2_value);
          if (ctx2[1]?.register_plugin === "plugins.manual.manual") {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block_33(ctx2);
              if_block.c();
              if_block.m(div0, t5);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block)
            if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_24.name,
        type: "if",
        source: "(113:4) {#if $userSettings?.register_plugin_name}",
        ctx
      });
      return block;
    }
    function create_if_block_33(ctx) {
      let div;
      let input;
      let t0;
      let label;
      let t2;
      let if_block_anchor;
      let mounted;
      let dispose;
      function select_block_type(ctx2, dirty) {
        if (ctx2[0] && ctx2[0][0])
          return create_if_block_43;
        return create_else_block_13;
      }
      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          div = element("div");
          input = element("input");
          t0 = space();
          label = element("label");
          label.textContent = "DATEI HOCHLADEN";
          t2 = space();
          if_block.c();
          if_block_anchor = empty();
          attr_dev(input, "type", "file");
          attr_dev(input, "id", "file");
          attr_dev(input, "class", "file svelte-19l48d9");
          attr_dev(input, "accept", ".xls,.xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel");
          add_location(input, file10, 120, 9, 3117);
          attr_dev(label, "for", "file");
          set_style(label, "background", "var(--mdc-theme-callout)");
          attr_dev(label, "class", "px-4 py-2 m-0 text-white text-sm font-medium tracking-widest rounded-sm svelte-19l48d9");
          add_location(label, file10, 127, 9, 3357);
          attr_dev(div, "class", "file-input svelte-19l48d9");
          add_location(div, file10, 119, 8, 3083);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input);
          append_dev(div, t0);
          append_dev(div, label);
          insert_dev(target, t2, anchor);
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          if (!mounted) {
            dispose = listen_dev(input, "change", ctx[3]);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t2);
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_33.name,
        type: "if",
        source: '(119:7) {#if $userSettings?.register_plugin===\\"plugins.manual.manual\\"}',
        ctx
      });
      return block;
    }
    function create_else_block_13(ctx) {
      let p;
      const block = {
        c: function create2() {
          p = element("p");
          p.textContent = "(.xlsx, .xls)";
          set_style(p, "text-align", "center");
          add_location(p, file10, 135, 9, 3662);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_13.name,
        type: "else",
        source: "(135:8) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_43(ctx) {
      let p;
      let t_value = ctx[0][0].name + "";
      let t;
      const block = {
        c: function create2() {
          p = element("p");
          t = text(t_value);
          add_location(p, file10, 133, 9, 3614);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1 && t_value !== (t_value = ctx2[0][0].name + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_43.name,
        type: "if",
        source: "(133:8) {#if files && files[0]}",
        ctx
      });
      return block;
    }
    function create_else_block4(ctx) {
      let option;
      let current;
      option = new Option({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(option.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(option, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const option_changes = {};
          if (dirty & 131072) {
            option_changes.$$scope = {dirty, ctx: ctx2};
          }
          option.$set(option_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(option.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(option.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(option, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block4.name,
        type: "else",
        source: "(158:8) {:else}",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Problem Loading");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(159:9) <Option>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t_value = ctx[14].store_name + "";
      let t;
      const block = {
        c: function create2() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 2 && t_value !== (t_value = ctx2[14].store_name + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: "(153:9) <Option           value={s.store}           on:SMUI:action={() => changeStore(s)}           >",
        ctx
      });
      return block;
    }
    function create_each_block3(ctx) {
      let option;
      let current;
      function SMUI_action_handler() {
        return ctx[4](ctx[14]);
      }
      option = new Option({
        props: {
          value: ctx[14].store,
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      option.$on("SMUI:action", SMUI_action_handler);
      const block = {
        c: function create2() {
          create_component(option.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(option, target, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          const option_changes = {};
          if (dirty & 2)
            option_changes.value = ctx[14].store;
          if (dirty & 131074) {
            option_changes.$$scope = {dirty, ctx};
          }
          option.$set(option_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(option.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(option.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(option, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block3.name,
        type: "each",
        source: "(152:8) {#each $userSettings.stores as s}",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let each_1_anchor;
      let current;
      let each_value = ctx[1].stores;
      validate_each_argument(each_value);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      let each_1_else = null;
      if (!each_value.length) {
        each_1_else = create_else_block4(ctx);
      }
      const block = {
        c: function create2() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty();
          if (each_1_else) {
            each_1_else.c();
          }
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          if (each_1_else) {
            each_1_else.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 6) {
            each_value = ctx2[1].stores;
            validate_each_argument(each_value);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context3(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block3(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx2, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block4(ctx2);
              each_1_else.c();
              transition_in(each_1_else, 1);
              each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
            } else if (each_1_else) {
              group_outros();
              transition_out(each_1_else, 1, 1, () => {
                each_1_else = null;
              });
              check_outros();
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
          if (each_1_else)
            each_1_else.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: '(148:7) <Select         bind:value={$userSettings.store}         style=\\"max-width:150px;\\"        >',
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding(value) {
        ctx[6](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].tomorrow !== void 0) {
        switch_1_props.checked = ctx[1].tomorrow;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].tomorrow;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: "(181:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot_2(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "Morgen";
          attr_dev(span, "slot", "label");
          add_location(span, file10, 185, 7, 4824);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot_2.name,
        type: "slot",
        source: "(186:7) ",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding_1(value) {
        ctx[7](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].day_after_tomorrow !== void 0) {
        switch_1_props.checked = ctx[1].day_after_tomorrow;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding_1));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].day_after_tomorrow;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(190:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot_1(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "\xDCbermorgen";
          attr_dev(span, "slot", "label");
          add_location(span, file10, 194, 7, 5029);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot_1.name,
        type: "slot",
        source: "(195:7) ",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding_2(value) {
        ctx[8](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].next_seven_days !== void 0) {
        switch_1_props.checked = ctx[1].next_seven_days;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding_2));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].next_seven_days;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(199:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "N\xE4chste 7 Tage";
          attr_dev(span, "slot", "label");
          add_location(span, file10, 203, 7, 5235);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot.name,
        type: "slot",
        source: "(204:7) ",
        ctx
      });
      return block;
    }
    function create_if_block_14(ctx) {
      let br;
      let t0;
      let div2;
      let div0;
      let h2;
      let t2;
      let p;
      let t3_value = ctx[1].rows_per_page + "";
      let t3;
      let t4;
      let div1;
      let slider;
      let updating_value;
      let current;
      function slider_value_binding(value) {
        ctx[9](value);
      }
      let slider_props = {
        min: 10,
        max: 100,
        step: 10,
        discrete: true,
        "input$aria-label": "Discrete slider"
      };
      if (ctx[1].rows_per_page !== void 0) {
        slider_props.value = ctx[1].rows_per_page;
      }
      slider = new Slider({props: slider_props, $$inline: true});
      binding_callbacks.push(() => bind3(slider, "value", slider_value_binding));
      const block = {
        c: function create2() {
          br = element("br");
          t0 = space();
          div2 = element("div");
          div0 = element("div");
          h2 = element("h2");
          h2.textContent = "Zeilen pro Seite";
          t2 = space();
          p = element("p");
          t3 = text(t3_value);
          t4 = space();
          div1 = element("div");
          create_component(slider.$$.fragment);
          add_location(br, file10, 208, 6, 5353);
          add_location(h2, file10, 211, 8, 5444);
          add_location(p, file10, 212, 8, 5478);
          attr_dev(div0, "class", "flex justify-between");
          add_location(div0, file10, 210, 7, 5401);
          attr_dev(div1, "class", "w-full");
          add_location(div1, file10, 215, 7, 5537);
          attr_dev(div2, "class", "flex flex-col");
          add_location(div2, file10, 209, 6, 5366);
        },
        m: function mount(target, anchor) {
          insert_dev(target, br, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div0, h2);
          append_dev(div0, t2);
          append_dev(div0, p);
          append_dev(p, t3);
          append_dev(div2, t4);
          append_dev(div2, div1);
          mount_component(slider, div1, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1].rows_per_page + ""))
            set_data_dev(t3, t3_value);
          const slider_changes = {};
          if (!updating_value && dirty & 2) {
            updating_value = true;
            slider_changes.value = ctx2[1].rows_per_page;
            add_flush_callback(() => updating_value = false);
          }
          slider.$set(slider_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(slider.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(slider.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(br);
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(div2);
          destroy_component(slider);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_14.name,
        type: "if",
        source: "(208:5) {#if $userSettings.rows_per_page}",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let div0;
      let h20;
      let t1;
      let p0;
      let t2_value = (ctx[1]?.username || "DEMO") + "";
      let t2;
      let t3;
      let t4;
      let separator0;
      let br0;
      let t5;
      let div1;
      let h21;
      let t7;
      let p1;
      let select;
      let updating_value;
      let t8;
      let div2;
      let h22;
      let t10;
      let p2;
      let t11_value = ctx[1]?.country + "";
      let t11;
      let t12;
      let div3;
      let h23;
      let t14;
      let p3;
      let t15_value = ctx[1]?.state + "";
      let t15;
      let t16;
      let div4;
      let h24;
      let t18;
      let p4;
      let t19_value = ctx[1]?.city + "";
      let t19;
      let t20;
      let separator1;
      let br1;
      let t21;
      let h25;
      let t23;
      let div5;
      let formfield0;
      let t24;
      let div6;
      let formfield1;
      let t25;
      let div7;
      let formfield2;
      let t26;
      let if_block1_anchor;
      let current;
      let if_block0 = ctx[1]?.register_plugin_name && create_if_block_24(ctx);
      separator0 = new Separator({$$inline: true});
      function select_value_binding(value) {
        ctx[5](value);
      }
      let select_props = {
        style: "max-width:150px;",
        $$slots: {default: [create_default_slot_62]},
        $$scope: {ctx}
      };
      if (ctx[1].store !== void 0) {
        select_props.value = ctx[1].store;
      }
      select = new Select({props: select_props, $$inline: true});
      binding_callbacks.push(() => bind3(select, "value", select_value_binding));
      separator1 = new Separator({$$inline: true});
      formfield0 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot_2],
            default: [create_default_slot_52]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      formfield1 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot_1],
            default: [create_default_slot_42]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      formfield2 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot],
            default: [create_default_slot_32]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      let if_block1 = ctx[1].rows_per_page && create_if_block_14(ctx);
      const block = {
        c: function create2() {
          div0 = element("div");
          h20 = element("h2");
          h20.textContent = "angemeldete/r Benutzer*In";
          t1 = space();
          p0 = element("p");
          t2 = text(t2_value);
          t3 = space();
          if (if_block0)
            if_block0.c();
          t4 = space();
          create_component(separator0.$$.fragment);
          br0 = element("br");
          t5 = space();
          div1 = element("div");
          h21 = element("h2");
          h21.textContent = "Standort";
          t7 = space();
          p1 = element("p");
          create_component(select.$$.fragment);
          t8 = space();
          div2 = element("div");
          h22 = element("h2");
          h22.textContent = "Land";
          t10 = space();
          p2 = element("p");
          t11 = text(t11_value);
          t12 = space();
          div3 = element("div");
          h23 = element("h2");
          h23.textContent = "Bundesland";
          t14 = space();
          p3 = element("p");
          t15 = text(t15_value);
          t16 = space();
          div4 = element("div");
          h24 = element("h2");
          h24.textContent = "Stadt";
          t18 = space();
          p4 = element("p");
          t19 = text(t19_value);
          t20 = space();
          create_component(separator1.$$.fragment);
          br1 = element("br");
          t21 = space();
          h25 = element("h2");
          h25.textContent = "Vorhersage und Planung";
          t23 = space();
          div5 = element("div");
          create_component(formfield0.$$.fragment);
          t24 = space();
          div6 = element("div");
          create_component(formfield1.$$.fragment);
          t25 = space();
          div7 = element("div");
          create_component(formfield2.$$.fragment);
          t26 = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          add_location(h20, file10, 109, 5, 2719);
          add_location(p0, file10, 110, 5, 2759);
          attr_dev(div0, "class", "flex justify-between");
          add_location(div0, file10, 108, 4, 2679);
          add_location(br0, file10, 142, 17, 3804);
          add_location(h21, file10, 145, 6, 3858);
          add_location(p1, file10, 146, 6, 3882);
          attr_dev(div1, "class", "flex justify-between");
          add_location(div1, file10, 144, 5, 3817);
          add_location(h22, file10, 164, 6, 4322);
          add_location(p2, file10, 165, 6, 4342);
          attr_dev(div2, "class", "flex justify-between");
          add_location(div2, file10, 163, 5, 4281);
          add_location(h23, file10, 168, 6, 4432);
          add_location(p3, file10, 169, 6, 4458);
          attr_dev(div3, "class", "flex justify-between");
          add_location(div3, file10, 167, 5, 4391);
          add_location(h24, file10, 172, 6, 4546);
          add_location(p4, file10, 173, 6, 4567);
          attr_dev(div4, "class", "flex justify-between");
          add_location(div4, file10, 171, 5, 4505);
          add_location(br1, file10, 176, 18, 4627);
          attr_dev(h25, "class", "text-xl my-6");
          add_location(h25, file10, 178, 5, 4640);
          add_location(div5, file10, 179, 5, 4698);
          add_location(div6, file10, 188, 5, 4893);
          add_location(div7, file10, 197, 5, 5102);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, h20);
          append_dev(div0, t1);
          append_dev(div0, p0);
          append_dev(p0, t2);
          insert_dev(target, t3, anchor);
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t4, anchor);
          mount_component(separator0, target, anchor);
          insert_dev(target, br0, anchor);
          insert_dev(target, t5, anchor);
          insert_dev(target, div1, anchor);
          append_dev(div1, h21);
          append_dev(div1, t7);
          append_dev(div1, p1);
          mount_component(select, p1, null);
          insert_dev(target, t8, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, h22);
          append_dev(div2, t10);
          append_dev(div2, p2);
          append_dev(p2, t11);
          insert_dev(target, t12, anchor);
          insert_dev(target, div3, anchor);
          append_dev(div3, h23);
          append_dev(div3, t14);
          append_dev(div3, p3);
          append_dev(p3, t15);
          insert_dev(target, t16, anchor);
          insert_dev(target, div4, anchor);
          append_dev(div4, h24);
          append_dev(div4, t18);
          append_dev(div4, p4);
          append_dev(p4, t19);
          insert_dev(target, t20, anchor);
          mount_component(separator1, target, anchor);
          insert_dev(target, br1, anchor);
          insert_dev(target, t21, anchor);
          insert_dev(target, h25, anchor);
          insert_dev(target, t23, anchor);
          insert_dev(target, div5, anchor);
          mount_component(formfield0, div5, null);
          insert_dev(target, t24, anchor);
          insert_dev(target, div6, anchor);
          mount_component(formfield1, div6, null);
          insert_dev(target, t25, anchor);
          insert_dev(target, div7, anchor);
          mount_component(formfield2, div7, null);
          insert_dev(target, t26, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t2_value !== (t2_value = (ctx2[1]?.username || "DEMO") + ""))
            set_data_dev(t2, t2_value);
          if (ctx2[1]?.register_plugin_name) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_24(ctx2);
              if_block0.c();
              if_block0.m(t4.parentNode, t4);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          const select_changes = {};
          if (dirty & 131074) {
            select_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value && dirty & 2) {
            updating_value = true;
            select_changes.value = ctx2[1].store;
            add_flush_callback(() => updating_value = false);
          }
          select.$set(select_changes);
          if ((!current || dirty & 2) && t11_value !== (t11_value = ctx2[1]?.country + ""))
            set_data_dev(t11, t11_value);
          if ((!current || dirty & 2) && t15_value !== (t15_value = ctx2[1]?.state + ""))
            set_data_dev(t15, t15_value);
          if ((!current || dirty & 2) && t19_value !== (t19_value = ctx2[1]?.city + ""))
            set_data_dev(t19, t19_value);
          const formfield0_changes = {};
          if (dirty & 131074) {
            formfield0_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield0.$set(formfield0_changes);
          const formfield1_changes = {};
          if (dirty & 131074) {
            formfield1_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield1.$set(formfield1_changes);
          const formfield2_changes = {};
          if (dirty & 131074) {
            formfield2_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield2.$set(formfield2_changes);
          if (ctx2[1].rows_per_page) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty & 2) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_14(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(separator0.$$.fragment, local);
          transition_in(select.$$.fragment, local);
          transition_in(separator1.$$.fragment, local);
          transition_in(formfield0.$$.fragment, local);
          transition_in(formfield1.$$.fragment, local);
          transition_in(formfield2.$$.fragment, local);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(separator0.$$.fragment, local);
          transition_out(select.$$.fragment, local);
          transition_out(separator1.$$.fragment, local);
          transition_out(formfield0.$$.fragment, local);
          transition_out(formfield1.$$.fragment, local);
          transition_out(formfield2.$$.fragment, local);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div0);
          if (detaching)
            detach_dev(t3);
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t4);
          destroy_component(separator0, detaching);
          if (detaching)
            detach_dev(br0);
          if (detaching)
            detach_dev(t5);
          if (detaching)
            detach_dev(div1);
          destroy_component(select);
          if (detaching)
            detach_dev(t8);
          if (detaching)
            detach_dev(div2);
          if (detaching)
            detach_dev(t12);
          if (detaching)
            detach_dev(div3);
          if (detaching)
            detach_dev(t16);
          if (detaching)
            detach_dev(div4);
          if (detaching)
            detach_dev(t20);
          destroy_component(separator1, detaching);
          if (detaching)
            detach_dev(br1);
          if (detaching)
            detach_dev(t21);
          if (detaching)
            detach_dev(h25);
          if (detaching)
            detach_dev(t23);
          if (detaching)
            detach_dev(div5);
          destroy_component(formfield0);
          if (detaching)
            detach_dev(t24);
          if (detaching)
            detach_dev(div6);
          destroy_component(formfield1);
          if (detaching)
            detach_dev(t25);
          if (detaching)
            detach_dev(div7);
          destroy_component(formfield2);
          if (detaching)
            detach_dev(t26);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: "(108:3) <List>",
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let list;
      let current;
      list = new List({
        props: {
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(list.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_changes = {};
          if (dirty & 131075) {
            list_changes.$$scope = {dirty, ctx: ctx2};
          }
          list.$set(list_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(107:2) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 131072) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 131075) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: "(105:1) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let show_if = Object.keys(ctx[1]).length > 0;
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block7(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 2)
            show_if = Object.keys(ctx2[1]).length > 0;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block7(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let $notification;
      let $userSettings;
      let $redirect;
      let $user;
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(10, $notification = $$value));
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(1, $userSettings = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(11, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(12, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Settings", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      function changeStore(storeObject) {
        set_store_value(userSettings, $userSettings.state = storeObject.state, $userSettings);
        set_store_value(userSettings, $userSettings.city = storeObject.city, $userSettings);
        set_store_value(userSettings, $userSettings.store_name = storeObject.store_name, $userSettings);
      }
      let files;
      function testFileUploaded(newValue) {
        if (files && files[0]) {
          console.log(newValue[0].name);
          let ext = files[0].name.split(".").pop();
          switch (ext) {
            case "xls":
            case "xlsx":
              console.log("Allowed");
              let formData = new FormData();
              formData.append("file", files[0]);
              axios.post("/api/sales_upload", formData, {
                headers: {"Content-Type": "multipart/form-data"}
              }).then((response) => {
                console.log(response.data);
              }).catch(function() {
                console.log("FAILURE!!");
              });
              break;
            default:
              console.log("Not allowed");
              $$invalidate(0, files = null);
              set_store_value(notification, $notification = {
                text: "Es k\xF6nnen nur Excel-Dateien hochgeladen werden.",
                bg: "var(--mdc-theme-callout);",
                color: "var(--mdc-theme-on-primary);"
              }, $notification);
              setTimeout(() => {
                set_store_value(notification, $notification = void 0, $notification);
              }, 5e3);
          }
        }
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console_12.warn(`<Settings> was created with unknown prop '${key}'`);
      });
      function input_change_handler() {
        files = this.files;
        $$invalidate(0, files);
      }
      const SMUI_action_handler = (s) => changeStore(s);
      function select_value_binding(value) {
        if ($$self.$$.not_equal($userSettings.store, value)) {
          $userSettings.store = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding(value) {
        if ($$self.$$.not_equal($userSettings.tomorrow, value)) {
          $userSettings.tomorrow = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding_1(value) {
        if ($$self.$$.not_equal($userSettings.day_after_tomorrow, value)) {
          $userSettings.day_after_tomorrow = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding_2(value) {
        if ($$self.$$.not_equal($userSettings.next_seven_days, value)) {
          $userSettings.next_seven_days = value;
          userSettings.set($userSettings);
        }
      }
      function slider_value_binding(value) {
        if ($$self.$$.not_equal($userSettings.rows_per_page, value)) {
          $userSettings.rows_per_page = value;
          userSettings.set($userSettings);
        }
      }
      $$self.$capture_state = () => ({
        user,
        userSettings,
        notification,
        Slider,
        Switch,
        FormField,
        Paper,
        Title,
        Content,
        Select,
        Option,
        List,
        Item,
        Separator,
        Subheader,
        axios,
        fade,
        redirect,
        onMount,
        changeStore,
        files,
        testFileUploaded,
        $notification,
        $userSettings,
        $redirect,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("files" in $$props2)
          $$invalidate(0, files = $$props2.files);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          {
            testFileUploaded(files);
          }
        }
      };
      return [
        files,
        $userSettings,
        changeStore,
        input_change_handler,
        SMUI_action_handler,
        select_value_binding,
        switch_1_checked_binding,
        switch_1_checked_binding_1,
        switch_1_checked_binding_2,
        slider_value_binding
      ];
    }
    var Settings = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Settings",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/signup.js
  var require_signup = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Signup
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$14 = {
      HELPER_TEXT_PERSISTENT: "mdc-text-field-helper-text--persistent",
      HELPER_TEXT_VALIDATION_MSG: "mdc-text-field-helper-text--validation-msg",
      ROOT: "mdc-text-field-helper-text"
    };
    var strings$12 = {
      ARIA_HIDDEN: "aria-hidden",
      ROLE: "role",
      ROOT_SELECTOR: "." + cssClasses$14.ROOT
    };
    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldHelperTextFoundation = function(_super) {
      __extends(MDCTextFieldHelperTextFoundation2, _super);
      function MDCTextFieldHelperTextFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$14;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            getAttr: function() {
              return null;
            },
            setAttr: function() {
              return void 0;
            },
            removeAttr: function() {
              return void 0;
            },
            setContent: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTextFieldHelperTextFoundation2.prototype.getId = function() {
        return this.adapter.getAttr("id");
      };
      MDCTextFieldHelperTextFoundation2.prototype.isVisible = function() {
        return this.adapter.getAttr(strings$12.ARIA_HIDDEN) !== "true";
      };
      MDCTextFieldHelperTextFoundation2.prototype.setContent = function(content) {
        this.adapter.setContent(content);
      };
      MDCTextFieldHelperTextFoundation2.prototype.isPersistent = function() {
        return this.adapter.hasClass(cssClasses$14.HELPER_TEXT_PERSISTENT);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setPersistent = function(isPersistent) {
        if (isPersistent) {
          this.adapter.addClass(cssClasses$14.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter.removeClass(cssClasses$14.HELPER_TEXT_PERSISTENT);
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.isValidation = function() {
        return this.adapter.hasClass(cssClasses$14.HELPER_TEXT_VALIDATION_MSG);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setValidation = function(isValidation) {
        if (isValidation) {
          this.adapter.addClass(cssClasses$14.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter.removeClass(cssClasses$14.HELPER_TEXT_VALIDATION_MSG);
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.showToScreenReader = function() {
        this.adapter.removeAttr(strings$12.ARIA_HIDDEN);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setValidity = function(inputIsValid) {
        var helperTextIsPersistent = this.adapter.hasClass(cssClasses$14.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter.hasClass(cssClasses$14.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
        if (validationMsgNeedsDisplay) {
          this.showToScreenReader();
          this.adapter.setAttr(strings$12.ROLE, "alert");
        } else {
          this.adapter.removeAttr(strings$12.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.hide_ = function() {
        this.adapter.setAttr(strings$12.ARIA_HIDDEN, "true");
      };
      return MDCTextFieldHelperTextFoundation2;
    }(MDCFoundation);
    var file$26 = "node_modules/@smui/textfield/helper-text/HelperText.svelte";
    function create_else_block4(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[8]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 256)
            set_data_dev(t, ctx2[8]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block4.name,
        type: "else",
        source: "(17:31) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block7(ctx) {
      let current;
      const default_slot_template = ctx[13].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 4096)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block7.name,
        type: "if",
        source: "(17:2) {#if content == null}",
        ctx
      });
      return block;
    }
    function create_fragment$28(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let div_class_value;
      let div_aria_hidden_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block7, create_else_block4];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[8] == null)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div_levels = [
        {
          class: div_class_value = classMap({
            [ctx[1]]: true,
            "mdc-text-field-helper-text": true,
            "mdc-text-field-helper-text--persistent": ctx[3],
            "mdc-text-field-helper-text--validation-msg": ctx[4],
            ...ctx[6]
          })
        },
        {
          "aria-hidden": div_aria_hidden_value = ctx[3] ? null : "true"
        },
        {id: ctx[2]},
        ctx[7],
        ctx[10]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if_block.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          ctx[14](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
              action_destroyer(ctx[9].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 90 && div_class_value !== (div_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-text-field-helper-text": true,
              "mdc-text-field-helper-text--persistent": ctx2[3],
              "mdc-text-field-helper-text--validation-msg": ctx2[4],
              ...ctx2[6]
            }))) && {class: div_class_value},
            (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? null : "true")) && {"aria-hidden": div_aria_hidden_value},
            (!current || dirty & 4) && {id: ctx2[2]},
            dirty & 128 && ctx2[7],
            dirty & 1024 && ctx2[10]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if_blocks[current_block_type_index].d();
          ctx[14](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("HelperText", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {id = "SMUI-textfield-helper-text-" + counter3++} = $$props;
      let {persistent = false} = $$props;
      let {validationMsg = false} = $$props;
      let element2;
      let instance8;
      let internalClasses = {};
      let internalAttrs = {};
      let content = null;
      onMount(() => {
        instance8 = new MDCTextFieldHelperTextFoundation({
          addClass,
          removeClass,
          hasClass,
          getAttr,
          setAttr: addAttr,
          removeAttr,
          setContent: (value) => {
            $$invalidate(8, content = value);
          }
        });
        if (id.startsWith("SMUI-textfield-helper-text-")) {
          dispatch(getElement(), "SMUI:textfield:helper-text:id", id);
        }
        dispatch(getElement(), "SMUI:textfield:helper-text:mount", instance8);
        instance8.init();
        return () => {
          dispatch(getElement(), "SMUI:textfield:helper-text:unmount", instance8);
          instance8.destroy();
        };
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = false, internalClasses);
        }
      }
      function getAttr(name2) {
        return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
      }
      function addAttr(name2, value) {
        if (internalAttrs[name2] !== value) {
          $$invalidate(7, internalAttrs[name2] = value, internalAttrs);
        }
      }
      function removeAttr(name2) {
        if (!(name2 in internalAttrs) || internalAttrs[name2] != null) {
          $$invalidate(7, internalAttrs[name2] = void 0, internalAttrs);
        }
      }
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(5, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("id" in $$new_props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$new_props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$new_props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("$$scope" in $$new_props)
          $$invalidate(12, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCTextFieldHelperTextFoundation,
        onMount,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        dispatch,
        forwardEvents,
        use: use2,
        className,
        id,
        persistent,
        validationMsg,
        element: element2,
        instance: instance8,
        internalClasses,
        internalAttrs,
        content,
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("id" in $$props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("element" in $$props)
          $$invalidate(5, element2 = $$new_props.element);
        if ("instance" in $$props)
          instance8 = $$new_props.instance;
        if ("internalClasses" in $$props)
          $$invalidate(6, internalClasses = $$new_props.internalClasses);
        if ("internalAttrs" in $$props)
          $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
        if ("content" in $$props)
          $$invalidate(8, content = $$new_props.content);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        id,
        persistent,
        validationMsg,
        element2,
        internalClasses,
        internalAttrs,
        content,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var HelperText = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$28, safe_not_equal, {
          use: 0,
          class: 1,
          id: 2,
          persistent: 3,
          validationMsg: 4,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HelperText",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get validationMsg() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set validationMsg(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses7 = {
      ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
      ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
      ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
      ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
      ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
      ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
      BACKGROUND: "mdc-checkbox__background",
      CHECKED: "mdc-checkbox--checked",
      CHECKMARK: "mdc-checkbox__checkmark",
      CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
      DISABLED: "mdc-checkbox--disabled",
      INDETERMINATE: "mdc-checkbox--indeterminate",
      MIXEDMARK: "mdc-checkbox__mixedmark",
      NATIVE_CONTROL: "mdc-checkbox__native-control",
      ROOT: "mdc-checkbox",
      SELECTED: "mdc-checkbox--selected",
      UPGRADED: "mdc-checkbox--upgraded"
    };
    var strings7 = {
      ARIA_CHECKED_ATTR: "aria-checked",
      ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
      DATA_INDETERMINATE_ATTR: "data-indeterminate",
      NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
      TRANSITION_STATE_CHECKED: "checked",
      TRANSITION_STATE_INDETERMINATE: "indeterminate",
      TRANSITION_STATE_INIT: "init",
      TRANSITION_STATE_UNCHECKED: "unchecked"
    };
    var numbers6 = {
      ANIM_END_LATCH_MS: 250
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCCheckboxFoundation = function(_super) {
      __extends(MDCCheckboxFoundation2, _super);
      function MDCCheckboxFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation2.defaultAdapter), adapter)) || this;
        _this.currentCheckState_ = strings7.TRANSITION_STATE_INIT;
        _this.currentAnimationClass_ = "";
        _this.animEndLatchTimer_ = 0;
        _this.enableAnimationEndHandler_ = false;
        return _this;
      }
      Object.defineProperty(MDCCheckboxFoundation2, "cssClasses", {
        get: function() {
          return cssClasses7;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "strings", {
        get: function() {
          return strings7;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "numbers", {
        get: function() {
          return numbers6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            forceLayout: function() {
              return void 0;
            },
            hasNativeControl: function() {
              return false;
            },
            isAttachedToDOM: function() {
              return false;
            },
            isChecked: function() {
              return false;
            },
            isIndeterminate: function() {
              return false;
            },
            removeClass: function() {
              return void 0;
            },
            removeNativeControlAttr: function() {
              return void 0;
            },
            setNativeControlAttr: function() {
              return void 0;
            },
            setNativeControlDisabled: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCCheckboxFoundation2.prototype.init = function() {
        this.currentCheckState_ = this.determineCheckState_();
        this.updateAriaChecked_();
        this.adapter.addClass(cssClasses7.UPGRADED);
      };
      MDCCheckboxFoundation2.prototype.destroy = function() {
        clearTimeout(this.animEndLatchTimer_);
      };
      MDCCheckboxFoundation2.prototype.setDisabled = function(disabled) {
        this.adapter.setNativeControlDisabled(disabled);
        if (disabled) {
          this.adapter.addClass(cssClasses7.DISABLED);
        } else {
          this.adapter.removeClass(cssClasses7.DISABLED);
        }
      };
      MDCCheckboxFoundation2.prototype.handleAnimationEnd = function() {
        var _this = this;
        if (!this.enableAnimationEndHandler_) {
          return;
        }
        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function() {
          _this.adapter.removeClass(_this.currentAnimationClass_);
          _this.enableAnimationEndHandler_ = false;
        }, numbers6.ANIM_END_LATCH_MS);
      };
      MDCCheckboxFoundation2.prototype.handleChange = function() {
        this.transitionCheckState_();
      };
      MDCCheckboxFoundation2.prototype.transitionCheckState_ = function() {
        if (!this.adapter.hasNativeControl()) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_();
        if (oldState === newState) {
          return;
        }
        this.updateAriaChecked_();
        var TRANSITION_STATE_UNCHECKED = strings7.TRANSITION_STATE_UNCHECKED;
        var SELECTED = cssClasses7.SELECTED;
        if (newState === TRANSITION_STATE_UNCHECKED) {
          this.adapter.removeClass(SELECTED);
        } else {
          this.adapter.addClass(SELECTED);
        }
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter.forceLayout();
          this.adapter.removeClass(this.currentAnimationClass_);
        }
        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;
        if (this.adapter.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter.addClass(this.currentAnimationClass_);
          this.enableAnimationEndHandler_ = true;
        }
      };
      MDCCheckboxFoundation2.prototype.determineCheckState_ = function() {
        var TRANSITION_STATE_INDETERMINATE = strings7.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings7.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings7.TRANSITION_STATE_UNCHECKED;
        if (this.adapter.isIndeterminate()) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return this.adapter.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      };
      MDCCheckboxFoundation2.prototype.getTransitionAnimationClass_ = function(oldState, newState) {
        var TRANSITION_STATE_INIT = strings7.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings7.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings7.TRANSITION_STATE_UNCHECKED;
        var _a2 = MDCCheckboxFoundation2.cssClasses, ANIM_UNCHECKED_CHECKED = _a2.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a2.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a2.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a2.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a2.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a2.ANIM_INDETERMINATE_UNCHECKED;
        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return "";
            }
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      };
      MDCCheckboxFoundation2.prototype.updateAriaChecked_ = function() {
        if (this.adapter.isIndeterminate()) {
          this.adapter.setNativeControlAttr(strings7.ARIA_CHECKED_ATTR, strings7.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter.removeNativeControlAttr(strings7.ARIA_CHECKED_ATTR);
        }
      };
      return MDCCheckboxFoundation2;
    }(MDCFoundation);
    var file$18 = "node_modules/@smui/checkbox/Checkbox.svelte";
    function create_fragment$18(ctx) {
      let div3;
      let input;
      let input_class_value;
      let input_value_value;
      let input_data_indeterminate_value;
      let useActions_action;
      let t0;
      let div1;
      let svg;
      let path;
      let t1;
      let div0;
      let t2;
      let div2;
      let div3_class_value;
      let div3_style_value;
      let useActions_action_1;
      let Ripple_action;
      let mounted;
      let dispose;
      let input_levels = [
        {
          class: input_class_value = classMap({
            [ctx[9]]: true,
            "mdc-checkbox__native-control": true
          })
        },
        {type: "checkbox"},
        ctx[20],
        {disabled: ctx[1]},
        {
          __value: input_value_value = ctx[7] === ctx[19] ? ctx[6] : ctx[7]
        },
        {
          "data-indeterminate": input_data_indeterminate_value = ctx[0] !== ctx[19] && ctx[0] ? "true" : null
        },
        ctx[16],
        prefixFilter2(ctx[26], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      let div3_levels = [
        {
          class: div3_class_value = classMap({
            [ctx[3]]: true,
            "mdc-checkbox": true,
            "mdc-checkbox--disabled": ctx[1],
            "mdc-checkbox--touch": ctx[5],
            "mdc-data-table__header-row-checkbox": ctx[21] === "data-table" && ctx[22],
            "mdc-data-table__row-checkbox": ctx[21] === "data-table" && !ctx[22],
            ...ctx[14]
          })
        },
        {
          style: div3_style_value = Object.entries(ctx[15]).map(func6).concat([ctx[4]]).join(" ")
        },
        exclude2(ctx[26], ["input$"])
      ];
      let div3_data = {};
      for (let i = 0; i < div3_levels.length; i += 1) {
        div3_data = assign(div3_data, div3_levels[i]);
      }
      const block = {
        c: function create2() {
          div3 = element("div");
          input = element("input");
          t0 = space();
          div1 = element("div");
          svg = svg_element("svg");
          path = svg_element("path");
          t1 = space();
          div0 = element("div");
          t2 = space();
          div2 = element("div");
          set_attributes(input, input_data);
          add_location(input, file$18, 30, 2, 804);
          attr_dev(path, "class", "mdc-checkbox__checkmark-path");
          attr_dev(path, "fill", "none");
          attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
          add_location(path, file$18, 52, 6, 1438);
          attr_dev(svg, "class", "mdc-checkbox__checkmark");
          attr_dev(svg, "viewBox", "0 0 24 24");
          add_location(svg, file$18, 51, 4, 1374);
          attr_dev(div0, "class", "mdc-checkbox__mixedmark");
          add_location(div0, file$18, 58, 4, 1578);
          attr_dev(div1, "class", "mdc-checkbox__background");
          add_location(div1, file$18, 50, 2, 1331);
          attr_dev(div2, "class", "mdc-checkbox__ripple");
          add_location(div2, file$18, 60, 2, 1629);
          set_attributes(div3, div3_data);
          add_location(div3, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, input);
          if (input.autofocus)
            input.focus();
          ctx[36](input);
          input.checked = ctx[12];
          append_dev(div3, t0);
          append_dev(div3, div1);
          append_dev(div1, svg);
          append_dev(svg, path);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div3, t2);
          append_dev(div3, div2);
          ctx[38](div3);
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, input, ctx[8])),
              listen_dev(input, "change", ctx[37]),
              listen_dev(input, "blur", ctx[34], false, false, false),
              listen_dev(input, "focus", ctx[35], false, false, false),
              action_destroyer(useActions_action_1 = useActions.call(null, div3, ctx[2])),
              action_destroyer(ctx[18].call(null, div3)),
              action_destroyer(Ripple_action = Ripple.call(null, div3, {
                unbounded: true,
                addClass: ctx[23],
                removeClass: ctx[24],
                addStyle: ctx[25],
                active: ctx[17],
                eventTarget: ctx[11]
              })),
              listen_dev(div3, "animationend", ctx[39], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            dirty[0] & 512 && input_class_value !== (input_class_value = classMap({
              [ctx2[9]]: true,
              "mdc-checkbox__native-control": true
            })) && {class: input_class_value},
            {type: "checkbox"},
            ctx2[20],
            dirty[0] & 2 && {disabled: ctx2[1]},
            dirty[0] & 192 && input_value_value !== (input_value_value = ctx2[7] === ctx2[19] ? ctx2[6] : ctx2[7]) && {__value: input_value_value},
            dirty[0] & 1 && input_data_indeterminate_value !== (input_data_indeterminate_value = ctx2[0] !== ctx2[19] && ctx2[0] ? "true" : null) && {
              "data-indeterminate": input_data_indeterminate_value
            },
            dirty[0] & 65536 && ctx2[16],
            dirty[0] & 67108864 && prefixFilter2(ctx2[26], "input$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
            useActions_action.update.call(null, ctx2[8]);
          if (dirty[0] & 4096) {
            input.checked = ctx2[12];
          }
          set_attributes(div3, div3_data = get_spread_update(div3_levels, [
            dirty[0] & 16426 && div3_class_value !== (div3_class_value = classMap({
              [ctx2[3]]: true,
              "mdc-checkbox": true,
              "mdc-checkbox--disabled": ctx2[1],
              "mdc-checkbox--touch": ctx2[5],
              "mdc-data-table__header-row-checkbox": ctx2[21] === "data-table" && ctx2[22],
              "mdc-data-table__row-checkbox": ctx2[21] === "data-table" && !ctx2[22],
              ...ctx2[14]
            })) && {class: div3_class_value},
            dirty[0] & 32784 && div3_style_value !== (div3_style_value = Object.entries(ctx2[15]).map(func6).concat([ctx2[4]]).join(" ")) && {style: div3_style_value},
            dirty[0] & 67108864 && exclude2(ctx2[26], ["input$"])
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 4)
            useActions_action_1.update.call(null, ctx2[2]);
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 133120)
            Ripple_action.update.call(null, {
              unbounded: true,
              addClass: ctx2[23],
              removeClass: ctx2[24],
              addStyle: ctx2[25],
              active: ctx2[17],
              eventTarget: ctx2[11]
            });
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div3);
          ctx[36](null);
          ctx[38](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func6 = ([name2, value]) => `${name2}: ${value};`;
    function instance_16($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "disabled",
        "touch",
        "indeterminate",
        "group",
        "checked",
        "value",
        "valueKey",
        "input$use",
        "input$class",
        "getId",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Checkbox", slots, []);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {disabled = false} = $$props;
      let {touch = false} = $$props;
      let {indeterminate = uninitializedValue} = $$props;
      let {group = uninitializedValue} = $$props;
      let {checked = uninitializedValue} = $$props;
      let {value = null} = $$props;
      let {valueKey = uninitializedValue} = $$props;
      let {input$use = []} = $$props;
      let {input$class = ""} = $$props;
      let element2;
      let instance8;
      let checkbox;
      let internalClasses = {};
      let internalStyles = {};
      let nativeControlAttrs = {};
      let rippleActive = false;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      let nativeChecked = group === uninitializedValue ? checked === uninitializedValue ? false : checked : group.indexOf(value) !== -1;
      let context = getContext("SMUI:checkbox:context");
      let dataTableHeader = getContext("SMUI:data-table:row:header");
      let previousChecked = checked;
      let previousGroup = group === uninitializedValue ? [] : [...group];
      let previousNativeChecked = nativeChecked;
      onMount(() => {
        $$invalidate(10, instance8 = new MDCCheckboxFoundation({
          addClass,
          forceLayout: () => element2.offsetWidth,
          hasNativeControl: () => true,
          isAttachedToDOM: () => Boolean(element2.parentNode),
          isChecked: () => nativeChecked,
          isIndeterminate: () => indeterminate === uninitializedValue ? false : indeterminate,
          removeClass,
          removeNativeControlAttr,
          setNativeControlAttr: addNativeControlAttr,
          setNativeControlDisabled: (value2) => $$invalidate(1, disabled = value2)
        }));
        const accessor = {
          _smui_checkbox_accessor: true,
          get element() {
            return getElement();
          },
          get checked() {
            return nativeChecked;
          },
          set checked(value2) {
            if (nativeChecked !== value2) {
              $$invalidate(12, nativeChecked = value2);
            }
          },
          get indeterminate() {
            return indeterminate === uninitializedValue ? false : indeterminate;
          },
          set indeterminate(value2) {
            $$invalidate(0, indeterminate = value2);
          },
          activateRipple() {
            if (!disabled) {
              $$invalidate(17, rippleActive = true);
            }
          },
          deactivateRipple() {
            $$invalidate(17, rippleActive = false);
          }
        };
        dispatch(element2, "SMUI:generic:input:mount", accessor);
        dispatch(element2, "SMUI:checkbox:mount", accessor);
        instance8.init();
        return () => {
          dispatch(element2, "SMUI:generic:input:unmount", accessor);
          dispatch(element2, "SMUI:checkbox:unmount", accessor);
          instance8.destroy();
        };
      });
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(14, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(14, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name2, value2) {
        if (internalStyles[name2] != value2) {
          if (value2 === "" || value2 == null) {
            delete internalStyles[name2];
            $$invalidate(15, internalStyles);
          } else {
            $$invalidate(15, internalStyles[name2] = value2, internalStyles);
          }
        }
      }
      function addNativeControlAttr(name2, value2) {
        if (nativeControlAttrs[name2] !== value2) {
          $$invalidate(16, nativeControlAttrs[name2] = value2, nativeControlAttrs);
        }
      }
      function removeNativeControlAttr(name2) {
        if (!(name2 in nativeControlAttrs) || nativeControlAttrs[name2] != null) {
          $$invalidate(16, nativeControlAttrs[name2] = void 0, nativeControlAttrs);
        }
      }
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element2;
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          checkbox = $$value;
          $$invalidate(11, checkbox), $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(10, instance8);
        });
      }
      function input_change_handler() {
        nativeChecked = this.checked;
        $$invalidate(12, nativeChecked), $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance8);
      }
      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(13, element2);
        });
      }
      const animationend_handler = () => instance8 && instance8.handleAnimationEnd();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(3, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(4, style = $$new_props.style);
        if ("disabled" in $$new_props)
          $$invalidate(1, disabled = $$new_props.disabled);
        if ("touch" in $$new_props)
          $$invalidate(5, touch = $$new_props.touch);
        if ("indeterminate" in $$new_props)
          $$invalidate(0, indeterminate = $$new_props.indeterminate);
        if ("group" in $$new_props)
          $$invalidate(27, group = $$new_props.group);
        if ("checked" in $$new_props)
          $$invalidate(28, checked = $$new_props.checked);
        if ("value" in $$new_props)
          $$invalidate(6, value = $$new_props.value);
        if ("valueKey" in $$new_props)
          $$invalidate(7, valueKey = $$new_props.valueKey);
        if ("input$use" in $$new_props)
          $$invalidate(8, input$use = $$new_props.input$use);
        if ("input$class" in $$new_props)
          $$invalidate(9, input$class = $$new_props.input$class);
      };
      $$self.$capture_state = () => ({
        MDCCheckboxFoundation,
        onMount,
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        exclude: exclude2,
        prefixFilter: prefixFilter2,
        useActions,
        dispatch,
        Ripple,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        disabled,
        touch,
        indeterminate,
        group,
        checked,
        value,
        valueKey,
        input$use,
        input$class,
        element: element2,
        instance: instance8,
        checkbox,
        internalClasses,
        internalStyles,
        nativeControlAttrs,
        rippleActive,
        inputProps,
        nativeChecked,
        context,
        dataTableHeader,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        addClass,
        removeClass,
        addStyle,
        addNativeControlAttr,
        removeNativeControlAttr,
        getId,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(19, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(3, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(4, style = $$new_props.style);
        if ("disabled" in $$props)
          $$invalidate(1, disabled = $$new_props.disabled);
        if ("touch" in $$props)
          $$invalidate(5, touch = $$new_props.touch);
        if ("indeterminate" in $$props)
          $$invalidate(0, indeterminate = $$new_props.indeterminate);
        if ("group" in $$props)
          $$invalidate(27, group = $$new_props.group);
        if ("checked" in $$props)
          $$invalidate(28, checked = $$new_props.checked);
        if ("value" in $$props)
          $$invalidate(6, value = $$new_props.value);
        if ("valueKey" in $$props)
          $$invalidate(7, valueKey = $$new_props.valueKey);
        if ("input$use" in $$props)
          $$invalidate(8, input$use = $$new_props.input$use);
        if ("input$class" in $$props)
          $$invalidate(9, input$class = $$new_props.input$class);
        if ("element" in $$props)
          $$invalidate(13, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(10, instance8 = $$new_props.instance);
        if ("checkbox" in $$props)
          $$invalidate(11, checkbox = $$new_props.checkbox);
        if ("internalClasses" in $$props)
          $$invalidate(14, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(15, internalStyles = $$new_props.internalStyles);
        if ("nativeControlAttrs" in $$props)
          $$invalidate(16, nativeControlAttrs = $$new_props.nativeControlAttrs);
        if ("rippleActive" in $$props)
          $$invalidate(17, rippleActive = $$new_props.rippleActive);
        if ("inputProps" in $$props)
          $$invalidate(20, inputProps = $$new_props.inputProps);
        if ("nativeChecked" in $$props)
          $$invalidate(12, nativeChecked = $$new_props.nativeChecked);
        if ("context" in $$props)
          $$invalidate(21, context = $$new_props.context);
        if ("dataTableHeader" in $$props)
          $$invalidate(22, dataTableHeader = $$new_props.dataTableHeader);
        if ("previousChecked" in $$props)
          $$invalidate(31, previousChecked = $$new_props.previousChecked);
        if ("previousGroup" in $$props)
          $$invalidate(32, previousGroup = $$new_props.previousGroup);
        if ("previousNativeChecked" in $$props)
          $$invalidate(33, previousNativeChecked = $$new_props.previousNativeChecked);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 402660417 | $$self.$$.dirty[1] & 7) {
          {
            let callHandleChange = false;
            if (group !== uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                const idx = group.indexOf(value);
                if (nativeChecked && idx === -1) {
                  group.push(value);
                  $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance8);
                } else if (!nativeChecked && idx !== -1) {
                  group.splice(idx, 1);
                  $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance8);
                }
                callHandleChange = true;
              } else {
                const idxPrev = previousGroup.indexOf(value);
                const idx = group.indexOf(value);
                if (idxPrev > -1 && idx === -1) {
                  $$invalidate(12, nativeChecked = false);
                  callHandleChange = true;
                } else if (idx > -1 && idxPrev === -1) {
                  $$invalidate(12, nativeChecked = true);
                  callHandleChange = true;
                }
              }
            }
            if (checked === uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                callHandleChange = true;
              }
            } else if (checked !== nativeChecked) {
              if (checked === previousChecked) {
                $$invalidate(28, checked = nativeChecked);
              } else {
                $$invalidate(12, nativeChecked = checked);
              }
              callHandleChange = true;
            }
            if (checkbox) {
              if (indeterminate === uninitializedValue) {
                if (checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = false, checkbox);
                  callHandleChange = true;
                }
              } else {
                if (!indeterminate && checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = false, checkbox);
                  callHandleChange = true;
                } else if (indeterminate && !checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = true, checkbox);
                  callHandleChange = true;
                }
              }
            }
            $$invalidate(31, previousChecked = checked);
            $$invalidate(32, previousGroup = group === uninitializedValue ? [] : [...group]);
            $$invalidate(33, previousNativeChecked = nativeChecked);
            if (callHandleChange && instance8) {
              instance8.handleChange();
            }
          }
        }
      };
      return [
        indeterminate,
        disabled,
        use2,
        className,
        style,
        touch,
        value,
        valueKey,
        input$use,
        input$class,
        instance8,
        checkbox,
        nativeChecked,
        element2,
        internalClasses,
        internalStyles,
        nativeControlAttrs,
        rippleActive,
        forwardEvents,
        uninitializedValue,
        inputProps,
        context,
        dataTableHeader,
        addClass,
        removeClass,
        addStyle,
        $$restProps,
        group,
        checked,
        getId,
        getElement,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        blur_handler,
        focus_handler,
        input_binding,
        input_change_handler,
        div3_binding,
        animationend_handler
      ];
    }
    var Checkbox = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_16, create_fragment$18, safe_not_equal, {
          use: 2,
          class: 3,
          style: 4,
          disabled: 1,
          touch: 5,
          indeterminate: 0,
          group: 27,
          checked: 28,
          value: 6,
          valueKey: 7,
          input$use: 8,
          input$class: 9,
          getId: 29,
          getElement: 30
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Checkbox",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get touch() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set touch(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get indeterminate() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set indeterminate(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get group() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set group(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get checked() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set checked(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get valueKey() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set valueKey(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$use() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$use(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$class() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$class(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getId() {
        return this.$$.ctx[29];
      }
      set getId(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[30];
      }
      set getElement(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_12} = globals;
    var file10 = "src/pages/signup.svelte";
    function create_default_slot_122(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Registrieren";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file10, 84, 8, 2054);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: "(85:1) <Title>",
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Wie d\xFCrfen wir Sie ansprechen?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: '(89:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_5(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_5.name,
        type: "slot",
        source: "(89:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("G\xFCltige E-Mail-Adresse");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: '(94:4) <HelperText slot=\\"helper\\">',
        ctx
      });
      return block;
    }
    function create_helper_slot_4(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_4.name,
        type: "slot",
        source: "(94:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Ben\xF6tigt z.B. wenn Sie ihr Passwort nicht mehr wissen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: '(97:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_3(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_3.name,
        type: "slot",
        source: "(97:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[7]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 128)
            set_data_dev(t, ctx2[7]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: '(109:4) <Icon      class=\\"material-icons\\"      slot=\\"trailingIcon\\"      on:click={() => togglePwd()}>',
        ctx
      });
      return block;
    }
    function create_trailingIcon_slot(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          class: "material-icons",
          slot: "trailingIcon",
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      icon.$on("click", ctx[15]);
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const icon_changes = {};
          if (dirty & 33554560) {
            icon_changes.$$scope = {dirty, ctx: ctx2};
          }
          icon.$set(icon_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_trailingIcon_slot.name,
        type: "slot",
        source: "(109:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Mind.12 Zeichen, Buchstaben, Zahlen, Sonderzeichen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(114:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_2(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_2.name,
        type: "slot",
        source: "(114:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Wo befindet sich Ihr (erstes) Gesch\xE4ft?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: '(119:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_1(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_1.name,
        type: "slot",
        source: "(119:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Welches Kassensystem verwenden Sie?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: '(124:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot.name,
        type: "slot",
        source: "(124:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let checkbox;
      let updating_checked;
      let current;
      function checkbox_checked_binding(value) {
        ctx[19](value);
      }
      let checkbox_props = {input$required: true};
      if (ctx[6] !== void 0) {
        checkbox_props.checked = ctx[6];
      }
      checkbox = new Checkbox({props: checkbox_props, $$inline: true});
      binding_callbacks.push(() => bind3(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create2() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const checkbox_changes = {};
          if (!updating_checked && dirty & 64) {
            updating_checked = true;
            checkbox_changes.checked = ctx2[6];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(128:3) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "Ich stimme zu, dass foodsight mich per E-Mail und Telefon\n					zwecks Onboarding kontaktiert.";
          attr_dev(span, "slot", "label");
          add_location(span, file10, 129, 4, 3486);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot.name,
        type: "slot",
        source: "(130:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Absenden");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(141:4) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 33554432) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: `(136:3) <Button     variant=\\"raised\\"     style=\\"background: {'var(--mdc-theme-callout)'}\\"     type=\\"submit\\"    >`,
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let form;
      let textfield0;
      let updating_value;
      let t0;
      let textfield1;
      let updating_value_1;
      let t1;
      let textfield2;
      let updating_value_2;
      let t2;
      let textfield3;
      let updating_value_3;
      let t3;
      let textfield4;
      let updating_value_4;
      let t4;
      let textfield5;
      let updating_value_5;
      let t5;
      let formfield;
      let t6;
      let br;
      let t7;
      let button;
      let current;
      let mounted;
      let dispose;
      function textfield0_value_binding(value) {
        ctx[12](value);
      }
      let textfield0_props = {
        label: "Name",
        type: "name",
        $$slots: {helper: [create_helper_slot_5]},
        $$scope: {ctx}
      };
      if (ctx[0] !== void 0) {
        textfield0_props.value = ctx[0];
      }
      textfield0 = new Textfield({props: textfield0_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield0, "value", textfield0_value_binding));
      function textfield1_value_binding(value) {
        ctx[13](value);
      }
      let textfield1_props = {
        label: "E-Mail",
        type: "email",
        required: true,
        $$slots: {helper: [create_helper_slot_4]},
        $$scope: {ctx}
      };
      if (ctx[1] !== void 0) {
        textfield1_props.value = ctx[1];
      }
      textfield1 = new Textfield({props: textfield1_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield1, "value", textfield1_value_binding));
      function textfield2_value_binding(value) {
        ctx[14](value);
      }
      let textfield2_props = {
        label: "Telefon",
        type: "phone",
        required: true,
        $$slots: {helper: [create_helper_slot_3]},
        $$scope: {ctx}
      };
      if (ctx[2] !== void 0) {
        textfield2_props.value = ctx[2];
      }
      textfield2 = new Textfield({props: textfield2_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield2, "value", textfield2_value_binding));
      function textfield3_value_binding(value) {
        ctx[16](value);
      }
      let textfield3_props = {
        label: "Passwort",
        type: ctx[8],
        required: true,
        input$pattern: ctx[11],
        style: "width:200px",
        $$slots: {
          helper: [create_helper_slot_2],
          trailingIcon: [create_trailingIcon_slot]
        },
        $$scope: {ctx}
      };
      if (ctx[3] !== void 0) {
        textfield3_props.value = ctx[3];
      }
      textfield3 = new Textfield({props: textfield3_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield3, "value", textfield3_value_binding));
      function textfield4_value_binding(value) {
        ctx[17](value);
      }
      let textfield4_props = {
        label: "Standort",
        type: "text",
        $$slots: {helper: [create_helper_slot_1]},
        $$scope: {ctx}
      };
      if (ctx[4] !== void 0) {
        textfield4_props.value = ctx[4];
      }
      textfield4 = new Textfield({props: textfield4_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield4, "value", textfield4_value_binding));
      function textfield5_value_binding(value) {
        ctx[18](value);
      }
      let textfield5_props = {
        label: "Kassensystem",
        type: "text",
        $$slots: {helper: [create_helper_slot]},
        $$scope: {ctx}
      };
      if (ctx[5] !== void 0) {
        textfield5_props.value = ctx[5];
      }
      textfield5 = new Textfield({props: textfield5_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield5, "value", textfield5_value_binding));
      formfield = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot],
            default: [create_default_slot_42]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      button = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          type: "submit",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          form = element("form");
          create_component(textfield0.$$.fragment);
          t0 = space();
          create_component(textfield1.$$.fragment);
          t1 = space();
          create_component(textfield2.$$.fragment);
          t2 = space();
          create_component(textfield3.$$.fragment);
          t3 = space();
          create_component(textfield4.$$.fragment);
          t4 = space();
          create_component(textfield5.$$.fragment);
          t5 = space();
          create_component(formfield.$$.fragment);
          t6 = space();
          br = element("br");
          t7 = space();
          create_component(button.$$.fragment);
          add_location(br, file10, 134, 3, 3636);
          add_location(form, file10, 86, 2, 2119);
        },
        m: function mount(target, anchor) {
          insert_dev(target, form, anchor);
          mount_component(textfield0, form, null);
          append_dev(form, t0);
          mount_component(textfield1, form, null);
          append_dev(form, t1);
          mount_component(textfield2, form, null);
          append_dev(form, t2);
          mount_component(textfield3, form, null);
          append_dev(form, t3);
          mount_component(textfield4, form, null);
          append_dev(form, t4);
          mount_component(textfield5, form, null);
          append_dev(form, t5);
          mount_component(formfield, form, null);
          append_dev(form, t6);
          append_dev(form, br);
          append_dev(form, t7);
          mount_component(button, form, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(ctx[9]), false, true, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          const textfield0_changes = {};
          if (dirty & 33554432) {
            textfield0_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value && dirty & 1) {
            updating_value = true;
            textfield0_changes.value = ctx2[0];
            add_flush_callback(() => updating_value = false);
          }
          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};
          if (dirty & 33554432) {
            textfield1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_1 && dirty & 2) {
            updating_value_1 = true;
            textfield1_changes.value = ctx2[1];
            add_flush_callback(() => updating_value_1 = false);
          }
          textfield1.$set(textfield1_changes);
          const textfield2_changes = {};
          if (dirty & 33554432) {
            textfield2_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_2 && dirty & 4) {
            updating_value_2 = true;
            textfield2_changes.value = ctx2[2];
            add_flush_callback(() => updating_value_2 = false);
          }
          textfield2.$set(textfield2_changes);
          const textfield3_changes = {};
          if (dirty & 256)
            textfield3_changes.type = ctx2[8];
          if (dirty & 33554560) {
            textfield3_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_3 && dirty & 8) {
            updating_value_3 = true;
            textfield3_changes.value = ctx2[3];
            add_flush_callback(() => updating_value_3 = false);
          }
          textfield3.$set(textfield3_changes);
          const textfield4_changes = {};
          if (dirty & 33554432) {
            textfield4_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_4 && dirty & 16) {
            updating_value_4 = true;
            textfield4_changes.value = ctx2[4];
            add_flush_callback(() => updating_value_4 = false);
          }
          textfield4.$set(textfield4_changes);
          const textfield5_changes = {};
          if (dirty & 33554432) {
            textfield5_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_5 && dirty & 32) {
            updating_value_5 = true;
            textfield5_changes.value = ctx2[5];
            add_flush_callback(() => updating_value_5 = false);
          }
          textfield5.$set(textfield5_changes);
          const formfield_changes = {};
          if (dirty & 33554496) {
            formfield_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield.$set(formfield_changes);
          const button_changes = {};
          if (dirty & 33554432) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(textfield2.$$.fragment, local);
          transition_in(textfield3.$$.fragment, local);
          transition_in(textfield4.$$.fragment, local);
          transition_in(textfield5.$$.fragment, local);
          transition_in(formfield.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(textfield2.$$.fragment, local);
          transition_out(textfield3.$$.fragment, local);
          transition_out(textfield4.$$.fragment, local);
          transition_out(textfield5.$$.fragment, local);
          transition_out(formfield.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(form);
          destroy_component(textfield0);
          destroy_component(textfield1);
          destroy_component(textfield2);
          destroy_component(textfield3);
          destroy_component(textfield4);
          destroy_component(textfield5);
          destroy_component(formfield);
          destroy_component(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(86:1) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 33554432) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 33554943) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: "(84:0) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let div;
      let paper;
      let div_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          create_component(paper.$$.fragment);
          add_location(div, file10, 82, 0, 2010);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(paper, div, null);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const paper_changes = {};
          if (dirty & 33554943) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!div_intro) {
            add_render_callback(() => {
              div_intro = create_in_transition(div, fade, {});
              div_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let $modal;
      let $notification;
      let $goto;
      let $redirect;
      let $user;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(20, $modal = $$value));
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(21, $notification = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(22, $goto = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(23, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(24, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Signup", slots, []);
      onMount(() => {
        if ($user && Object.keys($user).length) {
          $redirect("/");
        }
      });
      let name2 = "";
      let email = "";
      let phone = "";
      let password = "";
      let location2 = "";
      let register = "";
      let agree = null;
      async function sendSignup() {
        let payload = {
          name: name2,
          email,
          phone,
          password,
          location: location2,
          register_type: register,
          agree
        };
        axios.post(`${backendURL}/api/signup`, payload).then((response) => {
          set_store_value(notification, $notification = {
            text: "Danke! Ihre Registrierung ist eingegangen. Wir melden uns in K\xFCrze bei Ihnen.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
            set_store_value(modal, $modal = {}, $modal);
            $goto("/");
          }, 5e3);
        }, () => {
          set_store_value(notification, $notification = {
            text: "Leider ist etwas schiefgegangen. Bitte kontaktieren Sie uns unter support@ml4all.com",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
            set_store_value(modal, $modal = {}, $modal);
          }, 5e3);
        });
      }
      let pwdIcon = "visibility";
      let pwdType = "password";
      function togglePwd() {
        if (pwdIcon === "visibility") {
          $$invalidate(7, pwdIcon = "visibility_off");
          $$invalidate(8, pwdType = "text");
        } else {
          $$invalidate(7, pwdIcon = "visibility");
          $$invalidate(8, pwdType = "password");
        }
      }
      let pattern = ".{12,}";
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Signup> was created with unknown prop '${key}'`);
      });
      function textfield0_value_binding(value) {
        name2 = value;
        $$invalidate(0, name2);
      }
      function textfield1_value_binding(value) {
        email = value;
        $$invalidate(1, email);
      }
      function textfield2_value_binding(value) {
        phone = value;
        $$invalidate(2, phone);
      }
      const click_handler = () => togglePwd();
      function textfield3_value_binding(value) {
        password = value;
        $$invalidate(3, password);
      }
      function textfield4_value_binding(value) {
        location2 = value;
        $$invalidate(4, location2);
      }
      function textfield5_value_binding(value) {
        register = value;
        $$invalidate(5, register);
      }
      function checkbox_checked_binding(value) {
        agree = value;
        $$invalidate(6, agree);
      }
      $$self.$capture_state = () => ({
        Paper,
        Title,
        Content,
        Button: Button_1,
        Label: CommonLabel,
        Icon: CommonIcon,
        Textfield,
        HelperText,
        FormField,
        Checkbox,
        user,
        backendURL,
        modal,
        notification,
        axios,
        goto,
        redirect,
        fade,
        onMount,
        name: name2,
        email,
        phone,
        password,
        location: location2,
        register,
        agree,
        sendSignup,
        pwdIcon,
        pwdType,
        togglePwd,
        pattern,
        $modal,
        $notification,
        $goto,
        $redirect,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("name" in $$props2)
          $$invalidate(0, name2 = $$props2.name);
        if ("email" in $$props2)
          $$invalidate(1, email = $$props2.email);
        if ("phone" in $$props2)
          $$invalidate(2, phone = $$props2.phone);
        if ("password" in $$props2)
          $$invalidate(3, password = $$props2.password);
        if ("location" in $$props2)
          $$invalidate(4, location2 = $$props2.location);
        if ("register" in $$props2)
          $$invalidate(5, register = $$props2.register);
        if ("agree" in $$props2)
          $$invalidate(6, agree = $$props2.agree);
        if ("pwdIcon" in $$props2)
          $$invalidate(7, pwdIcon = $$props2.pwdIcon);
        if ("pwdType" in $$props2)
          $$invalidate(8, pwdType = $$props2.pwdType);
        if ("pattern" in $$props2)
          $$invalidate(11, pattern = $$props2.pattern);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        name2,
        email,
        phone,
        password,
        location2,
        register,
        agree,
        pwdIcon,
        pwdType,
        sendSignup,
        togglePwd,
        pattern,
        textfield0_value_binding,
        textfield1_value_binding,
        textfield2_value_binding,
        click_handler,
        textfield3_value_binding,
        textfield4_value_binding,
        textfield5_value_binding,
        checkbox_checked_binding
      ];
    }
    var Signup = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Signup",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/_layout.js
  var require_layout = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Layout
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var file$d = "node_modules/@smui/list/Label.svelte";
    function create_fragment$f(ctx) {
      let label;
      let label_class_value;
      let label_for_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let label_levels = [
        {
          class: label_class_value = classMap({
            [ctx[1]]: true,
            "mdc-deprecated-list-item__text": true
          })
        },
        {
          for: label_for_value = ctx[4] ? ctx[4].id : null
        },
        ctx[5]
      ];
      let label_data = {};
      for (let i = 0; i < label_levels.length; i += 1) {
        label_data = assign(label_data, label_levels[i]);
      }
      const block = {
        c: function create2() {
          label = element("label");
          if (default_slot)
            default_slot.c();
          set_attributes(label, label_data);
          add_location(label, file$d, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, label, anchor);
          if (default_slot) {
            default_slot.m(label, null);
          }
          ctx[9](label);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, label, ctx[0])),
              action_destroyer(ctx[3].call(null, label))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(label, label_data = get_spread_update(label_levels, [
            (!current || dirty & 2 && label_class_value !== (label_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-deprecated-list-item__text": true
            }))) && {class: label_class_value},
            {for: label_for_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(label);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$c($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Label", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let element2;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      function getElement() {
        return element2;
      }
      function label_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        element: element2,
        inputProps,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("inputProps" in $$props)
          $$invalidate(4, inputProps = $$new_props.inputProps);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        element2,
        forwardEvents,
        inputProps,
        $$restProps,
        getElement,
        $$scope,
        slots,
        label_binding
      ];
    }
    var Label = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$c, create_fragment$f, safe_not_equal, {use: 0, class: 1, getElement: 6});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Label",
          options,
          id: create_fragment$f.name
        });
      }
      get use() {
        throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$4} = globals;
    var file$c = "src/components/components/Notification.svelte";
    function create_if_block$6(ctx) {
      let div;
      let t_value = ctx[0].text + "";
      let t;
      let div_style_value;
      let div_intro;
      let div_outro;
      let current;
      const block = {
        c: function create2() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "fixed right-8 bottom-20 bg-green-500 rounded px-8 py-4");
          attr_dev(div, "style", div_style_value = `background: ${ctx[0].bg}; color: ${ctx[0].color}`);
          add_location(div, file$c, 7, 1, 206);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty & 1) && t_value !== (t_value = ctx[0].text + ""))
            set_data_dev(t, t_value);
          if (!current || dirty & 1 && div_style_value !== (div_style_value = `background: ${ctx[0].bg}; color: ${ctx[0].color}`)) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          add_render_callback(() => {
            if (div_outro)
              div_outro.end(1);
            div_intro = create_in_transition(div, fly, {
              duration: 300,
              x: 0,
              y: 500,
              opacity: 0.5,
              easing: quintOut
            });
            div_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          if (div_intro)
            div_intro.invalidate();
          div_outro = create_out_transition(div, fly, {
            delay: 250,
            duration: 300,
            x: 500,
            y: 0,
            opacity: 0.5,
            easing: quintOut
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching && div_outro)
            div_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(7:0) {#if $notification && Object.keys($notification).length}",
        ctx
      });
      return block;
    }
    function create_fragment$e(ctx) {
      let show_if = ctx[0] && Object.keys(ctx[0]).length;
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block$6(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 1)
            show_if = ctx2[0] && Object.keys(ctx2[0]).length;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$b($$self, $$props, $$invalidate) {
      let $notification;
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(0, $notification = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Notification", slots, []);
      const writable_props = [];
      Object_1$4.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Notification> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({
        notification,
        fly,
        quintOut,
        $notification
      });
      return [$notification];
    }
    var Notification = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$b, create_fragment$e, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Notification",
          options,
          id: create_fragment$e.name
        });
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$14 = {
      ICON_BUTTON_ON: "mdc-icon-button--on",
      ROOT: "mdc-icon-button"
    };
    var strings$22 = {
      ARIA_LABEL: "aria-label",
      ARIA_PRESSED: "aria-pressed",
      DATA_ARIA_LABEL_OFF: "data-aria-label-off",
      DATA_ARIA_LABEL_ON: "data-aria-label-on",
      CHANGE_EVENT: "MDCIconButtonToggle:change"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCIconButtonToggleFoundation = function(_super) {
      __extends(MDCIconButtonToggleFoundation2, _super);
      function MDCIconButtonToggleFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation2.defaultAdapter), adapter)) || this;
        _this.hasToggledAriaLabel = false;
        return _this;
      }
      Object.defineProperty(MDCIconButtonToggleFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$14;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCIconButtonToggleFoundation2, "strings", {
        get: function() {
          return strings$22;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCIconButtonToggleFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            notifyChange: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            getAttr: function() {
              return null;
            },
            setAttr: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCIconButtonToggleFoundation2.prototype.init = function() {
        var ariaLabelOn = this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_ON);
        var ariaLabelOff = this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_OFF);
        if (ariaLabelOn && ariaLabelOff) {
          if (this.adapter.getAttr(strings$22.ARIA_PRESSED) !== null) {
            throw new Error("MDCIconButtonToggleFoundation: Button should not set `aria-pressed` if it has a toggled aria label.");
          }
          this.hasToggledAriaLabel = true;
        } else {
          this.adapter.setAttr(strings$22.ARIA_PRESSED, String(this.isOn()));
        }
      };
      MDCIconButtonToggleFoundation2.prototype.handleClick = function() {
        this.toggle();
        this.adapter.notifyChange({isOn: this.isOn()});
      };
      MDCIconButtonToggleFoundation2.prototype.isOn = function() {
        return this.adapter.hasClass(cssClasses$14.ICON_BUTTON_ON);
      };
      MDCIconButtonToggleFoundation2.prototype.toggle = function(isOn) {
        if (isOn === void 0) {
          isOn = !this.isOn();
        }
        if (isOn) {
          this.adapter.addClass(cssClasses$14.ICON_BUTTON_ON);
        } else {
          this.adapter.removeClass(cssClasses$14.ICON_BUTTON_ON);
        }
        if (this.hasToggledAriaLabel) {
          var ariaLabel = isOn ? this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_OFF);
          this.adapter.setAttr(strings$22.ARIA_LABEL, ariaLabel || "");
        } else {
          this.adapter.setAttr(strings$22.ARIA_PRESSED, "" + isOn);
        }
      };
      return MDCIconButtonToggleFoundation2;
    }(MDCFoundation);
    function create_default_slot$4(ctx) {
      let current;
      const default_slot_template = ctx[28].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[32], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[1] & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[32], !current ? get_all_dirty_from_scope(ctx2[32]) : get_slot_changes(default_slot_template, ctx2[32], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: true,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-icon-button': true,     'mdc-icon-button--on': pressed !== uninitializedValue && pressed,     'mdc-card__action': context === 'card:action',     'mdc-card__action--icon': context === 'card:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__dismiss': context === 'snackbar:actions',     'mdc-data-table__pagination-button': context === 'data-table:pagination',     'mdc-data-table__sort-icon-button':       context === 'data-table:sortable-header-cell',     'mdc-dialog__close': context === 'dialog:header' && action === 'close',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   aria-pressed={pressed !== uninitializedValue     ? pressed       ? 'true'       : 'false'     : null}   aria-label={pressed ? ariaLabelOn : ariaLabelOff}   data-aria-label-on={ariaLabelOn}   data-aria-label-off={ariaLabelOff}   aria-describedby={ariaDescribedby}   on:click={() => instance && instance.handleClick()}   on:click={() =>     context === 'top-app-bar:navigation' &&     dispatch(element, 'SMUI:top-app-bar:icon-button:nav')}   {href}   {...actionProp}   {...internalAttrs}   {...$$restProps}>",
        ctx
      });
      return block;
    }
    function create_fragment$d(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
        {
          use: [
            [
              Ripple,
              {
                ripple: ctx[4],
                unbounded: true,
                color: ctx[5],
                disabled: !!ctx[24].disabled,
                addClass: ctx[21],
                removeClass: ctx[22],
                addStyle: ctx[23]
              }
            ],
            ctx[17],
            ...ctx[1]
          ]
        },
        {
          class: classMap({
            [ctx[2]]: true,
            "mdc-icon-button": true,
            "mdc-icon-button--on": ctx[0] !== ctx[18] && ctx[0],
            "mdc-card__action": ctx[19] === "card:action",
            "mdc-card__action--icon": ctx[19] === "card:action",
            "mdc-top-app-bar__navigation-icon": ctx[19] === "top-app-bar:navigation",
            "mdc-top-app-bar__action-item": ctx[19] === "top-app-bar:action",
            "mdc-snackbar__dismiss": ctx[19] === "snackbar:actions",
            "mdc-data-table__pagination-button": ctx[19] === "data-table:pagination",
            "mdc-data-table__sort-icon-button": ctx[19] === "data-table:sortable-header-cell",
            "mdc-dialog__close": ctx[19] === "dialog:header" && ctx[9] === "close",
            ...ctx[13]
          })
        },
        {
          style: Object.entries(ctx[14]).map(func$22).concat([ctx[3]]).join(" ")
        },
        {
          "aria-pressed": ctx[0] !== ctx[18] ? ctx[0] ? "true" : "false" : null
        },
        {
          "aria-label": ctx[0] ? ctx[6] : ctx[7]
        },
        {
          "data-aria-label-on": ctx[6]
        },
        {
          "data-aria-label-off": ctx[7]
        },
        {
          "aria-describedby": ctx[20]
        },
        {href: ctx[8]},
        ctx[16],
        ctx[15],
        ctx[24]
      ];
      var switch_value = ctx[10];
      function switch_props(ctx2) {
        let switch_instance_props = {
          $$slots: {default: [create_default_slot$4]},
          $$scope: {ctx: ctx2}
        };
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }
        return {
          props: switch_instance_props,
          $$inline: true
        };
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        ctx[29](switch_instance);
        switch_instance.$on("click", ctx[30]);
        switch_instance.$on("click", ctx[31]);
      }
      const block = {
        c: function create2() {
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }
          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_instance_changes = dirty[0] & 33547263 ? get_spread_update(switch_instance_spread_levels, [
            dirty[0] & 31588402 && {
              use: [
                [
                  Ripple,
                  {
                    ripple: ctx2[4],
                    unbounded: true,
                    color: ctx2[5],
                    disabled: !!ctx2[24].disabled,
                    addClass: ctx2[21],
                    removeClass: ctx2[22],
                    addStyle: ctx2[23]
                  }
                ],
                ctx2[17],
                ...ctx2[1]
              ]
            },
            dirty[0] & 795141 && {
              class: classMap({
                [ctx2[2]]: true,
                "mdc-icon-button": true,
                "mdc-icon-button--on": ctx2[0] !== ctx2[18] && ctx2[0],
                "mdc-card__action": ctx2[19] === "card:action",
                "mdc-card__action--icon": ctx2[19] === "card:action",
                "mdc-top-app-bar__navigation-icon": ctx2[19] === "top-app-bar:navigation",
                "mdc-top-app-bar__action-item": ctx2[19] === "top-app-bar:action",
                "mdc-snackbar__dismiss": ctx2[19] === "snackbar:actions",
                "mdc-data-table__pagination-button": ctx2[19] === "data-table:pagination",
                "mdc-data-table__sort-icon-button": ctx2[19] === "data-table:sortable-header-cell",
                "mdc-dialog__close": ctx2[19] === "dialog:header" && ctx2[9] === "close",
                ...ctx2[13]
              })
            },
            dirty[0] & 16392 && {
              style: Object.entries(ctx2[14]).map(func$22).concat([ctx2[3]]).join(" ")
            },
            dirty[0] & 262145 && {
              "aria-pressed": ctx2[0] !== ctx2[18] ? ctx2[0] ? "true" : "false" : null
            },
            dirty[0] & 193 && {
              "aria-label": ctx2[0] ? ctx2[6] : ctx2[7]
            },
            dirty[0] & 64 && {
              "data-aria-label-on": ctx2[6]
            },
            dirty[0] & 128 && {
              "data-aria-label-off": ctx2[7]
            },
            dirty[0] & 1048576 && {
              "aria-describedby": ctx2[20]
            },
            dirty[0] & 256 && {href: ctx2[8]},
            dirty[0] & 65536 && get_spread_object(ctx2[16]),
            dirty[0] & 32768 && get_spread_object(ctx2[15]),
            dirty[0] & 16777216 && get_spread_object(ctx2[24])
          ]) : {};
          if (dirty[1] & 2) {
            switch_instance_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (switch_value !== (switch_value = ctx2[10])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx2));
              ctx2[29](switch_instance);
              switch_instance.$on("click", ctx2[30]);
              switch_instance.$on("click", ctx2[31]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[29](null);
          if (detaching)
            detach_dev(switch_instance_anchor);
          if (switch_instance)
            destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func$22 = ([name2, value]) => `${name2}: ${value};`;
    function instance_1$23($$self, $$props, $$invalidate) {
      let actionProp;
      const omit_props_names = [
        "use",
        "class",
        "style",
        "ripple",
        "color",
        "toggle",
        "pressed",
        "ariaLabelOn",
        "ariaLabelOff",
        "href",
        "action",
        "component",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("IconButton", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {ripple = true} = $$props;
      let {color = null} = $$props;
      let {toggle = false} = $$props;
      let {pressed = uninitializedValue} = $$props;
      let {ariaLabelOn = null} = $$props;
      let {ariaLabelOff = null} = $$props;
      let {href = null} = $$props;
      let {action = null} = $$props;
      let element2;
      let instance8;
      let internalClasses = {};
      let internalStyles = {};
      let internalAttrs = {};
      let context = getContext("SMUI:icon-button:context");
      let ariaDescribedby = getContext("SMUI:icon-button:aria-describedby");
      let {component = href == null ? Button : A} = $$props;
      setContext("SMUI:icon:context", "icon-button");
      let oldToggle = null;
      onDestroy(() => {
        instance8 && instance8.destroy();
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(13, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(13, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name2, value) {
        if (internalStyles[name2] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name2];
            $$invalidate(14, internalStyles);
          } else {
            $$invalidate(14, internalStyles[name2] = value, internalStyles);
          }
        }
      }
      function getAttr(name2) {
        return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
      }
      function addAttr(name2, value) {
        if (internalAttrs[name2] !== value) {
          $$invalidate(15, internalAttrs[name2] = value, internalAttrs);
        }
      }
      function handleChange(evtData) {
        $$invalidate(0, pressed = evtData.isOn);
      }
      function getElement() {
        return element2.getElement();
      }
      function switch_instance_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(11, element2);
        });
      }
      const click_handler = () => instance8 && instance8.handleClick();
      const click_handler_1 = () => context === "top-app-bar:navigation" && dispatch(element2, "SMUI:top-app-bar:icon-button:nav");
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(3, style = $$new_props.style);
        if ("ripple" in $$new_props)
          $$invalidate(4, ripple = $$new_props.ripple);
        if ("color" in $$new_props)
          $$invalidate(5, color = $$new_props.color);
        if ("toggle" in $$new_props)
          $$invalidate(25, toggle = $$new_props.toggle);
        if ("pressed" in $$new_props)
          $$invalidate(0, pressed = $$new_props.pressed);
        if ("ariaLabelOn" in $$new_props)
          $$invalidate(6, ariaLabelOn = $$new_props.ariaLabelOn);
        if ("ariaLabelOff" in $$new_props)
          $$invalidate(7, ariaLabelOff = $$new_props.ariaLabelOff);
        if ("href" in $$new_props)
          $$invalidate(8, href = $$new_props.href);
        if ("action" in $$new_props)
          $$invalidate(9, action = $$new_props.action);
        if ("component" in $$new_props)
          $$invalidate(10, component = $$new_props.component);
        if ("$$scope" in $$new_props)
          $$invalidate(32, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        MDCIconButtonToggleFoundation,
        onDestroy,
        getContext,
        setContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        dispatch,
        Ripple,
        A,
        Button,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        ripple,
        color,
        toggle,
        pressed,
        ariaLabelOn,
        ariaLabelOff,
        href,
        action,
        element: element2,
        instance: instance8,
        internalClasses,
        internalStyles,
        internalAttrs,
        context,
        ariaDescribedby,
        component,
        oldToggle,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        getAttr,
        addAttr,
        handleChange,
        getElement,
        actionProp
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(18, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(3, style = $$new_props.style);
        if ("ripple" in $$props)
          $$invalidate(4, ripple = $$new_props.ripple);
        if ("color" in $$props)
          $$invalidate(5, color = $$new_props.color);
        if ("toggle" in $$props)
          $$invalidate(25, toggle = $$new_props.toggle);
        if ("pressed" in $$props)
          $$invalidate(0, pressed = $$new_props.pressed);
        if ("ariaLabelOn" in $$props)
          $$invalidate(6, ariaLabelOn = $$new_props.ariaLabelOn);
        if ("ariaLabelOff" in $$props)
          $$invalidate(7, ariaLabelOff = $$new_props.ariaLabelOff);
        if ("href" in $$props)
          $$invalidate(8, href = $$new_props.href);
        if ("action" in $$props)
          $$invalidate(9, action = $$new_props.action);
        if ("element" in $$props)
          $$invalidate(11, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(12, instance8 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(13, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(14, internalStyles = $$new_props.internalStyles);
        if ("internalAttrs" in $$props)
          $$invalidate(15, internalAttrs = $$new_props.internalAttrs);
        if ("context" in $$props)
          $$invalidate(19, context = $$new_props.context);
        if ("ariaDescribedby" in $$props)
          $$invalidate(20, ariaDescribedby = $$new_props.ariaDescribedby);
        if ("component" in $$props)
          $$invalidate(10, component = $$new_props.component);
        if ("oldToggle" in $$props)
          $$invalidate(27, oldToggle = $$new_props.oldToggle);
        if ("actionProp" in $$props)
          $$invalidate(16, actionProp = $$new_props.actionProp);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 512) {
          $$invalidate(16, actionProp = (() => {
            if (context === "data-table:pagination") {
              switch (action) {
                case "first-page":
                  return {"data-first-page": "true"};
                case "prev-page":
                  return {"data-prev-page": "true"};
                case "next-page":
                  return {"data-next-page": "true"};
                case "last-page":
                  return {"data-last-page": "true"};
                default:
                  return {"data-action": "true"};
              }
            } else if (context === "dialog:header") {
              return {"data-mdc-dialog-action": action};
            } else {
              return {action};
            }
          })());
        }
        if ($$self.$$.dirty[0] & 167778304) {
          if (element2 && getElement() && toggle !== oldToggle) {
            if (toggle && !instance8) {
              $$invalidate(12, instance8 = new MDCIconButtonToggleFoundation({
                addClass,
                hasClass,
                notifyChange: (evtData) => {
                  handleChange(evtData);
                  dispatch(getElement(), "MDCIconButtonToggle:change", evtData);
                },
                removeClass,
                getAttr,
                setAttr: addAttr
              }));
              instance8.init();
            } else if (!toggle && instance8) {
              instance8.destroy();
              $$invalidate(12, instance8 = null);
              $$invalidate(13, internalClasses = {});
              $$invalidate(15, internalAttrs = {});
            }
            $$invalidate(27, oldToggle = toggle);
          }
        }
        if ($$self.$$.dirty[0] & 4097) {
          if (instance8 && instance8.isOn() !== pressed) {
            instance8.toggle(pressed);
          }
        }
      };
      return [
        pressed,
        use2,
        className,
        style,
        ripple,
        color,
        ariaLabelOn,
        ariaLabelOff,
        href,
        action,
        component,
        element2,
        instance8,
        internalClasses,
        internalStyles,
        internalAttrs,
        actionProp,
        forwardEvents,
        uninitializedValue,
        context,
        ariaDescribedby,
        addClass,
        removeClass,
        addStyle,
        $$restProps,
        toggle,
        getElement,
        oldToggle,
        slots,
        switch_instance_binding,
        click_handler,
        click_handler_1,
        $$scope
      ];
    }
    var IconButton = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$23, create_fragment$d, safe_not_equal, {
          use: 1,
          class: 2,
          style: 3,
          ripple: 4,
          color: 5,
          toggle: 25,
          pressed: 0,
          ariaLabelOn: 6,
          ariaLabelOff: 7,
          href: 8,
          action: 9,
          component: 10,
          getElement: 26
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconButton",
          options,
          id: create_fragment$d.name
        });
      }
      get use() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ripple() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ripple(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get toggle() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set toggle(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get pressed() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set pressed(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ariaLabelOn() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ariaLabelOn(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ariaLabelOff() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ariaLabelOff(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get href() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set href(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get action() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set action(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get component() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set component(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[26];
      }
      set getElement(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$3} = globals;
    var file$b = "src/components/Modal/main.svelte";
    function create_if_block$5(ctx) {
      let div1;
      let div0;
      let div0_transition;
      let t0;
      let main1;
      let header;
      let h1;
      let t1_value = ctx[0]?.title + "";
      let t1;
      let t2;
      let iconbutton;
      let t3;
      let main0;
      let switch_instance;
      let main1_transition;
      let current;
      let mounted;
      let dispose;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot$3]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[3]);
      var switch_value = ctx[0]?.component;
      function switch_props(ctx2) {
        return {$$inline: true};
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          t0 = space();
          main1 = element("main");
          header = element("header");
          h1 = element("h1");
          t1 = text(t1_value);
          t2 = space();
          create_component(iconbutton.$$.fragment);
          t3 = space();
          main0 = element("main");
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          attr_dev(div0, "class", "bg-black bg-opacity-75 w-screen h-screen z-10 absolute top-0 left-0 bottom-0 right-0 ");
          add_location(div0, file$b, 10, 2, 365);
          attr_dev(h1, "class", "text-2xl");
          add_location(h1, file$b, 22, 4, 722);
          attr_dev(header, "class", "p-2 flex justify-between items-center");
          add_location(header, file$b, 21, 3, 663);
          attr_dev(main0, "class", "p-2");
          add_location(main0, file$b, 31, 3, 904);
          attr_dev(main1, "class", "bg-white rounded md:w-6/12 z-20 flex flex-col divide-y divide-gray-600");
          add_location(main1, file$b, 17, 2, 537);
          attr_dev(div1, "class", "fixed top-0 bottom-0 left-0 right-0 overflow-hidden flex justify-center items-center z-40 h-screen w-screen");
          add_location(div1, file$b, 7, 1, 237);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div1, t0);
          append_dev(div1, main1);
          append_dev(main1, header);
          append_dev(header, h1);
          append_dev(h1, t1);
          append_dev(header, t2);
          mount_component(iconbutton, header, null);
          append_dev(main1, t3);
          append_dev(main1, main0);
          if (switch_instance) {
            mount_component(switch_instance, main0, null);
          }
          current = true;
          if (!mounted) {
            dispose = listen_dev(div0, "click", ctx[2], false, false, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0]?.title + ""))
            set_data_dev(t1, t1_value);
          const iconbutton_changes = {};
          if (dirty & 16) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          if (switch_value !== (switch_value = ctx2[0]?.component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, main0, null);
            } else {
              switch_instance = null;
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          add_render_callback(() => {
            if (!div0_transition)
              div0_transition = create_bidirectional_transition(div0, fade, {}, true);
            div0_transition.run(1);
          });
          transition_in(iconbutton.$$.fragment, local);
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          add_render_callback(() => {
            if (!main1_transition)
              main1_transition = create_bidirectional_transition(main1, fly, {x: 500}, true);
            main1_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div0_transition)
            div0_transition = create_bidirectional_transition(div0, fade, {}, false);
          div0_transition.run(0);
          transition_out(iconbutton.$$.fragment, local);
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          if (!main1_transition)
            main1_transition = create_bidirectional_transition(main1, fly, {x: 500}, false);
          main1_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (detaching && div0_transition)
            div0_transition.end();
          destroy_component(iconbutton);
          if (switch_instance)
            destroy_component(switch_instance);
          if (detaching && main1_transition)
            main1_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(7:0) {#if $modal && Object.keys($modal).length != 0 && !$screenShotMode}",
        ctx
      });
      return block;
    }
    function create_default_slot$3(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("close");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$3.name,
        type: "slot",
        source: '(24:4) <IconButton      class=\\"material-icons\\"      on:click={() => {       $modal = {};      }}      >',
        ctx
      });
      return block;
    }
    function create_fragment$c(ctx) {
      let show_if = ctx[0] && Object.keys(ctx[0]).length != 0 && !ctx[1];
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block$5(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 3)
            show_if = ctx2[0] && Object.keys(ctx2[0]).length != 0 && !ctx2[1];
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 3) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$5(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$a($$self, $$props, $$invalidate) {
      let $modal;
      let $screenShotMode;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(0, $modal = $$value));
      validate_store(screenShotMode, "screenShotMode");
      component_subscribe($$self, screenShotMode, ($$value) => $$invalidate(1, $screenShotMode = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Main", slots, []);
      const writable_props = [];
      Object_1$3.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Main> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        set_store_value(modal, $modal = {}, $modal);
      };
      const click_handler_1 = () => {
        set_store_value(modal, $modal = {}, $modal);
      };
      $$self.$capture_state = () => ({
        fly,
        fade,
        IconButton,
        modal,
        screenShotMode,
        $modal,
        $screenShotMode
      });
      return [$modal, $screenShotMode, click_handler, click_handler_1];
    }
    var Main$1 = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$a, create_fragment$c, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Main",
          options,
          id: create_fragment$c.name
        });
      }
    };
    var html2canvas$1 = {exports: {}};
    /*!
     * html2canvas 1.3.2 <https://html2canvas.hertzen.com>
     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */
    (function(module2, exports2) {
      (function(global2, factory) {
        module2.exports = factory();
      })(commonjsGlobal, function() {
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.
        
            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.
        
            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        function __extends2(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign2 = function() {
          __assign2 = Object.assign || function __assign3(t) {
            for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s = arguments[i2];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign2.apply(this, arguments);
        };
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _2 = {label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: []}, f2, y, t, g;
          return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_2)
              try {
                if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _2.label++;
                    return {value: op[1], done: false};
                  case 5:
                    _2.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _2.ops.pop();
                    _2.trys.pop();
                    continue;
                  default:
                    if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _2 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _2.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _2.label < t[1]) {
                      _2.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _2.label < t[2]) {
                      _2.label = t[2];
                      _2.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _2.ops.pop();
                    _2.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _2);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f2 = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return {value: op[0] ? op[1] : void 0, done: true};
          }
        }
        function __spreadArray(to, from, pack2) {
          if (pack2 || arguments.length === 2)
            for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
              if (ar || !(i2 in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
              }
            }
          return to.concat(ar || from);
        }
        var Bounds = function() {
          function Bounds2(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
          }
          Bounds2.prototype.add = function(x, y, w, h) {
            return new Bounds2(this.left + x, this.top + y, this.width + w, this.height + h);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = domRectList[0];
            return domRect ? new Bounds2(domRect.x + context.windowBounds.left, domRect.y + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }();
        var parseBounds = function(context, node) {
          return Bounds.fromClientRect(context, node.getBoundingClientRect());
        };
        var parseDocumentSize = function(document2) {
          var body = document2.body;
          var documentElement = document2.documentElement;
          if (!body || !documentElement) {
            throw new Error("Unable to get document size");
          }
          var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
          var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
          return new Bounds(0, 0, width, height);
        };
        var toCodePoints$1 = function(str) {
          var codePoints = [];
          var i2 = 0;
          var length = str.length;
          while (i2 < length) {
            var value = str.charCodeAt(i2++);
            if (value >= 55296 && value <= 56319 && i2 < length) {
              var extra = str.charCodeAt(i2++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i2--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint$1 = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index = -1;
          var result = "";
          while (++index < length) {
            var codePoint = codePoints[index];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
          lookup$2[chars$2.charCodeAt(i$2)] = i$2;
        }
        var decode$1 = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup$2[base642.charCodeAt(i2)];
            encoded2 = lookup$2[base642.charCodeAt(i2 + 1)];
            encoded3 = lookup$2[base642.charCodeAt(i2 + 2)];
            encoded4 = lookup$2[base642.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 2) {
            bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var polyUint32Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 4) {
            bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2$1 = 5;
        var UTRIE2_SHIFT_1$1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT$1 = 2;
        var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
        var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
        var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
        var slice16$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64$1 = function(base642) {
          var buffer = decode$1(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
        };
        var Trie$1 = function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }();
        var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
        var LETTER_NUMBER_MODIFIER = 50;
        var BK = 1;
        var CR$1 = 2;
        var LF$1 = 3;
        var CM = 4;
        var NL = 5;
        var WJ = 7;
        var ZW = 8;
        var GL = 9;
        var SP = 10;
        var ZWJ$1 = 11;
        var B2 = 12;
        var BA = 13;
        var BB = 14;
        var HY = 15;
        var CB = 16;
        var CL = 17;
        var CP = 18;
        var EX = 19;
        var IN = 20;
        var NS = 21;
        var OP = 22;
        var QU = 23;
        var IS = 24;
        var NU = 25;
        var PO = 26;
        var PR = 27;
        var SY = 28;
        var AI = 29;
        var AL = 30;
        var CJ = 31;
        var EB = 32;
        var EM = 33;
        var H2 = 34;
        var H32 = 35;
        var HL = 36;
        var ID = 37;
        var JL = 38;
        var JV = 39;
        var JT = 40;
        var RI$1 = 41;
        var SA = 42;
        var XX = 43;
        var ea_OP = [9001, 65288];
        var BREAK_MANDATORY = "!";
        var BREAK_NOT_ALLOWED$1 = "\xD7";
        var BREAK_ALLOWED$1 = "\xF7";
        var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
        var ALPHABETICS = [AL, HL];
        var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
        var SPACE$1 = [SP, ZW];
        var PREFIX_POSTFIX = [PR, PO];
        var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
        var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H32];
        var HYPHEN = [HY, BA];
        var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
          if (lineBreak2 === void 0) {
            lineBreak2 = "strict";
          }
          var types = [];
          var indices = [];
          var categories = [];
          codePoints.forEach(function(codePoint, index) {
            var classType = UnicodeTrie$1.get(codePoint);
            if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
            } else {
              categories.push(false);
            }
            if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
              if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
                indices.push(index);
                return types.push(CB);
              }
            }
            if (classType === CM || classType === ZWJ$1) {
              if (index === 0) {
                indices.push(index);
                return types.push(AL);
              }
              var prev = types[index - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                indices.push(indices[index - 1]);
                return types.push(prev);
              }
              indices.push(index);
              return types.push(AL);
            }
            indices.push(index);
            if (classType === CJ) {
              return types.push(lineBreak2 === "strict" ? NS : ID);
            }
            if (classType === SA) {
              return types.push(AL);
            }
            if (classType === AI) {
              return types.push(AL);
            }
            if (classType === XX) {
              if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
                return types.push(ID);
              } else {
                return types.push(AL);
              }
            }
            types.push(classType);
          });
          return [indices, types, categories];
        };
        var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
          var current = classTypes[currentIndex];
          if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
            var i2 = currentIndex;
            while (i2 <= classTypes.length) {
              i2++;
              var next = classTypes[i2];
              if (next === b) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (current === SP) {
            var i2 = currentIndex;
            while (i2 > 0) {
              i2--;
              var prev = classTypes[i2];
              if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
                var n = currentIndex;
                while (n <= classTypes.length) {
                  n++;
                  var next = classTypes[n];
                  if (next === b) {
                    return true;
                  }
                  if (next !== SP) {
                    break;
                  }
                }
              }
              if (prev !== SP) {
                break;
              }
            }
          }
          return false;
        };
        var previousNonSpaceClassType = function(currentIndex, classTypes) {
          var i2 = currentIndex;
          while (i2 >= 0) {
            var type = classTypes[i2];
            if (type === SP) {
              i2--;
            } else {
              return type;
            }
          }
          return 0;
        };
        var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
          if (indicies[index] === 0) {
            return BREAK_NOT_ALLOWED$1;
          }
          var currentIndex = index - 1;
          if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
            return BREAK_NOT_ALLOWED$1;
          }
          var beforeIndex = currentIndex - 1;
          var afterIndex = currentIndex + 1;
          var current = classTypes[currentIndex];
          var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
          var next = classTypes[afterIndex];
          if (current === CR$1 && next === LF$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
            return BREAK_MANDATORY;
          }
          if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (SPACE$1.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
            return BREAK_ALLOWED$1;
          }
          if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === WJ || next === WJ) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SP) {
            return BREAK_ALLOWED$1;
          }
          if (current === QU || next === QU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === CB || current === CB) {
            return BREAK_ALLOWED$1;
          }
          if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (before === HL && HYPHEN.indexOf(current) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SY && next === HL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === IN) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
            var prevIndex = currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if ([PR, PO].indexOf(next) !== -1) {
            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if (JL === current && [JL, JV, H2, H32].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H32].indexOf(current) !== -1 && next === JT) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === RI$1 && next === RI$1) {
            var i2 = indicies[currentIndex];
            var count = 1;
            while (i2 > 0) {
              i2--;
              if (classTypes[i2] === RI$1) {
                count++;
              } else {
                break;
              }
            }
            if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
            }
          }
          if (current === EB && next === EM) {
            return BREAK_NOT_ALLOWED$1;
          }
          return BREAK_ALLOWED$1;
        };
        var cssFormattedClasses = function(codePoints, options) {
          if (!options) {
            options = {lineBreak: "normal", wordBreak: "normal"};
          }
          var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
          if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
            classTypes = classTypes.map(function(type) {
              return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
            });
          }
          var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
            return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
          }) : void 0;
          return [indicies, classTypes, forbiddenBreakpoints];
        };
        var Break = function() {
          function Break2(codePoints, lineBreak2, start, end) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start;
            this.end = end;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }();
        var LineBreaker = function(str, options) {
          var codePoints = toCodePoints$1(str);
          var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
          var length = codePoints.length;
          var lastEnd = 0;
          var nextIndex = 0;
          return {
            next: function() {
              if (nextIndex >= length) {
                return {done: true, value: null};
              }
              var lineBreak2 = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
              }
              if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
                lastEnd = nextIndex;
                return {value, done: false};
              }
              return {done: true, value: null};
            }
          };
        };
        var FLAG_UNRESTRICTED = 1 << 0;
        var FLAG_ID = 1 << 1;
        var FLAG_INTEGER = 1 << 2;
        var FLAG_NUMBER = 1 << 3;
        var LINE_FEED = 10;
        var SOLIDUS = 47;
        var REVERSE_SOLIDUS = 92;
        var CHARACTER_TABULATION = 9;
        var SPACE = 32;
        var QUOTATION_MARK = 34;
        var EQUALS_SIGN = 61;
        var NUMBER_SIGN = 35;
        var DOLLAR_SIGN = 36;
        var PERCENTAGE_SIGN = 37;
        var APOSTROPHE = 39;
        var LEFT_PARENTHESIS = 40;
        var RIGHT_PARENTHESIS = 41;
        var LOW_LINE = 95;
        var HYPHEN_MINUS = 45;
        var EXCLAMATION_MARK = 33;
        var LESS_THAN_SIGN = 60;
        var GREATER_THAN_SIGN = 62;
        var COMMERCIAL_AT = 64;
        var LEFT_SQUARE_BRACKET = 91;
        var RIGHT_SQUARE_BRACKET = 93;
        var CIRCUMFLEX_ACCENT = 61;
        var LEFT_CURLY_BRACKET = 123;
        var QUESTION_MARK = 63;
        var RIGHT_CURLY_BRACKET = 125;
        var VERTICAL_LINE = 124;
        var TILDE = 126;
        var CONTROL = 128;
        var REPLACEMENT_CHARACTER = 65533;
        var ASTERISK = 42;
        var PLUS_SIGN = 43;
        var COMMA = 44;
        var COLON = 58;
        var SEMICOLON = 59;
        var FULL_STOP = 46;
        var NULL = 0;
        var BACKSPACE = 8;
        var LINE_TABULATION = 11;
        var SHIFT_OUT = 14;
        var INFORMATION_SEPARATOR_ONE = 31;
        var DELETE = 127;
        var EOF = -1;
        var ZERO = 48;
        var a = 97;
        var e = 101;
        var f = 102;
        var u = 117;
        var z = 122;
        var A2 = 65;
        var E = 69;
        var F = 70;
        var U = 85;
        var Z = 90;
        var isDigit = function(codePoint) {
          return codePoint >= ZERO && codePoint <= 57;
        };
        var isSurrogateCodePoint = function(codePoint) {
          return codePoint >= 55296 && codePoint <= 57343;
        };
        var isHex = function(codePoint) {
          return isDigit(codePoint) || codePoint >= A2 && codePoint <= F || codePoint >= a && codePoint <= f;
        };
        var isLowerCaseLetter = function(codePoint) {
          return codePoint >= a && codePoint <= z;
        };
        var isUpperCaseLetter = function(codePoint) {
          return codePoint >= A2 && codePoint <= Z;
        };
        var isLetter = function(codePoint) {
          return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
        };
        var isNonASCIICodePoint = function(codePoint) {
          return codePoint >= CONTROL;
        };
        var isWhiteSpace = function(codePoint) {
          return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
        };
        var isNameStartCodePoint = function(codePoint) {
          return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
        };
        var isNameCodePoint = function(codePoint) {
          return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
        };
        var isNonPrintableCodePoint = function(codePoint) {
          return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
        };
        var isValidEscape = function(c1, c2) {
          if (c1 !== REVERSE_SOLIDUS) {
            return false;
          }
          return c2 !== LINE_FEED;
        };
        var isIdentifierStart = function(c1, c2, c3) {
          if (c1 === HYPHEN_MINUS) {
            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
          } else if (isNameStartCodePoint(c1)) {
            return true;
          } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
            return true;
          }
          return false;
        };
        var isNumberStart = function(c1, c2, c3) {
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
            if (isDigit(c2)) {
              return true;
            }
            return c2 === FULL_STOP && isDigit(c3);
          }
          if (c1 === FULL_STOP) {
            return isDigit(c2);
          }
          return isDigit(c1);
        };
        var stringToNumber = function(codePoints) {
          var c = 0;
          var sign = 1;
          if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
              sign = -1;
            }
            c++;
          }
          var integers = [];
          while (isDigit(codePoints[c])) {
            integers.push(codePoints[c++]);
          }
          var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
          if (codePoints[c] === FULL_STOP) {
            c++;
          }
          var fraction = [];
          while (isDigit(codePoints[c])) {
            fraction.push(codePoints[c++]);
          }
          var fracd = fraction.length;
          var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
          if (codePoints[c] === E || codePoints[c] === e) {
            c++;
          }
          var expsign = 1;
          if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
              expsign = -1;
            }
            c++;
          }
          var exponent = [];
          while (isDigit(codePoints[c])) {
            exponent.push(codePoints[c++]);
          }
          var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
          return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
        };
        var LEFT_PARENTHESIS_TOKEN = {
          type: 2
        };
        var RIGHT_PARENTHESIS_TOKEN = {
          type: 3
        };
        var COMMA_TOKEN = {type: 4};
        var SUFFIX_MATCH_TOKEN = {type: 13};
        var PREFIX_MATCH_TOKEN = {type: 8};
        var COLUMN_TOKEN = {type: 21};
        var DASH_MATCH_TOKEN = {type: 9};
        var INCLUDE_MATCH_TOKEN = {type: 10};
        var LEFT_CURLY_BRACKET_TOKEN = {
          type: 11
        };
        var RIGHT_CURLY_BRACKET_TOKEN = {
          type: 12
        };
        var SUBSTRING_MATCH_TOKEN = {type: 14};
        var BAD_URL_TOKEN = {type: 23};
        var BAD_STRING_TOKEN = {type: 1};
        var CDO_TOKEN = {type: 25};
        var CDC_TOKEN = {type: 24};
        var COLON_TOKEN = {type: 26};
        var SEMICOLON_TOKEN = {type: 27};
        var LEFT_SQUARE_BRACKET_TOKEN = {
          type: 28
        };
        var RIGHT_SQUARE_BRACKET_TOKEN = {
          type: 29
        };
        var WHITESPACE_TOKEN = {type: 31};
        var EOF_TOKEN = {type: 32};
        var Tokenizer = function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c2 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                  var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return {type: 5, value, flags};
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e2 = this.peekCodePoint(0);
                var e3 = this.peekCodePoint(1);
                if (isNumberStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c = this.consumeCodePoint();
                    if (c === ASTERISK) {
                      c = this.consumeCodePoint();
                      if (c === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a2 = this.peekCodePoint(1);
                var a3 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a2, a3)) {
                  var value = this.consumeName();
                  return {type: 7, value};
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u:
              case U:
                var u1 = this.peekCodePoint(0);
                var u2 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return {type: 6, value: fromCodePoint$1(codePoint)};
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F : digit;
              })), 16);
              return {type: 30, start: start_1, end};
            }
            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return {type: 30, start, end};
            } else {
              return {type: 30, start, end: start};
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return {type: 19, value};
            }
            return {type: 20, value};
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return {type: 22, value: ""};
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return {type: 22, value: stringToken.value};
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return {type: 22, value: fromCodePoint$1.apply(void 0, value)};
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return {type: 22, value: fromCodePoint$1.apply(void 0, value)};
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 6e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i2 = 0;
            do {
              var codePoint = this._value[i2];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i2);
                return {type: 0, value};
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i2);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next = this._value[i2 + 1];
                if (next !== EOF && next !== void 0) {
                  if (next === LINE_FEED) {
                    value += this.consumeStringSlice(i2);
                    i2 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next)) {
                    value += this.consumeStringSlice(i2);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i2 = -1;
                  }
                }
              }
              i2++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return {type: 15, number, flags, unit};
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return {type: 16, number, flags};
            }
            return {type: 17, number, flags};
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }();
        var Parser = function() {
          function Parser2(tokens) {
            this._tokens = tokens;
          }
          Parser2.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser2(tokenizer.read());
          };
          Parser2.parseValue = function(value) {
            return Parser2.create(value).parseComponentValue();
          };
          Parser2.parseValues = function(value) {
            return Parser2.create(value).parseComponentValues();
          };
          Parser2.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser2.prototype.parseComponentValues = function() {
            var values = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values;
              }
              values.push(value);
              values.push();
            }
          };
          Parser2.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser2.prototype.consumeSimpleBlock = function(type) {
            var block = {type, values: []};
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser2.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser2.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser2.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser2;
        }();
        var isDimensionToken = function(token) {
          return token.type === 15;
        };
        var isNumberToken = function(token) {
          return token.type === 17;
        };
        var isIdentToken = function(token) {
          return token.type === 20;
        };
        var isStringToken = function(token) {
          return token.type === 0;
        };
        var isIdentWithValue = function(token, value) {
          return isIdentToken(token) && token.value === value;
        };
        var nonWhiteSpace = function(token) {
          return token.type !== 31;
        };
        var nonFunctionArgSeparator = function(token) {
          return token.type !== 31 && token.type !== 4;
        };
        var parseFunctionArgs = function(tokens) {
          var args = [];
          var arg = [];
          tokens.forEach(function(token) {
            if (token.type === 4) {
              if (arg.length === 0) {
                throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
            }
            if (token.type !== 31) {
              arg.push(token);
            }
          });
          if (arg.length) {
            args.push(arg);
          }
          return args;
        };
        var isEndingTokenFor = function(token, type) {
          if (type === 11 && token.type === 12) {
            return true;
          }
          if (type === 28 && token.type === 29) {
            return true;
          }
          return type === 2 && token.type === 3;
        };
        var isLength = function(token) {
          return token.type === 17 || token.type === 15;
        };
        var isLengthPercentage = function(token) {
          return token.type === 16 || isLength(token);
        };
        var parseLengthPercentageTuple = function(tokens) {
          return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
        };
        var ZERO_LENGTH = {
          type: 17,
          number: 0,
          flags: FLAG_INTEGER
        };
        var FIFTY_PERCENT = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var HUNDRED_PERCENT = {
          type: 16,
          number: 100,
          flags: FLAG_INTEGER
        };
        var getAbsoluteValueForTuple = function(tuple, width, height) {
          var x = tuple[0], y = tuple[1];
          return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== "undefined" ? y : x, height)];
        };
        var getAbsoluteValue = function(token, parent2) {
          if (token.type === 16) {
            return token.number / 100 * parent2;
          }
          if (isDimensionToken(token)) {
            switch (token.unit) {
              case "rem":
              case "em":
                return 16 * token.number;
              case "px":
              default:
                return token.number;
            }
          }
          return token.number;
        };
        var DEG = "deg";
        var GRAD = "grad";
        var RAD = "rad";
        var TURN = "turn";
        var angle = {
          name: "angle",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit) {
                case DEG:
                  return Math.PI * value.number / 180;
                case GRAD:
                  return Math.PI / 200 * value.number;
                case RAD:
                  return value.number;
                case TURN:
                  return Math.PI * 2 * value.number;
              }
            }
            throw new Error("Unsupported angle type");
          }
        };
        var isAngle = function(value) {
          if (value.type === 15) {
            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
            }
          }
          return false;
        };
        var parseNamedSide = function(tokens) {
          var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
            return ident.value;
          }).join(" ");
          switch (sideOrCorner) {
            case "to bottom right":
            case "to right bottom":
            case "left top":
            case "top left":
              return [ZERO_LENGTH, ZERO_LENGTH];
            case "to top":
            case "bottom":
              return deg(0);
            case "to bottom left":
            case "to left bottom":
            case "right top":
            case "top right":
              return [ZERO_LENGTH, HUNDRED_PERCENT];
            case "to right":
            case "left":
              return deg(90);
            case "to top left":
            case "to left top":
            case "right bottom":
            case "bottom right":
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
            case "to bottom":
            case "top":
              return deg(180);
            case "to top right":
            case "to right top":
            case "left bottom":
            case "bottom left":
              return [HUNDRED_PERCENT, ZERO_LENGTH];
            case "to left":
            case "right":
              return deg(270);
          }
          return 0;
        };
        var deg = function(deg2) {
          return Math.PI * deg2 / 180;
        };
        var color$1 = {
          name: "color",
          parse: function(context, value) {
            if (value.type === 18) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
              }
              return colorFunction(context, value.values);
            }
            if (value.type === 5) {
              if (value.value.length === 3) {
                var r = value.value.substring(0, 1);
                var g = value.value.substring(1, 2);
                var b = value.value.substring(2, 3);
                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
              }
              if (value.value.length === 4) {
                var r = value.value.substring(0, 1);
                var g = value.value.substring(1, 2);
                var b = value.value.substring(2, 3);
                var a2 = value.value.substring(3, 4);
                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
              }
              if (value.value.length === 6) {
                var r = value.value.substring(0, 2);
                var g = value.value.substring(2, 4);
                var b = value.value.substring(4, 6);
                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
              }
              if (value.value.length === 8) {
                var r = value.value.substring(0, 2);
                var g = value.value.substring(2, 4);
                var b = value.value.substring(4, 6);
                var a2 = value.value.substring(6, 8);
                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
              }
            }
            if (value.type === 20) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== "undefined") {
                return namedColor;
              }
            }
            return COLORS.TRANSPARENT;
          }
        };
        var isTransparent = function(color2) {
          return (255 & color2) === 0;
        };
        var asString = function(color2) {
          var alpha = 255 & color2;
          var blue = 255 & color2 >> 8;
          var green = 255 & color2 >> 16;
          var red = 255 & color2 >> 24;
          return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
        };
        var pack = function(r, g, b, a2) {
          return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
        };
        var getTokenColorValue = function(token, i2) {
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 16) {
            var max = i2 === 3 ? 1 : 255;
            return i2 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
          }
          return 0;
        };
        var rgb = function(_context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          if (tokens.length === 3) {
            var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
            return pack(r, g, b, 1);
          }
          if (tokens.length === 4) {
            var _b2 = tokens.map(getTokenColorValue), r = _b2[0], g = _b2[1], b = _b2[2], a2 = _b2[3];
            return pack(r, g, b, a2);
          }
          return 0;
        };
        function hue2rgb(t1, t2, hue) {
          if (hue < 0) {
            hue += 1;
          }
          if (hue >= 1) {
            hue -= 1;
          }
          if (hue < 1 / 6) {
            return (t2 - t1) * hue * 6 + t1;
          } else if (hue < 1 / 2) {
            return t2;
          } else if (hue < 2 / 3) {
            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
          } else {
            return t1;
          }
        }
        var hsl = function(context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
          var h = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
          var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
          var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
          var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
          if (s === 0) {
            return pack(l * 255, l * 255, l * 255, 1);
          }
          var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var t1 = l * 2 - t2;
          var r = hue2rgb(t1, t2, h + 1 / 3);
          var g = hue2rgb(t1, t2, h);
          var b = hue2rgb(t1, t2, h - 1 / 3);
          return pack(r * 255, g * 255, b * 255, a2);
        };
        var SUPPORTED_COLOR_FUNCTIONS = {
          hsl,
          hsla: hsl,
          rgb,
          rgba: rgb
        };
        var parseColor = function(context, value) {
          return color$1.parse(context, Parser.create(value).parseComponentValue());
        };
        var COLORS = {
          ALICEBLUE: 4042850303,
          ANTIQUEWHITE: 4209760255,
          AQUA: 16777215,
          AQUAMARINE: 2147472639,
          AZURE: 4043309055,
          BEIGE: 4126530815,
          BISQUE: 4293182719,
          BLACK: 255,
          BLANCHEDALMOND: 4293643775,
          BLUE: 65535,
          BLUEVIOLET: 2318131967,
          BROWN: 2771004159,
          BURLYWOOD: 3736635391,
          CADETBLUE: 1604231423,
          CHARTREUSE: 2147418367,
          CHOCOLATE: 3530104575,
          CORAL: 4286533887,
          CORNFLOWERBLUE: 1687547391,
          CORNSILK: 4294499583,
          CRIMSON: 3692313855,
          CYAN: 16777215,
          DARKBLUE: 35839,
          DARKCYAN: 9145343,
          DARKGOLDENROD: 3095837695,
          DARKGRAY: 2846468607,
          DARKGREEN: 6553855,
          DARKGREY: 2846468607,
          DARKKHAKI: 3182914559,
          DARKMAGENTA: 2332068863,
          DARKOLIVEGREEN: 1433087999,
          DARKORANGE: 4287365375,
          DARKORCHID: 2570243327,
          DARKRED: 2332033279,
          DARKSALMON: 3918953215,
          DARKSEAGREEN: 2411499519,
          DARKSLATEBLUE: 1211993087,
          DARKSLATEGRAY: 793726975,
          DARKSLATEGREY: 793726975,
          DARKTURQUOISE: 13554175,
          DARKVIOLET: 2483082239,
          DEEPPINK: 4279538687,
          DEEPSKYBLUE: 12582911,
          DIMGRAY: 1768516095,
          DIMGREY: 1768516095,
          DODGERBLUE: 512819199,
          FIREBRICK: 2988581631,
          FLORALWHITE: 4294635775,
          FORESTGREEN: 579543807,
          FUCHSIA: 4278255615,
          GAINSBORO: 3705462015,
          GHOSTWHITE: 4177068031,
          GOLD: 4292280575,
          GOLDENROD: 3668254975,
          GRAY: 2155905279,
          GREEN: 8388863,
          GREENYELLOW: 2919182335,
          GREY: 2155905279,
          HONEYDEW: 4043305215,
          HOTPINK: 4285117695,
          INDIANRED: 3445382399,
          INDIGO: 1258324735,
          IVORY: 4294963455,
          KHAKI: 4041641215,
          LAVENDER: 3873897215,
          LAVENDERBLUSH: 4293981695,
          LAWNGREEN: 2096890111,
          LEMONCHIFFON: 4294626815,
          LIGHTBLUE: 2916673279,
          LIGHTCORAL: 4034953471,
          LIGHTCYAN: 3774873599,
          LIGHTGOLDENRODYELLOW: 4210742015,
          LIGHTGRAY: 3553874943,
          LIGHTGREEN: 2431553791,
          LIGHTGREY: 3553874943,
          LIGHTPINK: 4290167295,
          LIGHTSALMON: 4288707327,
          LIGHTSEAGREEN: 548580095,
          LIGHTSKYBLUE: 2278488831,
          LIGHTSLATEGRAY: 2005441023,
          LIGHTSLATEGREY: 2005441023,
          LIGHTSTEELBLUE: 2965692159,
          LIGHTYELLOW: 4294959359,
          LIME: 16711935,
          LIMEGREEN: 852308735,
          LINEN: 4210091775,
          MAGENTA: 4278255615,
          MAROON: 2147483903,
          MEDIUMAQUAMARINE: 1724754687,
          MEDIUMBLUE: 52735,
          MEDIUMORCHID: 3126187007,
          MEDIUMPURPLE: 2473647103,
          MEDIUMSEAGREEN: 1018393087,
          MEDIUMSLATEBLUE: 2070474495,
          MEDIUMSPRINGGREEN: 16423679,
          MEDIUMTURQUOISE: 1221709055,
          MEDIUMVIOLETRED: 3340076543,
          MIDNIGHTBLUE: 421097727,
          MINTCREAM: 4127193855,
          MISTYROSE: 4293190143,
          MOCCASIN: 4293178879,
          NAVAJOWHITE: 4292783615,
          NAVY: 33023,
          OLDLACE: 4260751103,
          OLIVE: 2155872511,
          OLIVEDRAB: 1804477439,
          ORANGE: 4289003775,
          ORANGERED: 4282712319,
          ORCHID: 3664828159,
          PALEGOLDENROD: 4008225535,
          PALEGREEN: 2566625535,
          PALETURQUOISE: 2951671551,
          PALEVIOLETRED: 3681588223,
          PAPAYAWHIP: 4293907967,
          PEACHPUFF: 4292524543,
          PERU: 3448061951,
          PINK: 4290825215,
          PLUM: 3718307327,
          POWDERBLUE: 2967529215,
          PURPLE: 2147516671,
          REBECCAPURPLE: 1714657791,
          RED: 4278190335,
          ROSYBROWN: 3163525119,
          ROYALBLUE: 1097458175,
          SADDLEBROWN: 2336560127,
          SALMON: 4202722047,
          SANDYBROWN: 4104413439,
          SEAGREEN: 780883967,
          SEASHELL: 4294307583,
          SIENNA: 2689740287,
          SILVER: 3233857791,
          SKYBLUE: 2278484991,
          SLATEBLUE: 1784335871,
          SLATEGRAY: 1887473919,
          SLATEGREY: 1887473919,
          SNOW: 4294638335,
          SPRINGGREEN: 16744447,
          STEELBLUE: 1182971135,
          TAN: 3535047935,
          TEAL: 8421631,
          THISTLE: 3636451583,
          TOMATO: 4284696575,
          TRANSPARENT: 0,
          TURQUOISE: 1088475391,
          VIOLET: 4001558271,
          WHEAT: 4125012991,
          WHITE: 4294967295,
          WHITESMOKE: 4126537215,
          YELLOW: 4294902015,
          YELLOWGREEN: 2597139199
        };
        var BACKGROUND_CLIP;
        (function(BACKGROUND_CLIP2) {
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["BORDER_BOX"] = 0] = "BORDER_BOX";
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["PADDING_BOX"] = 1] = "PADDING_BOX";
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["CONTENT_BOX"] = 2] = "CONTENT_BOX";
        })(BACKGROUND_CLIP || (BACKGROUND_CLIP = {}));
        var backgroundClip = {
          name: "background-clip",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return BACKGROUND_CLIP.PADDING_BOX;
                  case "content-box":
                    return BACKGROUND_CLIP.CONTENT_BOX;
                }
              }
              return BACKGROUND_CLIP.BORDER_BOX;
            });
          }
        };
        var backgroundColor = {
          name: "background-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var parseColorStop = function(context, args) {
          var color2 = color$1.parse(context, args[0]);
          var stop = args[1];
          return stop && isLengthPercentage(stop) ? {color: color2, stop} : {color: color2, stop: null};
        };
        var processColorStops = function(stops, lineLength) {
          var first = stops[0];
          var last = stops[stops.length - 1];
          if (first.stop === null) {
            first.stop = ZERO_LENGTH;
          }
          if (last.stop === null) {
            last.stop = HUNDRED_PERCENT;
          }
          var processStops = [];
          var previous = 0;
          for (var i2 = 0; i2 < stops.length; i2++) {
            var stop_1 = stops[i2].stop;
            if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                processStops.push(absoluteValue);
              } else {
                processStops.push(previous);
              }
              previous = absoluteValue;
            } else {
              processStops.push(null);
            }
          }
          var gapBegin = null;
          for (var i2 = 0; i2 < processStops.length; i2++) {
            var stop_2 = processStops[i2];
            if (stop_2 === null) {
              if (gapBegin === null) {
                gapBegin = i2;
              }
            } else if (gapBegin !== null) {
              var gapLength = i2 - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g = 1; g <= gapLength; g++) {
                processStops[gapBegin + g - 1] = gapValue * g;
              }
              gapBegin = null;
            }
          }
          return stops.map(function(_a2, i3) {
            var color2 = _a2.color;
            return {color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0)};
          });
        };
        var getAngleFromCorner = function(corner, width, height) {
          var centerX = width / 2;
          var centerY = height / 2;
          var x = getAbsoluteValue(corner[0], width) - centerX;
          var y = centerY - getAbsoluteValue(corner[1], height);
          return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
        };
        var calculateGradientDirection = function(angle2, width, height) {
          var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
          var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          var halfLineLength = lineLength / 2;
          var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
          var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
          return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
        };
        var distance = function(a2, b) {
          return Math.sqrt(a2 * a2 + b * b);
        };
        var findCorner = function(width, height, x, y, closest3) {
          var corners = [
            [0, 0],
            [0, height],
            [width, 0],
            [width, height]
          ];
          return corners.reduce(function(stat, corner) {
            var cx = corner[0], cy = corner[1];
            var d = distance(x - cx, y - cy);
            if (closest3 ? d < stat.optimumDistance : d > stat.optimumDistance) {
              return {
                optimumCorner: corner,
                optimumDistance: d
              };
            }
            return stat;
          }, {
            optimumDistance: closest3 ? Infinity : -Infinity,
            optimumCorner: null
          }).optimumCorner;
        };
        var calculateRadius = function(gradient, x, y, width, height) {
          var rx = 0;
          var ry = 0;
          switch (gradient.size) {
            case CSSRadialExtent.CLOSEST_SIDE:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                rx = Math.min(Math.abs(x), Math.abs(x - width));
                ry = Math.min(Math.abs(y), Math.abs(y - height));
              }
              break;
            case CSSRadialExtent.CLOSEST_CORNER:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                var _a2 = findCorner(width, height, x, y, true), cx = _a2[0], cy = _a2[1];
                rx = distance(cx - x, (cy - y) / c);
                ry = c * rx;
              }
              break;
            case CSSRadialExtent.FARTHEST_SIDE:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                rx = Math.max(Math.abs(x), Math.abs(x - width));
                ry = Math.max(Math.abs(y), Math.abs(y - height));
              }
              break;
            case CSSRadialExtent.FARTHEST_CORNER:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                var _b2 = findCorner(width, height, x, y, false), cx = _b2[0], cy = _b2[1];
                rx = distance(cx - x, (cy - y) / c);
                ry = c * rx;
              }
              break;
          }
          if (Array.isArray(gradient.size)) {
            rx = getAbsoluteValue(gradient.size[0], width);
            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
          }
          return [rx, ry];
        };
        var linearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            if (i2 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && firstToken.value === "to") {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = angle.parse(context, firstToken);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {angle: angle$1, stops, type: CSSImageType.LINEAR_GRADIENT};
        };
        var prefixLinearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            if (i2 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {
            angle: angle$1,
            stops,
            type: CSSImageType.LINEAR_GRADIENT
          };
        };
        var webkitGradient = function(context, tokens) {
          var angle2 = deg(180);
          var stops = [];
          var type = CSSImageType.LINEAR_GRADIENT;
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var firstToken = arg[0];
            if (i2 === 0) {
              if (isIdentToken(firstToken) && firstToken.value === "linear") {
                type = CSSImageType.LINEAR_GRADIENT;
                return;
              } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
                type = CSSImageType.RADIAL_GRADIENT;
                return;
              }
            }
            if (firstToken.type === 18) {
              if (firstToken.name === "from") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({stop: ZERO_LENGTH, color: color2});
              } else if (firstToken.name === "to") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({stop: HUNDRED_PERCENT, color: color2});
              } else if (firstToken.name === "color-stop") {
                var values = firstToken.values.filter(nonFunctionArgSeparator);
                if (values.length === 2) {
                  var color2 = color$1.parse(context, values[1]);
                  var stop_1 = values[0];
                  if (isNumberToken(stop_1)) {
                    stops.push({
                      stop: {type: 16, number: stop_1.number * 100, flags: stop_1.flags},
                      color: color2
                    });
                  }
                }
              }
            }
          });
          return type === CSSImageType.LINEAR_GRADIENT ? {
            angle: (angle2 + deg(180)) % deg(360),
            stops,
            type
          } : {size, shape, stops, position: position2, type};
        };
        var CLOSEST_SIDE = "closest-side";
        var FARTHEST_SIDE = "farthest-side";
        var CLOSEST_CORNER = "closest-corner";
        var FARTHEST_CORNER = "farthest-corner";
        var CIRCLE = "circle";
        var ELLIPSE = "ellipse";
        var COVER = "cover";
        var CONTAIN = "contain";
        var radialGradient = function(context, tokens) {
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var isColorStop = true;
            if (i2 === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function(acc, token) {
                if (isAtPosition_1) {
                  if (isIdentToken(token)) {
                    switch (token.value) {
                      case "center":
                        position2.push(FIFTY_PERCENT);
                        return acc;
                      case "top":
                      case "left":
                        position2.push(ZERO_LENGTH);
                        return acc;
                      case "right":
                      case "bottom":
                        position2.push(HUNDRED_PERCENT);
                        return acc;
                    }
                  } else if (isLengthPercentage(token) || isLength(token)) {
                    position2.push(token);
                  }
                } else if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = CSSRadialShape.CIRCLE;
                      return false;
                    case ELLIPSE:
                      shape = CSSRadialShape.ELLIPSE;
                      return false;
                    case "at":
                      isAtPosition_1 = true;
                      return false;
                    case CLOSEST_SIDE:
                      size = CSSRadialExtent.CLOSEST_SIDE;
                      return false;
                    case COVER:
                    case FARTHEST_SIDE:
                      size = CSSRadialExtent.FARTHEST_SIDE;
                      return false;
                    case CONTAIN:
                    case CLOSEST_CORNER:
                      size = CSSRadialExtent.CLOSEST_CORNER;
                      return false;
                    case FARTHEST_CORNER:
                      size = CSSRadialExtent.FARTHEST_CORNER;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {size, shape, stops, position: position2, type: CSSImageType.RADIAL_GRADIENT};
        };
        var prefixRadialGradient = function(context, tokens) {
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var isColorStop = true;
            if (i2 === 0) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return false;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return false;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return false;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            } else if (i2 === 1) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = CSSRadialShape.CIRCLE;
                      return false;
                    case ELLIPSE:
                      shape = CSSRadialShape.ELLIPSE;
                      return false;
                    case CONTAIN:
                    case CLOSEST_SIDE:
                      size = CSSRadialExtent.CLOSEST_SIDE;
                      return false;
                    case FARTHEST_SIDE:
                      size = CSSRadialExtent.FARTHEST_SIDE;
                      return false;
                    case CLOSEST_CORNER:
                      size = CSSRadialExtent.CLOSEST_CORNER;
                      return false;
                    case COVER:
                    case FARTHEST_CORNER:
                      size = CSSRadialExtent.FARTHEST_CORNER;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {size, shape, stops, position: position2, type: CSSImageType.RADIAL_GRADIENT};
        };
        var CSSImageType;
        (function(CSSImageType2) {
          CSSImageType2[CSSImageType2["URL"] = 0] = "URL";
          CSSImageType2[CSSImageType2["LINEAR_GRADIENT"] = 1] = "LINEAR_GRADIENT";
          CSSImageType2[CSSImageType2["RADIAL_GRADIENT"] = 2] = "RADIAL_GRADIENT";
        })(CSSImageType || (CSSImageType = {}));
        var isLinearGradient = function(background) {
          return background.type === CSSImageType.LINEAR_GRADIENT;
        };
        var isRadialGradient = function(background) {
          return background.type === CSSImageType.RADIAL_GRADIENT;
        };
        var CSSRadialShape;
        (function(CSSRadialShape2) {
          CSSRadialShape2[CSSRadialShape2["CIRCLE"] = 0] = "CIRCLE";
          CSSRadialShape2[CSSRadialShape2["ELLIPSE"] = 1] = "ELLIPSE";
        })(CSSRadialShape || (CSSRadialShape = {}));
        var CSSRadialExtent;
        (function(CSSRadialExtent2) {
          CSSRadialExtent2[CSSRadialExtent2["CLOSEST_SIDE"] = 0] = "CLOSEST_SIDE";
          CSSRadialExtent2[CSSRadialExtent2["FARTHEST_SIDE"] = 1] = "FARTHEST_SIDE";
          CSSRadialExtent2[CSSRadialExtent2["CLOSEST_CORNER"] = 2] = "CLOSEST_CORNER";
          CSSRadialExtent2[CSSRadialExtent2["FARTHEST_CORNER"] = 3] = "FARTHEST_CORNER";
        })(CSSRadialExtent || (CSSRadialExtent = {}));
        var image = {
          name: "image",
          parse: function(context, value) {
            if (value.type === 22) {
              var image_1 = {url: value.value, type: CSSImageType.URL};
              context.cache.addImage(value.value);
              return image_1;
            }
            if (value.type === 18) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
              }
              return imageFunction(context, value.values);
            }
            throw new Error("Unsupported image type " + value.type);
          }
        };
        function isSupportedImage(value) {
          return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
        }
        var SUPPORTED_IMAGE_FUNCTIONS = {
          "linear-gradient": linearGradient,
          "-moz-linear-gradient": prefixLinearGradient,
          "-ms-linear-gradient": prefixLinearGradient,
          "-o-linear-gradient": prefixLinearGradient,
          "-webkit-linear-gradient": prefixLinearGradient,
          "radial-gradient": radialGradient,
          "-moz-radial-gradient": prefixRadialGradient,
          "-ms-radial-gradient": prefixRadialGradient,
          "-o-radial-gradient": prefixRadialGradient,
          "-webkit-radial-gradient": prefixRadialGradient,
          "-webkit-gradient": webkitGradient
        };
        var backgroundImage = {
          name: "background-image",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens.filter(function(value) {
              return nonFunctionArgSeparator(value) && isSupportedImage(value);
            }).map(function(value) {
              return image.parse(context, value);
            });
          }
        };
        var backgroundOrigin = {
          name: "background-origin",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return 1;
                  case "content-box":
                    return 2;
                }
              }
              return 0;
            });
          }
        };
        var backgroundPosition = {
          name: "background-position",
          initialValue: "0% 0%",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isLengthPercentage);
            }).map(parseLengthPercentageTuple);
          }
        };
        var BACKGROUND_REPEAT;
        (function(BACKGROUND_REPEAT2) {
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT"] = 0] = "REPEAT";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["NO_REPEAT"] = 1] = "NO_REPEAT";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT_X"] = 2] = "REPEAT_X";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT_Y"] = 3] = "REPEAT_Y";
        })(BACKGROUND_REPEAT || (BACKGROUND_REPEAT = {}));
        var backgroundRepeat = {
          name: "background-repeat",
          initialValue: "repeat",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isIdentToken).map(function(token) {
                return token.value;
              }).join(" ");
            }).map(parseBackgroundRepeat);
          }
        };
        var parseBackgroundRepeat = function(value) {
          switch (value) {
            case "no-repeat":
              return BACKGROUND_REPEAT.NO_REPEAT;
            case "repeat-x":
            case "repeat no-repeat":
              return BACKGROUND_REPEAT.REPEAT_X;
            case "repeat-y":
            case "no-repeat repeat":
              return BACKGROUND_REPEAT.REPEAT_Y;
            case "repeat":
            default:
              return BACKGROUND_REPEAT.REPEAT;
          }
        };
        var BACKGROUND_SIZE;
        (function(BACKGROUND_SIZE2) {
          BACKGROUND_SIZE2["AUTO"] = "auto";
          BACKGROUND_SIZE2["CONTAIN"] = "contain";
          BACKGROUND_SIZE2["COVER"] = "cover";
        })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
        var backgroundSize = {
          name: "background-size",
          initialValue: "0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isBackgroundSizeInfoToken);
            });
          }
        };
        var isBackgroundSizeInfoToken = function(value) {
          return isIdentToken(value) || isLengthPercentage(value);
        };
        var borderColorForSide = function(side) {
          return {
            name: "border-" + side + "-color",
            initialValue: "transparent",
            prefix: false,
            type: 3,
            format: "color"
          };
        };
        var borderTopColor = borderColorForSide("top");
        var borderRightColor = borderColorForSide("right");
        var borderBottomColor = borderColorForSide("bottom");
        var borderLeftColor = borderColorForSide("left");
        var borderRadiusForSide = function(side) {
          return {
            name: "border-radius-" + side,
            initialValue: "0 0",
            prefix: false,
            type: 1,
            parse: function(_context, tokens) {
              return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
            }
          };
        };
        var borderTopLeftRadius = borderRadiusForSide("top-left");
        var borderTopRightRadius = borderRadiusForSide("top-right");
        var borderBottomRightRadius = borderRadiusForSide("bottom-right");
        var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
        var BORDER_STYLE;
        (function(BORDER_STYLE2) {
          BORDER_STYLE2[BORDER_STYLE2["NONE"] = 0] = "NONE";
          BORDER_STYLE2[BORDER_STYLE2["SOLID"] = 1] = "SOLID";
          BORDER_STYLE2[BORDER_STYLE2["DASHED"] = 2] = "DASHED";
          BORDER_STYLE2[BORDER_STYLE2["DOTTED"] = 3] = "DOTTED";
          BORDER_STYLE2[BORDER_STYLE2["DOUBLE"] = 4] = "DOUBLE";
        })(BORDER_STYLE || (BORDER_STYLE = {}));
        var borderStyleForSide = function(side) {
          return {
            name: "border-" + side + "-style",
            initialValue: "solid",
            prefix: false,
            type: 2,
            parse: function(_context, style) {
              switch (style) {
                case "none":
                  return BORDER_STYLE.NONE;
                case "dashed":
                  return BORDER_STYLE.DASHED;
                case "dotted":
                  return BORDER_STYLE.DOTTED;
                case "double":
                  return BORDER_STYLE.DOUBLE;
              }
              return BORDER_STYLE.SOLID;
            }
          };
        };
        var borderTopStyle = borderStyleForSide("top");
        var borderRightStyle = borderStyleForSide("right");
        var borderBottomStyle = borderStyleForSide("bottom");
        var borderLeftStyle = borderStyleForSide("left");
        var borderWidthForSide = function(side) {
          return {
            name: "border-" + side + "-width",
            initialValue: "0",
            type: 0,
            prefix: false,
            parse: function(_context, token) {
              if (isDimensionToken(token)) {
                return token.number;
              }
              return 0;
            }
          };
        };
        var borderTopWidth = borderWidthForSide("top");
        var borderRightWidth = borderWidthForSide("right");
        var borderBottomWidth = borderWidthForSide("bottom");
        var borderLeftWidth = borderWidthForSide("left");
        var color = {
          name: "color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var direction = {
          name: "direction",
          initialValue: "ltr",
          prefix: false,
          type: 2,
          parse: function(_context, direction2) {
            switch (direction2) {
              case "rtl":
                return 1;
              case "ltr":
              default:
                return 0;
            }
          }
        };
        var display = {
          name: "display",
          initialValue: "inline-block",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).reduce(function(bit, token) {
              return bit | parseDisplayValue(token.value);
            }, 0);
          }
        };
        var parseDisplayValue = function(display2) {
          switch (display2) {
            case "block":
            case "-webkit-box":
              return 2;
            case "inline":
              return 4;
            case "run-in":
              return 8;
            case "flow":
              return 16;
            case "flow-root":
              return 32;
            case "table":
              return 64;
            case "flex":
            case "-webkit-flex":
              return 128;
            case "grid":
            case "-ms-grid":
              return 256;
            case "ruby":
              return 512;
            case "subgrid":
              return 1024;
            case "list-item":
              return 2048;
            case "table-row-group":
              return 4096;
            case "table-header-group":
              return 8192;
            case "table-footer-group":
              return 16384;
            case "table-row":
              return 32768;
            case "table-cell":
              return 65536;
            case "table-column-group":
              return 131072;
            case "table-column":
              return 262144;
            case "table-caption":
              return 524288;
            case "ruby-base":
              return 1048576;
            case "ruby-text":
              return 2097152;
            case "ruby-base-container":
              return 4194304;
            case "ruby-text-container":
              return 8388608;
            case "contents":
              return 16777216;
            case "inline-block":
              return 33554432;
            case "inline-list-item":
              return 67108864;
            case "inline-table":
              return 134217728;
            case "inline-flex":
              return 268435456;
            case "inline-grid":
              return 536870912;
          }
          return 0;
        };
        var FLOAT;
        (function(FLOAT2) {
          FLOAT2[FLOAT2["NONE"] = 0] = "NONE";
          FLOAT2[FLOAT2["LEFT"] = 1] = "LEFT";
          FLOAT2[FLOAT2["RIGHT"] = 2] = "RIGHT";
          FLOAT2[FLOAT2["INLINE_START"] = 3] = "INLINE_START";
          FLOAT2[FLOAT2["INLINE_END"] = 4] = "INLINE_END";
        })(FLOAT || (FLOAT = {}));
        var float = {
          name: "float",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, float2) {
            switch (float2) {
              case "left":
                return FLOAT.LEFT;
              case "right":
                return FLOAT.RIGHT;
              case "inline-start":
                return FLOAT.INLINE_START;
              case "inline-end":
                return FLOAT.INLINE_END;
            }
            return FLOAT.NONE;
          }
        };
        var letterSpacing = {
          name: "letter-spacing",
          initialValue: "0",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "normal") {
              return 0;
            }
            if (token.type === 17) {
              return token.number;
            }
            if (token.type === 15) {
              return token.number;
            }
            return 0;
          }
        };
        var LINE_BREAK;
        (function(LINE_BREAK2) {
          LINE_BREAK2["NORMAL"] = "normal";
          LINE_BREAK2["STRICT"] = "strict";
        })(LINE_BREAK || (LINE_BREAK = {}));
        var lineBreak = {
          name: "line-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, lineBreak2) {
            switch (lineBreak2) {
              case "strict":
                return LINE_BREAK.STRICT;
              case "normal":
              default:
                return LINE_BREAK.NORMAL;
            }
          }
        };
        var lineHeight = {
          name: "line-height",
          initialValue: "normal",
          prefix: false,
          type: 4
        };
        var computeLineHeight = function(token, fontSize2) {
          if (isIdentToken(token) && token.value === "normal") {
            return 1.2 * fontSize2;
          } else if (token.type === 17) {
            return fontSize2 * token.number;
          } else if (isLengthPercentage(token)) {
            return getAbsoluteValue(token, fontSize2);
          }
          return fontSize2;
        };
        var listStyleImage = {
          name: "list-style-image",
          initialValue: "none",
          type: 0,
          prefix: false,
          parse: function(context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            return image.parse(context, token);
          }
        };
        var LIST_STYLE_POSITION;
        (function(LIST_STYLE_POSITION2) {
          LIST_STYLE_POSITION2[LIST_STYLE_POSITION2["INSIDE"] = 0] = "INSIDE";
          LIST_STYLE_POSITION2[LIST_STYLE_POSITION2["OUTSIDE"] = 1] = "OUTSIDE";
        })(LIST_STYLE_POSITION || (LIST_STYLE_POSITION = {}));
        var listStylePosition = {
          name: "list-style-position",
          initialValue: "outside",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "inside":
                return LIST_STYLE_POSITION.INSIDE;
              case "outside":
              default:
                return LIST_STYLE_POSITION.OUTSIDE;
            }
          }
        };
        var LIST_STYLE_TYPE;
        (function(LIST_STYLE_TYPE2) {
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["NONE"] = -1] = "NONE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISC"] = 0] = "DISC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CIRCLE"] = 1] = "CIRCLE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SQUARE"] = 2] = "SQUARE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DECIMAL"] = 3] = "DECIMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_DECIMAL"] = 4] = "CJK_DECIMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DECIMAL_LEADING_ZERO"] = 5] = "DECIMAL_LEADING_ZERO";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ROMAN"] = 6] = "LOWER_ROMAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ROMAN"] = 7] = "UPPER_ROMAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_GREEK"] = 8] = "LOWER_GREEK";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ALPHA"] = 9] = "LOWER_ALPHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ALPHA"] = 10] = "UPPER_ALPHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ARABIC_INDIC"] = 11] = "ARABIC_INDIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ARMENIAN"] = 12] = "ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["BENGALI"] = 13] = "BENGALI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CAMBODIAN"] = 14] = "CAMBODIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_EARTHLY_BRANCH"] = 15] = "CJK_EARTHLY_BRANCH";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_HEAVENLY_STEM"] = 16] = "CJK_HEAVENLY_STEM";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_IDEOGRAPHIC"] = 17] = "CJK_IDEOGRAPHIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DEVANAGARI"] = 18] = "DEVANAGARI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ETHIOPIC_NUMERIC"] = 19] = "ETHIOPIC_NUMERIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GEORGIAN"] = 20] = "GEORGIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GUJARATI"] = 21] = "GUJARATI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GURMUKHI"] = 22] = "GURMUKHI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HEBREW"] = 22] = "HEBREW";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HIRAGANA"] = 23] = "HIRAGANA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HIRAGANA_IROHA"] = 24] = "HIRAGANA_IROHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["JAPANESE_FORMAL"] = 25] = "JAPANESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["JAPANESE_INFORMAL"] = 26] = "JAPANESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KANNADA"] = 27] = "KANNADA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KATAKANA"] = 28] = "KATAKANA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KATAKANA_IROHA"] = 29] = "KATAKANA_IROHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KHMER"] = 30] = "KHMER";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANGUL_FORMAL"] = 31] = "KOREAN_HANGUL_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANJA_FORMAL"] = 32] = "KOREAN_HANJA_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANJA_INFORMAL"] = 33] = "KOREAN_HANJA_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LAO"] = 34] = "LAO";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ARMENIAN"] = 35] = "LOWER_ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MALAYALAM"] = 36] = "MALAYALAM";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MONGOLIAN"] = 37] = "MONGOLIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MYANMAR"] = 38] = "MYANMAR";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ORIYA"] = 39] = "ORIYA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["PERSIAN"] = 40] = "PERSIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SIMP_CHINESE_FORMAL"] = 41] = "SIMP_CHINESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SIMP_CHINESE_INFORMAL"] = 42] = "SIMP_CHINESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TAMIL"] = 43] = "TAMIL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TELUGU"] = 44] = "TELUGU";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["THAI"] = 45] = "THAI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TIBETAN"] = 46] = "TIBETAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TRAD_CHINESE_FORMAL"] = 47] = "TRAD_CHINESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TRAD_CHINESE_INFORMAL"] = 48] = "TRAD_CHINESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ARMENIAN"] = 49] = "UPPER_ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISCLOSURE_OPEN"] = 50] = "DISCLOSURE_OPEN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISCLOSURE_CLOSED"] = 51] = "DISCLOSURE_CLOSED";
        })(LIST_STYLE_TYPE || (LIST_STYLE_TYPE = {}));
        var listStyleType = {
          name: "list-style-type",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, type) {
            switch (type) {
              case "disc":
                return LIST_STYLE_TYPE.DISC;
              case "circle":
                return LIST_STYLE_TYPE.CIRCLE;
              case "square":
                return LIST_STYLE_TYPE.SQUARE;
              case "decimal":
                return LIST_STYLE_TYPE.DECIMAL;
              case "cjk-decimal":
                return LIST_STYLE_TYPE.CJK_DECIMAL;
              case "decimal-leading-zero":
                return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
              case "lower-roman":
                return LIST_STYLE_TYPE.LOWER_ROMAN;
              case "upper-roman":
                return LIST_STYLE_TYPE.UPPER_ROMAN;
              case "lower-greek":
                return LIST_STYLE_TYPE.LOWER_GREEK;
              case "lower-alpha":
                return LIST_STYLE_TYPE.LOWER_ALPHA;
              case "upper-alpha":
                return LIST_STYLE_TYPE.UPPER_ALPHA;
              case "arabic-indic":
                return LIST_STYLE_TYPE.ARABIC_INDIC;
              case "armenian":
                return LIST_STYLE_TYPE.ARMENIAN;
              case "bengali":
                return LIST_STYLE_TYPE.BENGALI;
              case "cambodian":
                return LIST_STYLE_TYPE.CAMBODIAN;
              case "cjk-earthly-branch":
                return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
              case "cjk-heavenly-stem":
                return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
              case "cjk-ideographic":
                return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
              case "devanagari":
                return LIST_STYLE_TYPE.DEVANAGARI;
              case "ethiopic-numeric":
                return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
              case "georgian":
                return LIST_STYLE_TYPE.GEORGIAN;
              case "gujarati":
                return LIST_STYLE_TYPE.GUJARATI;
              case "gurmukhi":
                return LIST_STYLE_TYPE.GURMUKHI;
              case "hebrew":
                return LIST_STYLE_TYPE.HEBREW;
              case "hiragana":
                return LIST_STYLE_TYPE.HIRAGANA;
              case "hiragana-iroha":
                return LIST_STYLE_TYPE.HIRAGANA_IROHA;
              case "japanese-formal":
                return LIST_STYLE_TYPE.JAPANESE_FORMAL;
              case "japanese-informal":
                return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
              case "kannada":
                return LIST_STYLE_TYPE.KANNADA;
              case "katakana":
                return LIST_STYLE_TYPE.KATAKANA;
              case "katakana-iroha":
                return LIST_STYLE_TYPE.KATAKANA_IROHA;
              case "khmer":
                return LIST_STYLE_TYPE.KHMER;
              case "korean-hangul-formal":
                return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
              case "korean-hanja-formal":
                return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
              case "korean-hanja-informal":
                return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
              case "lao":
                return LIST_STYLE_TYPE.LAO;
              case "lower-armenian":
                return LIST_STYLE_TYPE.LOWER_ARMENIAN;
              case "malayalam":
                return LIST_STYLE_TYPE.MALAYALAM;
              case "mongolian":
                return LIST_STYLE_TYPE.MONGOLIAN;
              case "myanmar":
                return LIST_STYLE_TYPE.MYANMAR;
              case "oriya":
                return LIST_STYLE_TYPE.ORIYA;
              case "persian":
                return LIST_STYLE_TYPE.PERSIAN;
              case "simp-chinese-formal":
                return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
              case "simp-chinese-informal":
                return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
              case "tamil":
                return LIST_STYLE_TYPE.TAMIL;
              case "telugu":
                return LIST_STYLE_TYPE.TELUGU;
              case "thai":
                return LIST_STYLE_TYPE.THAI;
              case "tibetan":
                return LIST_STYLE_TYPE.TIBETAN;
              case "trad-chinese-formal":
                return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
              case "trad-chinese-informal":
                return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
              case "upper-armenian":
                return LIST_STYLE_TYPE.UPPER_ARMENIAN;
              case "disclosure-open":
                return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
              case "disclosure-closed":
                return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
              case "none":
              default:
                return LIST_STYLE_TYPE.NONE;
            }
          }
        };
        var marginForSide = function(side) {
          return {
            name: "margin-" + side,
            initialValue: "0",
            prefix: false,
            type: 4
          };
        };
        var marginTop = marginForSide("top");
        var marginRight = marginForSide("right");
        var marginBottom = marginForSide("bottom");
        var marginLeft = marginForSide("left");
        var OVERFLOW;
        (function(OVERFLOW2) {
          OVERFLOW2[OVERFLOW2["VISIBLE"] = 0] = "VISIBLE";
          OVERFLOW2[OVERFLOW2["HIDDEN"] = 1] = "HIDDEN";
          OVERFLOW2[OVERFLOW2["SCROLL"] = 2] = "SCROLL";
          OVERFLOW2[OVERFLOW2["CLIP"] = 3] = "CLIP";
          OVERFLOW2[OVERFLOW2["AUTO"] = 4] = "AUTO";
        })(OVERFLOW || (OVERFLOW = {}));
        var overflow = {
          name: "overflow",
          initialValue: "visible",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(overflow2) {
              switch (overflow2.value) {
                case "hidden":
                  return OVERFLOW.HIDDEN;
                case "scroll":
                  return OVERFLOW.SCROLL;
                case "clip":
                  return OVERFLOW.CLIP;
                case "auto":
                  return OVERFLOW.AUTO;
                case "visible":
                default:
                  return OVERFLOW.VISIBLE;
              }
            });
          }
        };
        var overflowWrap = {
          name: "overflow-wrap",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "break-word":
                return "break-word";
              case "normal":
              default:
                return "normal";
            }
          }
        };
        var paddingForSide = function(side) {
          return {
            name: "padding-" + side,
            initialValue: "0",
            prefix: false,
            type: 3,
            format: "length-percentage"
          };
        };
        var paddingTop = paddingForSide("top");
        var paddingRight = paddingForSide("right");
        var paddingBottom = paddingForSide("bottom");
        var paddingLeft = paddingForSide("left");
        var TEXT_ALIGN;
        (function(TEXT_ALIGN2) {
          TEXT_ALIGN2[TEXT_ALIGN2["LEFT"] = 0] = "LEFT";
          TEXT_ALIGN2[TEXT_ALIGN2["CENTER"] = 1] = "CENTER";
          TEXT_ALIGN2[TEXT_ALIGN2["RIGHT"] = 2] = "RIGHT";
        })(TEXT_ALIGN || (TEXT_ALIGN = {}));
        var textAlign = {
          name: "text-align",
          initialValue: "left",
          prefix: false,
          type: 2,
          parse: function(_context, textAlign2) {
            switch (textAlign2) {
              case "right":
                return TEXT_ALIGN.RIGHT;
              case "center":
              case "justify":
                return TEXT_ALIGN.CENTER;
              case "left":
              default:
                return TEXT_ALIGN.LEFT;
            }
          }
        };
        var POSITION;
        (function(POSITION2) {
          POSITION2[POSITION2["STATIC"] = 0] = "STATIC";
          POSITION2[POSITION2["RELATIVE"] = 1] = "RELATIVE";
          POSITION2[POSITION2["ABSOLUTE"] = 2] = "ABSOLUTE";
          POSITION2[POSITION2["FIXED"] = 3] = "FIXED";
          POSITION2[POSITION2["STICKY"] = 4] = "STICKY";
        })(POSITION || (POSITION = {}));
        var position = {
          name: "position",
          initialValue: "static",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "relative":
                return POSITION.RELATIVE;
              case "absolute":
                return POSITION.ABSOLUTE;
              case "fixed":
                return POSITION.FIXED;
              case "sticky":
                return POSITION.STICKY;
            }
            return POSITION.STATIC;
          }
        };
        var textShadow = {
          name: "text-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: COLORS.TRANSPARENT,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH
              };
              var c = 0;
              for (var i2 = 0; i2 < values.length; i2++) {
                var token = values[i2];
                if (isLength(token)) {
                  if (c === 0) {
                    shadow.offsetX = token;
                  } else if (c === 1) {
                    shadow.offsetY = token;
                  } else {
                    shadow.blur = token;
                  }
                  c++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var TEXT_TRANSFORM;
        (function(TEXT_TRANSFORM2) {
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["NONE"] = 0] = "NONE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["LOWERCASE"] = 1] = "LOWERCASE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["UPPERCASE"] = 2] = "UPPERCASE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["CAPITALIZE"] = 3] = "CAPITALIZE";
        })(TEXT_TRANSFORM || (TEXT_TRANSFORM = {}));
        var textTransform = {
          name: "text-transform",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, textTransform2) {
            switch (textTransform2) {
              case "uppercase":
                return TEXT_TRANSFORM.UPPERCASE;
              case "lowercase":
                return TEXT_TRANSFORM.LOWERCASE;
              case "capitalize":
                return TEXT_TRANSFORM.CAPITALIZE;
            }
            return TEXT_TRANSFORM.NONE;
          }
        };
        var transform$1 = {
          name: "transform",
          initialValue: "none",
          prefix: true,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            if (token.type === 18) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
              }
              return transformFunction(token.values);
            }
            return null;
          }
        };
        var matrix = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          return values.length === 6 ? values : null;
        };
        var matrix3d = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          var a1 = values[0], b1 = values[1];
          values[2];
          values[3];
          var a2 = values[4], b2 = values[5];
          values[6];
          values[7];
          values[8];
          values[9];
          values[10];
          values[11];
          var a4 = values[12], b4 = values[13];
          values[14];
          values[15];
          return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
        };
        var SUPPORTED_TRANSFORM_FUNCTIONS = {
          matrix,
          matrix3d
        };
        var DEFAULT_VALUE = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
        var transformOrigin = {
          name: "transform-origin",
          initialValue: "50% 50%",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            var origins = tokens.filter(isLengthPercentage);
            if (origins.length !== 2) {
              return DEFAULT;
            }
            return [origins[0], origins[1]];
          }
        };
        var VISIBILITY;
        (function(VISIBILITY2) {
          VISIBILITY2[VISIBILITY2["VISIBLE"] = 0] = "VISIBLE";
          VISIBILITY2[VISIBILITY2["HIDDEN"] = 1] = "HIDDEN";
          VISIBILITY2[VISIBILITY2["COLLAPSE"] = 2] = "COLLAPSE";
        })(VISIBILITY || (VISIBILITY = {}));
        var visibility = {
          name: "visible",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, visibility2) {
            switch (visibility2) {
              case "hidden":
                return VISIBILITY.HIDDEN;
              case "collapse":
                return VISIBILITY.COLLAPSE;
              case "visible":
              default:
                return VISIBILITY.VISIBLE;
            }
          }
        };
        var WORD_BREAK;
        (function(WORD_BREAK2) {
          WORD_BREAK2["NORMAL"] = "normal";
          WORD_BREAK2["BREAK_ALL"] = "break-all";
          WORD_BREAK2["KEEP_ALL"] = "keep-all";
        })(WORD_BREAK || (WORD_BREAK = {}));
        var wordBreak = {
          name: "word-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, wordBreak2) {
            switch (wordBreak2) {
              case "break-all":
                return WORD_BREAK.BREAK_ALL;
              case "keep-all":
                return WORD_BREAK.KEEP_ALL;
              case "normal":
              default:
                return WORD_BREAK.NORMAL;
            }
          }
        };
        var zIndex = {
          name: "z-index",
          initialValue: "auto",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20) {
              return {auto: true, order: 0};
            }
            if (isNumberToken(token)) {
              return {auto: false, order: token.number};
            }
            throw new Error("Invalid z-index number parsed");
          }
        };
        var time = {
          name: "time",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit.toLowerCase()) {
                case "s":
                  return 1e3 * value.number;
                case "ms":
                  return value.number;
              }
            }
            throw new Error("Unsupported time type");
          }
        };
        var opacity = {
          name: "opacity",
          initialValue: "1",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            return 1;
          }
        };
        var textDecorationColor = {
          name: "text-decoration-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var textDecorationLine = {
          name: "text-decoration-line",
          initialValue: "none",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              switch (token.value) {
                case "underline":
                  return 1;
                case "overline":
                  return 2;
                case "line-through":
                  return 3;
                case "none":
                  return 4;
              }
              return 0;
            }).filter(function(line) {
              return line !== 0;
            });
          }
        };
        var fontFamily = {
          name: "font-family",
          initialValue: "",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var accumulator = [];
            var results = [];
            tokens.forEach(function(token) {
              switch (token.type) {
                case 20:
                case 0:
                  accumulator.push(token.value);
                  break;
                case 17:
                  accumulator.push(token.number.toString());
                  break;
                case 4:
                  results.push(accumulator.join(" "));
                  accumulator.length = 0;
                  break;
              }
            });
            if (accumulator.length) {
              results.push(accumulator.join(" "));
            }
            return results.map(function(result) {
              return result.indexOf(" ") === -1 ? result : "'" + result + "'";
            });
          }
        };
        var fontSize = {
          name: "font-size",
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length"
        };
        var fontWeight = {
          name: "font-weight",
          initialValue: "normal",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            if (isIdentToken(token)) {
              switch (token.value) {
                case "bold":
                  return 700;
                case "normal":
                default:
                  return 400;
              }
            }
            return 400;
          }
        };
        var fontVariant = {
          name: "font-variant",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              return token.value;
            });
          }
        };
        var FONT_STYLE;
        (function(FONT_STYLE2) {
          FONT_STYLE2["NORMAL"] = "normal";
          FONT_STYLE2["ITALIC"] = "italic";
          FONT_STYLE2["OBLIQUE"] = "oblique";
        })(FONT_STYLE || (FONT_STYLE = {}));
        var fontStyle = {
          name: "font-style",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "oblique":
                return FONT_STYLE.OBLIQUE;
              case "italic":
                return FONT_STYLE.ITALIC;
              case "normal":
              default:
                return FONT_STYLE.NORMAL;
            }
          }
        };
        var contains = function(bit, value) {
          return (bit & value) !== 0;
        };
        var content = {
          name: "content",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens;
          }
        };
        var counterIncrement = {
          name: "counter-increment",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var increments = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i2 = 0; i2 < filtered.length; i2++) {
              var counter4 = filtered[i2];
              var next = filtered[i2 + 1];
              if (counter4.type === 20) {
                var increment = next && isNumberToken(next) ? next.number : 1;
                increments.push({counter: counter4.value, increment});
              }
            }
            return increments;
          }
        };
        var counterReset = {
          name: "counter-reset",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var resets = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i2 = 0; i2 < filtered.length; i2++) {
              var counter4 = filtered[i2];
              var next = filtered[i2 + 1];
              if (isIdentToken(counter4) && counter4.value !== "none") {
                var reset = next && isNumberToken(next) ? next.number : 0;
                resets.push({counter: counter4.value, reset});
              }
            }
            return resets;
          }
        };
        var duration = {
          name: "duration",
          initialValue: "0s",
          prefix: false,
          type: 1,
          parse: function(context, tokens) {
            return tokens.filter(isDimensionToken).map(function(token) {
              return time.parse(context, token);
            });
          }
        };
        var quotes = {
          name: "quotes",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var quotes2 = [];
            var filtered = tokens.filter(isStringToken);
            if (filtered.length % 2 !== 0) {
              return null;
            }
            for (var i2 = 0; i2 < filtered.length; i2 += 2) {
              var open_1 = filtered[i2].value;
              var close_1 = filtered[i2 + 1].value;
              quotes2.push({open: open_1, close: close_1});
            }
            return quotes2;
          }
        };
        var getQuote = function(quotes2, depth, open) {
          if (!quotes2) {
            return "";
          }
          var quote = quotes2[Math.min(depth, quotes2.length - 1)];
          if (!quote) {
            return "";
          }
          return open ? quote.open : quote.close;
        };
        var boxShadow = {
          name: "box-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: 255,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH,
                spread: ZERO_LENGTH,
                inset: false
              };
              var c = 0;
              for (var i2 = 0; i2 < values.length; i2++) {
                var token = values[i2];
                if (isIdentWithValue(token, "inset")) {
                  shadow.inset = true;
                } else if (isLength(token)) {
                  if (c === 0) {
                    shadow.offsetX = token;
                  } else if (c === 1) {
                    shadow.offsetY = token;
                  } else if (c === 2) {
                    shadow.blur = token;
                  } else {
                    shadow.spread = token;
                  }
                  c++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var PAINT_ORDER_LAYER;
        (function(PAINT_ORDER_LAYER2) {
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["FILL"] = 0] = "FILL";
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["STROKE"] = 1] = "STROKE";
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["MARKERS"] = 2] = "MARKERS";
        })(PAINT_ORDER_LAYER || (PAINT_ORDER_LAYER = {}));
        var paintOrder = {
          name: "paint-order",
          initialValue: "normal",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var DEFAULT_VALUE2 = [PAINT_ORDER_LAYER.FILL, PAINT_ORDER_LAYER.STROKE, PAINT_ORDER_LAYER.MARKERS];
            var layers = [];
            tokens.filter(isIdentToken).forEach(function(token) {
              switch (token.value) {
                case "stroke":
                  layers.push(PAINT_ORDER_LAYER.STROKE);
                  break;
                case "fill":
                  layers.push(PAINT_ORDER_LAYER.FILL);
                  break;
                case "markers":
                  layers.push(PAINT_ORDER_LAYER.MARKERS);
                  break;
              }
            });
            DEFAULT_VALUE2.forEach(function(value) {
              if (layers.indexOf(value) === -1) {
                layers.push(value);
              }
            });
            return layers;
          }
        };
        var webkitTextStrokeColor = {
          name: "-webkit-text-stroke-color",
          initialValue: "currentcolor",
          prefix: false,
          type: 3,
          format: "color"
        };
        var webkitTextStrokeWidth = {
          name: "-webkit-text-stroke-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
        var CSSParsedDeclaration = function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a2, _b2;
            this.animationDuration = parse(context, duration, declaration.animationDuration);
            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
            this.color = parse(context, color, declaration.color);
            this.direction = parse(context, direction, declaration.direction);
            this.display = parse(context, display, declaration.display);
            this.float = parse(context, float, declaration.cssFloat);
            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse(context, fontSize, declaration.fontSize);
            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse(context, marginTop, declaration.marginTop);
            this.marginRight = parse(context, marginRight, declaration.marginRight);
            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
            this.opacity = parse(context, opacity, declaration.opacity);
            var overflowTuple = parse(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
            this.position = parse(context, position, declaration.position);
            this.textAlign = parse(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
            this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
            this.textShadow = parse(context, textShadow, declaration.textShadow);
            this.textTransform = parse(context, textTransform, declaration.textTransform);
            this.transform = parse(context, transform$1, declaration.transform);
            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== POSITION.STATIC;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== FLOAT.NONE;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
          };
          return CSSParsedDeclaration2;
        }();
        var CSSParsedPseudoDeclaration = function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse(context, content, declaration.content);
            this.quotes = parse(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }();
        var CSSParsedCounterDeclaration = function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }();
        var parse = function(context, descriptor, style) {
          var tokenizer = new Tokenizer();
          var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
          tokenizer.write(value);
          var parser = new Parser(tokenizer.read());
          switch (descriptor.type) {
            case 2:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
            case 0:
              return descriptor.parse(context, parser.parseComponentValue());
            case 1:
              return descriptor.parse(context, parser.parseComponentValues());
            case 4:
              return parser.parseComponentValue();
            case 3:
              switch (descriptor.format) {
                case "angle":
                  return angle.parse(context, parser.parseComponentValue());
                case "color":
                  return color$1.parse(context, parser.parseComponentValue());
                case "image":
                  return image.parse(context, parser.parseComponentValue());
                case "length":
                  var length_1 = parser.parseComponentValue();
                  return isLength(length_1) ? length_1 : ZERO_LENGTH;
                case "length-percentage":
                  var value_1 = parser.parseComponentValue();
                  return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                case "time":
                  return time.parse(context, parser.parseComponentValue());
              }
              break;
          }
        };
        var elementDebuggerAttribute = "data-html2canvas-debug";
        var getElementDebugType = function(element2) {
          var attribute = element2.getAttribute(elementDebuggerAttribute);
          switch (attribute) {
            case "all":
              return 1;
            case "clone":
              return 2;
            case "parse":
              return 3;
            case "render":
              return 4;
            default:
              return 0;
          }
        };
        var isDebugging = function(element2, type) {
          var elementType = getElementDebugType(element2);
          return elementType === 1 || type === elementType;
        };
        var ElementContainer = function() {
          function ElementContainer2(context, element2) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(element2, 3)) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element2, null));
            if (isHTMLElementNode(element2)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element2.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element2.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element2);
            if (isDebugging(element2, 4)) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }();
        var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
        var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
          lookup$1[chars$1.charCodeAt(i$1)] = i$1;
        }
        var decode = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup$1[base642.charCodeAt(i2)];
            encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
            encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
            encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 2) {
            bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var polyUint32Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 4) {
            bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2 = 5;
        var UTRIE2_SHIFT_1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT = 2;
        var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
        var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
        var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
        var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
        var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
        var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
        var slice16 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64 = function(base642, _byteLength) {
          var buffer = decode(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index = slice16(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
        };
        var Trie = function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }();
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        var Prepend = 1;
        var CR = 2;
        var LF = 3;
        var Control = 4;
        var Extend = 5;
        var SpacingMark = 7;
        var L = 8;
        var V = 9;
        var T = 10;
        var LV = 11;
        var LVT = 12;
        var ZWJ = 13;
        var Extended_Pictographic = 14;
        var RI = 15;
        var toCodePoints = function(str) {
          var codePoints = [];
          var i2 = 0;
          var length = str.length;
          while (i2 < length) {
            var value = str.charCodeAt(i2++);
            if (value >= 55296 && value <= 56319 && i2 < length) {
              var extra = str.charCodeAt(i2++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i2--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index = -1;
          var result = "";
          while (++index < length) {
            var codePoint = codePoints[index];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var UnicodeTrie = createTrieFromBase64(base64);
        var BREAK_NOT_ALLOWED = "\xD7";
        var BREAK_ALLOWED = "\xF7";
        var codePointToClass = function(codePoint) {
          return UnicodeTrie.get(codePoint);
        };
        var _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
          var prevIndex = index - 2;
          var prev = classTypes[prevIndex];
          var current = classTypes[index - 1];
          var next = classTypes[index];
          if (current === CR && next === LF) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === CR || current === LF || current === Control) {
            return BREAK_ALLOWED;
          }
          if (next === CR || next === LF || next === Control) {
            return BREAK_ALLOWED;
          }
          if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LV || current === V) && (next === V || next === T)) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LVT || current === T) && next === T) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === ZWJ || next === Extend) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === SpacingMark) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === Prepend) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === ZWJ && next === Extended_Pictographic) {
            while (prev === Extend) {
              prev = classTypes[--prevIndex];
            }
            if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
            }
          }
          if (current === RI && next === RI) {
            var countRI = 0;
            while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
            }
            if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
            }
          }
          return BREAK_ALLOWED;
        };
        var GraphemeBreaker = function(str) {
          var codePoints = toCodePoints(str);
          var length = codePoints.length;
          var index = 0;
          var lastEnd = 0;
          var classTypes = codePoints.map(codePointToClass);
          return {
            next: function() {
              if (index >= length) {
                return {done: true, value: null};
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {
              }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
                var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
                lastEnd = index;
                return {value, done: false};
              }
              return {done: true, value: null};
            }
          };
        };
        var splitGraphemes = function(str) {
          var breaker = GraphemeBreaker(str);
          var graphemes = [];
          var bk;
          while (!(bk = breaker.next()).done) {
            if (bk.value) {
              graphemes.push(bk.value.slice());
            }
          }
          return graphemes;
        };
        var testRangeBounds = function(document2) {
          var TEST_HEIGHT = 123;
          if (document2.createRange) {
            var range = document2.createRange();
            if (range.getBoundingClientRect) {
              var testElement = document2.createElement("boundtest");
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = "block";
              document2.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document2.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                return true;
              }
            }
          }
          return false;
        };
        var testIOSLineBreak = function(document2) {
          var testElement = document2.createElement("boundtest");
          testElement.style.width = "50px";
          testElement.style.display = "block";
          testElement.style.fontSize = "12px";
          testElement.style.letterSpacing = "0px";
          testElement.style.wordSpacing = "0px";
          document2.body.appendChild(testElement);
          var range = document2.createRange();
          testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
          var node = testElement.firstChild;
          var textList = toCodePoints$1(node.data).map(function(i2) {
            return fromCodePoint$1(i2);
          });
          var offset = 0;
          var prev = {};
          var supports = textList.every(function(text2, i2) {
            range.setStart(node, offset);
            range.setEnd(node, offset + text2.length);
            var rect = range.getBoundingClientRect();
            offset += text2.length;
            var boundAhead = rect.x > prev.x || rect.y > prev.y;
            prev = rect;
            if (i2 === 0) {
              return true;
            }
            return boundAhead;
          });
          document2.body.removeChild(testElement);
          return supports;
        };
        var testCORS = function() {
          return typeof new Image().crossOrigin !== "undefined";
        };
        var testResponseType = function() {
          return typeof new XMLHttpRequest().responseType === "string";
        };
        var testSVG = function(document2) {
          var img = new Image();
          var canvas = document2.createElement("canvas");
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return false;
          }
          img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
          try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
          } catch (e2) {
            return false;
          }
          return true;
        };
        var isGreenPixel = function(data) {
          return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
        };
        var testForeignObject = function(document2) {
          var canvas = document2.createElement("canvas");
          var size = 100;
          canvas.width = size;
          canvas.height = size;
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return Promise.reject(false);
          }
          ctx.fillStyle = "rgb(0, 255, 0)";
          ctx.fillRect(0, 0, size, size);
          var img = new Image();
          var greenImageSrc = canvas.toDataURL();
          img.src = greenImageSrc;
          var svg = createForeignObjectSVG(size, size, 0, 0, img);
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          return loadSerializedSVG$1(svg).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            var data = ctx.getImageData(0, 0, size, size).data;
            ctx.fillStyle = "red";
            ctx.fillRect(0, 0, size, size);
            var node = document2.createElement("div");
            node.style.backgroundImage = "url(" + greenImageSrc + ")";
            node.style.height = size + "px";
            return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
          }).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
          }).catch(function() {
            return false;
          });
        };
        var createForeignObjectSVG = function(width, height, x, y, node) {
          var xmlns = "http://www.w3.org/2000/svg";
          var svg = document.createElementNS(xmlns, "svg");
          var foreignObject = document.createElementNS(xmlns, "foreignObject");
          svg.setAttributeNS(null, "width", width.toString());
          svg.setAttributeNS(null, "height", height.toString());
          foreignObject.setAttributeNS(null, "width", "100%");
          foreignObject.setAttributeNS(null, "height", "100%");
          foreignObject.setAttributeNS(null, "x", x.toString());
          foreignObject.setAttributeNS(null, "y", y.toString());
          foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
          svg.appendChild(foreignObject);
          foreignObject.appendChild(node);
          return svg;
        };
        var loadSerializedSVG$1 = function(svg) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              return resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
          });
        };
        var FEATURES = {
          get SUPPORT_RANGE_BOUNDS() {
            var value = testRangeBounds(document);
            Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", {value});
            return value;
          },
          get SUPPORT_WORD_BREAKING() {
            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
            Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", {value});
            return value;
          },
          get SUPPORT_SVG_DRAWING() {
            var value = testSVG(document);
            Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", {value});
            return value;
          },
          get SUPPORT_FOREIGNOBJECT_DRAWING() {
            var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
            Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", {value});
            return value;
          },
          get SUPPORT_CORS_IMAGES() {
            var value = testCORS();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", {value});
            return value;
          },
          get SUPPORT_RESPONSE_TYPE() {
            var value = testResponseType();
            Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", {value});
            return value;
          },
          get SUPPORT_CORS_XHR() {
            var value = "withCredentials" in new XMLHttpRequest();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", {value});
            return value;
          }
        };
        var TextBounds = function() {
          function TextBounds2(text2, bounds) {
            this.text = text2;
            this.bounds = bounds;
          }
          return TextBounds2;
        }();
        var parseTextBounds = function(context, value, styles, node) {
          var textList = breakText(value, styles);
          var textBounds = [];
          var offset = 0;
          textList.forEach(function(text2) {
            if (styles.textDecorationLine.length || text2.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                if (!FEATURES.SUPPORT_WORD_BREAKING) {
                  textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, createRange(node, offset, text2.length).getClientRects())));
                } else {
                  textBounds.push(new TextBounds(text2, getRangeBounds(context, node, offset, text2.length)));
                }
              } else {
                var replacementNode = node.splitText(text2.length);
                textBounds.push(new TextBounds(text2, getWrapperBounds(context, node)));
                node = replacementNode;
              }
            } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node = node.splitText(text2.length);
            }
            offset += text2.length;
          });
          return textBounds;
        };
        var getWrapperBounds = function(context, node) {
          var ownerDocument = node.ownerDocument;
          if (ownerDocument) {
            var wrapper = ownerDocument.createElement("html2canvaswrapper");
            wrapper.appendChild(node.cloneNode(true));
            var parentNode = node.parentNode;
            if (parentNode) {
              parentNode.replaceChild(wrapper, node);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
            }
          }
          return Bounds.EMPTY;
        };
        var createRange = function(node, offset, length) {
          var ownerDocument = node.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Node has no owner document");
          }
          var range = ownerDocument.createRange();
          range.setStart(node, offset);
          range.setEnd(node, offset + length);
          return range;
        };
        var getRangeBounds = function(context, node, offset, length) {
          return Bounds.fromClientRect(context, createRange(node, offset, length).getBoundingClientRect());
        };
        var breakText = function(value, styles) {
          return styles.letterSpacing !== 0 ? splitGraphemes(value) : breakWords(value, styles);
        };
        var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
        var breakWords = function(str, styles) {
          var breaker = LineBreaker(str, {
            lineBreak: styles.lineBreak,
            wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
          });
          var words = [];
          var bk;
          var _loop_1 = function() {
            if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = "";
              codePoints.forEach(function(codePoint) {
                if (wordSeparators.indexOf(codePoint) === -1) {
                  word_1 += fromCodePoint$1(codePoint);
                } else {
                  if (word_1.length) {
                    words.push(word_1);
                  }
                  words.push(fromCodePoint$1(codePoint));
                  word_1 = "";
                }
              });
              if (word_1.length) {
                words.push(word_1);
              }
            }
          };
          while (!(bk = breaker.next()).done) {
            _loop_1();
          }
          return words;
        };
        var TextContainer = function() {
          function TextContainer2(context, node, styles) {
            this.text = transform(node.data, styles.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles, node);
          }
          return TextContainer2;
        }();
        var transform = function(text2, transform2) {
          switch (transform2) {
            case TEXT_TRANSFORM.LOWERCASE:
              return text2.toLowerCase();
            case TEXT_TRANSFORM.CAPITALIZE:
              return text2.replace(CAPITALIZE, capitalize);
            case TEXT_TRANSFORM.UPPERCASE:
              return text2.toUpperCase();
            default:
              return text2;
          }
        };
        var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
        var capitalize = function(m, p1, p2) {
          if (m.length > 0) {
            return p1 + p2.toUpperCase();
          }
          return m;
        };
        var ImageElementContainer = function(_super) {
          __extends2(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer);
        var CanvasElementContainer = function(_super) {
          __extends2(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer);
        var SVGElementContainer = function(_super) {
          __extends2(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer);
        var LIElementContainer = function(_super) {
          __extends2(LIElementContainer2, _super);
          function LIElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer);
        var OLElementContainer = function(_super) {
          __extends2(OLElementContainer2, _super);
          function OLElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.start = element2.start;
            _this.reversed = typeof element2.reversed === "boolean" && element2.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer);
        var CHECKBOX_BORDER_RADIUS = [
          {
            type: 15,
            flags: 0,
            unit: "px",
            number: 3
          }
        ];
        var RADIO_BORDER_RADIUS = [
          {
            type: 16,
            flags: 0,
            number: 50
          }
        ];
        var reformatInputBounds = function(bounds) {
          if (bounds.width > bounds.height) {
            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
          } else if (bounds.width < bounds.height) {
            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
          }
          return bounds;
        };
        var getInputValue = function(node) {
          var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
          return value.length === 0 ? node.placeholder || "" : value;
        };
        var CHECKBOX = "checkbox";
        var RADIO = "radio";
        var PASSWORD = "password";
        var INPUT_COLOR = 707406591;
        var InputElementContainer = function(_super) {
          __extends2(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = BORDER_STYLE.SOLID;
              _this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];
              _this.styles.backgroundOrigin = [0];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer);
        var SelectElementContainer = function(_super) {
          __extends2(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            var option = element2.options[element2.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer);
        var TextareaElementContainer = function(_super) {
          __extends2(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer);
        var IFrameElementContainer = function(_super) {
          __extends2(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e2) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer);
        var LIST_OWNERS = ["OL", "UL", "MENU"];
        var parseNodeTree = function(context, node, parent2, root) {
          for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
            nextNode = childNode.nextSibling;
            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent2.textNodes.push(new TextContainer(context, childNode, parent2.styles));
            } else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                childNode.assignedNodes().forEach(function(childNode2) {
                  return parseNodeTree(context, childNode2, parent2, root);
                });
              } else {
                var container = createContainer(context, childNode);
                if (container.styles.isVisible()) {
                  if (createsRealStackingContext(childNode, container, root)) {
                    container.flags |= 4;
                  } else if (createsStackingContext(container.styles)) {
                    container.flags |= 2;
                  }
                  if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                    container.flags |= 8;
                  }
                  parent2.elements.push(container);
                  childNode.slot;
                  if (childNode.shadowRoot) {
                    parseNodeTree(context, childNode.shadowRoot, container, root);
                  } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                    parseNodeTree(context, childNode, container, root);
                  }
                }
              }
            }
          }
        };
        var createContainer = function(context, element2) {
          if (isImageElement(element2)) {
            return new ImageElementContainer(context, element2);
          }
          if (isCanvasElement(element2)) {
            return new CanvasElementContainer(context, element2);
          }
          if (isSVGElement(element2)) {
            return new SVGElementContainer(context, element2);
          }
          if (isLIElement(element2)) {
            return new LIElementContainer(context, element2);
          }
          if (isOLElement(element2)) {
            return new OLElementContainer(context, element2);
          }
          if (isInputElement(element2)) {
            return new InputElementContainer(context, element2);
          }
          if (isSelectElement(element2)) {
            return new SelectElementContainer(context, element2);
          }
          if (isTextareaElement(element2)) {
            return new TextareaElementContainer(context, element2);
          }
          if (isIFrameElement(element2)) {
            return new IFrameElementContainer(context, element2);
          }
          return new ElementContainer(context, element2);
        };
        var parseTree = function(context, element2) {
          var container = createContainer(context, element2);
          container.flags |= 4;
          parseNodeTree(context, element2, container, container);
          return container;
        };
        var createsRealStackingContext = function(node, container, root) {
          return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
        };
        var createsStackingContext = function(styles) {
          return styles.isPositioned() || styles.isFloating();
        };
        var isTextNode = function(node) {
          return node.nodeType === Node.TEXT_NODE;
        };
        var isElementNode = function(node) {
          return node.nodeType === Node.ELEMENT_NODE;
        };
        var isHTMLElementNode = function(node) {
          return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
        };
        var isSVGElementNode = function(element2) {
          return typeof element2.className === "object";
        };
        var isLIElement = function(node) {
          return node.tagName === "LI";
        };
        var isOLElement = function(node) {
          return node.tagName === "OL";
        };
        var isInputElement = function(node) {
          return node.tagName === "INPUT";
        };
        var isHTMLElement = function(node) {
          return node.tagName === "HTML";
        };
        var isSVGElement = function(node) {
          return node.tagName === "svg";
        };
        var isBodyElement = function(node) {
          return node.tagName === "BODY";
        };
        var isCanvasElement = function(node) {
          return node.tagName === "CANVAS";
        };
        var isImageElement = function(node) {
          return node.tagName === "IMG";
        };
        var isIFrameElement = function(node) {
          return node.tagName === "IFRAME";
        };
        var isStyleElement = function(node) {
          return node.tagName === "STYLE";
        };
        var isScriptElement = function(node) {
          return node.tagName === "SCRIPT";
        };
        var isTextareaElement = function(node) {
          return node.tagName === "TEXTAREA";
        };
        var isSelectElement = function(node) {
          return node.tagName === "SELECT";
        };
        var isSlotElement = function(node) {
          return node.tagName === "SLOT";
        };
        var CounterState = function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name2) {
            var counter4 = this.counters[name2];
            if (counter4 && counter4.length) {
              return counter4[counter4.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name2) {
            var counter4 = this.counters[name2];
            return counter4 ? counter4 : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter4) {
              return _this.counters[counter4].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter4 = _this.counters[entry.counter];
                if (counter4 && entry.increment !== 0) {
                  canReset = false;
                  if (!counter4.length) {
                    counter4.push(1);
                  }
                  counter4[Math.max(0, counter4.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter4 = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter4) {
                  counter4 = _this.counters[entry.counter] = [];
                }
                counter4.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }();
        var ROMAN_UPPER = {
          integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
          values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
        };
        var ARMENIAN = {
          integers: [
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u0554",
            "\u0553",
            "\u0552",
            "\u0551",
            "\u0550",
            "\u054F",
            "\u054E",
            "\u054D",
            "\u054C",
            "\u054B",
            "\u054A",
            "\u0549",
            "\u0548",
            "\u0547",
            "\u0546",
            "\u0545",
            "\u0544",
            "\u0543",
            "\u0542",
            "\u0541",
            "\u0540",
            "\u053F",
            "\u053E",
            "\u053D",
            "\u053C",
            "\u053B",
            "\u053A",
            "\u0539",
            "\u0538",
            "\u0537",
            "\u0536",
            "\u0535",
            "\u0534",
            "\u0533",
            "\u0532",
            "\u0531"
          ]
        };
        var HEBREW = {
          integers: [
            1e4,
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            19,
            18,
            17,
            16,
            15,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u05D9\u05F3",
            "\u05D8\u05F3",
            "\u05D7\u05F3",
            "\u05D6\u05F3",
            "\u05D5\u05F3",
            "\u05D4\u05F3",
            "\u05D3\u05F3",
            "\u05D2\u05F3",
            "\u05D1\u05F3",
            "\u05D0\u05F3",
            "\u05EA",
            "\u05E9",
            "\u05E8",
            "\u05E7",
            "\u05E6",
            "\u05E4",
            "\u05E2",
            "\u05E1",
            "\u05E0",
            "\u05DE",
            "\u05DC",
            "\u05DB",
            "\u05D9\u05D8",
            "\u05D9\u05D7",
            "\u05D9\u05D6",
            "\u05D8\u05D6",
            "\u05D8\u05D5",
            "\u05D9",
            "\u05D8",
            "\u05D7",
            "\u05D6",
            "\u05D5",
            "\u05D4",
            "\u05D3",
            "\u05D2",
            "\u05D1",
            "\u05D0"
          ]
        };
        var GEORGIAN = {
          integers: [
            1e4,
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u10F5",
            "\u10F0",
            "\u10EF",
            "\u10F4",
            "\u10EE",
            "\u10ED",
            "\u10EC",
            "\u10EB",
            "\u10EA",
            "\u10E9",
            "\u10E8",
            "\u10E7",
            "\u10E6",
            "\u10E5",
            "\u10E4",
            "\u10F3",
            "\u10E2",
            "\u10E1",
            "\u10E0",
            "\u10DF",
            "\u10DE",
            "\u10DD",
            "\u10F2",
            "\u10DC",
            "\u10DB",
            "\u10DA",
            "\u10D9",
            "\u10D8",
            "\u10D7",
            "\u10F1",
            "\u10D6",
            "\u10D5",
            "\u10D4",
            "\u10D3",
            "\u10D2",
            "\u10D1",
            "\u10D0"
          ]
        };
        var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
          if (value < min || value > max) {
            return createCounterText(value, fallback, suffix.length > 0);
          }
          return symbols.integers.reduce(function(string, integer, index) {
            while (value >= integer) {
              value -= integer;
              string += symbols.values[index];
            }
            return string;
          }, "") + suffix;
        };
        var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
          var string = "";
          do {
            if (!isNumeric) {
              value--;
            }
            string = resolver(value) + string;
            value /= codePointRangeLength;
          } while (value * codePointRangeLength >= codePointRangeLength);
          return string;
        };
        var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
          var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
          return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
            return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) + suffix);
        };
        var createCounterStyleFromSymbols = function(value, symbols, suffix) {
          if (suffix === void 0) {
            suffix = ". ";
          }
          var codePointRangeLength = symbols.length;
          return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
            return symbols[Math.floor(codePoint % codePointRangeLength)];
          }) + suffix;
        };
        var CJK_ZEROS = 1 << 0;
        var CJK_TEN_COEFFICIENTS = 1 << 1;
        var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
        var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
        var createCJKCounter = function(value, numbers7, multipliers, negativeSign, suffix, flags) {
          if (value < -9999 || value > 9999) {
            return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
          }
          var tmp = Math.abs(value);
          var string = suffix;
          if (tmp === 0) {
            return numbers7[0] + string;
          }
          for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
            var coefficient = tmp % 10;
            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
              string = numbers7[coefficient] + string;
            } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
              string = numbers7[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
            } else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
            }
            tmp = Math.floor(tmp / 10);
          }
          return (value < 0 ? negativeSign : "") + string;
        };
        var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
        var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
        var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
        var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
        var createCounterText = function(value, type, appendSuffix) {
          var defaultSuffix = appendSuffix ? ". " : "";
          var cjkSuffix = appendSuffix ? "\u3001" : "";
          var koreanSuffix = appendSuffix ? ", " : "";
          var spaceSuffix = appendSuffix ? " " : "";
          switch (type) {
            case LIST_STYLE_TYPE.DISC:
              return "\u2022" + spaceSuffix;
            case LIST_STYLE_TYPE.CIRCLE:
              return "\u25E6" + spaceSuffix;
            case LIST_STYLE_TYPE.SQUARE:
              return "\u25FE" + spaceSuffix;
            case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
            case LIST_STYLE_TYPE.CJK_DECIMAL:
              return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
            case LIST_STYLE_TYPE.LOWER_ROMAN:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.UPPER_ROMAN:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_GREEK:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ALPHA:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
            case LIST_STYLE_TYPE.UPPER_ALPHA:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
            case LIST_STYLE_TYPE.ARABIC_INDIC:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
            case LIST_STYLE_TYPE.ARMENIAN:
            case LIST_STYLE_TYPE.UPPER_ARMENIAN:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ARMENIAN:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.BENGALI:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
            case LIST_STYLE_TYPE.CAMBODIAN:
            case LIST_STYLE_TYPE.KHMER:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
            case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
              return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
            case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
              return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
            case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
            case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.JAPANESE_INFORMAL:
              return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
            case LIST_STYLE_TYPE.JAPANESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
              return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
            case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.DEVANAGARI:
              return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
            case LIST_STYLE_TYPE.GEORGIAN:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.GUJARATI:
              return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
            case LIST_STYLE_TYPE.GURMUKHI:
              return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
            case LIST_STYLE_TYPE.HEBREW:
              return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.HIRAGANA:
              return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
            case LIST_STYLE_TYPE.HIRAGANA_IROHA:
              return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
            case LIST_STYLE_TYPE.KANNADA:
              return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
            case LIST_STYLE_TYPE.KATAKANA:
              return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
            case LIST_STYLE_TYPE.KATAKANA_IROHA:
              return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
            case LIST_STYLE_TYPE.LAO:
              return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
            case LIST_STYLE_TYPE.MONGOLIAN:
              return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
            case LIST_STYLE_TYPE.MYANMAR:
              return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
            case LIST_STYLE_TYPE.ORIYA:
              return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
            case LIST_STYLE_TYPE.PERSIAN:
              return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
            case LIST_STYLE_TYPE.TAMIL:
              return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
            case LIST_STYLE_TYPE.TELUGU:
              return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
            case LIST_STYLE_TYPE.THAI:
              return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
            case LIST_STYLE_TYPE.TIBETAN:
              return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
            case LIST_STYLE_TYPE.DECIMAL:
            default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          }
        };
        var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
        var DocumentCloner = function() {
          function DocumentCloner2(context, element2, options) {
            this.context = context;
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element2;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element2.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element2.ownerDocument.documentElement);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a2.sent();
                      _a2.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node) {
            if (isDebugging(node, 2)) {
              debugger;
            }
            if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
            }
            if (isStyleElement(node)) {
              return this.createStyleClone(node);
            }
            var clone2 = node.cloneNode(false);
            if (isImageElement(clone2)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                clone2.src = node.currentSrc;
                clone2.srcset = "";
              }
              if (clone2.loading === "lazy") {
                clone2.loading = "eager";
              }
            }
            return clone2;
          };
          DocumentCloner2.prototype.createStyleClone = function(node) {
            try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css2 + rule.cssText;
                  }
                  return css2;
                }, "");
                var style = node.cloneNode(false);
                style.textContent = css;
                return style;
              }
            } catch (e2) {
              this.context.logger.error("Unable to access cssRules property", e2);
              if (e2.name !== "SecurityError") {
                throw e2;
              }
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a2;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e2) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e2) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.cloneNode = function(node) {
            if (isTextNode(node)) {
              return document.createTextNode(node.data);
            }
            if (!node.ownerDocument) {
              return node.cloneNode(false);
            }
            var window2 = node.ownerDocument.defaultView;
            if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone2 = this.createElementClone(node);
              clone2.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node);
              var styleBefore = window2.getComputedStyle(node, ":before");
              var styleAfter = window2.getComputedStyle(node, ":after");
              if (this.referenceElement === node && isHTMLElementNode(clone2)) {
                this.clonedReferenceElement = clone2;
              }
              if (isBodyElement(clone2)) {
                createPseudoHideStyles(clone2);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone2, styleBefore, PseudoElementType.BEFORE);
              for (var child = node.firstChild; child; child = child.nextSibling) {
                if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
                  if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                    clone2.appendChild(this.cloneNode(child));
                  }
                }
              }
              if (before) {
                clone2.insertBefore(before, clone2.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone2, styleAfter, PseudoElementType.AFTER);
              if (after) {
                clone2.appendChild(after);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) {
                copyCSSStyles(style, clone2);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                this.scrolledElements.push([clone2, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
                clone2.value = node.value;
              }
              return clone2;
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node, clone2, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document2 = clone2.ownerDocument;
            if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document2.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr2 = token.values.filter(isIdentToken);
                  if (attr2.length) {
                    anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr2[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a2 = token.values.filter(nonFunctionArgSeparator), counter4 = _a2[0], counterStyle = _a2[1];
                  if (counter4 && isIdentToken(counter4)) {
                    var counterState = _this.counters.getCounterValue(counter4.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : LIST_STYLE_TYPE.DECIMAL;
                    anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b2 = token.values.filter(nonFunctionArgSeparator), counter4 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                  if (counter4 && isIdentToken(counter4)) {
                    var counterStates = _this.counters.getCounterValues(counter4.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : LIST_STYLE_TYPE.DECIMAL;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text2 = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document2.createTextNode(text2));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone2)) {
              clone2.className.baseValue += newClassName;
            } else {
              clone2.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }();
        var PseudoElementType;
        (function(PseudoElementType2) {
          PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
          PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
        })(PseudoElementType || (PseudoElementType = {}));
        var createIFrameContainer = function(ownerDocument, bounds) {
          var cloneIframeContainer = ownerDocument.createElement("iframe");
          cloneIframeContainer.className = "html2canvas-container";
          cloneIframeContainer.style.visibility = "hidden";
          cloneIframeContainer.style.position = "fixed";
          cloneIframeContainer.style.left = "-10000px";
          cloneIframeContainer.style.top = "0px";
          cloneIframeContainer.style.border = "0";
          cloneIframeContainer.width = bounds.width.toString();
          cloneIframeContainer.height = bounds.height.toString();
          cloneIframeContainer.scrolling = "no";
          cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
          ownerDocument.body.appendChild(cloneIframeContainer);
          return cloneIframeContainer;
        };
        var imageReady = function(img) {
          return new Promise(function(resolve) {
            if (img.complete) {
              resolve();
              return;
            }
            if (!img.src) {
              resolve();
              return;
            }
            img.onload = resolve;
            img.onerror = resolve;
          });
        };
        var imagesReady = function(document2) {
          return Promise.all([].slice.call(document2.images, 0).map(imageReady));
        };
        var iframeLoader = function(iframe) {
          return new Promise(function(resolve, reject) {
            var cloneWindow = iframe.contentWindow;
            if (!cloneWindow) {
              return reject("No window assigned for iframe");
            }
            var documentClone = cloneWindow.document;
            cloneWindow.onload = iframe.onload = function() {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                  clearInterval(interval);
                  resolve(iframe);
                }
              }, 50);
            };
          });
        };
        var ignoredStyleProperties = [
          "all",
          "d",
          "content"
        ];
        var copyCSSStyles = function(style, target) {
          for (var i2 = style.length - 1; i2 >= 0; i2--) {
            var property = style.item(i2);
            if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
            }
          }
          return target;
        };
        var serializeDoctype = function(doctype) {
          var str = "";
          if (doctype) {
            str += "<!DOCTYPE ";
            if (doctype.name) {
              str += doctype.name;
            }
            if (doctype.internalSubset) {
              str += doctype.internalSubset;
            }
            if (doctype.publicId) {
              str += '"' + doctype.publicId + '"';
            }
            if (doctype.systemId) {
              str += '"' + doctype.systemId + '"';
            }
            str += ">";
          }
          return str;
        };
        var restoreOwnerScroll = function(ownerDocument, x, y) {
          if (ownerDocument && ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x, y);
          }
        };
        var restoreNodeScroll = function(_a2) {
          var element2 = _a2[0], x = _a2[1], y = _a2[2];
          element2.scrollLeft = x;
          element2.scrollTop = y;
        };
        var PSEUDO_BEFORE = ":before";
        var PSEUDO_AFTER = ":after";
        var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
        var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
        var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
        var createPseudoHideStyles = function(body) {
          createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
        };
        var createStyles = function(body, styles) {
          var document2 = body.ownerDocument;
          if (document2) {
            var style = document2.createElement("style");
            style.textContent = styles;
            body.appendChild(style);
          }
        };
        var CacheStorage = function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url2) {
            var link = CacheStorage2._link;
            if (!link) {
              return "about:blank";
            }
            link.href = url2;
            link.href = link.href;
            return link.protocol + link.hostname + link.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }();
        var Cache = function() {
          function Cache2(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache2.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache2.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache2.prototype.loadImage = function(key) {
            return __awaiter(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [2];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve, reject) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve(img);
                      };
                      img.onerror = reject;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a2.sent()];
                }
              });
            });
          };
          Cache2.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache2.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache2.prototype.proxy = function(src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr2 = new XMLHttpRequest();
              xhr2.onload = function() {
                if (xhr2.status === 200) {
                  if (responseType === "text") {
                    resolve(xhr2.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e2) {
                      return reject(e2);
                    }, false);
                    reader_1.readAsDataURL(xhr2.response);
                  }
                } else {
                  reject("Failed to proxy resource " + key + " with status code " + xhr2.status);
                }
              };
              xhr2.onerror = reject;
              var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
              xhr2.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr2 instanceof XMLHttpRequest) {
                xhr2.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr2.timeout = timeout_1;
                xhr2.ontimeout = function() {
                  return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr2.send();
            });
          };
          return Cache2;
        }();
        var INLINE_SVG = /^data:image\/svg\+xml/i;
        var INLINE_BASE64 = /^data:image\/.*;base64,/i;
        var INLINE_IMG = /^data:image\/.*/i;
        var isRenderable = function(src) {
          return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
        };
        var isInlineImage = function(src) {
          return INLINE_IMG.test(src);
        };
        var isInlineBase64Image = function(src) {
          return INLINE_BASE64.test(src);
        };
        var isBlobImage = function(src) {
          return src.substr(0, 4) === "blob";
        };
        var isSVG = function(src) {
          return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
        };
        var PathType;
        (function(PathType2) {
          PathType2[PathType2["VECTOR"] = 0] = "VECTOR";
          PathType2[PathType2["BEZIER_CURVE"] = 1] = "BEZIER_CURVE";
        })(PathType || (PathType = {}));
        var equalPath = function(a2, b) {
          if (a2.length === b.length) {
            return a2.some(function(v, i2) {
              return v === b[i2];
            });
          }
          return false;
        };
        var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
          return path.map(function(point, index) {
            switch (index) {
              case 0:
                return point.add(deltaX, deltaY);
              case 1:
                return point.add(deltaX + deltaW, deltaY);
              case 2:
                return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                return point.add(deltaX, deltaY + deltaH);
            }
            return point;
          });
        };
        var Vector = function() {
          function Vector2(x, y) {
            this.type = PathType.VECTOR;
            this.x = x;
            this.y = y;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }();
        var lerp = function(a2, b, t) {
          return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
        };
        var BezierCurve = function() {
          function BezierCurve2(start, startControl, endControl, end) {
            this.type = PathType.BEZIER_CURVE;
            this.start = start;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
          }
          BezierCurve2.prototype.subdivide = function(t, firstHalf) {
            var ab = lerp(this.start, this.startControl, t);
            var bc = lerp(this.startControl, this.endControl, t);
            var cd = lerp(this.endControl, this.end, t);
            var abbc = lerp(ab, bc, t);
            var bccd = lerp(bc, cd, t);
            var dest = lerp(abbc, bccd, t);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }();
        var isBezierCurve = function(path) {
          return path.type === PathType.BEZIER_CURVE;
        };
        var BoundCurves = function() {
          function BoundCurves2(element2) {
            var styles = element2.styles;
            var bounds = element2.bounds;
            var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
            var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles.borderTopWidth;
            var borderRightWidth2 = styles.borderRightWidth;
            var borderBottomWidth2 = styles.borderBottomWidth;
            var borderLeftWidth2 = styles.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles.paddingTop, element2.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles.paddingRight, element2.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element2.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element2.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }();
        var CORNER;
        (function(CORNER2) {
          CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
          CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
          CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
          CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
        })(CORNER || (CORNER = {}));
        var getCurvePoints = function(x, y, r1, r2, position2) {
          var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
          var ox = r1 * kappa;
          var oy = r2 * kappa;
          var xm = x + r1;
          var ym = y + r2;
          switch (position2) {
            case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
            case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
            case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
            case CORNER.BOTTOM_LEFT:
            default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
          }
        };
        var calculateBorderBoxPath = function(curves) {
          return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
        };
        var calculateContentBoxPath = function(curves) {
          return [
            curves.topLeftContentBox,
            curves.topRightContentBox,
            curves.bottomRightContentBox,
            curves.bottomLeftContentBox
          ];
        };
        var calculatePaddingBoxPath = function(curves) {
          return [
            curves.topLeftPaddingBox,
            curves.topRightPaddingBox,
            curves.bottomRightPaddingBox,
            curves.bottomLeftPaddingBox
          ];
        };
        var TransformEffect = function() {
          function TransformEffect2(offsetX, offsetY, matrix2) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix2;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }();
        var ClipEffect = function() {
          function ClipEffect2(path, target) {
            this.path = path;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }();
        var OpacityEffect = function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }();
        var isTransformEffect = function(effect) {
          return effect.type === 0;
        };
        var isClipEffect = function(effect) {
          return effect.type === 1;
        };
        var isOpacityEffect = function(effect) {
          return effect.type === 2;
        };
        var StackingContext = function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }();
        var ElementPaint = function() {
          function ElementPaint2(container, parent2) {
            this.container = container;
            this.parent = parent2;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix2 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
            }
            if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(borderBox, 2 | 4));
              } else {
                this.effects.push(new ClipEffect(borderBox, 2));
                this.effects.push(new ClipEffect(paddingBox2, 4));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [POSITION.ABSOLUTE, POSITION.FIXED].indexOf(this.container.styles.position) === -1;
            var parent2 = this.parent;
            var effects = this.effects.slice(0);
            while (parent2) {
              var croplessEffects = parent2.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent2.container.styles.position !== POSITION.STATIC || !parent2.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [POSITION.ABSOLUTE, POSITION.FIXED].indexOf(parent2.container.styles.position) === -1;
                if (parent2.container.styles.overflowX !== OVERFLOW.VISIBLE) {
                  var borderBox = calculateBorderBoxPath(parent2.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent2.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent2 = parent2.parent;
            }
            return effects.filter(function(effect) {
              return contains(effect.target, target);
            });
          };
          return ElementPaint2;
        }();
        var parseStackTree = function(parent2, stackingContext, realStackingContext, listItems) {
          parent2.container.elements.forEach(function(child) {
            var treatAsRealStackingContext = contains(child.flags, 4);
            var createsStackingContext2 = contains(child.flags, 2);
            var paintContainer = new ElementPaint(child, parent2);
            if (contains(child.styles.display, 2048)) {
              listItems.push(paintContainer);
            }
            var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
            if (treatAsRealStackingContext || createsStackingContext2) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                var order_1 = child.styles.zIndex.order;
                if (order_1 < 0) {
                  var index_1 = 0;
                  parentStack.negativeZIndex.some(function(current, i2) {
                    if (order_1 > current.element.container.styles.zIndex.order) {
                      index_1 = i2;
                      return false;
                    } else if (index_1 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.negativeZIndex.splice(index_1, 0, stack);
                } else if (order_1 > 0) {
                  var index_2 = 0;
                  parentStack.positiveZIndex.some(function(current, i2) {
                    if (order_1 >= current.element.container.styles.zIndex.order) {
                      index_2 = i2 + 1;
                      return false;
                    } else if (index_2 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.positiveZIndex.splice(index_2, 0, stack);
                } else {
                  parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                }
              } else {
                if (child.styles.isFloating()) {
                  parentStack.nonPositionedFloats.push(stack);
                } else {
                  parentStack.nonPositionedInlineLevel.push(stack);
                }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
            } else {
              if (child.styles.isInlineLevel()) {
                stackingContext.inlineLevel.push(paintContainer);
              } else {
                stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
            }
            if (contains(child.flags, 8)) {
              processListItems(child, listOwnerItems);
            }
          });
        };
        var processListItems = function(owner, elements) {
          var numbering = owner instanceof OLElementContainer ? owner.start : 1;
          var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
          for (var i2 = 0; i2 < elements.length; i2++) {
            var item = elements[i2];
            if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
              numbering = item.container.value;
            }
            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
            numbering += reversed ? -1 : 1;
          }
        };
        var parseStackingContexts = function(container) {
          var paintContainer = new ElementPaint(container, null);
          var root = new StackingContext(paintContainer);
          var listItems = [];
          parseStackTree(paintContainer, root, root, listItems);
          processListItems(paintContainer.container, listItems);
          return root;
        };
        var parsePathForBorder = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderDoubleOuter = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
          }
        };
        var parsePathForBorderDoubleInner = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderStroke = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
            case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
            case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
            case 3:
            default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
          }
        };
        var createStrokePathFromCurves = function(outer1, outer2) {
          var path = [];
          if (isBezierCurve(outer1)) {
            path.push(outer1.subdivide(0.5, false));
          } else {
            path.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path.push(outer2.subdivide(0.5, true));
          } else {
            path.push(outer2);
          }
          return path;
        };
        var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
          var path = [];
          if (isBezierCurve(outer1)) {
            path.push(outer1.subdivide(0.5, false));
          } else {
            path.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path.push(outer2.subdivide(0.5, true));
          } else {
            path.push(outer2);
          }
          if (isBezierCurve(inner2)) {
            path.push(inner2.subdivide(0.5, true).reverse());
          } else {
            path.push(inner2);
          }
          if (isBezierCurve(inner1)) {
            path.push(inner1.subdivide(0.5, false).reverse());
          } else {
            path.push(inner1);
          }
          return path;
        };
        var paddingBox = function(element2) {
          var bounds = element2.bounds;
          var styles = element2.styles;
          return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
        };
        var contentBox = function(element2) {
          var styles = element2.styles;
          var bounds = element2.bounds;
          var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
          var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
          var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
          var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
          return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
        };
        var calculateBackgroundPositioningArea = function(backgroundOrigin2, element2) {
          if (backgroundOrigin2 === 0) {
            return element2.bounds;
          }
          if (backgroundOrigin2 === 2) {
            return contentBox(element2);
          }
          return paddingBox(element2);
        };
        var calculateBackgroundPaintingArea = function(backgroundClip2, element2) {
          if (backgroundClip2 === BACKGROUND_CLIP.BORDER_BOX) {
            return element2.bounds;
          }
          if (backgroundClip2 === BACKGROUND_CLIP.CONTENT_BOX) {
            return contentBox(element2);
          }
          return paddingBox(element2);
        };
        var calculateBackgroundRendering = function(container, index, intrinsicSize) {
          var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
          var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
          var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
          var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
          var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
          var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
          var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
          var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
          return [path, offsetX, offsetY, sizeWidth, sizeHeight];
        };
        var isAuto = function(token) {
          return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
        };
        var hasIntrinsicValue = function(value) {
          return typeof value === "number";
        };
        var calculateBackgroundSize = function(size, _a2, bounds) {
          var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
          var first = size[0], second = size[1];
          if (!first) {
            return [0, 0];
          }
          if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
          }
          var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
          if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
            if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
            }
            return [bounds.width, bounds.height];
          }
          var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
          var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
          var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
          if (isAuto(first) && (!second || isAuto(second))) {
            if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
            }
            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
            }
            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
            }
            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
            return [width_2, height_2];
          }
          if (hasIntrinsicProportion) {
            var width_3 = 0;
            var height_3 = 0;
            if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
            } else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
            }
            if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
            } else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
            }
            return [width_3, height_3];
          }
          var width = null;
          var height = null;
          if (isLengthPercentage(first)) {
            width = getAbsoluteValue(first, bounds.width);
          } else if (second && isLengthPercentage(second)) {
            height = getAbsoluteValue(second, bounds.height);
          }
          if (width !== null && (!second || isAuto(second))) {
            height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
          }
          if (height !== null && isAuto(first)) {
            width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
          }
          if (width !== null && height !== null) {
            return [width, height];
          }
          throw new Error("Unable to calculate background-size for element");
        };
        var getBackgroundValueForIndex = function(values, index) {
          var value = values[index];
          if (typeof value === "undefined") {
            return values[0];
          }
          return value;
        };
        var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
          var x = _a2[0], y = _a2[1];
          var width = _b2[0], height = _b2[1];
          switch (repeat) {
            case BACKGROUND_REPEAT.REPEAT_X:
              return [
                new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
              ];
            case BACKGROUND_REPEAT.REPEAT_Y:
              return [
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
              ];
            case BACKGROUND_REPEAT.NO_REPEAT:
              return [
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
              ];
            default:
              return [
                new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
              ];
          }
        };
        var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        var SAMPLE_TEXT = "Hidden Text";
        var FontMetrics = function() {
          function FontMetrics2(document2) {
            this._data = {};
            this._document = document2;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return {baseline, middle};
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }();
        var Renderer = function() {
          function Renderer2(context, options) {
            this.context = context;
            this.options = options;
          }
          return Renderer2;
        }();
        var MASK_OFFSET = 1e4;
        var CanvasRenderer = function(_super) {
          __extends2(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this._activeEffects = [];
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var styles;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    styles = stack.element.container.styles;
                    if (!styles.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (contains(paint.container.flags, 16)) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a2.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a2.sent();
                    _a2.label = 3;
                  case 3:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
            } else {
              var letters = splitGraphemes(text2.text);
              letters.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text2.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles) {
            var fontVariant2 = styles.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = styles.fontFamily.join(", ");
            var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
            return [
              [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
              var _this = this;
              return __generator(this, function(_c) {
                _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                this.ctx.font = font;
                this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                paintOrder2 = styles.paintOrder;
                text2.textBounds.forEach(function(text3) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case PAINT_ORDER_LAYER.FILL:
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text3.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                          styles.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case PAINT_ORDER_LAYER.STROKE:
                        if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x, textBounds, img, image2, url2, fontFamily2, bounds;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(4));
                    container = paint.container;
                    curves = paint.curves;
                    styles = container.styles;
                    _i = 0, _a2 = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    child = _a2[_i];
                    return [4, this.renderTextNode(child, styles)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x = 0;
                      switch (container.styles.textAlign) {
                        case TEXT_ALIGN.CENTER:
                          x += bounds.width / 2;
                          break;
                        case TEXT_ALIGN.RIGHT:
                          x += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains(container.styles.display, 2048))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === CSSImageType.URL))
                      return [3, 18];
                    image2 = void 0;
                    url2 = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url2)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url2);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {
                      fontFamily2 = this.createFontStyle(styles)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains(stack.element.container.flags, 16)) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a2 = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a2.length))
                      return [3, 5];
                    child = _a2[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b2 = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b2 < _c.length))
                      return [3, 10];
                    child = _c[_b2];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b2++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e.length))
                      return [3, 14];
                    child = _e[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point, index) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                _this.ctx.moveTo(start.x, start.y);
              } else {
                _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
            var _a2;
            if (image2.width === width && image2.height === height) {
              return image2;
            }
            var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width);
            canvas.height = Math.max(1, height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter(this, void 0, void 0, function() {
              var index, _loop_1, this_1, _i, _a2, backgroundImage2;
              return __generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    index = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url2, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                      return __generator(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === CSSImageType.URL))
                              return [3, 5];
                            image2 = void 0;
                            url2 = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url2)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url2);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                              this_1.renderRepeat(path, pattern, x, y);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                              _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width;
                              canvas.height = height;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width, height);
                              if (width > 0 && height > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path, pattern, x, y);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index, [
                                null,
                                null,
                                null
                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                              position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x = getAbsoluteValue(position2[0], width);
                              y = getAbsoluteValue(position2[position2.length - 1], height);
                              _g = calculateRadius(backgroundImage3, x, y, width, height), rx = _g[0], ry = _g[1];
                              if (rx > 0 && ry > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx !== ry) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f2 = ry / rx;
                                  invF = 1 / f2;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index--;
                            return [2];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                    _b2.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    backgroundImage2 = _a2[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b2.sent();
                    _b2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!(width < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a2.sent();
                    return [2];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(2));
                    styles = paint.container.styles;
                    hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                    borders = [
                      {style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth},
                      {style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth},
                      {style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth},
                      {style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth}
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent(styles.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a2.sent();
                    this.ctx.restore();
                    styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a2.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a2.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== BORDER_STYLE.NONE && !isTransparent(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === BORDER_STYLE.DASHED))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DASHED)];
                  case 4:
                    _a2.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === BORDER_STYLE.DOTTED))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DOTTED)];
                  case 6:
                    _a2.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === BORDER_STYLE.DOUBLE))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a2.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a2.sent();
                    _a2.label = 11;
                  case 11:
                    side++;
                    _a2.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
            return __awaiter(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function(_a2) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === BORDER_STYLE.DASHED) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length = Math.abs(startX - endX);
                } else {
                  length = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === BORDER_STYLE.DOTTED) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width < 3 ? width * 3 : width * 2;
                spaceLength = width < 3 ? width * 2 : width;
                if (style === BORDER_STYLE.DOTTED) {
                  dashLength = width;
                  spaceLength = width;
                }
                useLineDash = true;
                if (length <= dashLength * 2) {
                  useLineDash = false;
                } else if (length <= dashLength * 2 + spaceLength) {
                  multiplier = length / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === BORDER_STYLE.DOTTED) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === BORDER_STYLE.DOTTED) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width;
                } else {
                  this.ctx.lineWidth = width * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === BORDER_STYLE.DASHED) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var stack;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element2);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a2.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer);
        var isTextInputElement = function(container) {
          if (container instanceof TextareaElementContainer) {
            return true;
          } else if (container instanceof SelectElementContainer) {
            return true;
          } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
            return true;
          }
          return false;
        };
        var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
          switch (clip) {
            case BACKGROUND_CLIP.BORDER_BOX:
              return calculateBorderBoxPath(curves);
            case BACKGROUND_CLIP.CONTENT_BOX:
              return calculateContentBoxPath(curves);
            case BACKGROUND_CLIP.PADDING_BOX:
            default:
              return calculatePaddingBoxPath(curves);
          }
        };
        var canvasTextAlign = function(textAlign2) {
          switch (textAlign2) {
            case TEXT_ALIGN.CENTER:
              return "center";
            case TEXT_ALIGN.RIGHT:
              return "right";
            case TEXT_ALIGN.LEFT:
            default:
              return "left";
          }
        };
        var ForeignObjectRenderer = function(_super) {
          __extends2(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options;
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var svg, img;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element2);
                    return [4, loadSerializedSVG(svg)];
                  case 1:
                    img = _a2.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer);
        var loadSerializedSVG = function(svg) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
          });
        };
        var Logger = function() {
          function Logger2(_a2) {
            var id = _a2.id, enabled = _a2.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }();
        var Context = function() {
          function Context2(options, windowBounds) {
            var _a2;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({id: this.instanceName, enabled: options.logging});
            this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
          }
          Context2.instanceCount = 1;
          return Context2;
        }();
        var html2canvas2 = function(element2, options) {
          if (options === void 0) {
            options = {};
          }
          return renderElement(element2, options);
        };
        if (typeof window !== "undefined") {
          CacheStorage.setContext(window);
        }
        var renderElement = function(element2, opts) {
          return __awaiter(void 0, void 0, void 0, function() {
            var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
            var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
            return __generator(this, function(_u) {
              switch (_u.label) {
                case 0:
                  if (!element2 || typeof element2 !== "object") {
                    return [2, Promise.reject("Invalid element provided as first argument")];
                  }
                  ownerDocument = element2.ownerDocument;
                  if (!ownerDocument) {
                    throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                    throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                    allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                    imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                    proxy: opts.proxy,
                    useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign2({logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache}, resourceOptions);
                  windowOptions = {
                    windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                    windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                    scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                    scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                    allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                    onclone: opts.onclone,
                    ignoreElements: opts.ignoreElements,
                    inlineImages: foreignObjectRendering,
                    copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element2, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                    return [2, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
                case 1:
                  container = _u.sent();
                  _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
                  backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                    canvas: opts.canvas,
                    backgroundColor: backgroundColor2,
                    scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                    x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                    y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                    width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                    height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering)
                    return [3, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4, renderer.render(clonedElement)];
                case 2:
                  canvas = _u.sent();
                  return [3, 5];
                case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor2 === root.styles.backgroundColor) {
                    root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4, renderer.render(root)];
                case 4:
                  canvas = _u.sent();
                  _u.label = 5;
                case 5:
                  if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                    if (!DocumentCloner.destroy(container)) {
                      context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                    }
                  }
                  context.logger.debug("Finished rendering");
                  return [2, canvas];
              }
            });
          });
        };
        var parseBackgroundColor = function(context, element2, backgroundColorOverride) {
          var ownerDocument = element2.ownerDocument;
          var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
          var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
          return element2 === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
        };
        return html2canvas2;
      });
    })(html2canvas$1);
    var html2canvas = html2canvas$1.exports;
    var {Object: Object_1$2} = globals;
    var file$a = "src/components/Modal/ReportProblem.svelte";
    function create_if_block_1$1(ctx) {
      let img;
      let img_src_value;
      const block = {
        c: function create2() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = ctx[0].screenshot))
            attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "screenshot");
          attr_dev(img, "class", "mx-auto aspect-w-16 aspect-h-9 max-h-32");
          add_location(img, file$a, 24, 4, 611);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0].screenshot)) {
            attr_dev(img, "src", img_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(24:3) {#if $problemReport.screenshot}",
        ctx
      });
      return block;
    }
    function create_default_slot_3$2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Bidschirmfoto aufnehmen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$2.name,
        type: "slot",
        source: "(41:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_2$2(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_3$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 512) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$2.name,
        type: "slot",
        source: '(32:2) <Button    class=\\"whitespace-nowrap w-full\\"    on:click={() => {     html2canvas($svelteRenderParent).then((canvas) => {      const base64image = canvas.toDataURL(\\"image/png\\");      $problemReport.screenshot = base64image;     });    }}   >',
        ctx
      });
      return block;
    }
    function create_default_slot_1$2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Melden");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$2.name,
        type: "slot",
        source: "(96:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot$22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_1$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 512) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$22.name,
        type: "slot",
        source: '(74:2) <Button    variant=\\"raised\\"    class=\\"w-full\\"    on:click={async () => {     let { data } = await axios.post(      `${backendURL}/api/problem`,      $problemReport     );     $problemReport = { problem_text: \\"\\" };     if (data) {      $notification = {       text: \\"Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.\\",       bg: \\"var(--mdc-theme-callout);\\",       color: \\"var(--mdc-theme-on-primary);\\",      };      setTimeout(() => {       $notification = undefined;      }, 5000);      $modal = {};     }    }}   >',
        ctx
      });
      return block;
    }
    function create_if_block$4(ctx) {
      let div;
      const block = {
        c: function create2() {
          div = element("div");
          div.textContent = `${ctx[4]}`;
          attr_dev(div, "class", "absolute top-60 w-full bg-green-500 text-white rounded");
          add_location(div, file$a, 100, 1, 2333);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(100:0) {#if response}",
        ctx
      });
      return block;
    }
    function create_fragment$b(ctx) {
      let section;
      let div1;
      let div0;
      let t0;
      let button0;
      let t1;
      let from;
      let textarea;
      let t2;
      let button1;
      let t3;
      let if_block1_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block0 = ctx[0].screenshot && create_if_block_1$1(ctx);
      button0 = new Button_1({
        props: {
          class: "whitespace-nowrap w-full",
          $$slots: {default: [create_default_slot_2$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button0.$on("click", ctx[5]);
      button1 = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot$22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button1.$on("click", ctx[7]);
      let if_block1 = ctx[4] && create_if_block$4(ctx);
      const block = {
        c: function create2() {
          section = element("section");
          div1 = element("div");
          div0 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          create_component(button0.$$.fragment);
          t1 = space();
          from = element("from");
          textarea = element("textarea");
          t2 = space();
          create_component(button1.$$.fragment);
          t3 = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          attr_dev(div0, "class", "flex justify-center items-center");
          add_location(div0, file$a, 22, 2, 525);
          attr_dev(div1, "class", "flex justify-center items-center flex-col");
          add_location(div1, file$a, 21, 1, 467);
          attr_dev(textarea, "class", "w-full");
          attr_dev(textarea, "name", "problem_text");
          attr_dev(textarea, "rows", "4");
          attr_dev(textarea, "cols", "50");
          attr_dev(textarea, "placeholder", "Problem Beschreibung");
          add_location(textarea, file$a, 64, 2, 1576);
          attr_dev(from, "class", "flex flex-col gap-4 w-full");
          add_location(from, file$a, 43, 1, 1059);
          attr_dev(section, "class", "w-full grid grid-cols-1 md:grid-cols-2 justify-center items-center gap-8 p-4");
          add_location(section, file$a, 18, 0, 369);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div1);
          append_dev(div1, div0);
          if (if_block0)
            if_block0.m(div0, null);
          append_dev(div1, t0);
          mount_component(button0, div1, null);
          append_dev(section, t1);
          append_dev(section, from);
          append_dev(from, textarea);
          set_input_value(textarea, ctx[0].problem_text);
          append_dev(from, t2);
          mount_component(button1, from, null);
          insert_dev(target, t3, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(textarea, "input", ctx[6]),
              listen_dev(from, "submit", prevent_default(ctx[8]), false, true, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (ctx2[0].screenshot) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_1$1(ctx2);
              if_block0.c();
              if_block0.m(div0, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          const button0_changes = {};
          if (dirty & 512) {
            button0_changes.$$scope = {dirty, ctx: ctx2};
          }
          button0.$set(button0_changes);
          if (dirty & 1) {
            set_input_value(textarea, ctx2[0].problem_text);
          }
          const button1_changes = {};
          if (dirty & 512) {
            button1_changes.$$scope = {dirty, ctx: ctx2};
          }
          button1.$set(button1_changes);
          if (ctx2[4])
            if_block1.p(ctx2, dirty);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          if (if_block0)
            if_block0.d();
          destroy_component(button0);
          destroy_component(button1);
          if (detaching)
            detach_dev(t3);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$9($$self, $$props, $$invalidate) {
      let $problemReport;
      let $svelteRenderParent;
      let $notification;
      let $modal;
      validate_store(problemReport, "problemReport");
      component_subscribe($$self, problemReport, ($$value) => $$invalidate(0, $problemReport = $$value));
      validate_store(svelteRenderParent, "svelteRenderParent");
      component_subscribe($$self, svelteRenderParent, ($$value) => $$invalidate(1, $svelteRenderParent = $$value));
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(2, $notification = $$value));
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(3, $modal = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("ReportProblem", slots, []);
      let response;
      const writable_props = [];
      Object_1$2.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<ReportProblem> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        html2canvas($svelteRenderParent).then((canvas) => {
          const base64image = canvas.toDataURL("image/png");
          set_store_value(problemReport, $problemReport.screenshot = base64image, $problemReport);
        });
      };
      function textarea_input_handler() {
        $problemReport.problem_text = this.value;
        problemReport.set($problemReport);
      }
      const click_handler_1 = async () => {
        let {data} = await axios.post(`${backendURL}/api/problem`, $problemReport);
        set_store_value(problemReport, $problemReport = {problem_text: ""}, $problemReport);
        if (data) {
          set_store_value(notification, $notification = {
            text: "Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
          }, 5e3);
          set_store_value(modal, $modal = {}, $modal);
        }
      };
      const submit_handler = async () => {
        let {data} = await axios.post(`${backendURL}/api/problem/`, $problemReport);
        set_store_value(problemReport, $problemReport = {problem_text: ""}, $problemReport);
        if (data) {
          set_store_value(notification, $notification = {
            text: "Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
          }, 5e3);
          set_store_value(modal, $modal = {}, $modal);
        }
      };
      $$self.$capture_state = () => ({
        Button: Button_1,
        Label: CommonLabel,
        html2canvas,
        backendURL,
        problemReport,
        modal,
        notification,
        svelteRenderParent,
        axios,
        response,
        $problemReport,
        $svelteRenderParent,
        $notification,
        $modal
      });
      $$self.$inject_state = ($$props2) => {
        if ("response" in $$props2)
          $$invalidate(4, response = $$props2.response);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          if (!$problemReport || Object.keys($problemReport).length == 0) {
            set_store_value(problemReport, $problemReport.problem_text = "", $problemReport);
          }
        }
      };
      return [
        $problemReport,
        $svelteRenderParent,
        $notification,
        $modal,
        response,
        click_handler,
        textarea_input_handler,
        click_handler_1,
        submit_handler
      ];
    }
    var ReportProblem = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$9, create_fragment$b, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ReportProblem",
          options,
          id: create_fragment$b.name
        });
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses7 = {
      FIXED_CLASS: "mdc-top-app-bar--fixed",
      FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
      SHORT_CLASS: "mdc-top-app-bar--short",
      SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
      SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
    };
    var numbers$13 = {
      DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
      MAX_TOP_APP_BAR_HEIGHT: 128
    };
    var strings$12 = {
      ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
      NAVIGATION_EVENT: "MDCTopAppBar:nav",
      NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
      ROOT_SELECTOR: ".mdc-top-app-bar",
      TITLE_SELECTOR: ".mdc-top-app-bar__title"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTopAppBarBaseFoundation = function(_super) {
      __extends(MDCTopAppBarBaseFoundation2, _super);
      function MDCTopAppBarBaseFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "cssClasses", {
        get: function() {
          return cssClasses7;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "numbers", {
        get: function() {
          return numbers$13;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            setStyle: function() {
              return void 0;
            },
            getTopAppBarHeight: function() {
              return 0;
            },
            notifyNavigationIconClicked: function() {
              return void 0;
            },
            getViewportScrollY: function() {
              return 0;
            },
            getTotalActionItems: function() {
              return 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTopAppBarBaseFoundation2.prototype.handleTargetScroll = function() {
      };
      MDCTopAppBarBaseFoundation2.prototype.handleWindowResize = function() {
      };
      MDCTopAppBarBaseFoundation2.prototype.handleNavigationClick = function() {
        this.adapter.notifyNavigationIconClicked();
      };
      return MDCTopAppBarBaseFoundation2;
    }(MDCFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var INITIAL_VALUE = 0;
    var MDCTopAppBarFoundation = function(_super) {
      __extends(MDCTopAppBarFoundation2, _super);
      function MDCTopAppBarFoundation2(adapter) {
        var _this = _super.call(this, adapter) || this;
        _this.wasDocked_ = true;
        _this.isDockedShowing_ = true;
        _this.currentAppBarOffsetTop_ = 0;
        _this.isCurrentlyBeingResized_ = false;
        _this.resizeThrottleId_ = INITIAL_VALUE;
        _this.resizeDebounceId_ = INITIAL_VALUE;
        _this.lastScrollPosition_ = _this.adapter.getViewportScrollY();
        _this.topAppBarHeight_ = _this.adapter.getTopAppBarHeight();
        return _this;
      }
      MDCTopAppBarFoundation2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.adapter.setStyle("top", "");
      };
      MDCTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
        var diff = currentScrollPosition - this.lastScrollPosition_;
        this.lastScrollPosition_ = currentScrollPosition;
        if (!this.isCurrentlyBeingResized_) {
          this.currentAppBarOffsetTop_ -= diff;
          if (this.currentAppBarOffsetTop_ > 0) {
            this.currentAppBarOffsetTop_ = 0;
          } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
            this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
          }
          this.moveTopAppBar_();
        }
      };
      MDCTopAppBarFoundation2.prototype.handleWindowResize = function() {
        var _this = this;
        if (!this.resizeThrottleId_) {
          this.resizeThrottleId_ = setTimeout(function() {
            _this.resizeThrottleId_ = INITIAL_VALUE;
            _this.throttledResizeHandler_();
          }, numbers$13.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }
        this.isCurrentlyBeingResized_ = true;
        if (this.resizeDebounceId_) {
          clearTimeout(this.resizeDebounceId_);
        }
        this.resizeDebounceId_ = setTimeout(function() {
          _this.handleTargetScroll();
          _this.isCurrentlyBeingResized_ = false;
          _this.resizeDebounceId_ = INITIAL_VALUE;
        }, numbers$13.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
      };
      MDCTopAppBarFoundation2.prototype.checkForUpdate_ = function() {
        var offscreenBoundaryTop = -this.topAppBarHeight_;
        var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
        var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
        var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
        if (partiallyShowing) {
          this.wasDocked_ = false;
        } else {
          if (!this.wasDocked_) {
            this.wasDocked_ = true;
            return true;
          } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
            this.isDockedShowing_ = hasAnyPixelsOnscreen;
            return true;
          }
        }
        return partiallyShowing;
      };
      MDCTopAppBarFoundation2.prototype.moveTopAppBar_ = function() {
        if (this.checkForUpdate_()) {
          var offset = this.currentAppBarOffsetTop_;
          if (Math.abs(offset) >= this.topAppBarHeight_) {
            offset = -numbers$13.MAX_TOP_APP_BAR_HEIGHT;
          }
          this.adapter.setStyle("top", offset + "px");
        }
      };
      MDCTopAppBarFoundation2.prototype.throttledResizeHandler_ = function() {
        var currentHeight = this.adapter.getTopAppBarHeight();
        if (this.topAppBarHeight_ !== currentHeight) {
          this.wasDocked_ = false;
          this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
          this.topAppBarHeight_ = currentHeight;
        }
        this.handleTargetScroll();
      };
      return MDCTopAppBarFoundation2;
    }(MDCTopAppBarBaseFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFixedTopAppBarFoundation = function(_super) {
      __extends(MDCFixedTopAppBarFoundation2, _super);
      function MDCFixedTopAppBarFoundation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.wasScrolled_ = false;
        return _this;
      }
      MDCFixedTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        var currentScroll = this.adapter.getViewportScrollY();
        if (currentScroll <= 0) {
          if (this.wasScrolled_) {
            this.adapter.removeClass(cssClasses7.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = false;
          }
        } else {
          if (!this.wasScrolled_) {
            this.adapter.addClass(cssClasses7.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = true;
          }
        }
      };
      return MDCFixedTopAppBarFoundation2;
    }(MDCTopAppBarFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCShortTopAppBarFoundation = function(_super) {
      __extends(MDCShortTopAppBarFoundation2, _super);
      function MDCShortTopAppBarFoundation2(adapter) {
        var _this = _super.call(this, adapter) || this;
        _this.isCollapsed_ = false;
        _this.isAlwaysCollapsed_ = false;
        return _this;
      }
      Object.defineProperty(MDCShortTopAppBarFoundation2.prototype, "isCollapsed", {
        get: function() {
          return this.isCollapsed_;
        },
        enumerable: false,
        configurable: true
      });
      MDCShortTopAppBarFoundation2.prototype.init = function() {
        _super.prototype.init.call(this);
        if (this.adapter.getTotalActionItems() > 0) {
          this.adapter.addClass(cssClasses7.SHORT_HAS_ACTION_ITEM_CLASS);
        }
        this.setAlwaysCollapsed(this.adapter.hasClass(cssClasses7.SHORT_COLLAPSED_CLASS));
      };
      MDCShortTopAppBarFoundation2.prototype.setAlwaysCollapsed = function(value) {
        this.isAlwaysCollapsed_ = !!value;
        if (this.isAlwaysCollapsed_) {
          this.collapse_();
        } else {
          this.maybeCollapseBar_();
        }
      };
      MDCShortTopAppBarFoundation2.prototype.getAlwaysCollapsed = function() {
        return this.isAlwaysCollapsed_;
      };
      MDCShortTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        this.maybeCollapseBar_();
      };
      MDCShortTopAppBarFoundation2.prototype.maybeCollapseBar_ = function() {
        if (this.isAlwaysCollapsed_) {
          return;
        }
        var currentScroll = this.adapter.getViewportScrollY();
        if (currentScroll <= 0) {
          if (this.isCollapsed_) {
            this.uncollapse_();
          }
        } else {
          if (!this.isCollapsed_) {
            this.collapse_();
          }
        }
      };
      MDCShortTopAppBarFoundation2.prototype.uncollapse_ = function() {
        this.adapter.removeClass(cssClasses7.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = false;
      };
      MDCShortTopAppBarFoundation2.prototype.collapse_ = function() {
        this.adapter.addClass(cssClasses7.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = true;
      };
      return MDCShortTopAppBarFoundation2;
    }(MDCTopAppBarBaseFoundation);
    var {window: window_1} = globals;
    var file$9 = "node_modules/@smui/top-app-bar/TopAppBar.svelte";
    function create_fragment$a(ctx) {
      let header;
      let header_class_value;
      let header_style_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[22].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
      let header_levels = [
        {
          class: header_class_value = classMap({
            [ctx[2]]: true,
            "mdc-top-app-bar": true,
            "mdc-top-app-bar--short": ctx[4] === "short",
            "mdc-top-app-bar--short-collapsed": ctx[0],
            "mdc-top-app-bar--fixed": ctx[4] === "fixed",
            "smui-top-app-bar--static": ctx[4] === "static",
            "smui-top-app-bar--color-secondary": ctx[5] === "secondary",
            "mdc-top-app-bar--prominent": ctx[6],
            "mdc-top-app-bar--dense": ctx[7],
            ...ctx[11]
          })
        },
        {
          style: header_style_value = Object.entries(ctx[12]).map(func$13).concat([ctx[3]]).join(" ")
        },
        ctx[15]
      ];
      let header_data = {};
      for (let i = 0; i < header_levels.length; i += 1) {
        header_data = assign(header_data, header_levels[i]);
      }
      const block = {
        c: function create2() {
          header = element("header");
          if (default_slot)
            default_slot.c();
          set_attributes(header, header_data);
          add_location(header, file$9, 9, 0, 208);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, header, anchor);
          if (default_slot) {
            default_slot.m(header, null);
          }
          ctx[25](header);
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(window_1, "resize", ctx[23], false, false, false),
              listen_dev(window_1, "scroll", ctx[24], false, false, false),
              action_destroyer(useActions_action = useActions.call(null, header, ctx[1])),
              action_destroyer(ctx[13].call(null, header)),
              listen_dev(header, "SMUI:top-app-bar:icon-button:nav", ctx[26], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[0] & 2097152)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
            }
          }
          set_attributes(header, header_data = get_spread_update(header_levels, [
            (!current || dirty[0] & 2293 && header_class_value !== (header_class_value = classMap({
              [ctx2[2]]: true,
              "mdc-top-app-bar": true,
              "mdc-top-app-bar--short": ctx2[4] === "short",
              "mdc-top-app-bar--short-collapsed": ctx2[0],
              "mdc-top-app-bar--fixed": ctx2[4] === "fixed",
              "smui-top-app-bar--static": ctx2[4] === "static",
              "smui-top-app-bar--color-secondary": ctx2[5] === "secondary",
              "mdc-top-app-bar--prominent": ctx2[6],
              "mdc-top-app-bar--dense": ctx2[7],
              ...ctx2[11]
            }))) && {class: header_class_value},
            (!current || dirty[0] & 4104 && header_style_value !== (header_style_value = Object.entries(ctx2[12]).map(func$13).concat([ctx2[3]]).join(" "))) && {style: header_style_value},
            dirty[0] & 32768 && ctx2[15]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
            useActions_action.update.call(null, ctx2[1]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(header);
          if (default_slot)
            default_slot.d(detaching);
          ctx[25](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func$13 = ([name2, value]) => `${name2}: ${value};`;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "variant",
        "color",
        "collapsed",
        "prominent",
        "dense",
        "scrollTarget",
        "getPropStore",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("TopAppBar", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {variant = "standard"} = $$props;
      let {color = "primary"} = $$props;
      let {collapsed = uninitializedValue} = $$props;
      let {prominent = false} = $$props;
      let {dense = false} = $$props;
      let {scrollTarget = null} = $$props;
      let element2;
      let instance8;
      let internalClasses = {};
      let internalStyles = {};
      const alwaysCollapsed = collapsed !== uninitializedValue && !!collapsed;
      if (collapsed === uninitializedValue) {
        collapsed = false;
      }
      let propStoreSet;
      let propStore = readable({variant, prominent, dense}, (set) => {
        $$invalidate(18, propStoreSet = set);
      });
      let oldScrollTarget = null;
      let oldVariant = variant;
      onMount(() => {
        $$invalidate(9, instance8 = getInstance());
        instance8.init();
        return () => {
          instance8.destroy();
        };
      });
      function getInstance() {
        const Foundation = {
          static: MDCTopAppBarBaseFoundation,
          short: MDCShortTopAppBarFoundation,
          fixed: MDCFixedTopAppBarFoundation
        }[variant] || MDCTopAppBarFoundation;
        return new Foundation({
          hasClass,
          addClass,
          removeClass,
          setStyle: addStyle,
          getTopAppBarHeight: () => element2.clientHeight,
          notifyNavigationIconClicked: () => dispatch(element2, "MDCTopAppBar:nav"),
          getViewportScrollY: () => scrollTarget == null ? window.pageYOffset : scrollTarget.scrollTop,
          getTotalActionItems: () => element2.querySelectorAll(".mdc-top-app-bar__action-item").length
        });
      }
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name2, value) {
        if (internalStyles[name2] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name2];
            $$invalidate(12, internalStyles), $$invalidate(20, oldVariant), $$invalidate(4, variant), $$invalidate(9, instance8);
          } else {
            $$invalidate(12, internalStyles[name2] = value, internalStyles);
          }
        }
      }
      function handleTargetScroll() {
        if (instance8) {
          instance8.handleTargetScroll();
          if (variant === "short") {
            $$invalidate(0, collapsed = instance8.isCollapsed);
          }
        }
      }
      function getPropStore() {
        return propStore;
      }
      function getElement() {
        return element2;
      }
      const resize_handler = () => variant !== "short" && variant !== "fixed" && instance8 && instance8.handleWindowResize();
      const scroll_handler = () => scrollTarget == null && handleTargetScroll();
      function header_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(10, element2);
        });
      }
      const SMUI_top_app_bar_icon_button_nav_handler = () => instance8 && instance8.handleNavigationClick();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(3, style = $$new_props.style);
        if ("variant" in $$new_props)
          $$invalidate(4, variant = $$new_props.variant);
        if ("color" in $$new_props)
          $$invalidate(5, color = $$new_props.color);
        if ("collapsed" in $$new_props)
          $$invalidate(0, collapsed = $$new_props.collapsed);
        if ("prominent" in $$new_props)
          $$invalidate(6, prominent = $$new_props.prominent);
        if ("dense" in $$new_props)
          $$invalidate(7, dense = $$new_props.dense);
        if ("scrollTarget" in $$new_props)
          $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
        if ("$$scope" in $$new_props)
          $$invalidate(21, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        MDCTopAppBarBaseFoundation,
        MDCTopAppBarFoundation,
        MDCFixedTopAppBarFoundation,
        MDCShortTopAppBarFoundation,
        onMount,
        get_current_component,
        readable,
        forwardEventsBuilder,
        classMap,
        useActions,
        dispatch,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        variant,
        color,
        collapsed,
        prominent,
        dense,
        scrollTarget,
        element: element2,
        instance: instance8,
        internalClasses,
        internalStyles,
        alwaysCollapsed,
        propStoreSet,
        propStore,
        oldScrollTarget,
        oldVariant,
        getInstance,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        handleTargetScroll,
        getPropStore,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          uninitializedValue = $$new_props.uninitializedValue;
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(3, style = $$new_props.style);
        if ("variant" in $$props)
          $$invalidate(4, variant = $$new_props.variant);
        if ("color" in $$props)
          $$invalidate(5, color = $$new_props.color);
        if ("collapsed" in $$props)
          $$invalidate(0, collapsed = $$new_props.collapsed);
        if ("prominent" in $$props)
          $$invalidate(6, prominent = $$new_props.prominent);
        if ("dense" in $$props)
          $$invalidate(7, dense = $$new_props.dense);
        if ("scrollTarget" in $$props)
          $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
        if ("element" in $$props)
          $$invalidate(10, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(9, instance8 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(11, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(12, internalStyles = $$new_props.internalStyles);
        if ("propStoreSet" in $$props)
          $$invalidate(18, propStoreSet = $$new_props.propStoreSet);
        if ("propStore" in $$props)
          propStore = $$new_props.propStore;
        if ("oldScrollTarget" in $$props)
          $$invalidate(19, oldScrollTarget = $$new_props.oldScrollTarget);
        if ("oldVariant" in $$props)
          $$invalidate(20, oldVariant = $$new_props.oldVariant);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 262352) {
          if (propStoreSet) {
            propStoreSet({variant, prominent, dense});
          }
        }
        if ($$self.$$.dirty[0] & 1049104) {
          if (oldVariant !== variant && instance8) {
            $$invalidate(20, oldVariant = variant);
            instance8.destroy();
            $$invalidate(11, internalClasses = {});
            $$invalidate(12, internalStyles = {});
            $$invalidate(9, instance8 = getInstance());
            instance8.init();
          }
        }
        if ($$self.$$.dirty[0] & 528) {
          if (instance8 && variant === "short") {
            instance8.setAlwaysCollapsed(alwaysCollapsed);
          }
        }
        if ($$self.$$.dirty[0] & 524544) {
          if (oldScrollTarget !== scrollTarget) {
            if (oldScrollTarget) {
              oldScrollTarget.removeEventListener("scroll", handleTargetScroll);
            }
            if (scrollTarget) {
              scrollTarget.addEventListener("scroll", handleTargetScroll);
            }
            $$invalidate(19, oldScrollTarget = scrollTarget);
          }
        }
      };
      return [
        collapsed,
        use2,
        className,
        style,
        variant,
        color,
        prominent,
        dense,
        scrollTarget,
        instance8,
        element2,
        internalClasses,
        internalStyles,
        forwardEvents,
        handleTargetScroll,
        $$restProps,
        getPropStore,
        getElement,
        propStoreSet,
        oldScrollTarget,
        oldVariant,
        $$scope,
        slots,
        resize_handler,
        scroll_handler,
        header_binding,
        SMUI_top_app_bar_icon_button_nav_handler
      ];
    }
    var TopAppBar = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$a, safe_not_equal, {
          use: 1,
          class: 2,
          style: 3,
          variant: 4,
          color: 5,
          collapsed: 0,
          prominent: 6,
          dense: 7,
          scrollTarget: 8,
          getPropStore: 16,
          getElement: 17
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TopAppBar",
          options,
          id: create_fragment$a.name
        });
      }
      get use() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get collapsed() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set collapsed(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get prominent() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set prominent(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dense() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dense(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get scrollTarget() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set scrollTarget(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getPropStore() {
        return this.$$.ctx[16];
      }
      set getPropStore(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[17];
      }
      set getElement(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var Row = classAdderBuilder({
      class: "mdc-top-app-bar__row",
      component: Div
    });
    var file$8 = "node_modules/@smui/top-app-bar/Section.svelte";
    function create_fragment$9(ctx) {
      let section;
      let section_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[9].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
      let section_levels = [
        {
          class: section_class_value = classMap({
            [ctx[1]]: true,
            "mdc-top-app-bar__section": true,
            "mdc-top-app-bar__section--align-start": ctx[2] === "start",
            "mdc-top-app-bar__section--align-end": ctx[2] === "end"
          })
        },
        ctx[3] ? {role: "toolbar"} : {},
        ctx[6]
      ];
      let section_data = {};
      for (let i = 0; i < section_levels.length; i += 1) {
        section_data = assign(section_data, section_levels[i]);
      }
      const block = {
        c: function create2() {
          section = element("section");
          if (default_slot)
            default_slot.c();
          set_attributes(section, section_data);
          add_location(section, file$8, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          if (default_slot) {
            default_slot.m(section, null);
          }
          ctx[10](section);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, section, ctx[0])),
              action_destroyer(ctx[5].call(null, section))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 256)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
            }
          }
          set_attributes(section, section_data = get_spread_update(section_levels, [
            (!current || dirty & 6 && section_class_value !== (section_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-top-app-bar__section": true,
              "mdc-top-app-bar__section--align-start": ctx2[2] === "start",
              "mdc-top-app-bar__section--align-end": ctx2[2] === "end"
            }))) && {class: section_class_value},
            dirty & 8 && (ctx2[3] ? {role: "toolbar"} : {}),
            dirty & 64 && ctx2[6]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          if (default_slot)
            default_slot.d(detaching);
          ctx[10](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$8($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "align", "toolbar", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Section", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {align = "start"} = $$props;
      let {toolbar = false} = $$props;
      let element2;
      setContext("SMUI:icon-button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
      setContext("SMUI:button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
      function getElement() {
        return element2;
      }
      function section_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(4, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("align" in $$new_props)
          $$invalidate(2, align = $$new_props.align);
        if ("toolbar" in $$new_props)
          $$invalidate(3, toolbar = $$new_props.toolbar);
        if ("$$scope" in $$new_props)
          $$invalidate(8, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        setContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        align,
        toolbar,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("align" in $$props)
          $$invalidate(2, align = $$new_props.align);
        if ("toolbar" in $$props)
          $$invalidate(3, toolbar = $$new_props.toolbar);
        if ("element" in $$props)
          $$invalidate(4, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        align,
        toolbar,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        section_binding
      ];
    }
    var Section = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$8, create_fragment$9, safe_not_equal, {
          use: 0,
          class: 1,
          align: 2,
          toolbar: 3,
          getElement: 7
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Section",
          options,
          id: create_fragment$9.name
        });
      }
      get use() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get align() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set align(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get toolbar() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set toolbar(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[7];
      }
      set getElement(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var Title2 = classAdderBuilder({
      class: "mdc-top-app-bar__title",
      component: Span
    });
    var file$7 = "node_modules/@smui/common/Img.svelte";
    function create_fragment$8(ctx) {
      let img;
      let useActions_action;
      let t;
      let current;
      let mounted;
      let dispose;
      let img_levels = [{alt: ctx[0]}, ctx[4]];
      let img_data = {};
      for (let i = 0; i < img_levels.length; i += 1) {
        img_data = assign(img_data, img_levels[i]);
      }
      const default_slot_template = ctx[7].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
      const block = {
        c: function create2() {
          img = element("img");
          t = space();
          if (default_slot)
            default_slot.c();
          set_attributes(img, img_data);
          add_location(img, file$7, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          ctx[8](img);
          insert_dev(target, t, anchor);
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, img, ctx[1])),
              action_destroyer(ctx[3].call(null, img))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          set_attributes(img, img_data = get_spread_update(img_levels, [
            (!current || dirty & 1) && {alt: ctx2[0]},
            dirty & 16 && ctx2[4]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 2)
            useActions_action.update.call(null, ctx2[1]);
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 64)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(img);
          ctx[8](null);
          if (detaching)
            detach_dev(t);
          if (default_slot)
            default_slot.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$8.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$7($$self, $$props, $$invalidate) {
      const omit_props_names = ["alt", "use", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Img", slots, ["default"]);
      let {alt = ""} = $$props;
      let {use: use2 = []} = $$props;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let element2 = null;
      function getElement() {
        return element2;
      }
      function img_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("alt" in $$new_props)
          $$invalidate(0, alt = $$new_props.alt);
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("$$scope" in $$new_props)
          $$invalidate(6, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder,
        useActions,
        alt,
        use: use2,
        forwardEvents,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("alt" in $$props)
          $$invalidate(0, alt = $$new_props.alt);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        alt,
        use2,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        img_binding
      ];
    }
    var Img = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$7, create_fragment$8, safe_not_equal, {alt: 0, use: 1, getElement: 5});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Img",
          options,
          id: create_fragment$8.name
        });
      }
      get alt() {
        throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set alt(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get use() {
        throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[5];
      }
      set getElement(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function clickOutside(node) {
      const handleClick2 = (event) => {
        if (node && !node.contains(event.target) && !event.defaultPrevented) {
          node.dispatchEvent(new CustomEvent("click_outside", node));
        }
      };
      document.addEventListener("click", handleClick2, true);
      return {
        destroy() {
          document.removeEventListener("click", handleClick2, true);
        }
      };
    }
    var file$6 = "src/components/components/Menu.svelte";
    function create_if_block$3(ctx) {
      let div;
      let ul;
      let div_transition;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
      const block = {
        c: function create2() {
          div = element("div");
          ul = element("ul");
          if (default_slot)
            default_slot.c();
          add_location(ul, file$6, 18, 2, 397);
          attr_dev(div, "class", "absolute right-full top-0 rounded text-black py-2 text-xl bg-white shadow-xl");
          add_location(div, file$6, 7, 1, 153);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, ul);
          if (default_slot) {
            default_slot.m(ul, null);
          }
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(div, "click", ctx[3], false, false, false),
              action_destroyer(clickOutside.call(null, div)),
              listen_dev(div, "click_outside", ctx[4], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          add_render_callback(() => {
            if (!div_transition)
              div_transition = create_bidirectional_transition(div, fade, {}, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, {}, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          if (detaching && div_transition)
            div_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(7:0) {#if menuToggle}",
        ctx
      });
      return block;
    }
    function create_fragment$72(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[0] && create_if_block$3(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (ctx2[0]) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$3(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$72.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$62($$self, $$props, $$invalidate) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Menu", slots, ["default"]);
      let {menuToggle} = $$props;
      const writable_props = ["menuToggle"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Menu> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        $$invalidate(0, menuToggle = !menuToggle);
      };
      const click_outside_handler = () => {
        $$invalidate(0, menuToggle = false);
      };
      $$self.$$set = ($$props2) => {
        if ("menuToggle" in $$props2)
          $$invalidate(0, menuToggle = $$props2.menuToggle);
        if ("$$scope" in $$props2)
          $$invalidate(1, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => ({fade, clickOutside, menuToggle});
      $$self.$inject_state = ($$props2) => {
        if ("menuToggle" in $$props2)
          $$invalidate(0, menuToggle = $$props2.menuToggle);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [menuToggle, $$scope, slots, click_handler, click_outside_handler];
    }
    var Menu2 = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$62, create_fragment$72, safe_not_equal, {menuToggle: 0});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Menu",
          options,
          id: create_fragment$72.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("menuToggle" in props)) {
          console.warn("<Menu> was created without expected prop 'menuToggle'");
        }
      }
      get menuToggle() {
        throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set menuToggle(value) {
        throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var file$52 = "src/components/auth/login.svelte";
    function create_else_block$2(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot_4$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(83:2) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$2(ctx) {
      let await_block_anchor;
      let promise2;
      let current;
      let info = {
        ctx,
        current: null,
        token: null,
        hasCatch: true,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        value: 8,
        error: 9,
        blocks: [, , ,]
      };
      handle_promise(promise2 = ctx[1], info);
      const block = {
        c: function create2() {
          await_block_anchor = empty();
          info.block.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, await_block_anchor, anchor);
          info.block.m(target, info.anchor = anchor);
          info.mount = () => await_block_anchor.parentNode;
          info.anchor = await_block_anchor;
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          info.ctx = ctx;
          if (dirty & 2 && promise2 !== (promise2 = ctx[1]) && handle_promise(promise2, info))
            ;
          else {
            update_await_block_branch(info, ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(info.block);
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < 3; i += 1) {
            const block2 = info.blocks[i];
            transition_out(block2);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(await_block_anchor);
          info.block.d(detaching);
          info.token = null;
          info = null;
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(64:2) {#if loginPromise}",
        ctx
      });
      return block;
    }
    function create_default_slot_5$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: "(85:4) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_4$1(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_5$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: '(84:3) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_catch_block(ctx) {
      let div;
      let t0_value = ctx[9] + "";
      let t0;
      let t1;
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot_2$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          t0 = text(t0_value);
          t1 = space();
          create_component(button.$$.fragment);
          attr_dev(div, "class", "text-red-500");
          add_location(div, file$52, 75, 4, 1945);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          insert_dev(target, t1, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t0_value !== (t0_value = ctx2[9] + ""))
            set_data_dev(t0, t0_value);
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t1);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_catch_block.name,
        type: "catch",
        source: "(75:3) {:catch err}",
        ctx
      });
      return block;
    }
    function create_default_slot_3$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(80:5) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_2$1(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_3$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: '(79:4) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_then_block(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login sucessfull");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_then_block.name,
        type: "then",
        source: "(73:3) {:then data}",
        ctx
      });
      return block;
    }
    function create_pending_block(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot$14]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_pending_block.name,
        type: "pending",
        source: '(65:24)      <Button variant=\\"raised\\" class=\\"w-full\\">      <Label       ><span class=\\"material-icons animate-spin\\">        sync       </span></Label      >     </Button>    {:then data}',
        ctx
      });
      return block;
    }
    function create_default_slot_1$1(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "sync";
          attr_dev(span, "class", "material-icons animate-spin");
          add_location(span, file$52, 67, 7, 1790);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(67:5) <Label       >",
        ctx
      });
      return block;
    }
    function create_default_slot$14(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_1$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$14.name,
        type: "slot",
        source: '(66:4) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_fragment$64(ctx) {
      let div;
      let form;
      let textfield0;
      let updating_value;
      let t0;
      let textfield1;
      let updating_value_1;
      let t1;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      function textfield0_value_binding(value) {
        ctx[3](value);
      }
      let textfield0_props = {variant: "filled", label: "Benutzername"};
      if (ctx[0].username !== void 0) {
        textfield0_props.value = ctx[0].username;
      }
      textfield0 = new Textfield({props: textfield0_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield0, "value", textfield0_value_binding));
      function textfield1_value_binding(value) {
        ctx[4](value);
      }
      let textfield1_props = {
        variant: "filled",
        type: "password",
        label: "Passwort"
      };
      if (ctx[0].password !== void 0) {
        textfield1_props.value = ctx[0].password;
      }
      textfield1 = new Textfield({props: textfield1_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield1, "value", textfield1_value_binding));
      const if_block_creators = [create_if_block$2, create_else_block$2];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[1])
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          div = element("div");
          form = element("form");
          create_component(textfield0.$$.fragment);
          t0 = space();
          create_component(textfield1.$$.fragment);
          t1 = space();
          if_block.c();
          attr_dev(form, "action", "");
          attr_dev(form, "class", "flex flex-col justify-center items-center gap-2");
          add_location(form, file$52, 46, 1, 1350);
          attr_dev(div, "class", "flex flex-col w-full justify-center items-center py-16");
          add_location(div, file$52, 45, 0, 1280);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, form);
          mount_component(textfield0, form, null);
          append_dev(form, t0);
          mount_component(textfield1, form, null);
          append_dev(form, t1);
          if_blocks[current_block_type_index].m(form, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(ctx[2]), false, true, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          const textfield0_changes = {};
          if (!updating_value && dirty & 1) {
            updating_value = true;
            textfield0_changes.value = ctx2[0].username;
            add_flush_callback(() => updating_value = false);
          }
          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};
          if (!updating_value_1 && dirty & 1) {
            updating_value_1 = true;
            textfield1_changes.value = ctx2[0].password;
            add_flush_callback(() => updating_value_1 = false);
          }
          textfield1.$set(textfield1_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(form, null);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(textfield0);
          destroy_component(textfield1);
          if_blocks[current_block_type_index].d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$64.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$53($$self, $$props, $$invalidate) {
      let $redirect;
      let $modal;
      let $user;
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(5, $redirect = $$value));
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(6, $modal = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(7, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Login", slots, []);
      let userSettings2 = {
        grant_type: "password",
        username: "",
        password: ""
      };
      let loginPromise;
      async function login() {
        if (!userSettings2.username || !userSettings2.password)
          return;
        $$invalidate(1, loginPromise = new Promise(async (res, rej) => {
          let bodyFormData = new FormData();
          bodyFormData.append("username", userSettings2.username);
          bodyFormData.append("password", userSettings2.password);
          try {
            let {data} = await axios.post(`${backendURL}/api/token`, bodyFormData, {
              headers: {
                "Content-Type": "multipart/form-data",
                Authorization: "Basic Og=="
              }
            });
            if (data && user) {
              set_store_value(user, $user = data, $user);
              localStorage.setItem("auth", JSON.stringify(data));
              set_store_value(modal, $modal = {}, $modal);
              bodyFormData = void 0;
              $redirect("/");
            }
            res(data);
          } catch (err) {
            rej(err.response?.data.detail);
          }
        }));
      }
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Login> was created with unknown prop '${key}'`);
      });
      function textfield0_value_binding(value) {
        if ($$self.$$.not_equal(userSettings2.username, value)) {
          userSettings2.username = value;
          $$invalidate(0, userSettings2);
        }
      }
      function textfield1_value_binding(value) {
        if ($$self.$$.not_equal(userSettings2.password, value)) {
          userSettings2.password = value;
          $$invalidate(0, userSettings2);
        }
      }
      $$self.$capture_state = () => ({
        Textfield,
        Button: Button_1,
        Label,
        axios,
        modal,
        user,
        backendURL,
        goto,
        redirect,
        userSettings: userSettings2,
        loginPromise,
        login,
        $redirect,
        $modal,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("userSettings" in $$props2)
          $$invalidate(0, userSettings2 = $$props2.userSettings);
        if ("loginPromise" in $$props2)
          $$invalidate(1, loginPromise = $$props2.loginPromise);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        userSettings2,
        loginPromise,
        login,
        textfield0_value_binding,
        textfield1_value_binding
      ];
    }
    var Login = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$53, create_fragment$64, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Login",
          options,
          id: create_fragment$64.name
        });
      }
    };
    var file$43 = "node_modules/@smui/tooltip/Wrapper.svelte";
    function create_else_block$1(ctx) {
      let current;
      const default_slot_template = ctx[12].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2048)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(14:0) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$13(ctx) {
      let div;
      let div_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[12].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
      let div_levels = [
        {
          class: div_class_value = classMap({
            [ctx[1]]: true,
            "mdc-tooltip-wrapper--rich": true
          })
        },
        ctx[7]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div, div_data);
          add_location(div, file$43, 1, 2, 13);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (default_slot) {
            default_slot.m(div, null);
          }
          ctx[13](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
              action_destroyer(ctx[4].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2048)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
            }
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 2 && div_class_value !== (div_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-tooltip-wrapper--rich": true
            }))) && {class: div_class_value},
            dirty & 128 && ctx2[7]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          ctx[13](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$13.name,
        type: "if",
        source: "(1:0) {#if rich}",
        ctx
      });
      return block;
    }
    function create_fragment$54(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block$13, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[2])
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$54.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$44($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "rich", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $tooltip;
      let $anchor;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Wrapper", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {rich = false} = $$props;
      let element2;
      const anchor = writable(null);
      validate_store(anchor, "anchor");
      component_subscribe($$self, anchor, (value) => $$invalidate(10, $anchor = value));
      const tooltip = writable(null);
      validate_store(tooltip, "tooltip");
      component_subscribe($$self, tooltip, (value) => $$invalidate(9, $tooltip = value));
      setContext("SMUI:tooltip:wrapper:anchor", anchor);
      setContext("SMUI:tooltip:wrapper:tooltip", tooltip);
      setContext("SMUI:tooltip:rich", rich);
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(3, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("rich" in $$new_props)
          $$invalidate(2, rich = $$new_props.rich);
        if ("$$scope" in $$new_props)
          $$invalidate(11, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        setContext,
        writable,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        rich,
        element: element2,
        anchor,
        tooltip,
        getElement,
        $tooltip,
        $anchor
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("rich" in $$props)
          $$invalidate(2, rich = $$new_props.rich);
        if ("element" in $$props)
          $$invalidate(3, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1536) {
          if ($tooltip && !$anchor) {
            set_store_value(anchor, $anchor = $tooltip.previousElementSibling, $anchor);
          }
        }
      };
      return [
        use2,
        className,
        rich,
        element2,
        forwardEvents,
        anchor,
        tooltip,
        $$restProps,
        getElement,
        $tooltip,
        $anchor,
        $$scope,
        slots,
        div_binding
      ];
    }
    var Wrapper = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$44, create_fragment$54, safe_not_equal, {use: 0, class: 1, rich: 2, getElement: 8});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Wrapper",
          options,
          id: create_fragment$54.name
        });
      }
      get use() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get rich() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set rich(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[8];
      }
      set getElement(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var CssClasses;
    (function(CssClasses2) {
      CssClasses2["RICH"] = "mdc-tooltip--rich";
      CssClasses2["SHOWN"] = "mdc-tooltip--shown";
      CssClasses2["SHOWING"] = "mdc-tooltip--showing";
      CssClasses2["SHOWING_TRANSITION"] = "mdc-tooltip--showing-transition";
      CssClasses2["HIDE"] = "mdc-tooltip--hide";
      CssClasses2["HIDE_TRANSITION"] = "mdc-tooltip--hide-transition";
      CssClasses2["MULTILINE_TOOLTIP"] = "mdc-tooltip--multiline";
      CssClasses2["SURFACE"] = "mdc-tooltip__surface";
      CssClasses2["TOOLTIP_CARET_TOP"] = "mdc-tooltip__caret-surface-top";
      CssClasses2["TOOLTIP_CARET_BOTTOM"] = "mdc-tooltip__caret-surface-bottom";
    })(CssClasses || (CssClasses = {}));
    var numbers6 = {
      BOUNDED_ANCHOR_GAP: 4,
      UNBOUNDED_ANCHOR_GAP: 8,
      MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,
      HIDE_DELAY_MS: 600,
      SHOW_DELAY_MS: 500,
      MIN_HEIGHT: 24,
      MAX_WIDTH: 200,
      CARET_INDENTATION: 24
    };
    var attributes2 = {
      ARIA_EXPANDED: "aria-expanded",
      ARIA_HASPOPUP: "aria-haspopup",
      PERSISTENT: "data-mdc-tooltip-persistent",
      SCROLLABLE_ANCESTOR: "tooltip-scrollable-ancestor",
      HAS_CARET: "data-mdc-tooltip-has-caret"
    };
    var XPosition;
    (function(XPosition2) {
      XPosition2[XPosition2["DETECTED"] = 0] = "DETECTED";
      XPosition2[XPosition2["START"] = 1] = "START";
      XPosition2[XPosition2["CENTER"] = 2] = "CENTER";
      XPosition2[XPosition2["END"] = 3] = "END";
    })(XPosition || (XPosition = {}));
    var YPosition;
    (function(YPosition2) {
      YPosition2[YPosition2["DETECTED"] = 0] = "DETECTED";
      YPosition2[YPosition2["ABOVE"] = 1] = "ABOVE";
      YPosition2[YPosition2["BELOW"] = 2] = "BELOW";
    })(YPosition || (YPosition = {}));
    var AnchorBoundaryType;
    (function(AnchorBoundaryType2) {
      AnchorBoundaryType2[AnchorBoundaryType2["BOUNDED"] = 0] = "BOUNDED";
      AnchorBoundaryType2[AnchorBoundaryType2["UNBOUNDED"] = 1] = "UNBOUNDED";
    })(AnchorBoundaryType || (AnchorBoundaryType = {}));
    var strings7 = {
      LEFT: "left",
      RIGHT: "right",
      CENTER: "center",
      TOP: "top",
      BOTTOM: "bottom"
    };
    var PositionWithCaret;
    (function(PositionWithCaret2) {
      PositionWithCaret2[PositionWithCaret2["DETECTED"] = 0] = "DETECTED";
      PositionWithCaret2[PositionWithCaret2["ABOVE_START"] = 1] = "ABOVE_START";
      PositionWithCaret2[PositionWithCaret2["ABOVE_CENTER"] = 2] = "ABOVE_CENTER";
      PositionWithCaret2[PositionWithCaret2["ABOVE_END"] = 3] = "ABOVE_END";
      PositionWithCaret2[PositionWithCaret2["TOP_SIDE_START"] = 4] = "TOP_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_START"] = 5] = "CENTER_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_START"] = 6] = "BOTTOM_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["TOP_SIDE_END"] = 7] = "TOP_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_END"] = 8] = "CENTER_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_END"] = 9] = "BOTTOM_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["BELOW_START"] = 10] = "BELOW_START";
      PositionWithCaret2[PositionWithCaret2["BELOW_CENTER"] = 11] = "BELOW_CENTER";
      PositionWithCaret2[PositionWithCaret2["BELOW_END"] = 12] = "BELOW_END";
    })(PositionWithCaret || (PositionWithCaret = {}));
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var AnimationFrame2 = function() {
      function AnimationFrame3() {
        this.rafIDs = new Map();
      }
      AnimationFrame3.prototype.request = function(key, callback) {
        var _this = this;
        this.cancel(key);
        var frameID = requestAnimationFrame(function(frame) {
          _this.rafIDs.delete(key);
          callback(frame);
        });
        this.rafIDs.set(key, frameID);
      };
      AnimationFrame3.prototype.cancel = function(key) {
        var rafID = this.rafIDs.get(key);
        if (rafID) {
          cancelAnimationFrame(rafID);
          this.rafIDs.delete(key);
        }
      };
      AnimationFrame3.prototype.cancelAll = function() {
        var _this = this;
        this.rafIDs.forEach(function(_2, key) {
          _this.cancel(key);
        });
      };
      AnimationFrame3.prototype.getQueue = function() {
        var queue2 = [];
        this.rafIDs.forEach(function(_2, key) {
          queue2.push(key);
        });
        return queue2;
      };
      return AnimationFrame3;
    }();
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var RICH = CssClasses.RICH;
    var SHOWN = CssClasses.SHOWN;
    var SHOWING = CssClasses.SHOWING;
    var SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION;
    var HIDE = CssClasses.HIDE;
    var HIDE_TRANSITION = CssClasses.HIDE_TRANSITION;
    var MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;
    var AnimationKeys2;
    (function(AnimationKeys3) {
      AnimationKeys3["POLL_ANCHOR"] = "poll_anchor";
    })(AnimationKeys2 || (AnimationKeys2 = {}));
    var HAS_WINDOW2 = typeof window !== "undefined";
    var MDCTooltipFoundation = function(_super) {
      __extends(MDCTooltipFoundation2, _super);
      function MDCTooltipFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation2.defaultAdapter), adapter)) || this;
        _this.tooltipShown = false;
        _this.anchorGap = numbers6.BOUNDED_ANCHOR_GAP;
        _this.xTooltipPos = XPosition.DETECTED;
        _this.yTooltipPos = YPosition.DETECTED;
        _this.tooltipPositionWithCaret = PositionWithCaret.DETECTED;
        _this.minViewportTooltipThreshold = numbers6.MIN_VIEWPORT_TOOLTIP_THRESHOLD;
        _this.hideDelayMs = numbers6.HIDE_DELAY_MS;
        _this.showDelayMs = numbers6.SHOW_DELAY_MS;
        _this.anchorRect = null;
        _this.parentRect = null;
        _this.frameId = null;
        _this.hideTimeout = null;
        _this.showTimeout = null;
        _this.addAncestorScrollEventListeners = new Array();
        _this.removeAncestorScrollEventListeners = new Array();
        _this.animFrame = new AnimationFrame2();
        _this.anchorBlurHandler = function(evt) {
          _this.handleAnchorBlur(evt);
        };
        _this.documentClickHandler = function(evt) {
          _this.handleDocumentClick(evt);
        };
        _this.documentKeydownHandler = function(evt) {
          _this.handleKeydown(evt);
        };
        _this.richTooltipMouseEnterHandler = function() {
          _this.handleRichTooltipMouseEnter();
        };
        _this.richTooltipMouseLeaveHandler = function() {
          _this.handleRichTooltipMouseLeave();
        };
        _this.richTooltipFocusOutHandler = function(evt) {
          _this.handleRichTooltipFocusOut(evt);
        };
        _this.windowScrollHandler = function() {
          _this.handleWindowChangeEvent();
        };
        _this.windowResizeHandler = function() {
          _this.handleWindowChangeEvent();
        };
        return _this;
      }
      Object.defineProperty(MDCTooltipFoundation2, "defaultAdapter", {
        get: function() {
          return {
            getAttribute: function() {
              return null;
            },
            setAttribute: function() {
              return void 0;
            },
            addClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            removeClass: function() {
              return void 0;
            },
            getComputedStyleProperty: function() {
              return "";
            },
            setStyleProperty: function() {
              return void 0;
            },
            setSurfaceStyleProperty: function() {
              return void 0;
            },
            getViewportWidth: function() {
              return 0;
            },
            getViewportHeight: function() {
              return 0;
            },
            getTooltipSize: function() {
              return {width: 0, height: 0};
            },
            getAnchorBoundingRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            getParentBoundingRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            getAnchorAttribute: function() {
              return null;
            },
            setAnchorAttribute: function() {
              return null;
            },
            isRTL: function() {
              return false;
            },
            anchorContainsElement: function() {
              return false;
            },
            tooltipContainsElement: function() {
              return false;
            },
            focusAnchorElement: function() {
              return void 0;
            },
            registerEventHandler: function() {
              return void 0;
            },
            deregisterEventHandler: function() {
              return void 0;
            },
            registerAnchorEventHandler: function() {
              return void 0;
            },
            deregisterAnchorEventHandler: function() {
              return void 0;
            },
            registerDocumentEventHandler: function() {
              return void 0;
            },
            deregisterDocumentEventHandler: function() {
              return void 0;
            },
            registerWindowEventHandler: function() {
              return void 0;
            },
            deregisterWindowEventHandler: function() {
              return void 0;
            },
            notifyHidden: function() {
              return void 0;
            },
            getTooltipCaretSize: function() {
              return null;
            },
            setTooltipCaretStyle: function() {
              return void 0;
            },
            clearTooltipCaretStyles: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTooltipFoundation2.prototype.init = function() {
        this.richTooltip = this.adapter.hasClass(RICH);
        this.persistentTooltip = this.adapter.getAttribute(attributes2.PERSISTENT) === "true";
        this.interactiveTooltip = !!this.adapter.getAnchorAttribute(attributes2.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(attributes2.ARIA_HASPOPUP) === "dialog";
        this.hasCaret = this.richTooltip && this.adapter.getAttribute(attributes2.HAS_CARET) === "true";
      };
      MDCTooltipFoundation2.prototype.isShown = function() {
        return this.tooltipShown;
      };
      MDCTooltipFoundation2.prototype.isRich = function() {
        return this.richTooltip;
      };
      MDCTooltipFoundation2.prototype.isPersistent = function() {
        return this.persistentTooltip;
      };
      MDCTooltipFoundation2.prototype.handleAnchorMouseEnter = function() {
        var _this = this;
        if (this.tooltipShown) {
          this.show();
        } else {
          this.clearHideTimeout();
          this.showTimeout = setTimeout(function() {
            _this.show();
          }, this.showDelayMs);
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorTouchstart = function() {
        var _this = this;
        this.showTimeout = setTimeout(function() {
          _this.show();
        }, this.showDelayMs);
        this.adapter.registerWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
      };
      MDCTooltipFoundation2.prototype.preventContextMenuOnLongTouch = function(evt) {
        evt.preventDefault();
      };
      MDCTooltipFoundation2.prototype.handleAnchorTouchend = function() {
        this.clearShowTimeout();
        if (!this.isShown()) {
          this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorFocus = function(evt) {
        var _this = this;
        var relatedTarget = evt.relatedTarget;
        var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(relatedTarget);
        if (tooltipContainsRelatedTarget) {
          return;
        }
        this.showTimeout = setTimeout(function() {
          _this.show();
        }, this.showDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleAnchorMouseLeave = function() {
        var _this = this;
        this.clearShowTimeout();
        this.hideTimeout = setTimeout(function() {
          _this.hide();
        }, this.hideDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleAnchorClick = function() {
        if (this.tooltipShown) {
          this.hide();
        } else {
          this.show();
        }
      };
      MDCTooltipFoundation2.prototype.handleDocumentClick = function(evt) {
        var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.target) || this.adapter.tooltipContainsElement(evt.target));
        if (this.richTooltip && this.persistentTooltip && anchorOrTooltipContainsTargetElement) {
          return;
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleKeydown = function(evt) {
        var key = normalizeKey(evt);
        if (key === KEY.ESCAPE) {
          var tooltipContainsActiveElement = document.activeElement instanceof HTMLElement && this.adapter.tooltipContainsElement(document.activeElement);
          if (tooltipContainsActiveElement) {
            this.adapter.focusAnchorElement();
          }
          this.hide();
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorBlur = function(evt) {
        if (this.richTooltip) {
          var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(evt.relatedTarget);
          if (tooltipContainsRelatedTargetElement) {
            return;
          }
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipMouseEnter = function() {
        this.show();
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipMouseLeave = function() {
        var _this = this;
        this.clearShowTimeout();
        this.hideTimeout = setTimeout(function() {
          _this.hide();
        }, this.hideDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipFocusOut = function(evt) {
        var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.relatedTarget) || this.adapter.tooltipContainsElement(evt.relatedTarget));
        if (anchorOrTooltipContainsRelatedTargetElement) {
          return;
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleWindowChangeEvent = function() {
        var _this = this;
        this.animFrame.request(AnimationKeys2.POLL_ANCHOR, function() {
          _this.repositionTooltipOnAnchorMove();
        });
      };
      MDCTooltipFoundation2.prototype.show = function() {
        var e_1, _a2;
        var _this = this;
        this.clearHideTimeout();
        this.clearShowTimeout();
        if (this.tooltipShown) {
          return;
        }
        this.tooltipShown = true;
        var showTooltipOptions = this.parseShowTooltipOptions();
        if (!showTooltipOptions.hideFromScreenreader) {
          this.adapter.setAttribute("aria-hidden", "false");
        }
        if (this.richTooltip) {
          if (this.interactiveTooltip) {
            this.adapter.setAnchorAttribute("aria-expanded", "true");
          }
          this.adapter.registerEventHandler("focusout", this.richTooltipFocusOutHandler);
          if (!this.persistentTooltip) {
            this.adapter.registerEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.registerEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.adapter.removeClass(HIDE);
        this.adapter.addClass(SHOWING);
        if (this.isTooltipMultiline() && !this.richTooltip) {
          this.adapter.addClass(MULTILINE_TOOLTIP);
        }
        this.anchorRect = this.adapter.getAnchorBoundingRect();
        this.parentRect = this.adapter.getParentBoundingRect();
        this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
        if (this.hasCaret) {
          this.setCaretPositionStyles(this.tooltipPositionWithCaret);
        }
        this.adapter.registerAnchorEventHandler("blur", this.anchorBlurHandler);
        this.adapter.registerDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.registerDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.registerWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
        try {
          for (var _b2 = __values(this.addAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.frameId = requestAnimationFrame(function() {
          _this.clearAllAnimationClasses();
          _this.adapter.addClass(SHOWN);
          _this.adapter.addClass(SHOWING_TRANSITION);
        });
      };
      MDCTooltipFoundation2.prototype.hide = function() {
        var e_2, _a2;
        this.clearHideTimeout();
        this.clearShowTimeout();
        if (!this.tooltipShown) {
          return;
        }
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
        }
        this.tooltipShown = false;
        this.adapter.setAttribute("aria-hidden", "true");
        this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
        if (this.richTooltip) {
          if (this.interactiveTooltip) {
            this.adapter.setAnchorAttribute("aria-expanded", "false");
          }
          if (!this.persistentTooltip) {
            this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.clearAllAnimationClasses();
        this.adapter.addClass(HIDE);
        this.adapter.addClass(HIDE_TRANSITION);
        this.adapter.removeClass(SHOWN);
        this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
        this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
        this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
        try {
          for (var _b2 = __values(this.removeAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_2_1) {
          e_2 = {error: e_2_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      };
      MDCTooltipFoundation2.prototype.handleTransitionEnd = function() {
        var isHidingTooltip = this.adapter.hasClass(HIDE);
        this.adapter.removeClass(SHOWING);
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(HIDE);
        this.adapter.removeClass(HIDE_TRANSITION);
        if (isHidingTooltip) {
          this.adapter.notifyHidden();
        }
      };
      MDCTooltipFoundation2.prototype.clearAllAnimationClasses = function() {
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(HIDE_TRANSITION);
      };
      MDCTooltipFoundation2.prototype.setTooltipPosition = function(position) {
        var xPos = position.xPos, yPos = position.yPos, withCaretPos = position.withCaretPos;
        if (this.hasCaret && withCaretPos) {
          this.tooltipPositionWithCaret = withCaretPos;
          return;
        }
        if (xPos) {
          this.xTooltipPos = xPos;
        }
        if (yPos) {
          this.yTooltipPos = yPos;
        }
      };
      MDCTooltipFoundation2.prototype.setAnchorBoundaryType = function(type) {
        if (type === AnchorBoundaryType.UNBOUNDED) {
          this.anchorGap = numbers6.UNBOUNDED_ANCHOR_GAP;
        } else {
          this.anchorGap = numbers6.BOUNDED_ANCHOR_GAP;
        }
      };
      MDCTooltipFoundation2.prototype.parseShowTooltipOptions = function() {
        var hideFromScreenreader = Boolean(this.adapter.getAnchorAttribute("data-tooltip-id"));
        return {hideFromScreenreader};
      };
      MDCTooltipFoundation2.prototype.isTooltipMultiline = function() {
        var tooltipSize = this.adapter.getTooltipSize();
        return tooltipSize.height > numbers6.MIN_HEIGHT && tooltipSize.width >= numbers6.MAX_WIDTH;
      };
      MDCTooltipFoundation2.prototype.positionPlainTooltip = function() {
        var _a2 = this.calculateTooltipStyles(this.anchorRect), top = _a2.top, yTransformOrigin = _a2.yTransformOrigin, left = _a2.left, xTransformOrigin = _a2.xTransformOrigin;
        var transformProperty = HAS_WINDOW2 ? getCorrectPropertyName2(window, "transform") : "transform";
        this.adapter.setSurfaceStyleProperty(transformProperty + "-origin", yTransformOrigin + " " + xTransformOrigin);
        this.adapter.setStyleProperty("top", top + "px");
        this.adapter.setStyleProperty("left", left + "px");
      };
      MDCTooltipFoundation2.prototype.positionRichTooltip = function() {
        var _a2, _b2, _c, _d;
        var width = this.adapter.getComputedStyleProperty("width");
        this.adapter.setStyleProperty("width", width);
        var _e = this.calculateTooltipStyles(this.anchorRect), top = _e.top, yTransformOrigin = _e.yTransformOrigin, left = _e.left, xTransformOrigin = _e.xTransformOrigin;
        var transformProperty = HAS_WINDOW2 ? getCorrectPropertyName2(window, "transform") : "transform";
        this.adapter.setSurfaceStyleProperty(transformProperty + "-origin", yTransformOrigin + " " + xTransformOrigin);
        var leftAdjustment = left - ((_b2 = (_a2 = this.parentRect) === null || _a2 === void 0 ? void 0 : _a2.left) !== null && _b2 !== void 0 ? _b2 : 0);
        var topAdjustment = top - ((_d = (_c = this.parentRect) === null || _c === void 0 ? void 0 : _c.top) !== null && _d !== void 0 ? _d : 0);
        this.adapter.setStyleProperty("top", topAdjustment + "px");
        this.adapter.setStyleProperty("left", leftAdjustment + "px");
      };
      MDCTooltipFoundation2.prototype.calculateTooltipStyles = function(anchorRect) {
        if (!anchorRect) {
          return {top: 0, left: 0};
        }
        var tooltipSize = this.adapter.getTooltipSize();
        var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);
        var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);
        return {
          top: top.distance,
          yTransformOrigin: top.yTransformOrigin,
          left: left.distance,
          xTransformOrigin: left.xTransformOrigin
        };
      };
      MDCTooltipFoundation2.prototype.calculateXTooltipDistance = function(anchorRect, tooltipWidth) {
        var isLTR = !this.adapter.isRTL();
        var startPos, endPos, centerPos;
        var startTransformOrigin, endTransformOrigin;
        if (this.richTooltip) {
          startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;
          endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;
          startTransformOrigin = isLTR ? strings7.RIGHT : strings7.LEFT;
          endTransformOrigin = isLTR ? strings7.LEFT : strings7.RIGHT;
        } else {
          startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;
          endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;
          centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;
          startTransformOrigin = isLTR ? strings7.LEFT : strings7.RIGHT;
          endTransformOrigin = isLTR ? strings7.RIGHT : strings7.LEFT;
        }
        var positionOptions = this.richTooltip ? this.determineValidPositionOptions(startPos, endPos) : this.determineValidPositionOptions(centerPos, startPos, endPos);
        if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {
          return {distance: startPos, xTransformOrigin: startTransformOrigin};
        }
        if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {
          return {distance: endPos, xTransformOrigin: endTransformOrigin};
        }
        if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {
          return {distance: centerPos, xTransformOrigin: strings7.CENTER};
        }
        var possiblePositions = this.richTooltip ? [
          {distance: endPos, xTransformOrigin: endTransformOrigin},
          {distance: startPos, xTransformOrigin: startTransformOrigin}
        ] : [
          {distance: centerPos, xTransformOrigin: strings7.CENTER},
          {distance: startPos, xTransformOrigin: startTransformOrigin},
          {distance: endPos, xTransformOrigin: endTransformOrigin}
        ];
        var validPosition = possiblePositions.find(function(_a2) {
          var distance2 = _a2.distance;
          return positionOptions.has(distance2);
        });
        if (validPosition) {
          return validPosition;
        }
        if (anchorRect.left < 0) {
          return {
            distance: this.minViewportTooltipThreshold,
            xTransformOrigin: strings7.LEFT
          };
        } else {
          var viewportWidth = this.adapter.getViewportWidth();
          var distance = viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);
          return {distance, xTransformOrigin: strings7.RIGHT};
        }
      };
      MDCTooltipFoundation2.prototype.determineValidPositionOptions = function() {
        var e_3, _a2;
        var positions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          positions[_i] = arguments[_i];
        }
        var posWithinThreshold = new Set();
        var posWithinViewport = new Set();
        try {
          for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
            var position = positions_1_1.value;
            if (this.positionHonorsViewportThreshold(position)) {
              posWithinThreshold.add(position);
            } else if (this.positionDoesntCollideWithViewport(position)) {
              posWithinViewport.add(position);
            }
          }
        } catch (e_3_1) {
          e_3 = {error: e_3_1};
        } finally {
          try {
            if (positions_1_1 && !positions_1_1.done && (_a2 = positions_1.return))
              _a2.call(positions_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
      };
      MDCTooltipFoundation2.prototype.positionHonorsViewportThreshold = function(leftPos) {
        var viewportWidth = this.adapter.getViewportWidth();
        var tooltipWidth = this.adapter.getTooltipSize().width;
        return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;
      };
      MDCTooltipFoundation2.prototype.positionDoesntCollideWithViewport = function(leftPos) {
        var viewportWidth = this.adapter.getViewportWidth();
        var tooltipWidth = this.adapter.getTooltipSize().width;
        return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;
      };
      MDCTooltipFoundation2.prototype.calculateYTooltipDistance = function(anchorRect, tooltipHeight) {
        var belowYPos = anchorRect.bottom + this.anchorGap;
        var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);
        var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);
        if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {
          return {distance: aboveYPos, yTransformOrigin: strings7.BOTTOM};
        } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {
          return {distance: belowYPos, yTransformOrigin: strings7.TOP};
        }
        if (yPositionOptions.has(belowYPos)) {
          return {distance: belowYPos, yTransformOrigin: strings7.TOP};
        }
        if (yPositionOptions.has(aboveYPos)) {
          return {distance: aboveYPos, yTransformOrigin: strings7.BOTTOM};
        }
        return {distance: belowYPos, yTransformOrigin: strings7.TOP};
      };
      MDCTooltipFoundation2.prototype.determineValidYPositionOptions = function(aboveAnchorPos, belowAnchorPos) {
        var posWithinThreshold = new Set();
        var posWithinViewport = new Set();
        if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {
          posWithinThreshold.add(aboveAnchorPos);
        } else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {
          posWithinViewport.add(aboveAnchorPos);
        }
        if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {
          posWithinThreshold.add(belowAnchorPos);
        } else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {
          posWithinViewport.add(belowAnchorPos);
        }
        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
      };
      MDCTooltipFoundation2.prototype.yPositionHonorsViewportThreshold = function(yPos) {
        var viewportHeight = this.adapter.getViewportHeight();
        var tooltipHeight = this.adapter.getTooltipSize().height;
        return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;
      };
      MDCTooltipFoundation2.prototype.yPositionDoesntCollideWithViewport = function(yPos) {
        var viewportHeight = this.adapter.getViewportHeight();
        var tooltipHeight = this.adapter.getTooltipSize().height;
        return yPos + tooltipHeight <= viewportHeight && yPos >= 0;
      };
      MDCTooltipFoundation2.prototype.repositionTooltipOnAnchorMove = function() {
        var newAnchorRect = this.adapter.getAnchorBoundingRect();
        if (!newAnchorRect || !this.anchorRect)
          return;
        if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {
          this.anchorRect = newAnchorRect;
          this.parentRect = this.adapter.getParentBoundingRect();
          this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
        }
      };
      MDCTooltipFoundation2.prototype.setCaretPositionStyles = function(position) {
        var values = this.calculateCaretPositionOnTooltip(position);
        if (!values) {
          return {yTransformOrigin: 0, xTransformOrigin: 0};
        }
        this.adapter.clearTooltipCaretStyles();
        this.adapter.setTooltipCaretStyle(values.yAlignment, values.yAxisPx);
        this.adapter.setTooltipCaretStyle(values.xAlignment, values.xAxisPx);
        this.adapter.setTooltipCaretStyle("transform", "rotate(" + values.rotation + ")");
        this.adapter.setTooltipCaretStyle("transform-origin", values.yAlignment + " " + values.xAlignment);
        return {yTransformOrigin: values.yAxisPx, xTransformOrigin: values.xAxisPx};
      };
      MDCTooltipFoundation2.prototype.calculateCaretPositionOnTooltip = function(tooltipPos) {
        var isLTR = !this.adapter.isRTL();
        var tooltipWidth = this.adapter.getComputedStyleProperty("width");
        var tooltipHeight = this.adapter.getComputedStyleProperty("height");
        var caretDimensions = this.adapter.getTooltipCaretSize();
        if (!tooltipWidth || !tooltipHeight || !caretDimensions) {
          return;
        }
        var caretDiagonal = caretDimensions.width * Math.sqrt(2);
        var midpointWidth = "calc((" + tooltipWidth + " - " + caretDiagonal + "px) / 2)";
        var midpointHeight = "calc((" + tooltipHeight + " - " + caretDiagonal + "px) / 2)";
        var flushWithEdge = "0";
        var indentedFromEdge = numbers6.CARET_INDENTATION + "px";
        var positiveRot = "45deg";
        var negativeRot = "-45deg";
        switch (tooltipPos) {
          case PositionWithCaret.BELOW_CENTER:
            return {
              yAlignment: strings7.TOP,
              xAlignment: strings7.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: midpointWidth,
              rotation: negativeRot
            };
          case PositionWithCaret.BELOW_END:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.RIGHT : strings7.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.BELOW_START:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.LEFT : strings7.RIGHT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.TOP_SIDE_END:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.LEFT : strings7.RIGHT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.CENTER_SIDE_END:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.LEFT : strings7.RIGHT,
              yAxisPx: midpointHeight,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.BOTTOM_SIDE_END:
            return {
              yAlignment: strings7.BOTTOM,
              xAlignment: isLTR ? strings7.LEFT : strings7.RIGHT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.TOP_SIDE_START:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.RIGHT : strings7.LEFT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.CENTER_SIDE_START:
            return {
              yAlignment: strings7.TOP,
              xAlignment: isLTR ? strings7.RIGHT : strings7.LEFT,
              yAxisPx: midpointHeight,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.BOTTOM_SIDE_START:
            return {
              yAlignment: strings7.BOTTOM,
              xAlignment: isLTR ? strings7.RIGHT : strings7.LEFT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.ABOVE_CENTER:
            return {
              yAlignment: strings7.BOTTOM,
              xAlignment: strings7.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: midpointWidth,
              rotation: positiveRot
            };
          case PositionWithCaret.ABOVE_END:
            return {
              yAlignment: strings7.BOTTOM,
              xAlignment: isLTR ? strings7.RIGHT : strings7.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          default:
          case PositionWithCaret.ABOVE_START:
            return {
              yAlignment: strings7.BOTTOM,
              xAlignment: isLTR ? strings7.LEFT : strings7.RIGHT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
        }
      };
      MDCTooltipFoundation2.prototype.clearShowTimeout = function() {
        if (this.showTimeout) {
          clearTimeout(this.showTimeout);
          this.showTimeout = null;
        }
      };
      MDCTooltipFoundation2.prototype.clearHideTimeout = function() {
        if (this.hideTimeout) {
          clearTimeout(this.hideTimeout);
          this.hideTimeout = null;
        }
      };
      MDCTooltipFoundation2.prototype.attachScrollHandler = function(addEventListenerFn) {
        var _this = this;
        this.addAncestorScrollEventListeners.push(function() {
          addEventListenerFn("scroll", _this.windowScrollHandler);
        });
      };
      MDCTooltipFoundation2.prototype.removeScrollHandler = function(removeEventHandlerFn) {
        var _this = this;
        this.removeAncestorScrollEventListeners.push(function() {
          removeEventHandlerFn("scroll", _this.windowScrollHandler);
        });
      };
      MDCTooltipFoundation2.prototype.destroy = function() {
        var e_4, _a2;
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
          this.frameId = null;
        }
        this.clearHideTimeout();
        this.clearShowTimeout();
        this.adapter.removeClass(SHOWN);
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(SHOWING);
        this.adapter.removeClass(HIDE);
        this.adapter.removeClass(HIDE_TRANSITION);
        if (this.richTooltip) {
          this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
          if (!this.persistentTooltip) {
            this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
        try {
          for (var _b2 = __values(this.removeAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_4_1) {
          e_4 = {error: e_4_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        this.animFrame.cancelAll();
      };
      return MDCTooltipFoundation2;
    }(MDCFoundation);
    var file$33 = "node_modules/@smui/tooltip/Tooltip.svelte";
    function create_fragment$44(ctx) {
      let div1;
      let div0;
      let div0_class_value;
      let div0_style_value;
      let div1_class_value;
      let div1_style_value;
      let div1_role_value;
      let div1_tabindex_value;
      let div1_data_mdc_tooltip_persist_value;
      let div1_data_mdc_tooltip_persistent_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[28].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
      let div0_levels = [
        {
          class: div0_class_value = classMap({
            [ctx[6]]: true,
            "mdc-tooltip__surface": true,
            "mdc-tooltip__surface-animation": true
          })
        },
        {
          style: div0_style_value = Object.entries(ctx[13]).map(func6).concat([ctx[7]]).join(" ")
        },
        prefixFilter2(ctx[18], "surface$")
      ];
      let div0_data = {};
      for (let i = 0; i < div0_levels.length; i += 1) {
        div0_data = assign(div0_data, div0_levels[i]);
      }
      let div1_levels = [
        {
          class: div1_class_value = classMap({
            [ctx[1]]: true,
            "mdc-tooltip": true,
            "mdc-tooltip--rich": ctx[17],
            ...ctx[10]
          })
        },
        {
          style: div1_style_value = Object.entries(ctx[11]).map(func_14).concat([ctx[2]]).join(" ")
        },
        {
          role: div1_role_value = ctx[17] && ctx[5] ? "dialog" : "tooltip"
        },
        {"aria-hidden": "true"},
        {id: ctx[3]},
        {
          tabindex: div1_tabindex_value = ctx[17] && ctx[4] ? "-1" : null
        },
        {
          "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value = ctx[17] && ctx[4] ? "true" : null
        },
        {
          "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value = ctx[17] && ctx[4] ? "true" : null
        },
        ctx[12],
        exclude2(ctx[18], ["surface$"])
      ];
      let div1_data = {};
      for (let i = 0; i < div1_levels.length; i += 1) {
        div1_data = assign(div1_data, div1_levels[i]);
      }
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div0, div0_data);
          add_location(div0, file$33, 27, 2, 783);
          set_attributes(div1, div1_data);
          add_location(div1, file$33, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          if (default_slot) {
            default_slot.m(div0, null);
          }
          ctx[29](div1);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, div1, ctx[0])),
              action_destroyer(ctx[14].call(null, div1)),
              listen_dev(div1, "transitionend", ctx[30], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[0] & 134217728)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[27], !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null), null);
            }
          }
          set_attributes(div0, div0_data = get_spread_update(div0_levels, [
            (!current || dirty[0] & 64 && div0_class_value !== (div0_class_value = classMap({
              [ctx2[6]]: true,
              "mdc-tooltip__surface": true,
              "mdc-tooltip__surface-animation": true
            }))) && {class: div0_class_value},
            (!current || dirty[0] & 8320 && div0_style_value !== (div0_style_value = Object.entries(ctx2[13]).map(func6).concat([ctx2[7]]).join(" "))) && {style: div0_style_value},
            dirty[0] & 262144 && prefixFilter2(ctx2[18], "surface$")
          ]));
          set_attributes(div1, div1_data = get_spread_update(div1_levels, [
            (!current || dirty[0] & 1026 && div1_class_value !== (div1_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-tooltip": true,
              "mdc-tooltip--rich": ctx2[17],
              ...ctx2[10]
            }))) && {class: div1_class_value},
            (!current || dirty[0] & 2052 && div1_style_value !== (div1_style_value = Object.entries(ctx2[11]).map(func_14).concat([ctx2[2]]).join(" "))) && {style: div1_style_value},
            (!current || dirty[0] & 32 && div1_role_value !== (div1_role_value = ctx2[17] && ctx2[5] ? "dialog" : "tooltip")) && {role: div1_role_value},
            {"aria-hidden": "true"},
            (!current || dirty[0] & 8) && {id: ctx2[3]},
            (!current || dirty[0] & 16 && div1_tabindex_value !== (div1_tabindex_value = ctx2[17] && ctx2[4] ? "-1" : null)) && {tabindex: div1_tabindex_value},
            (!current || dirty[0] & 16 && div1_data_mdc_tooltip_persist_value !== (div1_data_mdc_tooltip_persist_value = ctx2[17] && ctx2[4] ? "true" : null)) && {
              "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value
            },
            (!current || dirty[0] & 16 && div1_data_mdc_tooltip_persistent_value !== (div1_data_mdc_tooltip_persistent_value = ctx2[17] && ctx2[4] ? "true" : null)) && {
              "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value
            },
            dirty[0] & 4096 && ctx2[12],
            dirty[0] & 262144 && exclude2(ctx2[18], ["surface$"])
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (default_slot)
            default_slot.d(detaching);
          ctx[29](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$44.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    var func6 = ([name2, value]) => `${name2}: ${value};`;
    var func_14 = ([name2, value]) => `${name2}: ${value};`;
    function instance_16($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "id",
        "unbounded",
        "xPos",
        "yPos",
        "persistent",
        "interactive",
        "surface$class",
        "surface$style",
        "attachScrollHandler",
        "removeScrollHandler",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $anchor;
      let $tooltip;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Tooltip", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {id = "SMUI-tooltip-" + counter3++} = $$props;
      let {unbounded = false} = $$props;
      let {xPos = "detected"} = $$props;
      let {yPos = "detected"} = $$props;
      let {persistent = false} = $$props;
      let {interactive = persistent} = $$props;
      let {surface$class = ""} = $$props;
      let {surface$style = ""} = $$props;
      let element2;
      let instance8;
      let nonReactiveLocationStore = {
        setParent(value) {
          Object.defineProperty(this, "parent", {value});
        },
        setNextSibling(value) {
          Object.defineProperty(this, "nextSibling", {value});
        }
      };
      let internalClasses = {};
      let internalStyles = {};
      let internalAttrs = {};
      let surfaceStyles = {};
      let anchor = getContext("SMUI:tooltip:wrapper:anchor");
      validate_store(anchor, "anchor");
      component_subscribe($$self, anchor, (value) => $$invalidate(26, $anchor = value));
      let tooltip = getContext("SMUI:tooltip:wrapper:tooltip");
      validate_store(tooltip, "tooltip");
      component_subscribe($$self, tooltip, (value) => $$invalidate(31, $tooltip = value));
      const rich = getContext("SMUI:tooltip:rich");
      let previousAnchor = null;
      onMount(() => {
        $$invalidate(8, instance8 = new MDCTooltipFoundation({
          getAttribute: getAttr,
          setAttribute: addAttr,
          addClass,
          hasClass,
          removeClass,
          getComputedStyleProperty: (propertyName) => {
            const element3 = getElement();
            let style2 = getComputedStyle(element3).getPropertyValue(propertyName);
            if (style2 === "auto") {
              element3.classList.add("smui-banner--force-show");
              style2 = getComputedStyle(element3).getPropertyValue(propertyName);
              element3.classList.remove("smui-banner--force-show");
            }
            return style2;
          },
          setStyleProperty: addStyle,
          setSurfaceStyleProperty: addSurfaceStyle,
          getViewportWidth: () => window.innerWidth,
          getViewportHeight: () => window.innerHeight,
          getTooltipSize: () => {
            const element3 = getElement();
            let size = {
              width: element3.offsetWidth,
              height: element3.offsetHeight
            };
            if (size.width === 0 || size.height === 0) {
              element3.classList.add("smui-banner--force-show");
              size = {
                width: element3.offsetWidth,
                height: element3.offsetHeight
              };
              element3.classList.remove("smui-banner--force-show");
            }
            return size;
          },
          getAnchorBoundingRect: () => {
            return $anchor ? $anchor.getBoundingClientRect() : null;
          },
          getParentBoundingRect: () => {
            let parent2 = getElement().parentNode;
            if (!rich) {
              parent2 = document.body;
            }
            return parent2.getBoundingClientRect() || null;
          },
          getAnchorAttribute: (attr2) => {
            return $anchor ? $anchor.getAttribute(attr2) : null;
          },
          setAnchorAttribute: (attr2, value) => {
            $anchor && $anchor.setAttribute(attr2, value);
          },
          isRTL: () => getComputedStyle(getElement()).direction === "rtl",
          anchorContainsElement: (element3) => {
            return !!($anchor && $anchor.contains(element3));
          },
          tooltipContainsElement: (element3) => {
            return getElement().contains(element3);
          },
          focusAnchorElement: () => {
            $anchor && $anchor.focus();
          },
          registerEventHandler: (evt, handler) => {
            getElement().addEventListener(evt, handler);
          },
          deregisterEventHandler: (evt, handler) => {
            getElement().removeEventListener(evt, handler);
          },
          registerAnchorEventHandler: (evt, handler) => {
            $anchor && $anchor.addEventListener(evt, handler);
          },
          deregisterAnchorEventHandler: (evt, handler) => {
            $anchor && $anchor.removeEventListener(evt, handler);
          },
          registerDocumentEventHandler: (evt, handler) => {
            document.body.addEventListener(evt, handler);
          },
          deregisterDocumentEventHandler: (evt, handler) => {
            document.body.removeEventListener(evt, handler);
          },
          registerWindowEventHandler: (evt, handler) => {
            window.addEventListener(evt, handler, evt === "scroll" && {capture: true, passive: true});
          },
          deregisterWindowEventHandler: (evt, handler) => {
            window.removeEventListener(evt, handler, evt === "scroll" && {capture: true, passive: true});
          },
          notifyHidden: () => {
            dispatch(getElement(), "MDCTooltip:hidden");
          }
        }));
        set_store_value(tooltip, $tooltip = element2, $tooltip);
        return () => {
          if ($anchor) {
            destroy($anchor);
          }
        };
      });
      onDestroy(() => {
        if (!rich && typeof document !== "undefined" && document.body === getElement().parentNode && nonReactiveLocationStore.parent.insertBefore) {
          nonReactiveLocationStore.parent.insertBefore(getElement(), nonReactiveLocationStore.nextSibling);
        }
      });
      function destroy(anchor2) {
        anchor2.removeEventListener("focusout", handleAnchorFocusOut);
        if (rich && persistent) {
          anchor2.removeEventListener("click", handleAnchorActivate);
          anchor2.removeEventListener("keydown", handleAnchorActivate);
        } else {
          anchor2.removeEventListener("mouseenter", handleAnchorMouseEnter);
          anchor2.removeEventListener("focusin", handleAnchorFocus);
          anchor2.removeEventListener("mouseleave", handleAnchorMouseLeave);
          anchor2.removeEventListener("touchstart", handleAnchorTouchStart);
          anchor2.removeEventListener("touchend", handleAnchorTouchEnd);
        }
        if (rich && interactive) {
          anchor2.removeAttribute("aria-haspopup");
          anchor2.removeAttribute("aria-expanded");
          anchor2.removeAttribute("data-tooltip-id");
        } else {
          anchor2.removeAttribute("aria-describedby");
        }
        instance8.destroy();
      }
      function init2(anchor2) {
        anchor2.addEventListener("focusout", handleAnchorFocusOut);
        if (rich && persistent) {
          anchor2.addEventListener("click", handleAnchorActivate);
          anchor2.addEventListener("keydown", handleAnchorActivate);
        } else {
          anchor2.addEventListener("mouseenter", handleAnchorMouseEnter);
          anchor2.addEventListener("focusin", handleAnchorFocus);
          anchor2.addEventListener("mouseleave", handleAnchorMouseLeave);
          anchor2.addEventListener("touchstart", handleAnchorTouchStart);
          anchor2.addEventListener("touchend", handleAnchorTouchEnd);
        }
        if (rich && interactive) {
          anchor2.setAttribute("aria-haspopup", "dialog");
          anchor2.setAttribute("aria-expanded", "false");
          anchor2.setAttribute("data-tooltip-id", id);
        } else {
          anchor2.setAttribute("aria-describedby", id);
        }
        if (!rich) {
          hoistToBody();
        }
        instance8.init();
      }
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(10, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(10, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name2, value) {
        if (internalStyles[name2] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name2];
            $$invalidate(11, internalStyles);
          } else {
            $$invalidate(11, internalStyles[name2] = value, internalStyles);
          }
        }
      }
      function addSurfaceStyle(name2, value) {
        if (surfaceStyles[name2] != value) {
          if (value === "" || value == null) {
            delete surfaceStyles[name2];
            $$invalidate(13, surfaceStyles);
          } else {
            $$invalidate(13, surfaceStyles[name2] = value, surfaceStyles);
          }
        }
      }
      function getAttr(name2) {
        return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
      }
      function addAttr(name2, value) {
        if (internalAttrs[name2] !== value) {
          $$invalidate(12, internalAttrs[name2] = value, internalAttrs);
        }
      }
      function handleAnchorFocusOut(event) {
        if (element2.contains(event.relatedTarget)) {
          return;
        }
        instance8 && instance8.hide();
      }
      function handleAnchorActivate(event) {
        if (event.type === "keydown" && event.key !== "Enter" && event.key !== " ") {
          return;
        }
        instance8 && instance8.handleAnchorClick();
      }
      function handleAnchorMouseEnter() {
        instance8 && instance8.handleAnchorMouseEnter();
      }
      function handleAnchorFocus(event) {
        instance8 && instance8.handleAnchorFocus(event);
      }
      function handleAnchorMouseLeave() {
        instance8 && instance8.handleAnchorMouseLeave();
      }
      function handleAnchorTouchStart() {
        instance8 && instance8.handleAnchorTouchstart();
      }
      function handleAnchorTouchEnd() {
        instance8 && instance8.handleAnchorTouchend();
      }
      function hoistToBody() {
        if ($anchor && document.body !== getElement().parentNode) {
          nonReactiveLocationStore.setParent(getElement().parentNode);
          nonReactiveLocationStore.setNextSibling(getElement().nextSibling);
          document.body.appendChild(getElement());
        }
      }
      function attachScrollHandler(addEventListenerFn) {
        instance8 && instance8.attachScrollHandler(addEventListenerFn);
      }
      function removeScrollHandler(removeEventHandlerFn) {
        instance8 && instance8.removeScrollHandler(removeEventHandlerFn);
      }
      function getElement() {
        return element2;
      }
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(9, element2);
        });
      }
      const transitionend_handler = () => instance8 && instance8.handleTransitionEnd();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(2, style = $$new_props.style);
        if ("id" in $$new_props)
          $$invalidate(3, id = $$new_props.id);
        if ("unbounded" in $$new_props)
          $$invalidate(19, unbounded = $$new_props.unbounded);
        if ("xPos" in $$new_props)
          $$invalidate(20, xPos = $$new_props.xPos);
        if ("yPos" in $$new_props)
          $$invalidate(21, yPos = $$new_props.yPos);
        if ("persistent" in $$new_props)
          $$invalidate(4, persistent = $$new_props.persistent);
        if ("interactive" in $$new_props)
          $$invalidate(5, interactive = $$new_props.interactive);
        if ("surface$class" in $$new_props)
          $$invalidate(6, surface$class = $$new_props.surface$class);
        if ("surface$style" in $$new_props)
          $$invalidate(7, surface$style = $$new_props.surface$style);
        if ("$$scope" in $$new_props)
          $$invalidate(27, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCTooltipFoundation,
        AnchorBoundaryType,
        XPosition,
        YPosition,
        onMount,
        onDestroy,
        getContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        exclude: exclude2,
        prefixFilter: prefixFilter2,
        useActions,
        dispatch,
        forwardEvents,
        use: use2,
        className,
        style,
        id,
        unbounded,
        xPos,
        yPos,
        persistent,
        interactive,
        surface$class,
        surface$style,
        element: element2,
        instance: instance8,
        nonReactiveLocationStore,
        internalClasses,
        internalStyles,
        internalAttrs,
        surfaceStyles,
        anchor,
        tooltip,
        rich,
        previousAnchor,
        destroy,
        init: init2,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        addSurfaceStyle,
        getAttr,
        addAttr,
        handleAnchorFocusOut,
        handleAnchorActivate,
        handleAnchorMouseEnter,
        handleAnchorFocus,
        handleAnchorMouseLeave,
        handleAnchorTouchStart,
        handleAnchorTouchEnd,
        hoistToBody,
        attachScrollHandler,
        removeScrollHandler,
        getElement,
        $anchor,
        $tooltip
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(2, style = $$new_props.style);
        if ("id" in $$props)
          $$invalidate(3, id = $$new_props.id);
        if ("unbounded" in $$props)
          $$invalidate(19, unbounded = $$new_props.unbounded);
        if ("xPos" in $$props)
          $$invalidate(20, xPos = $$new_props.xPos);
        if ("yPos" in $$props)
          $$invalidate(21, yPos = $$new_props.yPos);
        if ("persistent" in $$props)
          $$invalidate(4, persistent = $$new_props.persistent);
        if ("interactive" in $$props)
          $$invalidate(5, interactive = $$new_props.interactive);
        if ("surface$class" in $$props)
          $$invalidate(6, surface$class = $$new_props.surface$class);
        if ("surface$style" in $$props)
          $$invalidate(7, surface$style = $$new_props.surface$style);
        if ("element" in $$props)
          $$invalidate(9, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(8, instance8 = $$new_props.instance);
        if ("nonReactiveLocationStore" in $$props)
          nonReactiveLocationStore = $$new_props.nonReactiveLocationStore;
        if ("internalClasses" in $$props)
          $$invalidate(10, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(11, internalStyles = $$new_props.internalStyles);
        if ("internalAttrs" in $$props)
          $$invalidate(12, internalAttrs = $$new_props.internalAttrs);
        if ("surfaceStyles" in $$props)
          $$invalidate(13, surfaceStyles = $$new_props.surfaceStyles);
        if ("anchor" in $$props)
          $$invalidate(15, anchor = $$new_props.anchor);
        if ("tooltip" in $$props)
          $$invalidate(16, tooltip = $$new_props.tooltip);
        if ("previousAnchor" in $$props)
          $$invalidate(25, previousAnchor = $$new_props.previousAnchor);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 100663552) {
          if (instance8 && previousAnchor !== $anchor) {
            if (previousAnchor) {
              destroy(previousAnchor);
            }
            if ($anchor) {
              init2($anchor);
            }
            $$invalidate(25, previousAnchor = $anchor);
          }
        }
        if ($$self.$$.dirty[0] & 524544) {
          if (instance8) {
            instance8.setAnchorBoundaryType(AnchorBoundaryType[unbounded ? "UNBOUNDED" : "BOUNDED"]);
          }
        }
        if ($$self.$$.dirty[0] & 3145984) {
          if (instance8) {
            instance8.setTooltipPosition({
              xPos: XPosition[xPos.toUpperCase()],
              yPos: YPosition[yPos.toUpperCase()]
            });
          }
        }
      };
      return [
        use2,
        className,
        style,
        id,
        persistent,
        interactive,
        surface$class,
        surface$style,
        instance8,
        element2,
        internalClasses,
        internalStyles,
        internalAttrs,
        surfaceStyles,
        forwardEvents,
        anchor,
        tooltip,
        rich,
        $$restProps,
        unbounded,
        xPos,
        yPos,
        attachScrollHandler,
        removeScrollHandler,
        getElement,
        previousAnchor,
        $anchor,
        $$scope,
        slots,
        div1_binding,
        transitionend_handler
      ];
    }
    var Tooltip = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_16, create_fragment$44, safe_not_equal, {
          use: 0,
          class: 1,
          style: 2,
          id: 3,
          unbounded: 19,
          xPos: 20,
          yPos: 21,
          persistent: 4,
          interactive: 5,
          surface$class: 6,
          surface$style: 7,
          attachScrollHandler: 22,
          removeScrollHandler: 23,
          getElement: 24
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Tooltip",
          options,
          id: create_fragment$44.name
        });
      }
      get use() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get unbounded() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set unbounded(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get xPos() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set xPos(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get yPos() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set yPos(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get interactive() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set interactive(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get surface$class() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set surface$class(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get surface$style() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set surface$style(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get attachScrollHandler() {
        return this.$$.ctx[22];
      }
      set attachScrollHandler(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get removeScrollHandler() {
        return this.$$.ctx[23];
      }
      set removeScrollHandler(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[24];
      }
      set getElement(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$1} = globals;
    var file$26 = "src/components/nav/main.svelte";
    function create_default_slot_15(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          component: Img,
          src: "/logo_pretzel.png",
          style: "width:180px;"
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_15.name,
        type: "slot",
        source: '(50:5) <Title class=\\"cursor-pointer p-2\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_14(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Planung");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_14.name,
        type: "slot",
        source: "(57:5) <Tooltip>",
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let title;
      let t;
      let tooltip;
      let current;
      title = new Title2({
        props: {
          class: "cursor-pointer p-2",
          $$slots: {default: [create_default_slot_15]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_14]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 524288) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const tooltip_changes = {};
          if (dirty & 524288) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(49:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_122(ctx) {
      let wrapper;
      let current;
      wrapper = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(wrapper.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(wrapper, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const wrapper_changes = {};
          if (dirty & 524288) {
            wrapper_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper.$set(wrapper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(wrapper.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(wrapper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(wrapper, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: '(48:3) <Section on:click={() => $goto(\\"/\\")}>',
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let div;
      let t_value = (ctx[3]?.username || "DEMO") + "";
      let t;
      const block = {
        c: function create2() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "sm:flex hidden");
          add_location(div, file$26, 61, 5, 1729);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 8 && t_value !== (t_value = (ctx2[3]?.username || "DEMO") + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: "(61:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_else_block_2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2.name,
        type: "else",
        source: "(68:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_33(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_33.name,
        type: "if",
        source: "(68:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let show_if;
      let if_block_anchor;
      function select_block_type(ctx2, dirty) {
        if (show_if == null || dirty & 16)
          show_if = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if)
          return create_if_block_33;
        return create_else_block_2;
      }
      let current_block_type = select_block_type(ctx, -1);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: '(67:5) <IconButton class=\\"material-icons\\" on:click={auth}       >',
        ctx
      });
      return block;
    }
    function create_else_block_13(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_13.name,
        type: "else",
        source: "(71:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_24(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_24.name,
        type: "if",
        source: "(71:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let show_if;
      let if_block_anchor;
      function select_block_type_1(ctx2, dirty) {
        if (show_if == null || dirty & 16)
          show_if = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if)
          return create_if_block_24;
        return create_else_block_13;
      }
      let current_block_type = select_block_type_1(ctx, -1);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: "(70:5) <Tooltip       >",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let iconbutton;
      let t;
      let tooltip;
      let current;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[6]);
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(iconbutton.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconbutton, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const iconbutton_changes = {};
          if (dirty & 524304) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          const tooltip_changes = {};
          if (dirty & 524304) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconbutton.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconbutton.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconbutton, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(66:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("feedback");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(75:5) <IconButton class=\\"material-icons\\" on:click={reportProblem}>',
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Idee oder Problem");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: "(78:5) <Tooltip>",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let iconbutton;
      let t;
      let tooltip;
      let current;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[7]);
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(iconbutton.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconbutton, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const iconbutton_changes = {};
          if (dirty & 524288) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          const tooltip_changes = {};
          if (dirty & 524288) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconbutton.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconbutton.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconbutton, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: "(74:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("menu");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: '(82:5) <IconButton       class=\\"material-icons\\"       on:click={() => (menuToggle = !menuToggle)}       bind:id={burger}       >',
        ctx
      });
      return block;
    }
    function create_else_block4(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block4.name,
        type: "else",
        source: "(90:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_14(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_14.name,
        type: "if",
        source: "(90:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_if_block7(ctx) {
      let li0;
      let t1;
      let li1;
      let t3;
      let li2;
      let mounted;
      let dispose;
      const block = {
        c: function create2() {
          li0 = element("li");
          li0.textContent = "Hilfe";
          t1 = space();
          li1 = element("li");
          li1.textContent = "Planung";
          t3 = space();
          li2 = element("li");
          li2.textContent = "Einstellungen";
          attr_dev(li0, "class", "cursor-pointer p-2");
          add_location(li0, file$26, 92, 5, 2710);
          attr_dev(li1, "class", "cursor-pointer p-2");
          add_location(li1, file$26, 98, 5, 2818);
          attr_dev(li2, "class", "cursor-pointer p-2");
          add_location(li2, file$26, 106, 5, 2944);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, li1, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, li2, anchor);
          if (!mounted) {
            dispose = [
              listen_dev(li0, "click", ctx[12], false, false, false),
              listen_dev(li1, "click", ctx[13], false, false, false),
              listen_dev(li2, "click", ctx[14], false, false, false)
            ];
            mounted = true;
          }
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(li0);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(li1);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(li2);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block7.name,
        type: "if",
        source: "(92:5) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let li;
      let show_if_1;
      let t;
      let show_if = ctx[4] && Object.keys(ctx[4]).length;
      let if_block1_anchor;
      let mounted;
      let dispose;
      function select_block_type_2(ctx2, dirty) {
        if (show_if_1 == null || dirty & 16)
          show_if_1 = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if_1)
          return create_if_block_14;
        return create_else_block4;
      }
      let current_block_type = select_block_type_2(ctx, -1);
      let if_block0 = current_block_type(ctx);
      let if_block1 = show_if && create_if_block7(ctx);
      const block = {
        c: function create2() {
          li = element("li");
          if_block0.c();
          t = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          attr_dev(li, "class", "cursor-pointer p-2");
          add_location(li, file$26, 88, 6, 2528);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          if_block0.m(li, null);
          insert_dev(target, t, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          if (!mounted) {
            dispose = listen_dev(li, "click", ctx[6], false, false, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type_2(ctx2, dirty))) {
            if_block0.d(1);
            if_block0 = current_block_type(ctx2);
            if (if_block0) {
              if_block0.c();
              if_block0.m(li, null);
            }
          }
          if (dirty & 16)
            show_if = ctx2[4] && Object.keys(ctx2[4]).length;
          if (show_if) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block7(ctx2);
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(li);
          if_block0.d();
          if (detaching)
            detach_dev(t);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(88:5) <Menu bind:menuToggle>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let wrapper0;
      let t0;
      let wrapper1;
      let t1;
      let wrapper2;
      let t2;
      let div;
      let iconbutton;
      let updating_id;
      let t3;
      let menu_1;
      let updating_menuToggle;
      let current;
      wrapper0 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      wrapper1 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      wrapper2 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      function iconbutton_id_binding(value) {
        ctx[10](value);
      }
      let iconbutton_props = {
        class: "material-icons",
        $$slots: {default: [create_default_slot_42]},
        $$scope: {ctx}
      };
      if (ctx[0] !== void 0) {
        iconbutton_props.id = ctx[0];
      }
      iconbutton = new IconButton({props: iconbutton_props, $$inline: true});
      binding_callbacks.push(() => bind3(iconbutton, "id", iconbutton_id_binding));
      iconbutton.$on("click", ctx[11]);
      function menu_1_menuToggle_binding(value) {
        ctx[15](value);
      }
      let menu_1_props = {
        $$slots: {default: [create_default_slot_32]},
        $$scope: {ctx}
      };
      if (ctx[2] !== void 0) {
        menu_1_props.menuToggle = ctx[2];
      }
      menu_1 = new Menu2({props: menu_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(menu_1, "menuToggle", menu_1_menuToggle_binding));
      const block = {
        c: function create2() {
          create_component(wrapper0.$$.fragment);
          t0 = space();
          create_component(wrapper1.$$.fragment);
          t1 = space();
          create_component(wrapper2.$$.fragment);
          t2 = space();
          div = element("div");
          create_component(iconbutton.$$.fragment);
          t3 = space();
          create_component(menu_1.$$.fragment);
          attr_dev(div, "class", "relative");
          add_location(div, file$26, 80, 4, 2321);
        },
        m: function mount(target, anchor) {
          mount_component(wrapper0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(wrapper1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(wrapper2, target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, div, anchor);
          mount_component(iconbutton, div, null);
          append_dev(div, t3);
          mount_component(menu_1, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const wrapper0_changes = {};
          if (dirty & 524296) {
            wrapper0_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper0.$set(wrapper0_changes);
          const wrapper1_changes = {};
          if (dirty & 524304) {
            wrapper1_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper1.$set(wrapper1_changes);
          const wrapper2_changes = {};
          if (dirty & 524288) {
            wrapper2_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper2.$set(wrapper2_changes);
          const iconbutton_changes = {};
          if (dirty & 524288) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_id && dirty & 1) {
            updating_id = true;
            iconbutton_changes.id = ctx2[0];
            add_flush_callback(() => updating_id = false);
          }
          iconbutton.$set(iconbutton_changes);
          const menu_1_changes = {};
          if (dirty & 524336) {
            menu_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_menuToggle && dirty & 4) {
            updating_menuToggle = true;
            menu_1_changes.menuToggle = ctx2[2];
            add_flush_callback(() => updating_menuToggle = false);
          }
          menu_1.$set(menu_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(wrapper0.$$.fragment, local);
          transition_in(wrapper1.$$.fragment, local);
          transition_in(wrapper2.$$.fragment, local);
          transition_in(iconbutton.$$.fragment, local);
          transition_in(menu_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(wrapper0.$$.fragment, local);
          transition_out(wrapper1.$$.fragment, local);
          transition_out(wrapper2.$$.fragment, local);
          transition_out(iconbutton.$$.fragment, local);
          transition_out(menu_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(wrapper0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(wrapper1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(wrapper2, detaching);
          if (detaching)
            detach_dev(t2);
          if (detaching)
            detach_dev(div);
          destroy_component(iconbutton);
          destroy_component(menu_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: '(60:3) <Section align=\\"end\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_16(ctx) {
      let section0;
      let t;
      let section1;
      let current;
      section0 = new Section({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      section0.$on("click", ctx[9]);
      section1 = new Section({
        props: {
          align: "end",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(section0.$$.fragment);
          t = space();
          create_component(section1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(section0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(section1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const section0_changes = {};
          if (dirty & 524288) {
            section0_changes.$$scope = {dirty, ctx: ctx2};
          }
          section0.$set(section0_changes);
          const section1_changes = {};
          if (dirty & 524349) {
            section1_changes.$$scope = {dirty, ctx: ctx2};
          }
          section1.$set(section1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(section0.$$.fragment, local);
          transition_in(section1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(section0.$$.fragment, local);
          transition_out(section1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(section0, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(section1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_16.name,
        type: "slot",
        source: "(47:2) <Row>",
        ctx
      });
      return block;
    }
    function create_default_slot6(ctx) {
      let row;
      let current;
      row = new Row({
        props: {
          $$slots: {default: [create_default_slot_16]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(row.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const row_changes = {};
          if (dirty & 524349) {
            row_changes.$$scope = {dirty, ctx: ctx2};
          }
          row.$set(row_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(row, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot6.name,
        type: "slot",
        source: '(46:1) <TopAppBar variant=\\"static\\">',
        ctx
      });
      return block;
    }
    function create_fragment$35(ctx) {
      let header;
      let topappbar;
      let current;
      let mounted;
      let dispose;
      add_render_callback(ctx[8]);
      topappbar = new TopAppBar({
        props: {
          variant: "static",
          $$slots: {default: [create_default_slot6]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          header = element("header");
          create_component(topappbar.$$.fragment);
          add_location(header, file$26, 44, 0, 1365);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, header, anchor);
          mount_component(topappbar, header, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(window, "resize", ctx[8]);
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          const topappbar_changes = {};
          if (dirty & 524349) {
            topappbar_changes.$$scope = {dirty, ctx: ctx2};
          }
          topappbar.$set(topappbar_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(topappbar.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(topappbar.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(header);
          destroy_component(topappbar);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$35.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$35($$self, $$props, $$invalidate) {
      let $modal;
      let $redirect;
      let $userSettings;
      let $user;
      let $goto;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(16, $modal = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(17, $redirect = $$value));
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(3, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(4, $user = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(5, $goto = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Main", slots, []);
      let menu;
      let burger;
      let width;
      let menuToggle = false;
      function auth() {
        if ($user && Object.keys($user).length) {
          localStorage.clear();
          set_store_value(user, $user = {}, $user);
          set_store_value(userSettings, $userSettings = {}, $userSettings);
          $redirect("/signup");
        } else {
          set_store_value(modal, $modal.title = "Login", $modal);
          set_store_value(modal, $modal.component = Login, $modal);
        }
      }
      function reportProblem() {
        set_store_value(modal, $modal.title = "Idee oder Problem melden", $modal);
        set_store_value(modal, $modal.component = ReportProblem, $modal);
      }
      const writable_props = [];
      Object_1$1.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Main> was created with unknown prop '${key}'`);
      });
      function onwindowresize() {
        $$invalidate(1, width = window.outerWidth);
      }
      const click_handler = () => $goto("/");
      function iconbutton_id_binding(value) {
        burger = value;
        $$invalidate(0, burger);
      }
      const click_handler_1 = () => $$invalidate(2, menuToggle = !menuToggle);
      const click_handler_2 = () => $goto("/help");
      const click_handler_3 = () => {
        $goto("/");
      };
      const click_handler_4 = () => {
        $goto("/settings");
      };
      function menu_1_menuToggle_binding(value) {
        menuToggle = value;
        $$invalidate(2, menuToggle);
      }
      $$self.$capture_state = () => ({
        ReportProblem,
        modal,
        user,
        userSettings,
        TopAppBar,
        Row,
        Section,
        Title: Title2,
        IconButton,
        Img,
        Icon: CommonIcon,
        Menu: Menu2,
        Login,
        Wrapper,
        Tooltip,
        goto,
        redirect,
        menu,
        burger,
        width,
        menuToggle,
        auth,
        reportProblem,
        $modal,
        $redirect,
        $userSettings,
        $user,
        $goto
      });
      $$self.$inject_state = ($$props2) => {
        if ("menu" in $$props2)
          menu = $$props2.menu;
        if ("burger" in $$props2)
          $$invalidate(0, burger = $$props2.burger);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("menuToggle" in $$props2)
          $$invalidate(2, menuToggle = $$props2.menuToggle);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        burger,
        width,
        menuToggle,
        $userSettings,
        $user,
        $goto,
        auth,
        reportProblem,
        onwindowresize,
        click_handler,
        iconbutton_id_binding,
        click_handler_1,
        click_handler_2,
        click_handler_3,
        click_handler_4,
        menu_1_menuToggle_binding
      ];
    }
    var Main = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$35, create_fragment$35, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Main",
          options,
          id: create_fragment$35.name
        });
      }
    };
    var file$18 = "src/components/Footer.svelte";
    function add_css$1(target) {
      append_styles(target, "svelte-1puri16", "footer.svelte-1puri16{background-color:var(--mdc-theme-footer)}.copyright.svelte-1puri16{color:#aaa;font-size:14px;display:inline-block;padding:5px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9vdGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFDQyxNQUFBLGVBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxrQkFBQSxDQUF5QyxBQUMxQyxDQUFBLEFBQ0EsVUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxDQUNYLFNBQUEsQ0FBQSxJQUFlLENBQ2YsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLE9BQUEsQ0FBQSxHQUFZLEFBRWIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJzcmMvY29tcG9uZW50cy9zcmMvY29tcG9uZW50cy9Gb290ZXIuc3ZlbHRlIl19 */");
    }
    function create_fragment$28(ctx) {
      let footer;
      let div0;
      let t1;
      let div1;
      let t3;
      let div2;
      let t5;
      let div3;
      let t7;
      let div4;
      const block = {
        c: function create2() {
          footer = element("footer");
          div0 = element("div");
          div0.textContent = "\xA9 2021 ml4all";
          t1 = space();
          div1 = element("div");
          div1.textContent = "\u2022";
          t3 = space();
          div2 = element("div");
          div2.textContent = "Impressum";
          t5 = space();
          div3 = element("div");
          div3.textContent = "\u2022";
          t7 = space();
          div4 = element("div");
          div4.textContent = "Datenschutzerkl\xE4rung";
          attr_dev(div0, "class", "copyright svelte-1puri16");
          add_location(div0, file$18, 1, 1, 49);
          attr_dev(div1, "class", "copyright svelte-1puri16");
          add_location(div1, file$18, 2, 1, 93);
          attr_dev(div2, "class", "copyright svelte-1puri16");
          add_location(div2, file$18, 3, 1, 125);
          attr_dev(div3, "class", "copyright svelte-1puri16");
          add_location(div3, file$18, 4, 1, 165);
          attr_dev(div4, "class", "copyright svelte-1puri16");
          add_location(div4, file$18, 5, 1, 197);
          attr_dev(footer, "class", "mt-auto w-full p-4 text-center svelte-1puri16");
          add_location(footer, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, footer, anchor);
          append_dev(footer, div0);
          append_dev(footer, t1);
          append_dev(footer, div1);
          append_dev(footer, t3);
          append_dev(footer, div2);
          append_dev(footer, t5);
          append_dev(footer, div3);
          append_dev(footer, t7);
          append_dev(footer, div4);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(footer);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Footer", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Footer> was created with unknown prop '${key}'`);
      });
      return [];
    }
    var Footer = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$28, safe_not_equal, {}, add_css$1);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Footer",
          options,
          id: create_fragment$28.name
        });
      }
    };
    var {Object: Object_12} = globals;
    function create_fragment$18(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      let $userSettings;
      let $user;
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(1, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(0, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("BackendStores", slots, []);
      async function updateUserSettings() {
        if (!$user || Object.keys($user).length == 0) {
          return;
        }
        if ($user && Object.keys($user).length) {
          await axios.put(`${backendURL}/api/usersettings/`, $userSettings);
        }
      }
      async function getUserSettings() {
        if ($user && Object.keys($user).length) {
          let {data} = await axios.get(`${backendURL}/api/usersettings/`);
          set_store_value(userSettings, $userSettings = JSON.parse(JSON.stringify(data)), $userSettings);
        }
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<BackendStores> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({
        axios,
        user,
        userSettings,
        backendURL,
        updateUserSettings,
        getUserSettings,
        $userSettings,
        $user
      });
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          if ($user) {
            getUserSettings();
            let startTime = new Date($user.expires);
            let interval = setInterval(() => {
              let currentTime = new Date();
              if (currentTime > startTime) {
                clearInterval(interval);
                localStorage.removeItem("auth");
                set_store_value(user, $user = {}, $user);
              }
            }, 1e3);
          }
        }
      };
      return [$user];
    }
    var BackendStores = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "BackendStores",
          options,
          id: create_fragment$18.name
        });
      }
    };
    var file10 = "src/pages/_layout.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-15xksm", ".svelte-15xksm{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__leading{border-radius:28px 0 0 28px;width:28px}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__trailing{border-radius:0 28px 28px 0}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__notch{max-width:calc(100% - 28px * 2)}.svelte-15xksm .shaped-outlined{width:100px;height:35px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2xheW91dC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBQ0MsY0FBQSxDQUFBLEFBQ0Msa0JBQUEsQ0FBQSxVQUE4QixDQUM5QixlQUFBLENBQUEsVUFBMkIsQ0FDM0IsVUFBQSxDQUFBLFVBQXNCLEFBQ3ZCLENBQUEsQUFFQSxjQUFBOztpQ0FJQyxhQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBNEIsQ0FDNUIsS0FBQSxDQUFBLElBQVcsQUFDWixDQUFBLEFBQ0EsY0FBQTs7a0NBSUMsYUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQSxDQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSxjQUFBOzsrQkFJQyxTQUFBLENBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQyxBQUNqQyxDQUFBLEFBQ0EsY0FBQSxDQUFBLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLEtBQVksQ0FDWixNQUFBLENBQUEsSUFBWSxBQUNiLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzL3NyYy9wYWdlcy9fbGF5b3V0LnN2ZWx0ZSJdfQ== */");
    }
    function create_fragment10(ctx) {
      let backend;
      let t0;
      let link0;
      let link1;
      let link2;
      let link3;
      let link4;
      let t1;
      let notification2;
      let t2;
      let modal2;
      let t3;
      let main2;
      let nav;
      let t4;
      let div;
      let t5;
      let footer;
      let current;
      backend = new BackendStores({$$inline: true});
      notification2 = new Notification({$$inline: true});
      modal2 = new Main$1({$$inline: true});
      nav = new Main({$$inline: true});
      const default_slot_template = ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
      footer = new Footer({$$inline: true});
      const block = {
        c: function create2() {
          create_component(backend.$$.fragment);
          t0 = space();
          link0 = element("link");
          link1 = element("link");
          link2 = element("link");
          link3 = element("link");
          link4 = element("link");
          t1 = space();
          create_component(notification2.$$.fragment);
          t2 = space();
          create_component(modal2.$$.fragment);
          t3 = space();
          main2 = element("main");
          create_component(nav.$$.fragment);
          t4 = space();
          div = element("div");
          if (default_slot)
            default_slot.c();
          t5 = space();
          create_component(footer.$$.fragment);
          attr_dev(link0, "rel", "stylesheet");
          attr_dev(link0, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
          attr_dev(link0, "class", "svelte-15xksm");
          add_location(link0, file10, 13, 1, 412);
          attr_dev(link1, "rel", "stylesheet");
          attr_dev(link1, "href", "https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700");
          attr_dev(link1, "class", "svelte-15xksm");
          add_location(link1, file10, 17, 1, 507);
          attr_dev(link2, "rel", "stylesheet");
          attr_dev(link2, "href", "https://unpkg.com/@material/typography@11.0.0/dist/mdc.typography.css");
          attr_dev(link2, "class", "svelte-15xksm");
          add_location(link2, file10, 23, 1, 644);
          attr_dev(link3, "rel", "stylesheet");
          attr_dev(link3, "href", "/foodsight.css");
          attr_dev(link3, "class", "svelte-15xksm");
          add_location(link3, file10, 29, 1, 769);
          attr_dev(link4, "rel", "stylesheet");
          attr_dev(link4, "href", "/bare.css");
          attr_dev(link4, "class", "svelte-15xksm");
          add_location(link4, file10, 30, 1, 818);
          attr_dev(div, "class", "p-2 h-full overflow-y-auto  svelte-15xksm");
          add_location(div, file10, 37, 1, 985);
          attr_dev(main2, "class", "flex flex-col h-screen  svelte-15xksm");
          add_location(main2, file10, 35, 0, 904);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(backend, target, anchor);
          insert_dev(target, t0, anchor);
          append_dev(document.head, link0);
          append_dev(document.head, link1);
          append_dev(document.head, link2);
          append_dev(document.head, link3);
          append_dev(document.head, link4);
          insert_dev(target, t1, anchor);
          mount_component(notification2, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(modal2, target, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, main2, anchor);
          mount_component(nav, main2, null);
          append_dev(main2, t4);
          append_dev(main2, div);
          if (default_slot) {
            default_slot.m(div, null);
          }
          append_dev(main2, t5);
          mount_component(footer, main2, null);
          ctx[3](main2);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(backend.$$.fragment, local);
          transition_in(notification2.$$.fragment, local);
          transition_in(modal2.$$.fragment, local);
          transition_in(nav.$$.fragment, local);
          transition_in(default_slot, local);
          transition_in(footer.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(backend.$$.fragment, local);
          transition_out(notification2.$$.fragment, local);
          transition_out(modal2.$$.fragment, local);
          transition_out(nav.$$.fragment, local);
          transition_out(default_slot, local);
          transition_out(footer.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(backend, detaching);
          if (detaching)
            detach_dev(t0);
          detach_dev(link0);
          detach_dev(link1);
          detach_dev(link2);
          detach_dev(link3);
          detach_dev(link4);
          if (detaching)
            detach_dev(t1);
          destroy_component(notification2, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(modal2, detaching);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(main2);
          destroy_component(nav);
          if (default_slot)
            default_slot.d(detaching);
          destroy_component(footer);
          ctx[3](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance7($$self, $$props, $$invalidate) {
      let $svelteRenderParent;
      validate_store(svelteRenderParent, "svelteRenderParent");
      component_subscribe($$self, svelteRenderParent, ($$value) => $$invalidate(0, $svelteRenderParent = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Layout", slots, ["default"]);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Layout> was created with unknown prop '${key}'`);
      });
      function main_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $svelteRenderParent = $$value;
          svelteRenderParent.set($svelteRenderParent);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("$$scope" in $$props2)
          $$invalidate(1, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => ({
        Notification,
        Modal: Main$1,
        Nav: Main,
        Footer,
        Backend: BackendStores,
        svelteRenderParent,
        $svelteRenderParent
      });
      return [$svelteRenderParent, $$scope, slots, main_binding];
    }
    var Layout = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance7, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Layout",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/main.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  function HMR(Component, options = {target: document.body}, id = "hmr", eventName = "app-loaded") {
    const prerenderedHtmlElement = document.getElementById(id);
    const target = document.createElement("div");
    target.style.visibility = "hidden";
    options.target.appendChild(target);
    if (!prerenderedHtmlElement)
      showApp();
    else
      addEventListener(eventName, showApp);
    function showApp() {
      removeEventListener(eventName, showApp);
      if (prerenderedHtmlElement)
        prerenderedHtmlElement.remove();
      target.style.visibility = null;
      target.setAttribute("id", id);
    }
    return new Component({...options, target});
  }
  function noop() {
  }
  var identity = (x) => x;
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return tar;
  }
  function is_promise(value) {
    return value && typeof value === "object" && typeof value.then === "function";
  }
  function add_location(element2, file10, line, column, char) {
    element2.__svelte_meta = {
      loc: {file: file10, line, column, char}
    };
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url2) {
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url2;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function validate_store(store, name2) {
    if (store != null && typeof store.subscribe !== "function") {
      throw new Error(`'${name2}' is not a store with a 'subscribe' method`);
    }
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function get_store_value(store) {
    let value;
    subscribe(store, (_2) => value = _2)();
    return value;
  }
  function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
  }
  function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
      const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
      return definition[0](slot_ctx);
    }
  }
  function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
  }
  function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
      const lets = definition[2](fn(dirty));
      if ($$scope.dirty === void 0) {
        return lets;
      }
      if (typeof lets === "object") {
        const merged = [];
        const len = Math.max($$scope.dirty.length, lets.length);
        for (let i = 0; i < len; i += 1) {
          merged[i] = $$scope.dirty[i] | lets[i];
        }
        return merged;
      }
      return $$scope.dirty | lets;
    }
    return $$scope.dirty;
  }
  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
      const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
      slot.p(slot_context, slot_changes);
    }
  }
  function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
      const dirty = [];
      const length = $$scope.ctx.length / 32;
      for (let i = 0; i < length; i++) {
        dirty[i] = -1;
      }
      return dirty;
    }
    return -1;
  }
  function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
      if (k[0] !== "$")
        result[k] = props[k];
    return result;
  }
  function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
      if (!keys.has(k) && k[0] !== "$")
        rest[k] = props[k];
    return rest;
  }
  function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
      result[key] = true;
    }
    return result;
  }
  function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
  }
  function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
  }
  var is_client = typeof window !== "undefined";
  var now = is_client ? () => window.performance.now() : () => Date.now();
  var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
  var tasks = new Set();
  function run_tasks(now2) {
    tasks.forEach((task) => {
      if (!task.c(now2)) {
        tasks.delete(task);
        task.f();
      }
    });
    if (tasks.size !== 0)
      raf(run_tasks);
  }
  function loop(callback) {
    let task;
    if (tasks.size === 0)
      raf(run_tasks);
    return {
      promise: new Promise((fulfill) => {
        tasks.add(task = {c: callback, f: fulfill});
      }),
      abort() {
        tasks.delete(task);
      }
    };
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
      const style = element("style");
      style.id = style_sheet_id;
      style.textContent = styles;
      append_stylesheet(append_styles_to, style);
    }
  }
  function get_root_for_style(node) {
    if (!node)
      return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
      return root;
    }
    return node.ownerDocument;
  }
  function append_empty_stylesheet(node) {
    const style_element = element("style");
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
  }
  function append_stylesheet(node, style) {
    append(node.head || node, style);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name2) {
    return document.createElement(name2);
  }
  function svg_element(name2) {
    return document.createElementNS("http://www.w3.org/2000/svg", name2);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function prevent_default(fn) {
    return function(event) {
      event.preventDefault();
      return fn.call(this, event);
    };
  }
  function stop_propagation(fn) {
    return function(event) {
      event.stopPropagation();
      return fn.call(this, event);
    };
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes2) {
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes2) {
      if (attributes2[key] == null) {
        node.removeAttribute(key);
      } else if (key === "style") {
        node.style.cssText = attributes2[key];
      } else if (key === "__value") {
        node.value = node[key] = attributes2[key];
      } else if (descriptors[key] && descriptors[key].set) {
        node[key] = attributes2[key];
      } else {
        attr(node, key, attributes2[key]);
      }
    }
  }
  function set_svg_attributes(node, attributes2) {
    for (const key in attributes2) {
      attr(node, key, attributes2[key]);
    }
  }
  function to_number(value) {
    return value === "" ? null : +value;
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? "important" : "");
  }
  function toggle_class(element2, name2, toggle) {
    element2.classList[toggle ? "add" : "remove"](name2);
  }
  function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent("CustomEvent");
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
  }
  var active_docs = new Set();
  var active = 0;
  function hash(str) {
    let hash2 = 5381;
    let i = str.length;
    while (i--)
      hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
    return hash2 >>> 0;
  }
  function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = "{\n";
    for (let p = 0; p <= 1; p += step) {
      const t = a + (b - a) * ease(p);
      keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
    const name2 = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name2]) {
      current_rules[name2] = true;
      stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || "";
    node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name2;
  }
  function delete_rule(node, name2) {
    const previous = (node.style.animation || "").split(", ");
    const next = previous.filter(name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1);
    const deleted = previous.length - next.length;
    if (deleted) {
      node.style.animation = next.join(", ");
      active -= deleted;
      if (!active)
        clear_rules();
    }
  }
  function clear_rules() {
    raf(() => {
      if (active)
        return;
      active_docs.forEach((doc) => {
        const stylesheet = doc.__svelte_stylesheet;
        let i = stylesheet.cssRules.length;
        while (i--)
          stylesheet.deleteRule(i);
        doc.__svelte_rules = {};
      });
      active_docs.clear();
    });
  }
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
  }
  function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
  }
  function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
  }
  function getContext(key) {
    return get_current_component().$$.context.get(key);
  }
  function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, event));
    }
  }
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function tick() {
    schedule_update();
    return resolved_promise;
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  var flushing = false;
  var seen_callbacks = new Set();
  function flush() {
    if (flushing)
      return;
    flushing = true;
    do {
      for (let i = 0; i < dirty_components.length; i += 1) {
        const component = dirty_components[i];
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  var promise;
  function wait() {
    if (!promise) {
      promise = Promise.resolve();
      promise.then(() => {
        promise = null;
      });
    }
    return promise;
  }
  function dispatch3(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
  }
  var outroing = new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    }
  }
  var null_transition = {duration: 0};
  function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
      if (animation_name)
        delete_rule(node, animation_name);
    }
    function go() {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      if (css)
        animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
      tick2(0, 1);
      const start_time = now() + delay;
      const end_time = start_time + duration;
      if (task)
        task.abort();
      running = true;
      add_render_callback(() => dispatch3(node, true, "start"));
      task = loop((now2) => {
        if (running) {
          if (now2 >= end_time) {
            tick2(1, 0);
            dispatch3(node, true, "end");
            cleanup();
            return running = false;
          }
          if (now2 >= start_time) {
            const t = easing((now2 - start_time) / duration);
            tick2(t, 1 - t);
          }
        }
        return running;
      });
    }
    let started = false;
    return {
      start() {
        if (started)
          return;
        started = true;
        delete_rule(node);
        if (is_function(config)) {
          config = config();
          wait().then(go);
        } else {
          go();
        }
      },
      invalidate() {
        started = false;
      },
      end() {
        if (running) {
          cleanup();
          running = false;
        }
      }
    };
  }
  function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      if (css)
        animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
      const start_time = now() + delay;
      const end_time = start_time + duration;
      add_render_callback(() => dispatch3(node, false, "start"));
      loop((now2) => {
        if (running) {
          if (now2 >= end_time) {
            tick2(0, 1);
            dispatch3(node, false, "end");
            if (!--group.r) {
              run_all(group.c);
            }
            return false;
          }
          if (now2 >= start_time) {
            const t = easing((now2 - start_time) / duration);
            tick2(1 - t, t);
          }
        }
        return running;
      });
    }
    if (is_function(config)) {
      wait().then(() => {
        config = config();
        go();
      });
    } else {
      go();
    }
    return {
      end(reset) {
        if (reset && config.tick) {
          config.tick(1, 0);
        }
        if (running) {
          if (animation_name)
            delete_rule(node, animation_name);
          running = false;
        }
      }
    };
  }
  function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
      if (animation_name)
        delete_rule(node, animation_name);
    }
    function init2(program, duration) {
      const d = program.b - t;
      duration *= Math.abs(d);
      return {
        a: t,
        b: program.b,
        d,
        duration,
        start: program.start,
        end: program.start + duration,
        group: program.group
      };
    }
    function go(b) {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      const program = {
        start: now() + delay,
        b
      };
      if (!b) {
        program.group = outros;
        outros.r += 1;
      }
      if (running_program || pending_program) {
        pending_program = program;
      } else {
        if (css) {
          clear_animation();
          animation_name = create_rule(node, t, b, duration, delay, easing, css);
        }
        if (b)
          tick2(0, 1);
        running_program = init2(program, duration);
        add_render_callback(() => dispatch3(node, b, "start"));
        loop((now2) => {
          if (pending_program && now2 > pending_program.start) {
            running_program = init2(pending_program, duration);
            pending_program = null;
            dispatch3(node, running_program.b, "start");
            if (css) {
              clear_animation();
              animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
            }
          }
          if (running_program) {
            if (now2 >= running_program.end) {
              tick2(t = running_program.b, 1 - t);
              dispatch3(node, running_program.b, "end");
              if (!pending_program) {
                if (running_program.b) {
                  clear_animation();
                } else {
                  if (!--running_program.group.r)
                    run_all(running_program.group.c);
                }
              }
              running_program = null;
            } else if (now2 >= running_program.start) {
              const p = now2 - running_program.start;
              t = running_program.a + running_program.d * easing(p / running_program.duration);
              tick2(t, 1 - t);
            }
          }
          return !!(running_program || pending_program);
        });
      }
    }
    return {
      run(b) {
        if (is_function(config)) {
          wait().then(() => {
            config = config();
            go(b);
          });
        } else {
          go(b);
        }
      },
      end() {
        clear_animation();
        running_program = pending_program = null;
      }
    };
  }
  function handle_promise(promise2, info) {
    const token = info.token = {};
    function update2(type, index, key, value) {
      if (info.token !== token)
        return;
      info.resolved = value;
      let child_ctx = info.ctx;
      if (key !== void 0) {
        child_ctx = child_ctx.slice();
        child_ctx[key] = value;
      }
      const block = type && (info.current = type)(child_ctx);
      let needs_flush = false;
      if (info.block) {
        if (info.blocks) {
          info.blocks.forEach((block2, i) => {
            if (i !== index && block2) {
              group_outros();
              transition_out(block2, 1, 1, () => {
                if (info.blocks[i] === block2) {
                  info.blocks[i] = null;
                }
              });
              check_outros();
            }
          });
        } else {
          info.block.d(1);
        }
        block.c();
        transition_in(block, 1);
        block.m(info.mount(), info.anchor);
        needs_flush = true;
      }
      info.block = block;
      if (info.blocks)
        info.blocks[index] = block;
      if (needs_flush) {
        flush();
      }
    }
    if (is_promise(promise2)) {
      const current_component2 = get_current_component();
      promise2.then((value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      }, (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      });
      if (info.current !== info.pending) {
        update2(info.pending, 0);
        return true;
      }
    } else {
      if (info.current !== info.then) {
        update2(info.then, 1, info.value, promise2);
        return true;
      }
      info.resolved = promise2;
    }
  }
  function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const {resolved} = info;
    if (info.current === info.then) {
      child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
      child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
  }
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
  }
  function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
      lookup.delete(block.key);
    });
  }
  function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block3, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
      old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
      const child_ctx = get_context(ctx, list, i);
      const key = get_key(child_ctx);
      let block = lookup.get(key);
      if (!block) {
        block = create_each_block3(key, child_ctx);
        block.c();
      } else if (dynamic) {
        block.p(child_ctx, dirty);
      }
      new_lookup.set(key, new_blocks[i] = block);
      if (key in old_indexes)
        deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert2(block) {
      transition_in(block, 1);
      block.m(node, next);
      lookup.set(block.key, block);
      next = block.first;
      n--;
    }
    while (o && n) {
      const new_block = new_blocks[n - 1];
      const old_block = old_blocks[o - 1];
      const new_key = new_block.key;
      const old_key = old_block.key;
      if (new_block === old_block) {
        next = new_block.first;
        o--;
        n--;
      } else if (!new_lookup.has(old_key)) {
        destroy(old_block, lookup);
        o--;
      } else if (!lookup.has(new_key) || will_move.has(new_key)) {
        insert2(new_block);
      } else if (did_move.has(old_key)) {
        o--;
      } else if (deltas.get(new_key) > deltas.get(old_key)) {
        did_move.add(new_key);
        insert2(new_block);
      } else {
        will_move.add(old_key);
        o--;
      }
    }
    while (o--) {
      const old_block = old_blocks[o];
      if (!new_lookup.has(old_block.key))
        destroy(old_block, lookup);
    }
    while (n)
      insert2(new_blocks[n - 1]);
    return new_blocks;
  }
  function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
      const key = get_key(get_context(ctx, list, i));
      if (keys.has(key)) {
        throw new Error("Cannot have duplicate keys in a keyed each");
      }
      keys.add(key);
    }
  }
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = {$$scope: 1};
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update2[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update2))
        update2[key] = void 0;
    }
    return update2;
  }
  function get_spread_object(spread_props) {
    return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
  }
  function bind3(component, name2, callback) {
    const index = component.$$.props[name2];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor, customElement) {
    const {fragment, on_mount, on_destroy, after_update} = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init$1(component, options, instance7, create_fragment10, not_equal, props, append_styles2, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: null,
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(parent_component ? parent_component.$$.context : options.context || []),
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles2 && append_styles2($$.root);
    let ready = false;
    $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteComponent = class {
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
  function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({version: "3.42.4"}, detail), true));
  }
  function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", {target, node});
    append(target, node);
  }
  function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", {target, node, anchor});
    insert(target, node, anchor);
  }
  function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", {node});
    detach(node);
  }
  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
      modifiers.push("preventDefault");
    if (has_stop_propagation)
      modifiers.push("stopPropagation");
    dispatch_dev("SvelteDOMAddEventListener", {node, event, handler, modifiers});
    const dispose = listen(node, event, handler, options);
    return () => {
      dispatch_dev("SvelteDOMRemoveEventListener", {node, event, handler, modifiers});
      dispose();
    };
  }
  function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
      dispatch_dev("SvelteDOMRemoveAttribute", {node, attribute});
    else
      dispatch_dev("SvelteDOMSetAttribute", {node, attribute, value});
  }
  function set_data_dev(text2, data) {
    data = "" + data;
    if (text2.wholeText === data)
      return;
    dispatch_dev("SvelteDOMSetData", {node: text2, data});
    text2.data = data;
  }
  function validate_each_argument(arg) {
    if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
      let msg = "{#each} only iterates over array-like objects.";
      if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
        msg += " You can use a spread to convert this iterable into an array.";
      }
      throw new Error(msg);
    }
  }
  function validate_slots(name2, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
      if (!~keys.indexOf(slot_key)) {
        console.warn(`<${name2}> received an unexpected slot "${slot_key}".`);
      }
    }
  }
  var SvelteComponentDev = class extends SvelteComponent {
    constructor(options) {
      if (!options || !options.target && !options.$$inline) {
        throw new Error("'target' is a required option");
      }
      super();
    }
    $destroy() {
      super.$destroy();
      this.$destroy = () => {
        console.warn("Component was already destroyed");
      };
    }
    $capture_state() {
    }
    $inject_state() {
    }
  };
  var {console: console_1} = globals;
  function create_fragment$63(ctx) {
    const block = {
      c: noop,
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$63.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$6($$self, $$props) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Serviceworker", slots, []);
    if ("serviceWorker" in navigator) {
      Promise.resolve().then(() => require_workbox_window_prod_es5()).then(async ({Workbox}) => {
        const wb = new Workbox("/serviceworker.js");
        await wb.register();
        wb.addEventListener("redundant", () => {
          location.reload();
          console.log("updated app");
        });
      });
    }
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console_1.warn(`<Serviceworker> was created with unknown prop '${key}'`);
    });
    return [];
  }
  var Serviceworker = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$6, create_fragment$63, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Serviceworker",
        options,
        id: create_fragment$63.name
      });
    }
  };
  var defaultConfig = {
    queryHandler: {
      parse: (search) => fromEntries(new URLSearchParams(search)),
      stringify: (params) => "?" + new URLSearchParams(params).toString()
    },
    urlTransform: {
      apply: (x) => x,
      remove: (x) => x
    },
    useHash: false
  };
  function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) => {
      obj[key] = val;
      return obj;
    }, {});
  }
  var MATCH_PARAM = RegExp(/\:([^/()]+)/g);
  function handleScroll(element2, scrollToTop) {
    if (navigator.userAgent.includes("jsdom"))
      return false;
    if (scrollToTop)
      scrollAncestorsToTop(element2);
    handleHash();
  }
  function handleHash() {
    if (navigator.userAgent.includes("jsdom"))
      return false;
    const {hash: hash2} = window.location;
    if (hash2) {
      const validElementIdRegex = /^[A-Za-z]+[\w\-\:\.]*$/;
      if (validElementIdRegex.test(hash2.substring(1))) {
        const el = document.querySelector(hash2);
        if (el)
          el.scrollIntoView();
      }
    }
  }
  function scrollAncestorsToTop(element2) {
    if (element2 && element2.scrollTo && element2.dataset.routify !== "scroll-lock" && element2.dataset["routify-scroll"] !== "lock") {
      element2.style["scroll-behavior"] = "auto";
      element2.scrollTo({top: 0, behavior: "auto"});
      element2.style["scroll-behavior"] = "";
      scrollAncestorsToTop(element2.parentElement);
    }
  }
  var pathToRegex = (str, recursive) => {
    const suffix = recursive ? "" : "/?$";
    str = str.replace(/\/_fallback?$/, "(/|$)");
    str = str.replace(/\/index$/, "(/index)?");
    str = str.replace(MATCH_PARAM, "([^/]+)") + suffix;
    str = `^${str}`;
    return str;
  };
  var pathToParamKeys = (string) => {
    const paramsKeys = [];
    let matches3;
    while (matches3 = MATCH_PARAM.exec(string))
      paramsKeys.push(matches3[1]);
    return paramsKeys;
  };
  var pathToRank = ({path}) => {
    return path.split("/").filter(Boolean).map((str) => str === "_fallback" ? "A" : str.startsWith(":") ? "B" : "C").join("");
  };
  function suppressComponentWarnings(ctx, tick2) {
    suppressComponentWarnings._console = suppressComponentWarnings._console || {log: console.log, warn: console.warn};
    const {_console} = suppressComponentWarnings;
    const name2 = ctx.componentFile.name.replace(/Proxy<_?(.+)>/, "$1").replace(/^Index$/, ctx.component.shortPath.split("/").pop()).replace(/^./, (s) => s.toUpperCase()).replace(/\:(.+)/, "U5B$1u5D");
    const ignores = [
      `<${name2}> received an unexpected slot "default".`,
      `<${name2}> was created with unknown prop 'scoped'`,
      `<${name2}> was created with unknown prop 'scopedSync'`
    ];
    for (const log of ["log", "warn"]) {
      console[log] = (...args) => {
        if (!ignores.includes(args[0]))
          _console[log](...args);
      };
      tick2().then(() => {
        console[log] = _console[log];
      });
    }
  }
  function currentLocation() {
    let dirtyFullpath = window.location.pathname + window.location.search + window.location.hash;
    const {url: url2, options} = resolvePrefetch(dirtyFullpath);
    const parsedUrl = parseUrl(url2);
    return {...parsedUrl, options};
  }
  function resolvePrefetch(dirtyFullpath) {
    const [url2, _options] = dirtyFullpath.split("__[[routify_url_options]]__");
    const options = JSON.parse(decodeURIComponent(_options || "") || "{}");
    window.routify = window.routify || {};
    window.routify.prefetched = options.prefetch;
    return {url: url2, options};
  }
  function parseUrl(url2) {
    if (defaultConfig.useHash)
      url2 = url2.replace(/.*#(.+)/, "$1");
    const origin = url2.startsWith("/") ? window.location.origin : void 0;
    const _url = new URL(url2, origin);
    const fullpath = _url.pathname + _url.search + _url.hash;
    return {url: _url, fullpath};
  }
  function resolveUrl(path, params, inheritedParams) {
    const hash2 = defaultConfig.useHash ? "#" : "";
    let url2;
    url2 = populateUrl(path, params, inheritedParams);
    url2 = defaultConfig.urlTransform.apply(url2);
    url2 = hash2 + url2;
    return url2;
  }
  function populateUrl(path, params, inheritedParams) {
    const allParams = Object.assign({}, inheritedParams, params);
    const queryString = getQueryString(path, params);
    for (const [key, value] of Object.entries(allParams))
      path = path.replace(`:${key}`, value);
    return `${path}${queryString}`;
  }
  function getQueryString(path, params) {
    if (!defaultConfig.queryHandler)
      return "";
    const ignoredKeys = pathToParamKeys(path);
    const queryParams = {};
    if (params)
      Object.entries(params).forEach(([key, value]) => {
        if (!ignoredKeys.includes(key))
          queryParams[key] = value;
      });
    return defaultConfig.queryHandler.stringify(queryParams).replace(/\?$/, "");
  }
  function create_fragment$53(ctx) {
    let current;
    const default_slot_template = ctx[2].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$53.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$52($$self, $$props, $$invalidate) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Noop", slots, ["default"]);
    let {scoped = {}} = $$props;
    const writable_props = ["scoped"];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Noop> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("$$scope" in $$props2)
        $$invalidate(1, $$scope = $$props2.$$scope);
    };
    $$self.$capture_state = () => ({scoped});
    $$self.$inject_state = ($$props2) => {
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [scoped, $$scope, slots];
  }
  var Noop = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$52, create_fragment$53, safe_not_equal, {scoped: 0});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Noop",
        options,
        id: create_fragment$53.name
      });
    }
    get scoped() {
      throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set scoped(value) {
      throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var subscriber_queue = [];
  function readable(value, start) {
    return {
      subscribe: writable(value, start).subscribe
    };
  }
  function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set(fn(value));
    }
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0) {
          stop();
          stop = null;
        }
      };
    }
    return {set, update: update2, subscribe: subscribe2};
  }
  function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
      let inited = false;
      const values = [];
      let pending = 0;
      let cleanup = noop;
      const sync = () => {
        if (pending) {
          return;
        }
        cleanup();
        const result = fn(single ? values[0] : values, set);
        if (auto) {
          set(result);
        } else {
          cleanup = is_function(result) ? result : noop;
        }
      };
      const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
        values[i] = value;
        pending &= ~(1 << i);
        if (inited) {
          sync();
        }
      }, () => {
        pending |= 1 << i;
      }));
      inited = true;
      sync();
      return function stop() {
        run_all(unsubscribers);
        cleanup();
      };
    });
  }
  window.routify = window.routify || {};
  var route = writable(null);
  var routes$1 = writable([]);
  routes$1.subscribe((routes2) => window.routify.routes = routes2);
  var rootContext = writable({component: {params: {}}});
  var urlRoute = writable(null);
  var isChangingPage = writable(true);
  async function onPageLoaded({page, metatags: metatags2, afterPageLoad: afterPageLoad2, parentNode}) {
    const scrollToTop = page.last !== page;
    setTimeout(() => handleScroll(parentNode, scrollToTop));
    const {path} = page;
    const {options} = currentLocation();
    const prefetchId = options.prefetch;
    for (const hook of afterPageLoad2._hooks) {
      if (hook)
        await hook(page.api);
    }
    metatags2.update();
    dispatchEvent(new CustomEvent("app-loaded"));
    parent.postMessage({
      msg: "app-loaded",
      prefetched: window.routify.prefetched,
      path,
      prefetchId
    }, "*");
    window["routify"].appLoaded = true;
    window["routify"].stopAutoReady = false;
  }
  function urlToRoute(url2, clone2 = false) {
    url2 = defaultConfig.urlTransform.remove(url2);
    let {pathname, search} = parseUrl(url2).url;
    const routes2 = get_store_value(routes$1);
    const matchingRoute = routes2.find((route3) => pathname === route3.meta.name) || routes2.find((route3) => pathname.match(route3.regex));
    if (!matchingRoute)
      throw new Error(`Route could not be found for "${pathname}".`);
    const _matchingRoute = clone2 ? Object.create(matchingRoute) : matchingRoute;
    const {route: route2, redirectPath, rewritePath} = resolveRedirects(_matchingRoute, routes2);
    if (rewritePath) {
      ({pathname, search} = parseUrl(resolveUrl(rewritePath, route2.params)).url);
      if (redirectPath)
        route2.redirectTo = resolveUrl(redirectPath, route2.params || {});
    }
    if (defaultConfig.queryHandler)
      route2.params = Object.assign({}, defaultConfig.queryHandler.parse(search));
    assignParamsToRouteAndLayouts(route2, pathname);
    route2.leftover = url2.replace(new RegExp(route2.regex), "");
    return route2;
  }
  function assignParamsToRouteAndLayouts(route2, pathname) {
    if (route2.paramKeys) {
      const layouts = layoutByPos(route2.layouts);
      const fragments = pathname.split("/").filter(Boolean);
      const routeProps = getRouteProps(route2.path);
      routeProps.forEach((prop, i) => {
        if (prop) {
          route2.params[prop] = fragments[i];
          if (layouts[i])
            layouts[i].param = {[prop]: fragments[i]};
          else
            route2.param = {[prop]: fragments[i]};
        }
      });
    }
  }
  function resolveRedirects(route2, routes2, redirectPath, rewritePath) {
    const {redirect: redirect2, rewrite} = route2.meta;
    if (redirect2 || rewrite) {
      redirectPath = redirect2 ? redirect2.path || redirect2 : redirectPath;
      rewritePath = rewrite ? rewrite.path || rewrite : redirectPath;
      const redirectParams = redirect2 && redirect2.params;
      const rewriteParams = rewrite && rewrite.params;
      const newRoute = routes2.find((r) => r.path.replace(/\/index$/, "") === rewritePath);
      if (newRoute === route2)
        console.error(`${rewritePath} is redirecting to itself`);
      if (!newRoute)
        console.error(`${route2.path} is redirecting to non-existent path: ${rewritePath}`);
      if (redirectParams || rewriteParams)
        newRoute.params = Object.assign({}, newRoute.params, redirectParams, rewriteParams);
      return resolveRedirects(newRoute, routes2, redirectPath, rewritePath);
    }
    return {route: route2, redirectPath, rewritePath};
  }
  function layoutByPos(layouts) {
    const arr = [];
    layouts.forEach((layout) => {
      arr[layout.path.split("/").filter(Boolean).length - 1] = layout;
    });
    return arr;
  }
  function getRouteProps(url2) {
    return url2.split("/").filter(Boolean).map((f) => f.match(/\:(.+)/)).map((f) => f && f[1]);
  }
  var file$17 = "node_modules/@roxi/routify/runtime/Prefetcher.svelte";
  function get_each_context$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[1] = list[i];
    return child_ctx;
  }
  function create_each_block$1(key_1, ctx) {
    let iframe;
    let iframe_src_value;
    const block = {
      key: key_1,
      first: null,
      c: function create2() {
        iframe = element("iframe");
        if (!src_url_equal(iframe.src, iframe_src_value = ctx[1].url))
          attr_dev(iframe, "src", iframe_src_value);
        attr_dev(iframe, "frameborder", "0");
        attr_dev(iframe, "title", "routify prefetcher");
        add_location(iframe, file$17, 80, 4, 2274);
        this.first = iframe;
      },
      m: function mount(target, anchor) {
        insert_dev(target, iframe, anchor);
      },
      p: function update2(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && !src_url_equal(iframe.src, iframe_src_value = ctx[1].url)) {
          attr_dev(iframe, "src", iframe_src_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(iframe);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_each_block$1.name,
      type: "each",
      source: "(80:2) {#each $actives as prefetch (prefetch.options.prefetch)}",
      ctx
    });
    return block;
  }
  function create_fragment$43(ctx) {
    let div;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let each_value = ctx[0];
    validate_each_argument(each_value);
    const get_key = (ctx2) => ctx2[1].options.prefetch;
    validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context$1(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    }
    const block = {
      c: function create2() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr_dev(div, "id", "__routify_iframes");
        set_style(div, "display", "none");
        add_location(div, file$17, 78, 0, 2160);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div, null);
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (dirty & 1) {
          each_value = ctx2[0];
          validate_each_argument(each_value);
          validate_each_keys(ctx2, each_value, get_each_context$1, get_key);
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$1, null, get_each_context$1);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$43.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var iframeNum = 2;
  var defaults2 = {
    validFor: 60,
    timeout: 5e3,
    gracePeriod: 1e3
  };
  var queue = writable([]);
  var actives = derived(queue, (q) => q.slice(0, iframeNum));
  actives.subscribe((actives2) => actives2.forEach(({options}) => {
    setTimeout(() => removeFromQueue(options.prefetch), options.timeout);
  }));
  function prefetch(path, options = {}) {
    prefetch.id = prefetch.id || 1;
    path = path.href || path;
    options = {...defaults2, ...options};
    options.prefetch = prefetch.id++;
    if (window.routify.prefetched || navigator.userAgent.match("jsdom"))
      return false;
    queue.update((q) => {
      if (!q.some((e) => e.options.path === path))
        q.push({
          url: `${path}__[[routify_url_options]]__${encodeURIComponent(JSON.stringify(options))}`,
          options
        });
      return q;
    });
  }
  function removeFromQueue(idOrEvent) {
    const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent;
    if (!id)
      return null;
    const entry = get_store_value(queue).find((entry2) => entry2 && entry2.options.prefetch == id);
    if (entry) {
      const {gracePeriod} = entry.options;
      const gracePromise = new Promise((resolve) => setTimeout(resolve, gracePeriod));
      const idlePromise = new Promise((resolve) => {
        window.requestIdleCallback ? window.requestIdleCallback(resolve) : setTimeout(resolve, gracePeriod + 1e3);
      });
      Promise.all([gracePromise, idlePromise]).then(() => {
        queue.update((q) => q.filter((q2) => q2.options.prefetch != id));
      });
    }
  }
  addEventListener("message", removeFromQueue, false);
  function instance$43($$self, $$props, $$invalidate) {
    let $actives;
    validate_store(actives, "actives");
    component_subscribe($$self, actives, ($$value) => $$invalidate(0, $actives = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Prefetcher", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Prefetcher> was created with unknown prop '${key}'`);
    });
    $$self.$capture_state = () => ({
      writable,
      derived,
      get: get_store_value,
      iframeNum,
      defaults: defaults2,
      queue,
      actives,
      prefetch,
      removeFromQueue,
      $actives
    });
    return [$actives];
  }
  var Prefetcher = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$43, create_fragment$43, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Prefetcher",
        options,
        id: create_fragment$43.name
      });
    }
  };
  function getRoutifyContext() {
    return getContext("routify") || rootContext;
  }
  var afterPageLoad = {
    _hooks: [
      (event) => isChangingPage.set(false)
    ],
    subscribe: hookHandler
  };
  var beforeUrlChange = {
    _hooks: [],
    subscribe: hookHandler
  };
  function hookHandler(listener) {
    const hooks = this._hooks;
    const index = hooks.length;
    listener((callback) => {
      hooks[index] = callback;
    });
    return (...params) => {
      delete hooks[index];
      listener(...params);
    };
  }
  var url = {
    subscribe(listener) {
      const ctx = getRoutifyContext();
      return derived(ctx, (ctx2) => makeUrlHelper(ctx2, ctx2.route, ctx2.routes)).subscribe(listener);
    }
  };
  function makeUrlHelper($ctx, $currentRoute, $routes) {
    return function url2(path, params = {}, options) {
      const {component} = $ctx;
      const inheritedParams = Object.assign({}, $currentRoute.params, component.params);
      let el = path && path.nodeType && path;
      if (el)
        path = path.getAttribute("href");
      path = path ? resolvePath(path) : component.shortPath;
      const route2 = $routes.find((route3) => [route3.shortPath || "/", route3.path].includes(path));
      if (route2 && route2.meta.preload === "proximity" && window.requestIdleCallback) {
        const delay = routify.appLoaded ? 0 : 1500;
        setTimeout(() => {
          window.requestIdleCallback(() => route2.api.preload());
        }, delay);
      }
      const strict = options && options.strict !== false;
      if (!strict)
        path = path.replace(/index$/, "");
      let url3 = resolveUrl(path, params, inheritedParams);
      if (el) {
        el.href = url3;
        return {
          update(changedParams) {
            el.href = resolveUrl(path, changedParams, inheritedParams);
          }
        };
      }
      return url3;
      function resolvePath(path2) {
        if (path2.match(/^\.\.?\//)) {
          let [, breadcrumbs, relativePath] = path2.match(/^([\.\/]+)(.*)/);
          let dir = component.path.replace(/\/$/, "");
          const traverse = breadcrumbs.match(/\.\.\//g) || [];
          if (component.isPage)
            traverse.push(null);
          traverse.forEach(() => dir = dir.replace(/\/[^\/]+\/?$/, ""));
          path2 = `${dir}/${relativePath}`.replace(/\/$/, "");
          path2 = path2 || "/";
        } else if (path2.match(/^\//))
          ;
        else {
          const matchingRoute = $routes.find((route3) => route3.meta.name === path2);
          if (matchingRoute)
            path2 = matchingRoute.shortPath;
        }
        return path2;
      }
    };
  }
  var goto = {
    subscribe(listener) {
      const routifyUpdatePage = getContext("routifyupdatepage");
      return derived(url, (url2) => function goto2(path, params, _static, shallow) {
        const href = url2(path, params);
        if (!_static)
          history.pushState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }).subscribe(listener);
    }
  };
  var redirect = {
    subscribe(listener) {
      const routifyUpdatePage = getContext("routifyupdatepage");
      return derived(url, (url2) => function redirect2(path, params, _static, shallow) {
        const href = url2(path, params);
        if (!_static)
          history.replaceState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }).subscribe(listener);
    }
  };
  var _metatags = {
    subscribe(listener) {
      this._origin = this.getOrigin();
      return listener(metatags);
    },
    props: {},
    templates: {},
    services: {
      plain: {propField: "name", valueField: "content"},
      twitter: {propField: "name", valueField: "content"},
      og: {propField: "property", valueField: "content"}
    },
    plugins: [
      {
        name: "applyTemplate",
        condition: () => true,
        action: (prop, value) => {
          const template = _metatags.getLongest(_metatags.templates, prop) || ((x) => x);
          return [prop, template(value)];
        }
      },
      {
        name: "createMeta",
        condition: () => true,
        action(prop, value) {
          _metatags.writeMeta(prop, value);
        }
      },
      {
        name: "createOG",
        condition: (prop) => !prop.match(":"),
        action(prop, value) {
          _metatags.writeMeta(`og:${prop}`, value);
        }
      },
      {
        name: "createTitle",
        condition: (prop) => prop === "title",
        action(prop, value) {
          document.title = value;
        }
      }
    ],
    getLongest(repo, name2) {
      const providers = repo[name2];
      if (providers) {
        const currentPath = get_store_value(route).path;
        const allPaths = Object.keys(repo[name2]);
        const matchingPaths = allPaths.filter((path) => currentPath.includes(path));
        const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0];
        return providers[longestKey];
      }
    },
    writeMeta(prop, value) {
      const head = document.getElementsByTagName("head")[0];
      const match = prop.match(/(.+)\:/);
      const serviceName = match && match[1] || "plain";
      const {propField, valueField} = metatags.services[serviceName] || metatags.services.plain;
      const oldElement = document.querySelector(`meta[${propField}='${prop}']`);
      if (oldElement)
        oldElement.remove();
      const newElement = document.createElement("meta");
      newElement.setAttribute(propField, prop);
      newElement.setAttribute(valueField, value);
      newElement.setAttribute("data-origin", "routify");
      head.appendChild(newElement);
    },
    set(prop, value) {
      if (typeof prop === "string") {
        _metatags.plugins.forEach((plugin) => {
          if (plugin.condition(prop, value))
            [prop, value] = plugin.action(prop, value) || [prop, value];
        });
      }
    },
    clear() {
      const oldElement = document.querySelector(`meta`);
      if (oldElement)
        oldElement.remove();
    },
    template(name2, fn) {
      const origin = _metatags.getOrigin;
      _metatags.templates[name2] = _metatags.templates[name2] || {};
      _metatags.templates[name2][origin] = fn;
    },
    update() {
      Object.keys(_metatags.props).forEach((prop) => {
        let value = _metatags.getLongest(_metatags.props, prop);
        _metatags.plugins.forEach((plugin) => {
          if (plugin.condition(prop, value)) {
            [prop, value] = plugin.action(prop, value) || [prop, value];
          }
        });
      });
    },
    batchedUpdate() {
      if (!_metatags._pendingUpdate) {
        _metatags._pendingUpdate = true;
        setTimeout(() => {
          _metatags._pendingUpdate = false;
          this.update();
        });
      }
    },
    _updateQueued: false,
    _origin: false,
    getOrigin() {
      if (this._origin)
        return this._origin;
      const routifyCtx = getRoutifyContext();
      return routifyCtx && get_store_value(routifyCtx).path || "/";
    },
    _pendingUpdate: false
  };
  var metatags = new Proxy(_metatags, {
    set(target, name2, value, receiver) {
      const {props} = target;
      if (Reflect.has(target, name2))
        Reflect.set(target, name2, value, receiver);
      else {
        props[name2] = props[name2] || {};
        props[name2][target.getOrigin()] = value;
      }
      if (window["routify"].appLoaded)
        target.batchedUpdate();
      return true;
    }
  });
  var file9 = "node_modules/@roxi/routify/runtime/Route.svelte";
  function get_each_context2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[21] = list[i].component;
    child_ctx[22] = list[i].componentFile;
    child_ctx[2] = list[i].decorator;
    child_ctx[1] = list[i].nodes;
    return child_ctx;
  }
  function create_if_block_13(ctx) {
    let each_blocks = [];
    let each_1_lookup = new Map();
    let each_1_anchor;
    let current;
    let each_value = [ctx[4]];
    validate_each_argument(each_value);
    const get_key = (ctx2) => ctx2[7];
    validate_each_keys(ctx, each_value, get_each_context2, get_key);
    for (let i = 0; i < 1; i += 1) {
      let child_ctx = get_each_context2(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
    }
    const block = {
      c: function create2() {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m: function mount(target, anchor) {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].m(target, anchor);
        }
        insert_dev(target, each_1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (dirty & 33554621) {
          each_value = [ctx2[4]];
          validate_each_argument(each_value);
          group_outros();
          validate_each_keys(ctx2, each_value, get_each_context2, get_key);
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block2, each_1_anchor, get_each_context2);
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        for (let i = 0; i < 1; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o: function outro(local) {
        for (let i = 0; i < 1; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d: function destroy(detaching) {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].d(detaching);
        }
        if (detaching)
          detach_dev(each_1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_13.name,
      type: "if",
      source: "(109:0) {#if $context}",
      ctx
    });
    return block;
  }
  function create_if_block_23(ctx) {
    let route_1;
    let current;
    route_1 = new Route({
      props: {
        decorator: ctx[2],
        nodes: ctx[1],
        scoped: {
          ...ctx[0],
          ...ctx[25]
        }
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(route_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(route_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const route_1_changes = {};
        if (dirty & 4)
          route_1_changes.decorator = ctx2[2];
        if (dirty & 16)
          route_1_changes.nodes = ctx2[1];
        if (dirty & 33554433)
          route_1_changes.scoped = {
            ...ctx2[0],
            ...ctx2[25]
          };
        route_1.$set(route_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(route_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(route_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(route_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_23.name,
      type: "if",
      source: "(120:8) {#if component && nodes.length}",
      ctx
    });
    return block;
  }
  function create_default_slot_12(ctx) {
    let if_block_anchor;
    let current;
    let if_block = ctx[21] && ctx[1].length && create_if_block_23(ctx);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[21] && ctx2[1].length) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 16) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_23(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_12.name,
      type: "slot",
      source: "(112:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...node.param || {}}       >",
      ctx
    });
    return block;
  }
  function create_default_slot5(ctx) {
    let switch_instance;
    let t;
    let current;
    const switch_instance_spread_levels = [
      {scoped: ctx[0]},
      {scopedSync: ctx[5]},
      ctx[3].param || {}
    ];
    var switch_value = ctx[22];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {
          default: [
            create_default_slot_12,
            ({scoped: scopeToChild, decorator}) => ({25: scopeToChild, 2: decorator}),
            ({scoped: scopeToChild, decorator}) => (scopeToChild ? 33554432 : 0) | (decorator ? 4 : 0)
          ]
        },
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        t = space();
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, t, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty & 41 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 1 && {scoped: ctx2[0]},
          dirty & 32 && {scopedSync: ctx2[5]},
          dirty & 8 && get_spread_object(ctx2[3].param || {})
        ]) : {};
        if (dirty & 100663317) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[22])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, t.parentNode, t);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (switch_instance)
          destroy_component(switch_instance, detaching);
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot5.name,
      type: "slot",
      source: "(111:4) <svelte:component this={decorator} {scoped}>",
      ctx
    });
    return block;
  }
  function create_each_block2(key_1, ctx) {
    let first;
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      return {
        props: {
          scoped: ctx2[0],
          $$slots: {default: [create_default_slot5]},
          $$scope: {ctx: ctx2}
        },
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    const block = {
      key: key_1,
      first: null,
      c: function create2() {
        first = empty();
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
        this.first = first;
      },
      m: function mount(target, anchor) {
        insert_dev(target, first, anchor);
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(new_ctx, dirty) {
        ctx = new_ctx;
        const switch_instance_changes = {};
        if (dirty & 1)
          switch_instance_changes.scoped = ctx[0];
        if (dirty & 67108925) {
          switch_instance_changes.$$scope = {dirty, ctx};
        }
        if (switch_value !== (switch_value = ctx[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(first);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_each_block2.name,
      type: "each",
      source: "(110:2) {#each [$context] as { component, componentFile, decorator, nodes }",
      ctx
    });
    return block;
  }
  function create_if_block$12(ctx) {
    let div;
    let mounted;
    let dispose;
    const block = {
      c: function create2() {
        div = element("div");
        set_style(div, "display", "contents");
        add_location(div, file9, 133, 2, 4153);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (!mounted) {
          dispose = action_destroyer(ctx[10].call(null, div));
          mounted = true;
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block$12.name,
      type: "if",
      source: "(133:0) {#if !parentNode}",
      ctx
    });
    return block;
  }
  function create_fragment$34(ctx) {
    let t;
    let if_block1_anchor;
    let current;
    let if_block0 = ctx[4] && create_if_block_13(ctx);
    let if_block1 = !ctx[6] && create_if_block$12(ctx);
    const block = {
      c: function create2() {
        if (if_block0)
          if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (ctx2[4]) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & 16) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_13(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t.parentNode, t);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (!ctx2[6]) {
          if (if_block1)
            ;
          else {
            if_block1 = create_if_block$12(ctx2);
            if_block1.c();
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$34.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$34($$self, $$props, $$invalidate) {
    let id;
    let $context;
    let $route;
    let $parentContext;
    let $routes;
    validate_store(route, "route");
    component_subscribe($$self, route, ($$value) => $$invalidate(14, $route = $$value));
    validate_store(routes$1, "routes");
    component_subscribe($$self, routes$1, ($$value) => $$invalidate(16, $routes = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Route", slots, []);
    let {nodes = []} = $$props;
    let {scoped = {}} = $$props;
    let {decorator = void 0} = $$props;
    let node = null;
    let remainingNodes = null;
    let scopedSync = {};
    let parentNode;
    let invalidate = 1;
    const context = writable(null);
    validate_store(context, "context");
    component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
    const parentContext = getContext("routify") || rootContext;
    validate_store(parentContext, "parentContext");
    component_subscribe($$self, parentContext, (value) => $$invalidate(15, $parentContext = value));
    const setParentNode = (el) => $$invalidate(6, parentNode = el.parentNode);
    setContext("routify", context);
    let lastNodes = [];
    function setComponent(node2) {
      let PendingComponent = node2.component();
      if (PendingComponent instanceof Promise)
        PendingComponent.then(onComponentLoaded);
      else
        onComponentLoaded(PendingComponent);
    }
    function onComponentLoaded(componentFile) {
      $$invalidate(5, scopedSync = {...scoped});
      const ctx = {
        ...$context,
        nodes: remainingNodes,
        decorator: decorator || Noop,
        layout: node.isLayout ? node : $parentContext.layout,
        component: node,
        route: $route,
        routes: $routes,
        componentFile,
        parentNode: parentNode || $parentContext.parentNode
      };
      context.set(ctx);
      set_store_value(parentContext, $parentContext.child = node, $parentContext);
      if (remainingNodes.length === 0)
        onLastComponentLoaded();
    }
    async function onLastComponentLoaded() {
      await new Promise((resolve) => setTimeout(resolve));
      const isOnCurrentRoute = $context.component.path === $route.path;
      if (!window["routify"].stopAutoReady && isOnCurrentRoute)
        onPageLoaded({
          page: $context.component,
          metatags,
          afterPageLoad,
          parentNode
        });
    }
    function getID({meta, path, param, params}) {
      return JSON.stringify({
        path,
        invalidate,
        param: (meta["param-is-page"] || meta["slug-is-page"]) && param,
        queryParams: meta["query-params-is-page"] && params
      });
    }
    const writable_props = ["nodes", "scoped", "decorator"];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Route> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("nodes" in $$props2)
        $$invalidate(1, nodes = $$props2.nodes);
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("decorator" in $$props2)
        $$invalidate(2, decorator = $$props2.decorator);
    };
    $$self.$capture_state = () => ({
      suppressComponentWarnings,
      Noop,
      getContext,
      setContext,
      tick,
      writable,
      metatags,
      afterPageLoad,
      route,
      routes: routes$1,
      rootContext,
      handleScroll,
      onPageLoaded,
      nodes,
      scoped,
      decorator,
      node,
      remainingNodes,
      scopedSync,
      parentNode,
      invalidate,
      context,
      parentContext,
      setParentNode,
      lastNodes,
      setComponent,
      onComponentLoaded,
      onLastComponentLoaded,
      getID,
      id,
      $context,
      $route,
      $parentContext,
      $routes
    });
    $$self.$inject_state = ($$props2) => {
      if ("nodes" in $$props2)
        $$invalidate(1, nodes = $$props2.nodes);
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("decorator" in $$props2)
        $$invalidate(2, decorator = $$props2.decorator);
      if ("node" in $$props2)
        $$invalidate(3, node = $$props2.node);
      if ("remainingNodes" in $$props2)
        remainingNodes = $$props2.remainingNodes;
      if ("scopedSync" in $$props2)
        $$invalidate(5, scopedSync = $$props2.scopedSync);
      if ("parentNode" in $$props2)
        $$invalidate(6, parentNode = $$props2.parentNode);
      if ("invalidate" in $$props2)
        $$invalidate(11, invalidate = $$props2.invalidate);
      if ("lastNodes" in $$props2)
        $$invalidate(12, lastNodes = $$props2.lastNodes);
      if ("id" in $$props2)
        $$invalidate(7, id = $$props2.id);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 6146) {
        if (lastNodes !== nodes) {
          $$invalidate(12, lastNodes = nodes);
          $$invalidate(3, [node, ...remainingNodes] = [...nodes], node);
          $$invalidate(3, node.api.reset = () => $$invalidate(11, invalidate++, invalidate), node);
        }
      }
      if ($$self.$$.dirty & 8) {
        setComponent(node);
      }
      if ($$self.$$.dirty & 2064) {
        $$invalidate(7, id = $context && invalidate && getID($context.component));
      }
      if ($$self.$$.dirty & 16) {
        $context && suppressComponentWarnings($context, tick);
      }
    };
    return [
      scoped,
      nodes,
      decorator,
      node,
      $context,
      scopedSync,
      parentNode,
      id,
      context,
      parentContext,
      setParentNode,
      invalidate,
      lastNodes
    ];
  }
  var Route = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$34, create_fragment$34, safe_not_equal, {nodes: 1, scoped: 0, decorator: 2});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Route",
        options,
        id: create_fragment$34.name
      });
    }
    get nodes() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nodes(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get scoped() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set scoped(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get decorator() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set decorator(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function init(routes2, callback) {
    let lastRoute = false;
    function updatePage(proxyToUrl, shallow) {
      const url2 = proxyToUrl || currentLocation().fullpath;
      const route$1 = urlToRoute(url2);
      if (route$1.redirectTo) {
        history.replaceStateNative({}, null, route$1.redirectTo);
        delete route$1.redirectTo;
      }
      const currentRoute = shallow && urlToRoute(currentLocation().fullpath, routes2);
      const contextRoute = currentRoute || route$1;
      const nodes = [...contextRoute.layouts, route$1];
      if (lastRoute)
        delete lastRoute.last;
      route$1.last = lastRoute;
      lastRoute = route$1;
      if (!proxyToUrl)
        urlRoute.set(route$1);
      route.set(route$1);
      route$1.api.preload().then(() => {
        isChangingPage.set(true);
        callback(nodes);
      });
    }
    const destroy = createEventListeners(updatePage);
    return {updatePage, destroy};
  }
  function createEventListeners(updatePage) {
    ["pushState", "replaceState"].forEach((eventName) => {
      if (!history[eventName + "Native"])
        history[eventName + "Native"] = history[eventName];
      history[eventName] = async function(state = {}, title, url2) {
        const currentUrl = location.pathname + location.search + location.hash;
        if (url2 === currentUrl)
          return false;
        const {id, path, params} = get_store_value(route);
        state = {id, path, params, ...state};
        const event = new Event(eventName.toLowerCase());
        Object.assign(event, {state, title, url: url2});
        const route$1 = await runHooksBeforeUrlChange(event, url2);
        if (route$1) {
          history[eventName + "Native"].apply(this, [state, title, url2]);
          return dispatchEvent(event);
        }
      };
    });
    let _ignoreNextPop = false;
    const listeners = {
      click: handleClick,
      pushstate: () => updatePage(),
      replacestate: () => updatePage(),
      popstate: async (event) => {
        if (_ignoreNextPop)
          _ignoreNextPop = false;
        else {
          if (await runHooksBeforeUrlChange(event, currentLocation().fullpath)) {
            updatePage();
          } else {
            _ignoreNextPop = true;
            event.preventDefault();
            history.go(1);
          }
        }
      }
    };
    Object.entries(listeners).forEach((args) => addEventListener(...args));
    const unregister = () => {
      Object.entries(listeners).forEach((args) => removeEventListener(...args));
    };
    return unregister;
  }
  function handleClick(event) {
    const el = event.target.closest("a");
    const href = el && el.href;
    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.defaultPrevented)
      return;
    if (!href || el.target || el.host !== location.host)
      return;
    const url2 = new URL(href);
    const relativeUrl = url2.pathname + url2.search + url2.hash;
    event.preventDefault();
    history.pushState({}, "", relativeUrl);
  }
  async function runHooksBeforeUrlChange(event, url2) {
    const route2 = urlToRoute(url2).api;
    for (const hook of beforeUrlChange._hooks.filter(Boolean)) {
      const result = await hook(event, route2, {url: url2});
      if (!result)
        return false;
    }
    return true;
  }
  var {Object: Object_1} = globals;
  function create_if_block6(ctx) {
    let route_1;
    let current;
    route_1 = new Route({
      props: {nodes: ctx[0]},
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(route_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(route_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const route_1_changes = {};
        if (dirty & 1)
          route_1_changes.nodes = ctx2[0];
        route_1.$set(route_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(route_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(route_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(route_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block6.name,
      type: "if",
      source: "(58:0) {#if nodes && $route !== null}",
      ctx
    });
    return block;
  }
  function create_fragment$27(ctx) {
    let t;
    let prefetcher;
    let current;
    let if_block = ctx[0] && ctx[1] !== null && create_if_block6(ctx);
    prefetcher = new Prefetcher({$$inline: true});
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        t = space();
        create_component(prefetcher.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        mount_component(prefetcher, target, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (ctx2[0] && ctx2[1] !== null) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 3) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block6(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        transition_in(prefetcher.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        transition_out(prefetcher.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(t);
        destroy_component(prefetcher, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$27.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$26($$self, $$props, $$invalidate) {
    let $route;
    validate_store(route, "route");
    component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Router", slots, []);
    let {routes: routes2} = $$props;
    let {config = {}} = $$props;
    let nodes;
    let navigator2;
    window.routify = window.routify || {};
    window.routify.inBrowser = !window.navigator.userAgent.match("jsdom");
    Object.assign(defaultConfig, config);
    const updatePage = (...args) => navigator2 && navigator2.updatePage(...args);
    setContext("routifyupdatepage", updatePage);
    const callback = (res) => $$invalidate(0, nodes = res);
    const cleanup = () => {
      if (!navigator2)
        return;
      navigator2.destroy();
      navigator2 = null;
    };
    let initTimeout = null;
    const doInit = () => {
      clearTimeout(initTimeout);
      initTimeout = setTimeout(() => {
        cleanup();
        navigator2 = init(routes2, callback);
        routes$1.set(routes2);
        navigator2.updatePage();
      });
    };
    onDestroy(cleanup);
    const writable_props = ["routes", "config"];
    Object_1.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Router> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("routes" in $$props2)
        $$invalidate(2, routes2 = $$props2.routes);
      if ("config" in $$props2)
        $$invalidate(3, config = $$props2.config);
    };
    $$self.$capture_state = () => ({
      setContext,
      onDestroy,
      Route,
      Prefetcher,
      init,
      route,
      routesStore: routes$1,
      defaultConfig,
      routes: routes2,
      config,
      nodes,
      navigator: navigator2,
      updatePage,
      callback,
      cleanup,
      initTimeout,
      doInit,
      $route
    });
    $$self.$inject_state = ($$props2) => {
      if ("routes" in $$props2)
        $$invalidate(2, routes2 = $$props2.routes);
      if ("config" in $$props2)
        $$invalidate(3, config = $$props2.config);
      if ("nodes" in $$props2)
        $$invalidate(0, nodes = $$props2.nodes);
      if ("navigator" in $$props2)
        navigator2 = $$props2.navigator;
      if ("initTimeout" in $$props2)
        initTimeout = $$props2.initTimeout;
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        if (routes2)
          doInit();
      }
    };
    return [nodes, $route, routes2, config];
  }
  var Router = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$26, create_fragment$27, safe_not_equal, {routes: 2, config: 3});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Router",
        options,
        id: create_fragment$27.name
      });
      const {ctx} = this.$$;
      const props = options.props || {};
      if (ctx[2] === void 0 && !("routes" in props)) {
        console.warn("<Router> was created without expected prop 'routes'");
      }
    }
    get routes() {
      throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set routes(value) {
      throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get config() {
      throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set config(value) {
      throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function createNodeMiddleware(fn) {
    const inner = async function execute(payload) {
      return await nodeMiddleware(fn, {
        file: payload.tree,
        state: {treePayload: payload},
        scope: {}
      });
    };
    inner.sync = function executeSync(payload) {
      return nodeMiddlewareSync(fn, {
        file: payload.tree,
        state: {treePayload: payload},
        scope: {}
      });
    };
    return inner;
  }
  async function nodeMiddleware(fn, payload) {
    const _file = await fn(payload);
    if (_file === false)
      return false;
    const file10 = _file || payload.file;
    if (file10.children) {
      const children2 = await Promise.all(file10.children.map(async (_file2) => nodeMiddleware(fn, {
        state: payload.state,
        scope: clone(payload.scope || {}),
        parent: payload.file,
        file: await _file2
      })));
      file10.children = children2.filter(Boolean);
    }
    return file10;
  }
  function nodeMiddlewareSync(fn, payload) {
    const _file = fn(payload);
    if (_file === false)
      return false;
    const file10 = _file || payload.file;
    if (file10.children) {
      const children2 = file10.children.map((_file2) => nodeMiddlewareSync(fn, {
        state: payload.state,
        scope: clone(payload.scope || {}),
        parent: payload.file,
        file: _file2
      }));
      file10.children = children2.filter(Boolean);
    }
    return file10;
  }
  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var setRegex = createNodeMiddleware(({file: file10}) => {
    if (file10.isPage || file10.isFallback)
      file10.regex = pathToRegex(file10.path, file10.isFallback);
  });
  var setParamKeys = createNodeMiddleware(({file: file10}) => {
    file10.paramKeys = pathToParamKeys(file10.path);
  });
  var setShortPath = createNodeMiddleware(({file: file10}) => {
    if (file10.isFallback || file10.isIndex)
      file10.shortPath = file10.path.replace(/\/[^/]+$/, "");
    else
      file10.shortPath = file10.path;
  });
  var setRank = createNodeMiddleware(({file: file10}) => {
    file10.ranking = pathToRank(file10);
  });
  var addMetaChildren = createNodeMiddleware(({file: file10}) => {
    const node = file10;
    const metaChildren = file10.meta && file10.meta.children || [];
    if (metaChildren.length) {
      node.children = node.children || [];
      node.children.push(...metaChildren.map((meta) => ({isMeta: true, ...meta, meta})));
    }
  });
  var setIsIndexable = createNodeMiddleware((payload) => {
    const {file: file10} = payload;
    const {isFallback, meta} = file10;
    const isDynamic = file10.path.split("/").pop().startsWith(":");
    const isIndex = file10.path.endsWith("/index");
    const isIndexed = meta.index || meta.index === 0;
    const isHidden = meta.index === false;
    file10.isIndexable = isIndexed || !isFallback && !isDynamic && !isIndex && !isHidden;
    file10.isNonIndexable = !file10.isIndexable;
  });
  var assignRelations = createNodeMiddleware(({file: file10, parent: parent2}) => {
    Object.defineProperty(file10, "parent", {get: () => parent2});
    Object.defineProperty(file10, "nextSibling", {get: () => _getSibling(file10, 1)});
    Object.defineProperty(file10, "prevSibling", {get: () => _getSibling(file10, -1)});
    Object.defineProperty(file10, "lineage", {get: () => _getLineage(parent2)});
  });
  function _getLineage(node, lineage = []) {
    if (node) {
      lineage.unshift(node);
      _getLineage(node.parent, lineage);
    }
    return lineage;
  }
  function _getSibling(file10, direction) {
    if (!file10.root) {
      const siblings = file10.parent.children.filter((c) => c.isIndexable);
      const index = siblings.indexOf(file10);
      return siblings[index + direction];
    }
  }
  var assignIndex = createNodeMiddleware(({file: file10, parent: parent2}) => {
    if (file10.isIndex)
      Object.defineProperty(parent2, "index", {get: () => file10});
  });
  var assignLayout = createNodeMiddleware(({file: file10, scope}) => {
    Object.defineProperty(file10, "layouts", {get: () => getLayouts(file10)});
    function getLayouts(file11) {
      if (!file11.isLayout && file11.meta.reset)
        return [];
      const {parent: parent2} = file11;
      const layout = parent2 && parent2.component && parent2;
      const isReset = layout && (layout.isReset || layout.meta.reset);
      const layouts = parent2 && !isReset && getLayouts(parent2) || [];
      if (layout)
        layouts.push(layout);
      return layouts;
    }
  });
  var createFlatList = (treePayload) => {
    createNodeMiddleware((payload) => {
      if (payload.file.isPage || payload.file.isFallback)
        payload.state.treePayload.routes.push(payload.file);
    }).sync(treePayload);
    treePayload.routes.sort((c, p) => c.ranking >= p.ranking ? -1 : 1);
  };
  var setPrototype = createNodeMiddleware(({file: file10}) => {
    const Prototype = file10.root ? Root : file10.children ? file10.isPage ? PageDir : Dir : file10.isReset ? Reset : file10.isLayout ? Layout : file10.isFallback ? Fallback : Page;
    Object.setPrototypeOf(file10, Prototype.prototype);
    function Layout() {
    }
    function Dir() {
    }
    function Fallback() {
    }
    function Page() {
    }
    function PageDir() {
    }
    function Reset() {
    }
    function Root() {
    }
  });
  var miscPlugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setRegex,
    setParamKeys,
    setShortPath,
    setRank,
    addMetaChildren,
    setIsIndexable,
    assignRelations,
    assignIndex,
    assignLayout,
    createFlatList,
    setPrototype
  });
  var defaultNode = {
    isDir: false,
    ext: "svelte",
    isLayout: false,
    isReset: false,
    isIndex: false,
    isFallback: false,
    isPage: false,
    ownMeta: {},
    meta: {
      recursive: true,
      preload: false,
      prerender: true
    },
    id: "__fallback"
  };
  function restoreDefaults(node) {
    Object.entries(defaultNode).forEach(([key, value]) => {
      if (typeof node[key] === "undefined")
        node[key] = value;
    });
    if (node.children)
      node.children = node.children.map(restoreDefaults);
    return node;
  }
  var assignAPI = createNodeMiddleware(({file: file10}) => {
    file10.api = new ClientApi(file10);
  });
  var ClientApi = class {
    constructor(file10) {
      this.__file = file10;
      Object.defineProperty(this, "__file", {enumerable: false});
      this.isMeta = !!file10.isMeta;
      this.path = file10.path;
      this.title = _prettyName(file10);
      this.meta = file10.meta;
    }
    get parent() {
      return !this.__file.root && this.__file.parent.api;
    }
    get children() {
      return (this.__file.children || this.__file.isLayout && this.__file.parent.children || []).filter((c) => !c.isNonIndexable).sort((a, b) => {
        if (a.isMeta && b.isMeta)
          return 0;
        a = (a.meta.index || a.meta.title || a.path).toString();
        b = (b.meta.index || b.meta.title || b.path).toString();
        return a.localeCompare(b, void 0, {numeric: true, sensitivity: "base"});
      }).map(({api}) => api);
    }
    get next() {
      return _navigate(this, 1);
    }
    get prev() {
      return _navigate(this, -1);
    }
    async preload() {
      const filePromises = [
        ...this.__file.layouts,
        this.__file,
        this.index && this.index.__file
      ].filter(Boolean).map((file10) => file10.component());
      await Promise.all(filePromises);
    }
    get component() {
      return this.__file.component ? this.__file.component() : this.__file.index ? this.__file.index.component() : false;
    }
    get componentWithIndex() {
      return new Promise((resolve) => Promise.all([
        this.component,
        this.index && this.index.component
      ]).then((res) => resolve(res)));
    }
    get index() {
      const child = this.__file.children && this.__file.children.find((child2) => child2.isIndex);
      return child && child.api;
    }
  };
  function _navigate(node, direction) {
    if (!node.__file.root) {
      const siblings = node.parent.children;
      const index = siblings.indexOf(node);
      return node.parent.children[index + direction];
    }
  }
  function _prettyName(file10) {
    if (typeof file10.meta.title !== "undefined")
      return file10.meta.title;
    else
      return (file10.shortPath || file10.path).split("/").pop().replace(/-/g, " ");
  }
  var plugins = {
    ...miscPlugins,
    restoreDefaults: ({tree: tree2}) => restoreDefaults(tree2),
    assignAPI
  };
  function buildClientTree(tree2) {
    const order = [
      "restoreDefaults",
      "setParamKeys",
      "setRegex",
      "setShortPath",
      "setRank",
      "assignLayout",
      "setPrototype",
      "addMetaChildren",
      "assignRelations",
      "setIsIndexable",
      "assignIndex",
      "assignAPI",
      "createFlatList"
    ];
    const payload = {tree: tree2, routes: []};
    for (let name2 of order) {
      const fn = plugins[name2].sync || plugins[name2];
      fn(payload);
    }
    return payload;
  }

  // dist/build/index.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder(component) {
    let $on;
    let events3 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events3.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex);
        const newModifierMatch = eventType.match(newModifierRegex);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events3.length; i++) {
        $on(events3[i][0], events3[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap(classObj) {
    return Object.entries(classObj).filter(([name2, value]) => name2 !== "" && value).map(([name2]) => name2).join(" ");
  }
  function create_default_slot(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$3(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$3.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance$3($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals.contexts;
    const props = internals.props;
    let {component = internals.component} = $$props;
    Object.entries(internals.classMap).forEach(([name2, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name2] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment$3.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults$4 = {...internals};
  function classAdderBuilder(props) {
    function Component(...args) {
      Object.assign(internals, defaults$4, props);
      return new ClassAdder(...args);
    }
    Component.prototype = ClassAdder;
    if (ClassAdder.$$render) {
      Component.$$render = (...args) => Object.assign(internals, defaults$4, props) && ClassAdder.$$render(...args);
    }
    if (ClassAdder.render) {
      Component.render = (...args) => Object.assign(internals, defaults$4, props) && ClassAdder.render(...args);
    }
    return Component;
  }
  function dispatch(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  function useActions(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file$2 = "node_modules/@smui/common/Div.svelte";
  function create_fragment$2(ctx) {
    let div;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let div_levels = [ctx[3]];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$2, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[7](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
            action_destroyer(ctx[2].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$2.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$2($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Div", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      div_binding
    ];
  }
  var Div = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Div",
        options,
        id: create_fragment$2.name
      });
    }
    get use() {
      throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var supportsCssVariables_;
  function supportsCssVariables(windowObj, forceRefresh) {
    if (forceRefresh === void 0) {
      forceRefresh = false;
    }
    var CSS = windowObj.CSS;
    var supportsCssVars = supportsCssVariables_;
    if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
      return supportsCssVariables_;
    }
    var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
    if (!supportsFunctionPresent) {
      return false;
    }
    var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
    var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
    supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVars;
    }
    return supportsCssVars;
  }
  function getNormalizedEventCoords(evt, pageOffset, clientRect) {
    if (!evt) {
      return {x: 0, y: 0};
    }
    var x = pageOffset.x, y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY;
    if (evt.type === "touchstart") {
      var touchEvent = evt;
      normalizedX = touchEvent.changedTouches[0].pageX - documentX;
      normalizedY = touchEvent.changedTouches[0].pageY - documentY;
    } else {
      var mouseEvent = evt;
      normalizedX = mouseEvent.pageX - documentX;
      normalizedY = mouseEvent.pageY - documentY;
    }
    return {x: normalizedX, y: normalizedY};
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {value: o && o[i++], done: !o};
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFoundation = function() {
    function MDCFoundation3(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation3, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation3.prototype.init = function() {
    };
    MDCFoundation3.prototype.destroy = function() {
    };
    return MDCFoundation3;
  }();
  /**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function applyPassive$1(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    return supportsPassiveOption(globalObj) ? {passive: true} : false;
  }
  function supportsPassiveOption(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    var passiveSupported = false;
    try {
      var options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      var handler = function() {
      };
      globalObj.document.addEventListener("test", handler, options);
      globalObj.document.removeEventListener("test", handler, options);
    } catch (err) {
      passiveSupported = false;
    }
    return passiveSupported;
  }
  var events = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    applyPassive: applyPassive$1
  });
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function closest(element2, selector) {
    if (element2.closest) {
      return element2.closest(selector);
    }
    var el = element2;
    while (el) {
      if (matches$1(el, selector)) {
        return el;
      }
      el = el.parentElement;
    }
    return null;
  }
  function matches$1(element2, selector) {
    var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
    return nativeMatches.call(element2, selector);
  }
  function estimateScrollWidth(element2) {
    var htmlEl = element2;
    if (htmlEl.offsetParent !== null) {
      return htmlEl.scrollWidth;
    }
    var clone2 = htmlEl.cloneNode(true);
    clone2.style.setProperty("position", "absolute");
    clone2.style.setProperty("transform", "translate(-9999px, -9999px)");
    document.documentElement.appendChild(clone2);
    var scrollWidth = clone2.scrollWidth;
    document.documentElement.removeChild(clone2);
    return scrollWidth;
  }
  var ponyfill = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    closest,
    matches: matches$1,
    estimateScrollWidth
  });
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses = {
    BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
    FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
    FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
    ROOT: "mdc-ripple-upgraded",
    UNBOUNDED: "mdc-ripple-upgraded--unbounded"
  };
  var strings = {
    VAR_FG_SCALE: "--mdc-ripple-fg-scale",
    VAR_FG_SIZE: "--mdc-ripple-fg-size",
    VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
    VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
    VAR_LEFT: "--mdc-ripple-left",
    VAR_TOP: "--mdc-ripple-top"
  };
  var numbers = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: 0.6,
    PADDING: 10,
    TAP_DELAY_MS: 300
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ACTIVATION_EVENT_TYPES = [
    "touchstart",
    "pointerdown",
    "mousedown",
    "keydown"
  ];
  var POINTER_DEACTIVATION_EVENT_TYPES = [
    "touchend",
    "pointerup",
    "mouseup",
    "contextmenu"
  ];
  var activatedTargets = [];
  var MDCRippleFoundation = function(_super) {
    __extends(MDCRippleFoundation3, _super);
    function MDCRippleFoundation3(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation3.defaultAdapter), adapter)) || this;
      _this.activationAnimationHasEnded_ = false;
      _this.activationTimer_ = 0;
      _this.fgDeactivationRemovalTimer_ = 0;
      _this.fgScale_ = "0";
      _this.frame_ = {width: 0, height: 0};
      _this.initialSize_ = 0;
      _this.layoutFrame_ = 0;
      _this.maxRadius_ = 0;
      _this.unboundedCoords_ = {left: 0, top: 0};
      _this.activationState_ = _this.defaultActivationState_();
      _this.activationTimerCallback_ = function() {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };
      _this.activateHandler_ = function(e) {
        return _this.activate_(e);
      };
      _this.deactivateHandler_ = function() {
        return _this.deactivate_();
      };
      _this.focusHandler_ = function() {
        return _this.handleFocus();
      };
      _this.blurHandler_ = function() {
        return _this.handleBlur();
      };
      _this.resizeHandler_ = function() {
        return _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCRippleFoundation3, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          browserSupportsCssVars: function() {
            return true;
          },
          computeBoundingRect: function() {
            return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
          },
          containsEventTarget: function() {
            return true;
          },
          deregisterDocumentInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          deregisterResizeHandler: function() {
            return void 0;
          },
          getWindowPageOffset: function() {
            return {x: 0, y: 0};
          },
          isSurfaceActive: function() {
            return true;
          },
          isSurfaceDisabled: function() {
            return true;
          },
          isUnbounded: function() {
            return true;
          },
          registerDocumentInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          registerResizeHandler: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          updateCssVariable: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRippleFoundation3.prototype.init = function() {
      var _this = this;
      var supportsPressRipple = this.supportsPressRipple_();
      this.registerRootHandlers_(supportsPressRipple);
      if (supportsPressRipple) {
        var _a2 = MDCRippleFoundation3.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.addClass(ROOT_1);
          if (_this.adapter.isUnbounded()) {
            _this.adapter.addClass(UNBOUNDED_1);
            _this.layoutInternal_();
          }
        });
      }
    };
    MDCRippleFoundation3.prototype.destroy = function() {
      var _this = this;
      if (this.supportsPressRipple_()) {
        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          this.adapter.removeClass(MDCRippleFoundation3.cssClasses.FG_ACTIVATION);
        }
        if (this.fgDeactivationRemovalTimer_) {
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.fgDeactivationRemovalTimer_ = 0;
          this.adapter.removeClass(MDCRippleFoundation3.cssClasses.FG_DEACTIVATION);
        }
        var _a2 = MDCRippleFoundation3.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.removeClass(ROOT_2);
          _this.adapter.removeClass(UNBOUNDED_2);
          _this.removeCssVars_();
        });
      }
      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();
    };
    MDCRippleFoundation3.prototype.activate = function(evt) {
      this.activate_(evt);
    };
    MDCRippleFoundation3.prototype.deactivate = function() {
      this.deactivate_();
    };
    MDCRippleFoundation3.prototype.layout = function() {
      var _this = this;
      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }
      this.layoutFrame_ = requestAnimationFrame(function() {
        _this.layoutInternal_();
        _this.layoutFrame_ = 0;
      });
    };
    MDCRippleFoundation3.prototype.setUnbounded = function(unbounded) {
      var UNBOUNDED = MDCRippleFoundation3.cssClasses.UNBOUNDED;
      if (unbounded) {
        this.adapter.addClass(UNBOUNDED);
      } else {
        this.adapter.removeClass(UNBOUNDED);
      }
    };
    MDCRippleFoundation3.prototype.handleFocus = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.addClass(MDCRippleFoundation3.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation3.prototype.handleBlur = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.removeClass(MDCRippleFoundation3.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation3.prototype.supportsPressRipple_ = function() {
      return this.adapter.browserSupportsCssVars();
    };
    MDCRippleFoundation3.prototype.defaultActivationState_ = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: false,
        isActivated: false,
        isProgrammatic: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false
      };
    };
    MDCRippleFoundation3.prototype.registerRootHandlers_ = function(supportsPressRipple) {
      var _this = this;
      if (supportsPressRipple) {
        ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
          _this.adapter.registerInteractionHandler(evtType, _this.activateHandler_);
        });
        if (this.adapter.isUnbounded()) {
          this.adapter.registerResizeHandler(this.resizeHandler_);
        }
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler_);
      this.adapter.registerInteractionHandler("blur", this.blurHandler_);
    };
    MDCRippleFoundation3.prototype.registerDeactivationHandlers_ = function(evt) {
      var _this = this;
      if (evt.type === "keydown") {
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
          _this.adapter.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
        });
      }
    };
    MDCRippleFoundation3.prototype.deregisterRootHandlers_ = function() {
      var _this = this;
      ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.deregisterInteractionHandler(evtType, _this.activateHandler_);
      });
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler_);
      this.adapter.deregisterInteractionHandler("blur", this.blurHandler_);
      if (this.adapter.isUnbounded()) {
        this.adapter.deregisterResizeHandler(this.resizeHandler_);
      }
    };
    MDCRippleFoundation3.prototype.deregisterDeactivationHandlers_ = function() {
      var _this = this;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
      });
    };
    MDCRippleFoundation3.prototype.removeCssVars_ = function() {
      var _this = this;
      var rippleStrings = MDCRippleFoundation3.strings;
      var keys = Object.keys(rippleStrings);
      keys.forEach(function(key) {
        if (key.indexOf("VAR_") === 0) {
          _this.adapter.updateCssVariable(rippleStrings[key], null);
        }
      });
    };
    MDCRippleFoundation3.prototype.activate_ = function(evt) {
      var _this = this;
      if (this.adapter.isSurfaceDisabled()) {
        return;
      }
      var activationState = this.activationState_;
      if (activationState.isActivated) {
        return;
      }
      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
      if (isSameInteraction) {
        return;
      }
      activationState.isActivated = true;
      activationState.isProgrammatic = evt === void 0;
      activationState.activationEvent = evt;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
      var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
        return _this.adapter.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        this.resetActivationState_();
        return;
      }
      if (evt !== void 0) {
        activatedTargets.push(evt.target);
        this.registerDeactivationHandlers_(evt);
      }
      activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
      if (activationState.wasElementMadeActive) {
        this.animateActivation_();
      }
      requestAnimationFrame(function() {
        activatedTargets = [];
        if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
          activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
          if (activationState.wasElementMadeActive) {
            _this.animateActivation_();
          }
        }
        if (!activationState.wasElementMadeActive) {
          _this.activationState_ = _this.defaultActivationState_();
        }
      });
    };
    MDCRippleFoundation3.prototype.checkElementMadeActive_ = function(evt) {
      return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
    };
    MDCRippleFoundation3.prototype.animateActivation_ = function() {
      var _this = this;
      var _a2 = MDCRippleFoundation3.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
      var _b2 = MDCRippleFoundation3.cssClasses, FG_DEACTIVATION = _b2.FG_DEACTIVATION, FG_ACTIVATION = _b2.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation3.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal_();
      var translateStart = "";
      var translateEnd = "";
      if (!this.adapter.isUnbounded()) {
        var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
        translateStart = startPoint.x + "px, " + startPoint.y + "px";
        translateEnd = endPoint.x + "px, " + endPoint.y + "px";
      }
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter.removeClass(FG_DEACTIVATION);
      this.adapter.computeBoundingRect();
      this.adapter.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function() {
        return _this.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation3.prototype.getFgTranslationCoordinates_ = function() {
      var _a2 = this.activationState_, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
      var startPoint;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      }
      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };
      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };
      return {startPoint, endPoint};
    };
    MDCRippleFoundation3.prototype.runDeactivationUXLogicIfReady_ = function() {
      var _this = this;
      var FG_DEACTIVATION = MDCRippleFoundation3.cssClasses.FG_DEACTIVATION;
      var _a2 = this.activationState_, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;
      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function() {
          _this.adapter.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    };
    MDCRippleFoundation3.prototype.rmBoundedActivationClasses_ = function() {
      var FG_ACTIVATION = MDCRippleFoundation3.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter.computeBoundingRect();
    };
    MDCRippleFoundation3.prototype.resetActivationState_ = function() {
      var _this = this;
      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_();
      setTimeout(function() {
        return _this.previousActivationEvent_ = void 0;
      }, MDCRippleFoundation3.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation3.prototype.deactivate_ = function() {
      var _this = this;
      var activationState = this.activationState_;
      if (!activationState.isActivated) {
        return;
      }
      var state = __assign({}, activationState);
      if (activationState.isProgrammatic) {
        requestAnimationFrame(function() {
          return _this.animateDeactivation_(state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function() {
          _this.activationState_.hasDeactivationUXRun = true;
          _this.animateDeactivation_(state);
          _this.resetActivationState_();
        });
      }
    };
    MDCRippleFoundation3.prototype.animateDeactivation_ = function(_a2) {
      var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    };
    MDCRippleFoundation3.prototype.layoutInternal_ = function() {
      var _this = this;
      this.frame_ = this.adapter.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width);
      var getBoundedRadius = function() {
        var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation3.numbers.PADDING;
      };
      this.maxRadius_ = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
      var initialSize = Math.floor(maxDim * MDCRippleFoundation3.numbers.INITIAL_ORIGIN_SCALE);
      if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
        this.initialSize_ = initialSize - 1;
      } else {
        this.initialSize_ = initialSize;
      }
      this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
      this.updateLayoutCssVars_();
    };
    MDCRippleFoundation3.prototype.updateLayoutCssVars_ = function() {
      var _a2 = MDCRippleFoundation3.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
      this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
      this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
      if (this.adapter.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };
        this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
        this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
      }
    };
    return MDCRippleFoundation3;
  }(MDCFoundation);
  var {applyPassive} = events;
  var {matches} = ponyfill;
  function Ripple(node, {
    ripple = true,
    surface = false,
    unbounded = false,
    disabled = false,
    color = null,
    active: active2 = null,
    eventTarget = null,
    activeTarget = null,
    addClass = (className) => node.classList.add(className),
    removeClass = (className) => node.classList.remove(className),
    addStyle = (name2, value) => node.style.setProperty(name2, value),
    initPromise = Promise.resolve()
  } = {}) {
    let instance7;
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let oldActive = active2;
    let oldEventTarget = eventTarget;
    let oldActiveTarget = activeTarget;
    function handleProps() {
      if (surface) {
        addClass("mdc-ripple-surface");
        if (color === "primary") {
          addClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        } else if (color === "secondary") {
          removeClass("smui-ripple-surface--primary");
          addClass("smui-ripple-surface--secondary");
        } else {
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
      }
      if (instance7 && oldActive !== active2) {
        oldActive = active2;
        if (active2) {
          instance7.activate();
        } else if (active2 === false) {
          instance7.deactivate();
        }
      }
      if (ripple && !instance7) {
        instance7 = new MDCRippleFoundation({
          addClass,
          browserSupportsCssVars: () => supportsCssVariables(window),
          computeBoundingRect: () => node.getBoundingClientRect(),
          containsEventTarget: (target) => node.contains(target),
          deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
          deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
          deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
          getWindowPageOffset: () => ({
            x: window.pageXOffset,
            y: window.pageYOffset
          }),
          isSurfaceActive: () => active2 == null ? matches(activeTarget || node, ":active") : active2,
          isSurfaceDisabled: () => !!disabled,
          isUnbounded: () => !!unbounded,
          registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
          registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
          registerResizeHandler: (handler) => window.addEventListener("resize", handler),
          removeClass,
          updateCssVariable: addStyle
        });
        initPromise.then(() => {
          instance7.init();
          instance7.setUnbounded(unbounded);
        });
      } else if (instance7 && !ripple) {
        initPromise.then(() => {
          instance7.destroy();
          instance7 = null;
        });
      }
      if (instance7 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
        oldEventTarget = eventTarget;
        oldActiveTarget = activeTarget;
        instance7.destroy();
        requestAnimationFrame(() => {
          if (instance7) {
            instance7.init();
            instance7.setUnbounded(unbounded);
          }
        });
      }
      if (!ripple && unbounded) {
        addClass("mdc-ripple-upgraded--unbounded");
      }
    }
    handleProps();
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    function layout() {
      if (instance7) {
        instance7.layout();
      }
    }
    return {
      update(props) {
        ({
          ripple,
          surface,
          unbounded,
          disabled,
          color,
          active: active2,
          eventTarget,
          activeTarget,
          addClass,
          removeClass,
          addStyle,
          initPromise
        } = {
          ripple: true,
          surface: false,
          unbounded: false,
          disabled: false,
          color: null,
          active: null,
          eventTarget: null,
          activeTarget: null,
          addClass: (className) => node.classList.add(className),
          removeClass: (className) => node.classList.remove(className),
          addStyle: (name2, value) => node.style.setProperty(name2, value),
          initPromise: Promise.resolve(),
          ...props
        });
        handleProps();
      },
      destroy() {
        if (instance7) {
          instance7.destroy();
          instance7 = null;
          removeClass("mdc-ripple-surface");
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      }
    };
  }
  var file$1 = "node_modules/@smui/common/A.svelte";
  function create_fragment$1(ctx) {
    let a;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[7].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
    let a_levels = [{href: ctx[0]}, ctx[4]];
    let a_data = {};
    for (let i = 0; i < a_levels.length; i += 1) {
      a_data = assign(a_data, a_levels[i]);
    }
    const block = {
      c: function create2() {
        a = element("a");
        if (default_slot)
          default_slot.c();
        set_attributes(a, a_data);
        add_location(a, file$1, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        if (default_slot) {
          default_slot.m(a, null);
        }
        ctx[8](a);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, a, ctx[1])),
            action_destroyer(ctx[3].call(null, a))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 64)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
          }
        }
        set_attributes(a, a_data = get_spread_update(a_levels, [
          (!current || dirty & 1) && {href: ctx2[0]},
          dirty & 16 && ctx2[4]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 2)
          useActions_action.update.call(null, ctx2[1]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(a);
        if (default_slot)
          default_slot.d(detaching);
        ctx[8](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$1.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$1($$self, $$props, $$invalidate) {
    const omit_props_names = ["href", "use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("A", slots, ["default"]);
    let {href = "javascript:void(0);"} = $$props;
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function a_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(2, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("href" in $$new_props)
        $$invalidate(0, href = $$new_props.href);
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(6, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      href,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("href" in $$props)
        $$invalidate(0, href = $$new_props.href);
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(2, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      href,
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      a_binding
    ];
  }
  var A = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {href: 0, use: 1, getElement: 5});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "A",
        options,
        id: create_fragment$1.name
      });
    }
    get href() {
      throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get use() {
      throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[5];
    }
    set getElement(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file = "node_modules/@smui/common/Span.svelte";
  function create_fragment(ctx) {
    let span;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let span_levels = [ctx[3]];
    let span_data = {};
    for (let i = 0; i < span_levels.length; i += 1) {
      span_data = assign(span_data, span_levels[i]);
    }
    const block = {
      c: function create2() {
        span = element("span");
        if (default_slot)
          default_slot.c();
        set_attributes(span, span_data);
        add_location(span, file, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        if (default_slot) {
          default_slot.m(span, null);
        }
        ctx[7](span);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, span, ctx[0])),
            action_destroyer(ctx[2].call(null, span))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(span, span_data = get_spread_update(span_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Span", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function span_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      span_binding
    ];
  }
  var Span = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance, create_fragment, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Span",
        options,
        id: create_fragment.name
      });
    }
    get use() {
      throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var axios$2 = {exports: {}};
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  var utils$d = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM
  };
  var utils$c = utils$d;
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url2, params, paramsSerializer) {
    if (!params) {
      return url2;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$c.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$c.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$c.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$c.forEach(val, function parseValue(v) {
          if (utils$c.isDate(v)) {
            v = v.toISOString();
          } else if (utils$c.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  };
  var utils$b = utils$d;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$b.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$a = utils$d;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$a.forEach(headers, function processHeader(value, name2) {
      if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name2];
      }
    });
  };
  var enhanceError$2 = function enhanceError(error, config, code, request2, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request2;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  var enhanceError$1 = enhanceError$2;
  var createError$2 = function createError(message, config, code, request2, response) {
    var error = new Error(message);
    return enhanceError$1(error, config, code, request2, response);
  };
  var createError$1 = createError$2;
  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
  var utils$9 = utils$d;
  var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils$9.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$9.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$9.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL2 = isAbsoluteURL$1;
  var combineURLs2 = combineURLs$1;
  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$8 = utils$d;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$8.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$8.trim(line.substr(0, i)).toLowerCase();
      val = utils$8.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$7 = utils$d;
  var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url2) {
      var href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  var utils$6 = utils$d;
  var settle2 = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath2 = buildFullPath$1;
  var parseHeaders2 = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError2 = createError$2;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      if (utils$6.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(resolve, reject, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError2("Network Error", config, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError2(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
        request2 = null;
      };
      if (utils$6.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$6.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request2) {
            return;
          }
          request2.abort();
          reject(cancel);
          request2 = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  var utils$5 = utils$d;
  var normalizeHeaderName2 = normalizeHeaderName$1;
  var enhanceError2 = enhanceError$2;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$5.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$5.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults$3 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
        return data;
      }
      if (utils$5.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$5.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils$5.isObject(data) || headers && headers["Content-Type"] === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      var transitional2 = this.transitional;
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw enhanceError2(e, this, "E_JSON_PARSE");
            }
            throw e;
          }
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$3.headers = {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  };
  utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$4 = utils$d;
  var defaults$2 = defaults_1;
  var transformData$1 = function transformData(data, headers, fns) {
    var context = this || defaults$2;
    utils$4.forEach(fns, function transform(fn) {
      data = fn.call(context, data, headers);
    });
    return data;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$3 = utils$d;
  var transformData2 = transformData$1;
  var isCancel2 = isCancel$1;
  var defaults$1 = defaults_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2.call(config, config.data, config.headers, config.transformRequest);
    config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2.call(config, response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(config, reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$2 = utils$d;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source2) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
        return utils$2.merge(target, source2);
      } else if (utils$2.isPlainObject(source2)) {
        return utils$2.merge({}, source2);
      } else if (utils$2.isArray(source2)) {
        return source2.slice();
      }
      return source2;
    }
    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge2(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
  var name = "axios";
  var version = "0.21.4";
  var description = "Promise based HTTP client for the browser and node.js";
  var main = "index.js";
  var scripts = {
    test: "grunt test",
    start: "node ./sandbox/server.js",
    build: "NODE_ENV=production grunt build",
    preversion: "npm test",
    version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    postversion: "git push && git push --tags",
    examples: "node ./examples/server.js",
    coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    fix: "eslint --fix lib/**/*.js"
  };
  var repository = {
    type: "git",
    url: "https://github.com/axios/axios.git"
  };
  var keywords = [
    "xhr",
    "http",
    "ajax",
    "promise",
    "node"
  ];
  var author = "Matt Zabriskie";
  var license = "MIT";
  var bugs = {
    url: "https://github.com/axios/axios/issues"
  };
  var homepage = "https://axios-http.com";
  var devDependencies = {
    coveralls: "^3.0.0",
    "es6-promise": "^4.2.4",
    grunt: "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    karma: "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    minimist: "^1.2.0",
    mocha: "^8.2.1",
    sinon: "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    typescript: "^4.0.5",
    "url-search-params": "^0.10.0",
    webpack: "^4.44.2",
    "webpack-dev-server": "^3.11.0"
  };
  var browser = {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
  };
  var jsdelivr = "dist/axios.min.js";
  var unpkg = "dist/axios.min.js";
  var typings = "./index.d.ts";
  var dependencies = {
    "follow-redirects": "^1.14.0"
  };
  var bundlesize = [
    {
      path: "./dist/axios.min.js",
      threshold: "5kB"
    }
  ];
  var require$$0 = {
    name,
    version,
    description,
    main,
    scripts,
    repository,
    keywords,
    author,
    license,
    bugs,
    homepage,
    devDependencies,
    browser,
    jsdelivr,
    unpkg,
    typings,
    dependencies,
    bundlesize
  };
  var pkg = require$$0;
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  var currentVerArr = pkg.version.split(".");
  function isOlderVersion(version2, thanVersion) {
    var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
    var destVer = version2.split(".");
    for (var i = 0; i < 3; i++) {
      if (pkgVersionArr[i] > destVer[i]) {
        return true;
      } else if (pkgVersionArr[i] < destVer[i]) {
        return false;
      }
    }
    return false;
  }
  validators$1.transitional = function transitional(validator2, version2, message) {
    var isDeprecated = version2 && isOlderVersion(version2);
    function formatMessage(opt, desc) {
      return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new Error(formatMessage(opt, " has been removed in " + version2));
      }
      if (isDeprecated && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while (i-- > 0) {
      var opt = keys[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new TypeError("option " + opt + " must be " + result);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw Error("Unknown option " + opt);
      }
    }
  }
  var validator$1 = {
    isOlderVersion,
    assertOptions,
    validators: validators$1
  };
  var utils$1 = utils$d;
  var buildURL2 = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest2 = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var validator = validator$1;
  var validators = validator.validators;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional2 = config.transitional;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor2) {
      if (typeof interceptor2.runWhen === "function" && interceptor2.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor2.synchronous;
      requestInterceptorChain.unshift(interceptor2.fulfilled, interceptor2.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor2) {
      responseInterceptorChain.push(interceptor2.fulfilled, interceptor2.rejected);
    });
    var promise2;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise2 = Promise.resolve(config);
      while (chain.length) {
        promise2 = promise2.then(chain.shift(), chain.shift());
      }
      return promise2;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest2(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise2;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
    Axios$1.prototype[method] = function(url2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
    Axios$1.prototype[method] = function(url2, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url: url2,
        data
      }));
    };
  });
  var Axios_1 = Axios$1;
  function Cancel$1(message) {
    this.message = message;
  }
  Cancel$1.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;
  var Cancel = Cancel_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  var utils = utils$d;
  var bind2 = bind$2;
  var Axios = Axios_1;
  var mergeConfig2 = mergeConfig$2;
  var defaults = defaults_1;
  function createInstance(defaultConfig2) {
    var context = new Axios(defaultConfig2);
    var instance7 = bind2(Axios.prototype.request, context);
    utils.extend(instance7, Axios.prototype, context);
    utils.extend(instance7, context);
    return instance7;
  }
  var axios$1 = createInstance(defaults);
  axios$1.Axios = Axios;
  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(axios$1.defaults, instanceConfig));
  };
  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  var backendURL = "https://foodsight.ml4all.com";
  var modal = writable({});
  var user = writable(localStorage.getItem("user") ? JSON.parse(localStorage.getItem("user")) : {});
  var userSettings = writable({});
  var screenShotMode = writable(false);
  var problemReport = writable({});
  var notification = writable({});
  var svelteRenderParent = writable();
  var interceptor;
  user.subscribe((val) => {
    localStorage.setItem("user", JSON.stringify(val));
    if (val && Object.keys(val).length) {
      interceptor = axios.interceptors.request.use((config) => {
        config.headers.authorization = `Bearer ${val.access_token}`;
        return config;
      }, (error) => {
        return Promise.reject(error);
      });
    } else {
      axios.interceptors.request.eject(interceptor);
    }
  });
  function cubicInOut(t) {
    return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;
  }
  function cubicOut(t) {
    const f = t - 1;
    return f * f * f + 1;
  }
  function quintOut(t) {
    return --t * t * t * t * t + 1;
  }
  function blur(node, {delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0} = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === "none" ? "" : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
      delay,
      duration,
      easing,
      css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * amount}px);`
    };
  }
  function fade(node, {delay = 0, duration = 400, easing = identity} = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
      delay,
      duration,
      easing,
      css: (t) => `opacity: ${t * o}`
    };
  }
  function fly(node, {delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0} = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === "none" ? "" : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
      delay,
      duration,
      easing,
      css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
    };
  }

  // dist/build/Subtitle.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var file$22 = "node_modules/@smui/paper/Paper.svelte";
  function create_fragment$22(ctx) {
    let div;
    let div_class_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    let div_levels = [
      {
        class: div_class_value = classMap({
          [ctx[1]]: true,
          "smui-paper": true,
          ["smui-paper--elevation-z" + ctx[4]]: ctx[4] !== 0,
          "smui-paper--rounded": !ctx[2],
          ["smui-paper--color-" + ctx[3]]: ctx[3] !== "default",
          "smui-paper-transition": ctx[5]
        })
      },
      ctx[8]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$22, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[12](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
            action_destroyer(ctx[7].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty & 62 && div_class_value !== (div_class_value = classMap({
            [ctx2[1]]: true,
            "smui-paper": true,
            ["smui-paper--elevation-z" + ctx2[4]]: ctx2[4] !== 0,
            "smui-paper--rounded": !ctx2[2],
            ["smui-paper--color-" + ctx2[3]]: ctx2[3] !== "default",
            "smui-paper-transition": ctx2[5]
          }))) && {class: div_class_value},
          dirty & 256 && ctx2[8]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[12](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$22.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$22($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "square", "color", "elevation", "transition", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Paper", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {square = false} = $$props;
    let {color = "default"} = $$props;
    let {elevation = 1} = $$props;
    let {transition = false} = $$props;
    let element2;
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(6, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("square" in $$new_props)
        $$invalidate(2, square = $$new_props.square);
      if ("color" in $$new_props)
        $$invalidate(3, color = $$new_props.color);
      if ("elevation" in $$new_props)
        $$invalidate(4, elevation = $$new_props.elevation);
      if ("transition" in $$new_props)
        $$invalidate(5, transition = $$new_props.transition);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      forwardEvents,
      use: use2,
      className,
      square,
      color,
      elevation,
      transition,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("square" in $$props)
        $$invalidate(2, square = $$new_props.square);
      if ("color" in $$props)
        $$invalidate(3, color = $$new_props.color);
      if ("elevation" in $$props)
        $$invalidate(4, elevation = $$new_props.elevation);
      if ("transition" in $$props)
        $$invalidate(5, transition = $$new_props.transition);
      if ("element" in $$props)
        $$invalidate(6, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      square,
      color,
      elevation,
      transition,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      div_binding
    ];
  }
  var Paper = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$22, create_fragment$22, safe_not_equal, {
        use: 0,
        class: 1,
        square: 2,
        color: 3,
        elevation: 4,
        transition: 5,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Paper",
        options,
        id: create_fragment$22.name
      });
    }
    get use() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get square() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set square(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get elevation() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set elevation(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get transition() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set transition(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Content = classAdderBuilder({
    class: "smui-paper__content",
    component: Div
  });
  var file$12 = "node_modules/@smui/common/H5.svelte";
  function create_fragment$12(ctx) {
    let h5;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h5_levels = [ctx[3]];
    let h5_data = {};
    for (let i = 0; i < h5_levels.length; i += 1) {
      h5_data = assign(h5_data, h5_levels[i]);
    }
    const block = {
      c: function create2() {
        h5 = element("h5");
        if (default_slot)
          default_slot.c();
        set_attributes(h5, h5_data);
        add_location(h5, file$12, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h5, anchor);
        if (default_slot) {
          default_slot.m(h5, null);
        }
        ctx[7](h5);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h5, ctx[0])),
            action_destroyer(ctx[2].call(null, h5))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h5, h5_data = get_spread_update(h5_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h5);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$12.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$12($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H5", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h5_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h5_binding
    ];
  }
  var H5 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$12, create_fragment$12, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H5",
        options,
        id: create_fragment$12.name
      });
    }
    get use() {
      throw new Error("<H5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Title = classAdderBuilder({
    class: "smui-paper__title",
    component: H5
  });
  var file2 = "node_modules/@smui/common/H6.svelte";
  function create_fragment2(ctx) {
    let h6;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h6_levels = [ctx[3]];
    let h6_data = {};
    for (let i = 0; i < h6_levels.length; i += 1) {
      h6_data = assign(h6_data, h6_levels[i]);
    }
    const block = {
      c: function create2() {
        h6 = element("h6");
        if (default_slot)
          default_slot.c();
        set_attributes(h6, h6_data);
        add_location(h6, file2, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h6, anchor);
        if (default_slot) {
          default_slot.m(h6, null);
        }
        ctx[7](h6);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h6, ctx[0])),
            action_destroyer(ctx[2].call(null, h6))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h6, h6_data = get_spread_update(h6_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h6);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment2.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance2($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H6", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h6_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h6_binding
    ];
  }
  var H6 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance2, create_fragment2, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H6",
        options,
        id: create_fragment2.name
      });
    }
    get use() {
      throw new Error("<H6>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H6>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H6>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  classAdderBuilder({
    class: "smui-paper__subtitle",
    component: H6
  });

  // dist/build/CommonLabel.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var file$13 = "node_modules/@smui/common/Button.svelte";
  function create_fragment$23(ctx) {
    let button;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let button_levels = [ctx[3]];
    let button_data = {};
    for (let i = 0; i < button_levels.length; i += 1) {
      button_data = assign(button_data, button_levels[i]);
    }
    const block = {
      c: function create2() {
        button = element("button");
        if (default_slot)
          default_slot.c();
        set_attributes(button, button_data);
        add_location(button, file$13, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, button, anchor);
        if (default_slot) {
          default_slot.m(button, null);
        }
        if (button.autofocus)
          button.focus();
        ctx[7](button);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, button, ctx[0])),
            action_destroyer(ctx[2].call(null, button))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(button, button_data = get_spread_update(button_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(button);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$23.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$23($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Button", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function button_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      button_binding
    ];
  }
  var Button = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$23, create_fragment$23, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Button",
        options,
        id: create_fragment$23.name
      });
    }
    get use() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file3 = "node_modules/@smui/button/Button.svelte";
  function create_if_block(ctx) {
    let div;
    const block = {
      c: function create2() {
        div = element("div");
        attr_dev(div, "class", "mdc-button__touch");
        add_location(div, file3, 49, 21, 1522);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block.name,
      type: "if",
      source: "(50:10) {#if touch}",
      ctx
    });
    return block;
  }
  function create_default_slot$1(ctx) {
    let div;
    let t;
    let if_block_anchor;
    let current;
    const default_slot_template = ctx[26].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[28], null);
    let if_block = ctx[6] && create_if_block(ctx);
    const block = {
      c: function create2() {
        div = element("div");
        t = space();
        if (default_slot)
          default_slot.c();
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
        attr_dev(div, "class", "mdc-button__ripple");
        add_location(div, file3, 48, 3, 1466);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        insert_dev(target, t, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 268435456)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[28], !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(default_slot_template, ctx2[28], dirty, null), null);
          }
        }
        if (ctx2[6]) {
          if (if_block)
            ;
          else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (detaching)
          detach_dev(t);
        if (default_slot)
          default_slot.d(detaching);
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$1.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: false,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-button': true,     'mdc-button--raised': variant === 'raised',     'mdc-button--unelevated': variant === 'unelevated',     'mdc-button--outlined': variant === 'outlined',     'smui-button--color-secondary': color === 'secondary',     'mdc-button--touch': touch,     'mdc-card__action': context === 'card:action',     'mdc-card__action--button': context === 'card:action',     'mdc-dialog__button': context === 'dialog:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__action': context === 'snackbar:actions',     'mdc-banner__secondary-action': context === 'banner' && secondary,     'mdc-banner__primary-action': context === 'banner' && !secondary,     'mdc-tooltip__action': context === 'tooltip:rich-actions',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...actionProp}   {...defaultProp}   {...secondaryProp}   {href}   on:click={handleClick}   {...$$restProps}   >",
      ctx
    });
    return block;
  }
  function create_fragment$13(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [
          [
            Ripple,
            {
              ripple: ctx[3],
              unbounded: false,
              color: ctx[4],
              disabled: !!ctx[22].disabled,
              addClass: ctx[18],
              removeClass: ctx[19],
              addStyle: ctx[20]
            }
          ],
          ctx[16],
          ...ctx[0]
        ]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-button": true,
          "mdc-button--raised": ctx[5] === "raised",
          "mdc-button--unelevated": ctx[5] === "unelevated",
          "mdc-button--outlined": ctx[5] === "outlined",
          "smui-button--color-secondary": ctx[4] === "secondary",
          "mdc-button--touch": ctx[6],
          "mdc-card__action": ctx[17] === "card:action",
          "mdc-card__action--button": ctx[17] === "card:action",
          "mdc-dialog__button": ctx[17] === "dialog:action",
          "mdc-top-app-bar__navigation-icon": ctx[17] === "top-app-bar:navigation",
          "mdc-top-app-bar__action-item": ctx[17] === "top-app-bar:action",
          "mdc-snackbar__action": ctx[17] === "snackbar:actions",
          "mdc-banner__secondary-action": ctx[17] === "banner" && ctx[8],
          "mdc-banner__primary-action": ctx[17] === "banner" && !ctx[8],
          "mdc-tooltip__action": ctx[17] === "tooltip:rich-actions",
          ...ctx[11]
        })
      },
      {
        style: Object.entries(ctx[12]).map(func).concat([ctx[2]]).join(" ")
      },
      ctx[15],
      ctx[14],
      ctx[13],
      {href: ctx[7]},
      ctx[22]
    ];
    var switch_value = ctx[9];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$1]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[27](switch_instance);
      switch_instance.$on("click", ctx[21]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 6289919 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 6094873 && {
            use: [
              [
                Ripple,
                {
                  ripple: ctx2[3],
                  unbounded: false,
                  color: ctx2[4],
                  disabled: !!ctx2[22].disabled,
                  addClass: ctx2[18],
                  removeClass: ctx2[19],
                  addStyle: ctx2[20]
                }
              ],
              ctx2[16],
              ...ctx2[0]
            ]
          },
          dirty & 133490 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-button": true,
              "mdc-button--raised": ctx2[5] === "raised",
              "mdc-button--unelevated": ctx2[5] === "unelevated",
              "mdc-button--outlined": ctx2[5] === "outlined",
              "smui-button--color-secondary": ctx2[4] === "secondary",
              "mdc-button--touch": ctx2[6],
              "mdc-card__action": ctx2[17] === "card:action",
              "mdc-card__action--button": ctx2[17] === "card:action",
              "mdc-dialog__button": ctx2[17] === "dialog:action",
              "mdc-top-app-bar__navigation-icon": ctx2[17] === "top-app-bar:navigation",
              "mdc-top-app-bar__action-item": ctx2[17] === "top-app-bar:action",
              "mdc-snackbar__action": ctx2[17] === "snackbar:actions",
              "mdc-banner__secondary-action": ctx2[17] === "banner" && ctx2[8],
              "mdc-banner__primary-action": ctx2[17] === "banner" && !ctx2[8],
              "mdc-tooltip__action": ctx2[17] === "tooltip:rich-actions",
              ...ctx2[11]
            })
          },
          dirty & 4100 && {
            style: Object.entries(ctx2[12]).map(func).concat([ctx2[2]]).join(" ")
          },
          dirty & 32768 && get_spread_object(ctx2[15]),
          dirty & 16384 && get_spread_object(ctx2[14]),
          dirty & 8192 && get_spread_object(ctx2[13]),
          dirty & 128 && {href: ctx2[7]},
          dirty & 4194304 && get_spread_object(ctx2[22])
        ]) : {};
        if (dirty & 268435520) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[9])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[27](switch_instance);
            switch_instance.$on("click", ctx2[21]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[27](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$13.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func = ([name2, value]) => `${name2}: ${value};`;
  function instance$13($$self, $$props, $$invalidate) {
    let actionProp;
    let defaultProp;
    let secondaryProp;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "ripple",
      "color",
      "variant",
      "touch",
      "href",
      "action",
      "default",
      "secondary",
      "component",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Button", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {ripple = true} = $$props;
    let {color = "primary"} = $$props;
    let {variant = "text"} = $$props;
    let {touch = false} = $$props;
    let {href = null} = $$props;
    let {action = "close"} = $$props;
    let {default: defaultAction = false} = $$props;
    let {secondary = false} = $$props;
    let element2;
    let internalClasses = {};
    let internalStyles = {};
    let context = getContext("SMUI:button:context");
    let {component = href == null ? Button : A} = $$props;
    setContext("SMUI:label:context", "button");
    setContext("SMUI:icon:context", "button");
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(11, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(11, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name2, value) {
      if (internalStyles[name2] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name2];
          $$invalidate(12, internalStyles);
        } else {
          $$invalidate(12, internalStyles[name2] = value, internalStyles);
        }
      }
    }
    function handleClick2() {
      if (context === "banner") {
        dispatch(getElement(), secondary ? "SMUI:banner:button:secondaryActionClick" : "SMUI:banner:button:primaryActionClick");
      }
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(10, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(2, style = $$new_props.style);
      if ("ripple" in $$new_props)
        $$invalidate(3, ripple = $$new_props.ripple);
      if ("color" in $$new_props)
        $$invalidate(4, color = $$new_props.color);
      if ("variant" in $$new_props)
        $$invalidate(5, variant = $$new_props.variant);
      if ("touch" in $$new_props)
        $$invalidate(6, touch = $$new_props.touch);
      if ("href" in $$new_props)
        $$invalidate(7, href = $$new_props.href);
      if ("action" in $$new_props)
        $$invalidate(23, action = $$new_props.action);
      if ("default" in $$new_props)
        $$invalidate(24, defaultAction = $$new_props.default);
      if ("secondary" in $$new_props)
        $$invalidate(8, secondary = $$new_props.secondary);
      if ("component" in $$new_props)
        $$invalidate(9, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(28, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      setContext,
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      dispatch,
      Ripple,
      A,
      Button,
      forwardEvents,
      use: use2,
      className,
      style,
      ripple,
      color,
      variant,
      touch,
      href,
      action,
      defaultAction,
      secondary,
      element: element2,
      internalClasses,
      internalStyles,
      context,
      component,
      addClass,
      removeClass,
      addStyle,
      handleClick: handleClick2,
      getElement,
      secondaryProp,
      defaultProp,
      actionProp
    });
    $$self.$inject_state = ($$new_props) => {
      $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(2, style = $$new_props.style);
      if ("ripple" in $$props)
        $$invalidate(3, ripple = $$new_props.ripple);
      if ("color" in $$props)
        $$invalidate(4, color = $$new_props.color);
      if ("variant" in $$props)
        $$invalidate(5, variant = $$new_props.variant);
      if ("touch" in $$props)
        $$invalidate(6, touch = $$new_props.touch);
      if ("href" in $$props)
        $$invalidate(7, href = $$new_props.href);
      if ("action" in $$props)
        $$invalidate(23, action = $$new_props.action);
      if ("defaultAction" in $$props)
        $$invalidate(24, defaultAction = $$new_props.defaultAction);
      if ("secondary" in $$props)
        $$invalidate(8, secondary = $$new_props.secondary);
      if ("element" in $$props)
        $$invalidate(10, element2 = $$new_props.element);
      if ("internalClasses" in $$props)
        $$invalidate(11, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(12, internalStyles = $$new_props.internalStyles);
      if ("context" in $$props)
        $$invalidate(17, context = $$new_props.context);
      if ("component" in $$props)
        $$invalidate(9, component = $$new_props.component);
      if ("secondaryProp" in $$props)
        $$invalidate(13, secondaryProp = $$new_props.secondaryProp);
      if ("defaultProp" in $$props)
        $$invalidate(14, defaultProp = $$new_props.defaultProp);
      if ("actionProp" in $$props)
        $$invalidate(15, actionProp = $$new_props.actionProp);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      $$invalidate(15, actionProp = context === "dialog:action" && action != null ? {"data-mdc-dialog-action": action} : {action: $$props.action});
      $$invalidate(14, defaultProp = context === "dialog:action" && defaultAction ? {"data-mdc-dialog-button-default": ""} : {default: $$props.default});
      $$invalidate(13, secondaryProp = context === "banner" ? {} : {secondary: $$props.secondary});
    };
    $$props = exclude_internal_props($$props);
    return [
      use2,
      className,
      style,
      ripple,
      color,
      variant,
      touch,
      href,
      secondary,
      component,
      element2,
      internalClasses,
      internalStyles,
      secondaryProp,
      defaultProp,
      actionProp,
      forwardEvents,
      context,
      addClass,
      removeClass,
      addStyle,
      handleClick2,
      $$restProps,
      action,
      defaultAction,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var Button_1 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$13, create_fragment$13, safe_not_equal, {
        use: 0,
        class: 1,
        style: 2,
        ripple: 3,
        color: 4,
        variant: 5,
        touch: 6,
        href: 7,
        action: 23,
        default: 24,
        secondary: 8,
        component: 9,
        getElement: 25
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Button_1",
        options,
        id: create_fragment$13.name
      });
    }
    get use() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get variant() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set variant(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get touch() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set touch(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get href() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get action() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set action(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get default() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set default(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get secondary() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set secondary(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[25];
    }
    set getElement(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot2(ctx) {
    let current;
    const default_slot_template = ctx[9].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2048)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot2.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment3(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[4], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-button__label": ctx[5] === "button",
          "mdc-fab__label": ctx[5] === "fab",
          "mdc-tab__text-label": ctx[5] === "tab",
          "mdc-image-list__label": ctx[5] === "image-list",
          "mdc-snackbar__label": ctx[5] === "snackbar",
          "mdc-banner__text": ctx[5] === "banner",
          "mdc-segmented-button__label": ctx[5] === "segmented-button",
          "mdc-data-table__pagination-rows-per-page-label": ctx[5] === "data-table:pagination",
          "mdc-data-table__header-cell-label": ctx[5] === "data-table:sortable-header-cell"
        })
      },
      ctx[5] === "snackbar" ? {"aria-atomic": "false"} : {},
      {tabindex: ctx[6]},
      ctx[7]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot2]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[10](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 243 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 17 && {
            use: [ctx2[4], ...ctx2[0]]
          },
          dirty & 34 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-button__label": ctx2[5] === "button",
              "mdc-fab__label": ctx2[5] === "fab",
              "mdc-tab__text-label": ctx2[5] === "tab",
              "mdc-image-list__label": ctx2[5] === "image-list",
              "mdc-snackbar__label": ctx2[5] === "snackbar",
              "mdc-banner__text": ctx2[5] === "banner",
              "mdc-segmented-button__label": ctx2[5] === "segmented-button",
              "mdc-data-table__pagination-rows-per-page-label": ctx2[5] === "data-table:pagination",
              "mdc-data-table__header-cell-label": ctx2[5] === "data-table:sortable-header-cell"
            })
          },
          dirty & 32 && get_spread_object(ctx2[5] === "snackbar" ? {"aria-atomic": "false"} : {}),
          dirty & 64 && {tabindex: ctx2[6]},
          dirty & 128 && get_spread_object(ctx2[7])
        ]) : {};
        if (dirty & 2048) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[10](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[10](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment3.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance3($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("CommonLabel", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    let {component = Span} = $$props;
    const context = getContext("SMUI:label:context");
    const tabindex = getContext("SMUI:label:tabindex");
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(11, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      Span,
      forwardEvents,
      use: use2,
      className,
      element: element2,
      component,
      context,
      tabindex,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      forwardEvents,
      context,
      tabindex,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var CommonLabel = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance3, create_fragment3, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 8
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "CommonLabel",
        options,
        id: create_fragment3.name
      });
    }
    get use() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[8];
    }
    set getElement(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/Slider.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFoundation$1 = function() {
    function MDCFoundation3(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation3, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation3.prototype.init = function() {
    };
    MDCFoundation3.prototype.destroy = function() {
    };
    return MDCFoundation3;
  }();
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$1 = {
    DISABLED: "mdc-slider--disabled",
    DISCRETE: "mdc-slider--discrete",
    INPUT: "mdc-slider__input",
    RANGE: "mdc-slider--range",
    THUMB: "mdc-slider__thumb",
    THUMB_FOCUSED: "mdc-slider__thumb--focused",
    THUMB_KNOB: "mdc-slider__thumb-knob",
    THUMB_TOP: "mdc-slider__thumb--top",
    THUMB_WITH_INDICATOR: "mdc-slider__thumb--with-indicator",
    TICK_MARKS: "mdc-slider--tick-marks",
    TICK_MARKS_CONTAINER: "mdc-slider__tick-marks",
    TICK_MARK_ACTIVE: "mdc-slider__tick-mark--active",
    TICK_MARK_INACTIVE: "mdc-slider__tick-mark--inactive",
    TRACK: "mdc-slider__track",
    TRACK_ACTIVE: "mdc-slider__track--active_fill",
    VALUE_INDICATOR_TEXT: "mdc-slider__value-indicator-text"
  };
  var numbers$1 = {
    STEP_SIZE: 1,
    THUMB_UPDATE_MIN_PX: 5
  };
  var attributes = {
    ARIA_VALUETEXT: "aria-valuetext",
    INPUT_DISABLED: "disabled",
    INPUT_MIN: "min",
    INPUT_MAX: "max",
    INPUT_VALUE: "value",
    INPUT_STEP: "step"
  };
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var AnimationFrame = function() {
    function AnimationFrame2() {
      this.rafIDs = new Map();
    }
    AnimationFrame2.prototype.request = function(key, callback) {
      var _this = this;
      this.cancel(key);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key);
        callback(frame);
      });
      this.rafIDs.set(key, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key) {
      var rafID = this.rafIDs.get(key);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_2, key) {
        _this.cancel(key);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue2 = [];
      this.rafIDs.forEach(function(_2, key) {
        queue2.push(key);
      });
      return queue2;
    };
    return AnimationFrame2;
  }();
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssPropertyNameMap = {
    animation: {
      prefixed: "-webkit-animation",
      standard: "animation"
    },
    transform: {
      prefixed: "-webkit-transform",
      standard: "transform"
    },
    transition: {
      prefixed: "-webkit-transition",
      standard: "transition"
    }
  };
  function isWindow(windowObj) {
    return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
  }
  function getCorrectPropertyName(windowObj, cssProperty) {
    if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
      var el = windowObj.document.createElement("div");
      var _a2 = cssPropertyNameMap[cssProperty], standard = _a2.standard, prefixed = _a2.prefixed;
      var isStandard = standard in el.style;
      return isStandard ? standard : prefixed;
    }
    return cssProperty;
  }
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var TickMark;
  (function(TickMark2) {
    TickMark2[TickMark2["ACTIVE"] = 0] = "ACTIVE";
    TickMark2[TickMark2["INACTIVE"] = 1] = "INACTIVE";
  })(TickMark || (TickMark = {}));
  var Thumb;
  (function(Thumb2) {
    Thumb2[Thumb2["START"] = 1] = "START";
    Thumb2[Thumb2["END"] = 2] = "END";
  })(Thumb || (Thumb = {}));
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var AnimationKeys;
  (function(AnimationKeys2) {
    AnimationKeys2["SLIDER_UPDATE"] = "slider_update";
  })(AnimationKeys || (AnimationKeys = {}));
  var HAS_WINDOW = typeof window !== "undefined";
  var MDCSliderFoundation = function(_super) {
    __extends(MDCSliderFoundation2, _super);
    function MDCSliderFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCSliderFoundation2.defaultAdapter), adapter)) || this;
      _this.initialStylesRemoved = false;
      _this.isDisabled = false;
      _this.isDiscrete = false;
      _this.step = numbers$1.STEP_SIZE;
      _this.hasTickMarks = false;
      _this.isRange = false;
      _this.thumb = null;
      _this.downEventClientX = null;
      _this.startThumbKnobWidth = 0;
      _this.endThumbKnobWidth = 0;
      _this.animFrame = new AnimationFrame();
      return _this;
    }
    Object.defineProperty(MDCSliderFoundation2, "defaultAdapter", {
      get: function() {
        return {
          hasClass: function() {
            return false;
          },
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          addThumbClass: function() {
            return void 0;
          },
          removeThumbClass: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          getInputValue: function() {
            return "";
          },
          setInputValue: function() {
            return void 0;
          },
          getInputAttribute: function() {
            return null;
          },
          setInputAttribute: function() {
            return null;
          },
          removeInputAttribute: function() {
            return null;
          },
          focusInput: function() {
            return void 0;
          },
          isInputFocused: function() {
            return false;
          },
          getThumbKnobWidth: function() {
            return 0;
          },
          getThumbBoundingClientRect: function() {
            return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
          },
          getBoundingClientRect: function() {
            return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
          },
          isRTL: function() {
            return false;
          },
          setThumbStyleProperty: function() {
            return void 0;
          },
          removeThumbStyleProperty: function() {
            return void 0;
          },
          setTrackActiveStyleProperty: function() {
            return void 0;
          },
          removeTrackActiveStyleProperty: function() {
            return void 0;
          },
          setValueIndicatorText: function() {
            return void 0;
          },
          getValueToAriaValueTextFn: function() {
            return null;
          },
          updateTickMarks: function() {
            return void 0;
          },
          setPointerCapture: function() {
            return void 0;
          },
          emitChangeEvent: function() {
            return void 0;
          },
          emitInputEvent: function() {
            return void 0;
          },
          emitDragStartEvent: function() {
            return void 0;
          },
          emitDragEndEvent: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          },
          registerThumbEventHandler: function() {
            return void 0;
          },
          deregisterThumbEventHandler: function() {
            return void 0;
          },
          registerInputEventHandler: function() {
            return void 0;
          },
          deregisterInputEventHandler: function() {
            return void 0;
          },
          registerBodyEventHandler: function() {
            return void 0;
          },
          deregisterBodyEventHandler: function() {
            return void 0;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSliderFoundation2.prototype.init = function() {
      var _this = this;
      this.isDisabled = this.adapter.hasClass(cssClasses$1.DISABLED);
      this.isDiscrete = this.adapter.hasClass(cssClasses$1.DISCRETE);
      this.hasTickMarks = this.adapter.hasClass(cssClasses$1.TICK_MARKS);
      this.isRange = this.adapter.hasClass(cssClasses$1.RANGE);
      var min = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MIN, this.isRange ? Thumb.START : Thumb.END), attributes.INPUT_MIN);
      var max = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MAX, Thumb.END), attributes.INPUT_MAX);
      var value = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.END), attributes.INPUT_VALUE);
      var valueStart = this.isRange ? this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.START), attributes.INPUT_VALUE) : min;
      var stepAttr = this.adapter.getInputAttribute(attributes.INPUT_STEP, Thumb.END);
      var step = stepAttr ? this.convertAttributeValueToNumber(stepAttr, attributes.INPUT_STEP) : this.step;
      this.validateProperties({min, max, value, valueStart, step});
      this.min = min;
      this.max = max;
      this.value = value;
      this.valueStart = valueStart;
      this.step = step;
      this.numDecimalPlaces = getNumDecimalPlaces(this.step);
      this.valueBeforeDownEvent = value;
      this.valueStartBeforeDownEvent = valueStart;
      this.mousedownOrTouchstartListener = this.handleMousedownOrTouchstart.bind(this);
      this.moveListener = this.handleMove.bind(this);
      this.pointerdownListener = this.handlePointerdown.bind(this);
      this.pointerupListener = this.handlePointerup.bind(this);
      this.thumbMouseenterListener = this.handleThumbMouseenter.bind(this);
      this.thumbMouseleaveListener = this.handleThumbMouseleave.bind(this);
      this.inputStartChangeListener = function() {
        _this.handleInputChange(Thumb.START);
      };
      this.inputEndChangeListener = function() {
        _this.handleInputChange(Thumb.END);
      };
      this.inputStartFocusListener = function() {
        _this.handleInputFocus(Thumb.START);
      };
      this.inputEndFocusListener = function() {
        _this.handleInputFocus(Thumb.END);
      };
      this.inputStartBlurListener = function() {
        _this.handleInputBlur(Thumb.START);
      };
      this.inputEndBlurListener = function() {
        _this.handleInputBlur(Thumb.END);
      };
      this.resizeListener = this.handleResize.bind(this);
      this.registerEventHandlers();
    };
    MDCSliderFoundation2.prototype.destroy = function() {
      this.deregisterEventHandlers();
    };
    MDCSliderFoundation2.prototype.setMin = function(value) {
      this.min = value;
      if (!this.isRange) {
        this.valueStart = value;
      }
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.setMax = function(value) {
      this.max = value;
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.getMin = function() {
      return this.min;
    };
    MDCSliderFoundation2.prototype.getMax = function() {
      return this.max;
    };
    MDCSliderFoundation2.prototype.getValue = function() {
      return this.value;
    };
    MDCSliderFoundation2.prototype.setValue = function(value) {
      if (this.isRange && value < this.valueStart) {
        throw new Error("end thumb value (" + value + ") must be >= start thumb " + ("value (" + this.valueStart + ")"));
      }
      this.updateValue(value, Thumb.END);
    };
    MDCSliderFoundation2.prototype.getValueStart = function() {
      if (!this.isRange) {
        throw new Error("`valueStart` is only applicable for range sliders.");
      }
      return this.valueStart;
    };
    MDCSliderFoundation2.prototype.setValueStart = function(valueStart) {
      if (!this.isRange) {
        throw new Error("`valueStart` is only applicable for range sliders.");
      }
      if (this.isRange && valueStart > this.value) {
        throw new Error("start thumb value (" + valueStart + ") must be <= end thumb " + ("value (" + this.value + ")"));
      }
      this.updateValue(valueStart, Thumb.START);
    };
    MDCSliderFoundation2.prototype.setStep = function(value) {
      this.step = value;
      this.numDecimalPlaces = getNumDecimalPlaces(value);
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.setIsDiscrete = function(value) {
      this.isDiscrete = value;
      this.updateValueIndicatorUI();
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.getStep = function() {
      return this.step;
    };
    MDCSliderFoundation2.prototype.setHasTickMarks = function(value) {
      this.hasTickMarks = value;
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.getDisabled = function() {
      return this.isDisabled;
    };
    MDCSliderFoundation2.prototype.setDisabled = function(disabled) {
      this.isDisabled = disabled;
      if (disabled) {
        this.adapter.addClass(cssClasses$1.DISABLED);
        if (this.isRange) {
          this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.START);
        }
        this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.END);
      } else {
        this.adapter.removeClass(cssClasses$1.DISABLED);
        if (this.isRange) {
          this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.START);
        }
        this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.END);
      }
    };
    MDCSliderFoundation2.prototype.getIsRange = function() {
      return this.isRange;
    };
    MDCSliderFoundation2.prototype.layout = function(_a2) {
      var _b2 = _a2 === void 0 ? {} : _a2, skipUpdateUI = _b2.skipUpdateUI;
      this.rect = this.adapter.getBoundingClientRect();
      if (this.isRange) {
        this.startThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.START);
        this.endThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.END);
      }
      if (!skipUpdateUI) {
        this.updateUI();
      }
    };
    MDCSliderFoundation2.prototype.handleResize = function() {
      this.layout();
    };
    MDCSliderFoundation2.prototype.handleDown = function(event) {
      if (this.isDisabled)
        return;
      this.valueStartBeforeDownEvent = this.valueStart;
      this.valueBeforeDownEvent = this.value;
      var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
      this.downEventClientX = clientX;
      var value = this.mapClientXOnSliderScale(clientX);
      this.thumb = this.getThumbFromDownEvent(clientX, value);
      if (this.thumb === null)
        return;
      this.handleDragStart(event, value, this.thumb);
      this.updateValue(value, this.thumb, {emitInputEvent: true});
    };
    MDCSliderFoundation2.prototype.handleMove = function(event) {
      if (this.isDisabled)
        return;
      event.preventDefault();
      var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
      var dragAlreadyStarted = this.thumb != null;
      this.thumb = this.getThumbFromMoveEvent(clientX);
      if (this.thumb === null)
        return;
      var value = this.mapClientXOnSliderScale(clientX);
      if (!dragAlreadyStarted) {
        this.handleDragStart(event, value, this.thumb);
        this.adapter.emitDragStartEvent(value, this.thumb);
      }
      this.updateValue(value, this.thumb, {emitInputEvent: true});
    };
    MDCSliderFoundation2.prototype.handleUp = function() {
      if (this.isDisabled || this.thumb === null)
        return;
      var oldValue = this.thumb === Thumb.START ? this.valueStartBeforeDownEvent : this.valueBeforeDownEvent;
      var newValue = this.thumb === Thumb.START ? this.valueStart : this.value;
      if (oldValue !== newValue) {
        this.adapter.emitChangeEvent(newValue, this.thumb);
      }
      this.adapter.emitDragEndEvent(newValue, this.thumb);
      this.thumb = null;
    };
    MDCSliderFoundation2.prototype.handleThumbMouseenter = function() {
      if (!this.isDiscrete || !this.isRange)
        return;
      this.adapter.addThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, Thumb.START);
      this.adapter.addThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, Thumb.END);
    };
    MDCSliderFoundation2.prototype.handleThumbMouseleave = function() {
      if (!this.isDiscrete || !this.isRange)
        return;
      if (this.adapter.isInputFocused(Thumb.START) || this.adapter.isInputFocused(Thumb.END)) {
        return;
      }
      this.adapter.removeThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, Thumb.START);
      this.adapter.removeThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, Thumb.END);
    };
    MDCSliderFoundation2.prototype.handleMousedownOrTouchstart = function(event) {
      var _this = this;
      var moveEventType = event.type === "mousedown" ? "mousemove" : "touchmove";
      this.adapter.registerBodyEventHandler(moveEventType, this.moveListener);
      var upHandler = function() {
        _this.handleUp();
        _this.adapter.deregisterBodyEventHandler(moveEventType, _this.moveListener);
        _this.adapter.deregisterEventHandler("mouseup", upHandler);
        _this.adapter.deregisterEventHandler("touchend", upHandler);
      };
      this.adapter.registerBodyEventHandler("mouseup", upHandler);
      this.adapter.registerBodyEventHandler("touchend", upHandler);
      this.handleDown(event);
    };
    MDCSliderFoundation2.prototype.handlePointerdown = function(event) {
      this.adapter.setPointerCapture(event.pointerId);
      this.adapter.registerEventHandler("pointermove", this.moveListener);
      this.handleDown(event);
    };
    MDCSliderFoundation2.prototype.handleInputChange = function(thumb) {
      var value = Number(this.adapter.getInputValue(thumb));
      if (thumb === Thumb.START) {
        this.setValueStart(value);
      } else {
        this.setValue(value);
      }
      this.adapter.emitChangeEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
      this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
    };
    MDCSliderFoundation2.prototype.handleInputFocus = function(thumb) {
      this.adapter.addThumbClass(cssClasses$1.THUMB_FOCUSED, thumb);
      if (!this.isDiscrete)
        return;
      this.adapter.addThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, thumb);
      if (this.isRange) {
        var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
        this.adapter.addThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, otherThumb);
      }
    };
    MDCSliderFoundation2.prototype.handleInputBlur = function(thumb) {
      this.adapter.removeThumbClass(cssClasses$1.THUMB_FOCUSED, thumb);
      if (!this.isDiscrete)
        return;
      this.adapter.removeThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, thumb);
      if (this.isRange) {
        var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
        this.adapter.removeThumbClass(cssClasses$1.THUMB_WITH_INDICATOR, otherThumb);
      }
    };
    MDCSliderFoundation2.prototype.handleDragStart = function(event, value, thumb) {
      this.adapter.emitDragStartEvent(value, thumb);
      this.adapter.focusInput(thumb);
      event.preventDefault();
    };
    MDCSliderFoundation2.prototype.getThumbFromDownEvent = function(clientX, value) {
      if (!this.isRange)
        return Thumb.END;
      var thumbStartRect = this.adapter.getThumbBoundingClientRect(Thumb.START);
      var thumbEndRect = this.adapter.getThumbBoundingClientRect(Thumb.END);
      var inThumbStartBounds = clientX >= thumbStartRect.left && clientX <= thumbStartRect.right;
      var inThumbEndBounds = clientX >= thumbEndRect.left && clientX <= thumbEndRect.right;
      if (inThumbStartBounds && inThumbEndBounds) {
        return null;
      }
      if (inThumbStartBounds) {
        return Thumb.START;
      }
      if (inThumbEndBounds) {
        return Thumb.END;
      }
      if (value < this.valueStart) {
        return Thumb.START;
      }
      if (value > this.value) {
        return Thumb.END;
      }
      return value - this.valueStart <= this.value - value ? Thumb.START : Thumb.END;
    };
    MDCSliderFoundation2.prototype.getThumbFromMoveEvent = function(clientX) {
      if (this.thumb !== null)
        return this.thumb;
      if (this.downEventClientX === null) {
        throw new Error("`downEventClientX` is null after move event.");
      }
      var moveDistanceUnderThreshold = Math.abs(this.downEventClientX - clientX) < numbers$1.THUMB_UPDATE_MIN_PX;
      if (moveDistanceUnderThreshold)
        return this.thumb;
      var draggedThumbToLeft = clientX < this.downEventClientX;
      if (draggedThumbToLeft) {
        return this.adapter.isRTL() ? Thumb.END : Thumb.START;
      } else {
        return this.adapter.isRTL() ? Thumb.START : Thumb.END;
      }
    };
    MDCSliderFoundation2.prototype.updateUI = function(thumb) {
      this.updateThumbAndInputAttributes(thumb);
      this.updateThumbAndTrackUI(thumb);
      this.updateValueIndicatorUI(thumb);
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.updateThumbAndInputAttributes = function(thumb) {
      if (!thumb)
        return;
      var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
      var valueStr = String(value);
      this.adapter.setInputAttribute(attributes.INPUT_VALUE, valueStr, thumb);
      if (this.isRange && thumb === Thumb.START) {
        this.adapter.setInputAttribute(attributes.INPUT_MIN, valueStr, Thumb.END);
      } else if (this.isRange && thumb === Thumb.END) {
        this.adapter.setInputAttribute(attributes.INPUT_MAX, valueStr, Thumb.START);
      }
      if (this.adapter.getInputValue(thumb) !== valueStr) {
        this.adapter.setInputValue(valueStr, thumb);
      }
      var valueToAriaValueTextFn = this.adapter.getValueToAriaValueTextFn();
      if (valueToAriaValueTextFn) {
        this.adapter.setInputAttribute(attributes.ARIA_VALUETEXT, valueToAriaValueTextFn(value), thumb);
      }
    };
    MDCSliderFoundation2.prototype.updateValueIndicatorUI = function(thumb) {
      if (!this.isDiscrete)
        return;
      var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
      this.adapter.setValueIndicatorText(value, thumb === Thumb.START ? Thumb.START : Thumb.END);
      if (!thumb && this.isRange) {
        this.adapter.setValueIndicatorText(this.valueStart, Thumb.START);
      }
    };
    MDCSliderFoundation2.prototype.updateTickMarksUI = function() {
      if (!this.isDiscrete || !this.hasTickMarks)
        return;
      var numTickMarksInactiveStart = (this.valueStart - this.min) / this.step;
      var numTickMarksActive = (this.value - this.valueStart) / this.step + 1;
      var numTickMarksInactiveEnd = (this.max - this.value) / this.step;
      var tickMarksInactiveStart = Array.from({length: numTickMarksInactiveStart}).fill(TickMark.INACTIVE);
      var tickMarksActive = Array.from({length: numTickMarksActive}).fill(TickMark.ACTIVE);
      var tickMarksInactiveEnd = Array.from({length: numTickMarksInactiveEnd}).fill(TickMark.INACTIVE);
      this.adapter.updateTickMarks(tickMarksInactiveStart.concat(tickMarksActive).concat(tickMarksInactiveEnd));
    };
    MDCSliderFoundation2.prototype.mapClientXOnSliderScale = function(clientX) {
      var xPos = clientX - this.rect.left;
      var pctComplete = xPos / this.rect.width;
      if (this.adapter.isRTL()) {
        pctComplete = 1 - pctComplete;
      }
      var value = this.min + pctComplete * (this.max - this.min);
      if (value === this.max || value === this.min) {
        return value;
      }
      return Number(this.quantize(value).toFixed(this.numDecimalPlaces));
    };
    MDCSliderFoundation2.prototype.quantize = function(value) {
      var numSteps = Math.round((value - this.min) / this.step);
      return this.min + numSteps * this.step;
    };
    MDCSliderFoundation2.prototype.updateValue = function(value, thumb, _a2) {
      var _b2 = _a2 === void 0 ? {} : _a2, emitInputEvent = _b2.emitInputEvent;
      value = this.clampValue(value, thumb);
      if (this.isRange && thumb === Thumb.START) {
        if (this.valueStart === value)
          return;
        this.valueStart = value;
      } else {
        if (this.value === value)
          return;
        this.value = value;
      }
      this.updateUI(thumb);
      if (emitInputEvent) {
        this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
      }
    };
    MDCSliderFoundation2.prototype.clampValue = function(value, thumb) {
      value = Math.min(Math.max(value, this.min), this.max);
      var thumbStartMovedPastThumbEnd = this.isRange && thumb === Thumb.START && value > this.value;
      if (thumbStartMovedPastThumbEnd) {
        return this.value;
      }
      var thumbEndMovedPastThumbStart = this.isRange && thumb === Thumb.END && value < this.valueStart;
      if (thumbEndMovedPastThumbStart) {
        return this.valueStart;
      }
      return value;
    };
    MDCSliderFoundation2.prototype.updateThumbAndTrackUI = function(thumb) {
      var _this = this;
      var _a2 = this, max = _a2.max, min = _a2.min;
      var pctComplete = (this.value - this.valueStart) / (max - min);
      var rangePx = pctComplete * this.rect.width;
      var isRtl = this.adapter.isRTL();
      var transformProp = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
      if (this.isRange) {
        var thumbLeftPos_1 = this.adapter.isRTL() ? (max - this.value) / (max - min) * this.rect.width : (this.valueStart - min) / (max - min) * this.rect.width;
        var thumbRightPos_1 = thumbLeftPos_1 + rangePx;
        this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
          var trackAnimatesFromRight = !isRtl && thumb === Thumb.START || isRtl && thumb !== Thumb.START;
          if (trackAnimatesFromRight) {
            _this.adapter.setTrackActiveStyleProperty("transform-origin", "right");
            _this.adapter.setTrackActiveStyleProperty("left", "unset");
            _this.adapter.setTrackActiveStyleProperty("right", _this.rect.width - thumbRightPos_1 + "px");
          } else {
            _this.adapter.setTrackActiveStyleProperty("transform-origin", "left");
            _this.adapter.setTrackActiveStyleProperty("right", "unset");
            _this.adapter.setTrackActiveStyleProperty("left", thumbLeftPos_1 + "px");
          }
          _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
          var thumbStartPos = isRtl ? thumbRightPos_1 : thumbLeftPos_1;
          var thumbEndPos = _this.adapter.isRTL() ? thumbLeftPos_1 : thumbRightPos_1;
          if (thumb === Thumb.START || !thumb || !_this.initialStylesRemoved) {
            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.START);
          }
          if (thumb === Thumb.END || !thumb || !_this.initialStylesRemoved) {
            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbEndPos + "px)", Thumb.END);
          }
          _this.removeInitialStyles(isRtl);
          _this.updateOverlappingThumbsUI(thumbStartPos, thumbEndPos, thumb);
        });
      } else {
        this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
          var thumbStartPos = isRtl ? _this.rect.width - rangePx : rangePx;
          _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.END);
          _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
          _this.removeInitialStyles(isRtl);
        });
      }
    };
    MDCSliderFoundation2.prototype.removeInitialStyles = function(isRtl) {
      if (this.initialStylesRemoved)
        return;
      var position = isRtl ? "right" : "left";
      this.adapter.removeThumbStyleProperty(position, Thumb.END);
      if (this.isRange) {
        this.adapter.removeThumbStyleProperty(position, Thumb.START);
      }
      this.initialStylesRemoved = true;
      this.resetTrackAndThumbAnimation();
    };
    MDCSliderFoundation2.prototype.resetTrackAndThumbAnimation = function() {
      var _this = this;
      if (!this.isDiscrete)
        return;
      var transitionProp = HAS_WINDOW ? getCorrectPropertyName(window, "transition") : "transition";
      var transitionDefault = "all 0s ease 0s";
      this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.END);
      if (this.isRange) {
        this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.START);
      }
      this.adapter.setTrackActiveStyleProperty(transitionProp, transitionDefault);
      requestAnimationFrame(function() {
        _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.END);
        _this.adapter.removeTrackActiveStyleProperty(transitionProp);
        if (_this.isRange) {
          _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.START);
        }
      });
    };
    MDCSliderFoundation2.prototype.updateOverlappingThumbsUI = function(thumbStartPos, thumbEndPos, thumb) {
      var thumbsOverlap = false;
      if (this.adapter.isRTL()) {
        var startThumbLeftEdge = thumbStartPos - this.startThumbKnobWidth / 2;
        var endThumbRightEdge = thumbEndPos + this.endThumbKnobWidth / 2;
        thumbsOverlap = endThumbRightEdge >= startThumbLeftEdge;
      } else {
        var startThumbRightEdge = thumbStartPos + this.startThumbKnobWidth / 2;
        var endThumbLeftEdge = thumbEndPos - this.endThumbKnobWidth / 2;
        thumbsOverlap = startThumbRightEdge >= endThumbLeftEdge;
      }
      if (thumbsOverlap) {
        this.adapter.addThumbClass(cssClasses$1.THUMB_TOP, thumb || Thumb.END);
        this.adapter.removeThumbClass(cssClasses$1.THUMB_TOP, thumb === Thumb.START ? Thumb.END : Thumb.START);
      } else {
        this.adapter.removeThumbClass(cssClasses$1.THUMB_TOP, Thumb.START);
        this.adapter.removeThumbClass(cssClasses$1.THUMB_TOP, Thumb.END);
      }
    };
    MDCSliderFoundation2.prototype.convertAttributeValueToNumber = function(attributeValue, attributeName) {
      if (attributeValue === null) {
        throw new Error("MDCSliderFoundation: `" + attributeName + "` must be non-null.");
      }
      var value = Number(attributeValue);
      if (isNaN(value)) {
        throw new Error("MDCSliderFoundation: `" + attributeName + "` value is " + ("`" + attributeValue + "`, but must be a number."));
      }
      return value;
    };
    MDCSliderFoundation2.prototype.validateProperties = function(_a2) {
      var min = _a2.min, max = _a2.max, value = _a2.value, valueStart = _a2.valueStart, step = _a2.step;
      if (min >= max) {
        throw new Error("MDCSliderFoundation: min must be strictly less than max. " + ("Current: [min: " + min + ", max: " + max + "]"));
      }
      if (step <= 0) {
        throw new Error("MDCSliderFoundation: step must be a positive number. " + ("Current step: " + this.step));
      }
      if (this.isRange) {
        if (value < min || value > max || valueStart < min || valueStart > max) {
          throw new Error("MDCSliderFoundation: values must be in [min, max] range. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
        }
        if (valueStart > value) {
          throw new Error("MDCSliderFoundation: start value must be <= end value. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
        }
        var numStepsValueStartFromMin = (valueStart - min) / step;
        var numStepsValueFromMin = (value - min) / step;
        if (numStepsValueStartFromMin % 1 !== 0 || numStepsValueFromMin % 1 !== 0) {
          throw new Error("MDCSliderFoundation: Slider values must be valid based on the " + ("step value. Current values: [start value: " + valueStart + ", ") + ("end value: " + value + "]"));
        }
      } else {
        if (value < min || value > max) {
          throw new Error("MDCSliderFoundation: value must be in [min, max] range. " + ("Current value: " + value));
        }
        var numStepsValueFromMin = (value - min) / step;
        if (numStepsValueFromMin % 1 !== 0) {
          throw new Error("MDCSliderFoundation: Slider value must be valid based on the " + ("step value. Current value: " + value));
        }
      }
    };
    MDCSliderFoundation2.prototype.registerEventHandlers = function() {
      this.adapter.registerWindowEventHandler("resize", this.resizeListener);
      if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
        this.adapter.registerEventHandler("pointerdown", this.pointerdownListener);
        this.adapter.registerEventHandler("pointerup", this.pointerupListener);
      } else {
        this.adapter.registerEventHandler("mousedown", this.mousedownOrTouchstartListener);
        this.adapter.registerEventHandler("touchstart", this.mousedownOrTouchstartListener);
      }
      if (this.isRange) {
        this.adapter.registerThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
        this.adapter.registerThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.registerInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
        this.adapter.registerInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
        this.adapter.registerInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
      }
      this.adapter.registerThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
      this.adapter.registerThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
      this.adapter.registerInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
      this.adapter.registerInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
      this.adapter.registerInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
    };
    MDCSliderFoundation2.prototype.deregisterEventHandlers = function() {
      this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
      if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
        this.adapter.deregisterEventHandler("pointerdown", this.pointerdownListener);
        this.adapter.deregisterEventHandler("pointerup", this.pointerupListener);
      } else {
        this.adapter.deregisterEventHandler("mousedown", this.mousedownOrTouchstartListener);
        this.adapter.deregisterEventHandler("touchstart", this.mousedownOrTouchstartListener);
      }
      if (this.isRange) {
        this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
        this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
      }
      this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
      this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
    };
    MDCSliderFoundation2.prototype.handlePointerup = function() {
      this.handleUp();
      this.adapter.deregisterEventHandler("pointermove", this.moveListener);
    };
    MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS = HAS_WINDOW && Boolean(window.PointerEvent) && !isIOS();
    return MDCSliderFoundation2;
  }(MDCFoundation$1);
  function isIOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  function getNumDecimalPlaces(n) {
    var match = /(?:\.(\d+))?(?:[eE]([+\-]?\d+))?$/.exec(String(n));
    if (!match)
      return 0;
    var fraction = match[1] || "";
    var exponent = match[2] || 0;
    return Math.max(0, (fraction === "0" ? 0 : fraction.length) - Number(exponent));
  }
  function classMap2(classObj) {
    return Object.entries(classObj).filter(([name2, value]) => name2 !== "" && value).map(([name2]) => name2).join(" ");
  }
  function dispatch2(element2, eventType, detail, eventInit = {bubbles: true}, duplicateEventForMDC = false) {
    if (typeof Event !== "undefined" && element2) {
      const event = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), {detail}));
      element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(event);
      if (duplicateEventForMDC && eventType.startsWith("SMUI")) {
        const duplicateEvent = new CustomEvent(eventType.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, eventInit), {detail}));
        element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(duplicateEvent);
        if (duplicateEvent.defaultPrevented) {
          event.preventDefault();
        }
      }
      return event;
    }
  }
  function exclude(obj, keys) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name2 = names[i];
      const cashIndex = name2.indexOf("$");
      if (cashIndex !== -1 && keys.indexOf(name2.substring(0, cashIndex + 1)) !== -1) {
        continue;
      }
      if (keys.indexOf(name2) !== -1) {
        continue;
      }
      newObj[name2] = obj[name2];
    }
    return newObj;
  }
  var oldModifierRegex2 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex2 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder2(component) {
    let $on;
    let events3 = [];
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events3.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex2);
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      return () => {
        destructor();
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex2);
        const newModifierMatch = eventType.match(newModifierRegex2);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (eventType.match(/^SMUI:\w+:/)) {
          const newEventTypeParts = eventType.split(":");
          let newEventType = "";
          for (let i = 0; i < newEventTypeParts.length; i++) {
            newEventType += i === newEventTypeParts.length - 1 ? ":" + newEventTypeParts[i] : newEventTypeParts[i].split("-").map((value) => value.slice(0, 1).toUpperCase() + value.slice(1)).join("");
          }
          console.warn(`The event ${eventType.split("$")[0]} has been renamed to ${newEventType.split("$")[0]}.`);
          eventType = newEventType;
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (eventOptions.passive) {
            options = options || {};
            options.passive = true;
          }
          if (eventOptions.nonpassive) {
            options = options || {};
            options.passive = false;
          }
          if (eventOptions.capture) {
            options = options || {};
            options.capture = true;
          }
          if (eventOptions.once) {
            options = options || {};
            options.once = true;
          }
          if (eventOptions.preventDefault) {
            handler = prevent_default(handler);
          }
          if (eventOptions.stopPropagation) {
            handler = stop_propagation(handler);
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!(eventType in forwardDestructors)) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events3.length; i++) {
        $on(events3[i][0], events3[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function prefixFilter(obj, prefix) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name2 = names[i];
      if (name2.substring(0, prefix.length) === prefix) {
        newObj[name2.substring(prefix.length)] = obj[name2];
      }
    }
    return newObj;
  }
  function useActions2(node, actions) {
    let actionReturns = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const actionEntry = actions[i];
        const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
        if (Array.isArray(actionEntry) && actionEntry.length > 1) {
          actionReturns.push(action(node, actionEntry[1]));
        } else {
          actionReturns.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != actionReturns.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            const returnEntry = actionReturns[i];
            if (returnEntry && returnEntry.update) {
              const actionEntry = actions2[i];
              if (Array.isArray(actionEntry) && actionEntry.length > 1) {
                returnEntry.update(actionEntry[1]);
              } else {
                returnEntry.update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < actionReturns.length; i++) {
          const returnEntry = actionReturns[i];
          if (returnEntry && returnEntry.destroy) {
            returnEntry.destroy();
          }
        }
      }
    };
  }
  var supportsCssVariables_2;
  function supportsCssVariables2(windowObj, forceRefresh) {
    if (forceRefresh === void 0) {
      forceRefresh = false;
    }
    var CSS = windowObj.CSS;
    var supportsCssVars = supportsCssVariables_2;
    if (typeof supportsCssVariables_2 === "boolean" && !forceRefresh) {
      return supportsCssVariables_2;
    }
    var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
    if (!supportsFunctionPresent) {
      return false;
    }
    var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
    var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
    supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
    if (!forceRefresh) {
      supportsCssVariables_2 = supportsCssVars;
    }
    return supportsCssVars;
  }
  function getNormalizedEventCoords2(evt, pageOffset, clientRect) {
    if (!evt) {
      return {x: 0, y: 0};
    }
    var x = pageOffset.x, y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY;
    if (evt.type === "touchstart") {
      var touchEvent = evt;
      normalizedX = touchEvent.changedTouches[0].pageX - documentX;
      normalizedY = touchEvent.changedTouches[0].pageY - documentY;
    } else {
      var mouseEvent = evt;
      normalizedX = mouseEvent.pageX - documentX;
      normalizedY = mouseEvent.pageY - documentY;
    }
    return {x: normalizedX, y: normalizedY};
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFoundation2 = function() {
    function MDCFoundation3(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation3, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation3, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation3.prototype.init = function() {
    };
    MDCFoundation3.prototype.destroy = function() {
    };
    return MDCFoundation3;
  }();
  /**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function applyPassive$12(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    return supportsPassiveOption2(globalObj) ? {passive: true} : false;
  }
  function supportsPassiveOption2(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    var passiveSupported = false;
    try {
      var options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      var handler = function() {
      };
      globalObj.document.addEventListener("test", handler, options);
      globalObj.document.removeEventListener("test", handler, options);
    } catch (err) {
      passiveSupported = false;
    }
    return passiveSupported;
  }
  var events2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    applyPassive: applyPassive$12
  });
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function closest2(element2, selector) {
    if (element2.closest) {
      return element2.closest(selector);
    }
    var el = element2;
    while (el) {
      if (matches$12(el, selector)) {
        return el;
      }
      el = el.parentElement;
    }
    return null;
  }
  function matches$12(element2, selector) {
    var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
    return nativeMatches.call(element2, selector);
  }
  function estimateScrollWidth2(element2) {
    var htmlEl = element2;
    if (htmlEl.offsetParent !== null) {
      return htmlEl.scrollWidth;
    }
    var clone2 = htmlEl.cloneNode(true);
    clone2.style.setProperty("position", "absolute");
    clone2.style.setProperty("transform", "translate(-9999px, -9999px)");
    document.documentElement.appendChild(clone2);
    var scrollWidth = clone2.scrollWidth;
    document.documentElement.removeChild(clone2);
    return scrollWidth;
  }
  var ponyfill2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    closest: closest2,
    matches: matches$12,
    estimateScrollWidth: estimateScrollWidth2
  });
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses2 = {
    BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
    FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
    FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
    ROOT: "mdc-ripple-upgraded",
    UNBOUNDED: "mdc-ripple-upgraded--unbounded"
  };
  var strings2 = {
    VAR_FG_SCALE: "--mdc-ripple-fg-scale",
    VAR_FG_SIZE: "--mdc-ripple-fg-size",
    VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
    VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
    VAR_LEFT: "--mdc-ripple-left",
    VAR_TOP: "--mdc-ripple-top"
  };
  var numbers2 = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: 0.6,
    PADDING: 10,
    TAP_DELAY_MS: 300
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ACTIVATION_EVENT_TYPES2 = [
    "touchstart",
    "pointerdown",
    "mousedown",
    "keydown"
  ];
  var POINTER_DEACTIVATION_EVENT_TYPES2 = [
    "touchend",
    "pointerup",
    "mouseup",
    "contextmenu"
  ];
  var activatedTargets2 = [];
  var MDCRippleFoundation2 = function(_super) {
    __extends(MDCRippleFoundation3, _super);
    function MDCRippleFoundation3(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation3.defaultAdapter), adapter)) || this;
      _this.activationAnimationHasEnded = false;
      _this.activationTimer = 0;
      _this.fgDeactivationRemovalTimer = 0;
      _this.fgScale = "0";
      _this.frame = {width: 0, height: 0};
      _this.initialSize = 0;
      _this.layoutFrame = 0;
      _this.maxRadius = 0;
      _this.unboundedCoords = {left: 0, top: 0};
      _this.activationState = _this.defaultActivationState();
      _this.activationTimerCallback = function() {
        _this.activationAnimationHasEnded = true;
        _this.runDeactivationUXLogicIfReady();
      };
      _this.activateHandler = function(e) {
        _this.activateImpl(e);
      };
      _this.deactivateHandler = function() {
        _this.deactivateImpl();
      };
      _this.focusHandler = function() {
        _this.handleFocus();
      };
      _this.blurHandler = function() {
        _this.handleBlur();
      };
      _this.resizeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCRippleFoundation3, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "numbers", {
      get: function() {
        return numbers2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation3, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          browserSupportsCssVars: function() {
            return true;
          },
          computeBoundingRect: function() {
            return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
          },
          containsEventTarget: function() {
            return true;
          },
          deregisterDocumentInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          deregisterResizeHandler: function() {
            return void 0;
          },
          getWindowPageOffset: function() {
            return {x: 0, y: 0};
          },
          isSurfaceActive: function() {
            return true;
          },
          isSurfaceDisabled: function() {
            return true;
          },
          isUnbounded: function() {
            return true;
          },
          registerDocumentInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          registerResizeHandler: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          updateCssVariable: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRippleFoundation3.prototype.init = function() {
      var _this = this;
      var supportsPressRipple = this.supportsPressRipple();
      this.registerRootHandlers(supportsPressRipple);
      if (supportsPressRipple) {
        var _a2 = MDCRippleFoundation3.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.addClass(ROOT_1);
          if (_this.adapter.isUnbounded()) {
            _this.adapter.addClass(UNBOUNDED_1);
            _this.layoutInternal();
          }
        });
      }
    };
    MDCRippleFoundation3.prototype.destroy = function() {
      var _this = this;
      if (this.supportsPressRipple()) {
        if (this.activationTimer) {
          clearTimeout(this.activationTimer);
          this.activationTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation3.cssClasses.FG_ACTIVATION);
        }
        if (this.fgDeactivationRemovalTimer) {
          clearTimeout(this.fgDeactivationRemovalTimer);
          this.fgDeactivationRemovalTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation3.cssClasses.FG_DEACTIVATION);
        }
        var _a2 = MDCRippleFoundation3.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.removeClass(ROOT_2);
          _this.adapter.removeClass(UNBOUNDED_2);
          _this.removeCssVars();
        });
      }
      this.deregisterRootHandlers();
      this.deregisterDeactivationHandlers();
    };
    MDCRippleFoundation3.prototype.activate = function(evt) {
      this.activateImpl(evt);
    };
    MDCRippleFoundation3.prototype.deactivate = function() {
      this.deactivateImpl();
    };
    MDCRippleFoundation3.prototype.layout = function() {
      var _this = this;
      if (this.layoutFrame) {
        cancelAnimationFrame(this.layoutFrame);
      }
      this.layoutFrame = requestAnimationFrame(function() {
        _this.layoutInternal();
        _this.layoutFrame = 0;
      });
    };
    MDCRippleFoundation3.prototype.setUnbounded = function(unbounded) {
      var UNBOUNDED = MDCRippleFoundation3.cssClasses.UNBOUNDED;
      if (unbounded) {
        this.adapter.addClass(UNBOUNDED);
      } else {
        this.adapter.removeClass(UNBOUNDED);
      }
    };
    MDCRippleFoundation3.prototype.handleFocus = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.addClass(MDCRippleFoundation3.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation3.prototype.handleBlur = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.removeClass(MDCRippleFoundation3.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation3.prototype.supportsPressRipple = function() {
      return this.adapter.browserSupportsCssVars();
    };
    MDCRippleFoundation3.prototype.defaultActivationState = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: false,
        isActivated: false,
        isProgrammatic: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false
      };
    };
    MDCRippleFoundation3.prototype.registerRootHandlers = function(supportsPressRipple) {
      var e_1, _a2;
      if (supportsPressRipple) {
        try {
          for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES2), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerInteractionHandler(evtType, this.activateHandler);
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a2 = ACTIVATION_EVENT_TYPES_1.return))
              _a2.call(ACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (this.adapter.isUnbounded()) {
          this.adapter.registerResizeHandler(this.resizeHandler);
        }
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler);
      this.adapter.registerInteractionHandler("blur", this.blurHandler);
    };
    MDCRippleFoundation3.prototype.registerDeactivationHandlers = function(evt) {
      var e_2, _a2;
      if (evt.type === "keydown") {
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
      } else {
        try {
          for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES2), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
          }
        } catch (e_2_1) {
          e_2 = {error: e_2_1};
        } finally {
          try {
            if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
              _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    };
    MDCRippleFoundation3.prototype.deregisterRootHandlers = function() {
      var e_3, _a2;
      try {
        for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES2), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_3_1) {
        e_3 = {error: e_3_1};
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a2 = ACTIVATION_EVENT_TYPES_2.return))
            _a2.call(ACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
      this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
      if (this.adapter.isUnbounded()) {
        this.adapter.deregisterResizeHandler(this.resizeHandler);
      }
    };
    MDCRippleFoundation3.prototype.deregisterDeactivationHandlers = function() {
      var e_4, _a2;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES2), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_4_1) {
        e_4 = {error: e_4_1};
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
            _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    MDCRippleFoundation3.prototype.removeCssVars = function() {
      var _this = this;
      var rippleStrings = MDCRippleFoundation3.strings;
      var keys = Object.keys(rippleStrings);
      keys.forEach(function(key) {
        if (key.indexOf("VAR_") === 0) {
          _this.adapter.updateCssVariable(rippleStrings[key], null);
        }
      });
    };
    MDCRippleFoundation3.prototype.activateImpl = function(evt) {
      var _this = this;
      if (this.adapter.isSurfaceDisabled()) {
        return;
      }
      var activationState = this.activationState;
      if (activationState.isActivated) {
        return;
      }
      var previousActivationEvent = this.previousActivationEvent;
      var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
      if (isSameInteraction) {
        return;
      }
      activationState.isActivated = true;
      activationState.isProgrammatic = evt === void 0;
      activationState.activationEvent = evt;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
      var hasActivatedChild = evt !== void 0 && activatedTargets2.length > 0 && activatedTargets2.some(function(target) {
        return _this.adapter.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        this.resetActivationState();
        return;
      }
      if (evt !== void 0) {
        activatedTargets2.push(evt.target);
        this.registerDeactivationHandlers(evt);
      }
      activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
      if (activationState.wasElementMadeActive) {
        this.animateActivation();
      }
      requestAnimationFrame(function() {
        activatedTargets2 = [];
        if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
          activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
          if (activationState.wasElementMadeActive) {
            _this.animateActivation();
          }
        }
        if (!activationState.wasElementMadeActive) {
          _this.activationState = _this.defaultActivationState();
        }
      });
    };
    MDCRippleFoundation3.prototype.checkElementMadeActive = function(evt) {
      return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
    };
    MDCRippleFoundation3.prototype.animateActivation = function() {
      var _this = this;
      var _a2 = MDCRippleFoundation3.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
      var _b2 = MDCRippleFoundation3.cssClasses, FG_DEACTIVATION = _b2.FG_DEACTIVATION, FG_ACTIVATION = _b2.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation3.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var translateStart = "";
      var translateEnd = "";
      if (!this.adapter.isUnbounded()) {
        var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
        translateStart = startPoint.x + "px, " + startPoint.y + "px";
        translateEnd = endPoint.x + "px, " + endPoint.y + "px";
      }
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      clearTimeout(this.activationTimer);
      clearTimeout(this.fgDeactivationRemovalTimer);
      this.rmBoundedActivationClasses();
      this.adapter.removeClass(FG_DEACTIVATION);
      this.adapter.computeBoundingRect();
      this.adapter.addClass(FG_ACTIVATION);
      this.activationTimer = setTimeout(function() {
        _this.activationTimerCallback();
      }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation3.prototype.getFgTranslationCoordinates = function() {
      var _a2 = this.activationState, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
      var startPoint;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords2(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame.width / 2,
          y: this.frame.height / 2
        };
      }
      startPoint = {
        x: startPoint.x - this.initialSize / 2,
        y: startPoint.y - this.initialSize / 2
      };
      var endPoint = {
        x: this.frame.width / 2 - this.initialSize / 2,
        y: this.frame.height / 2 - this.initialSize / 2
      };
      return {startPoint, endPoint};
    };
    MDCRippleFoundation3.prototype.runDeactivationUXLogicIfReady = function() {
      var _this = this;
      var FG_DEACTIVATION = MDCRippleFoundation3.cssClasses.FG_DEACTIVATION;
      var _a2 = this.activationState, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;
      if (activationHasEnded && this.activationAnimationHasEnded) {
        this.rmBoundedActivationClasses();
        this.adapter.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer = setTimeout(function() {
          _this.adapter.removeClass(FG_DEACTIVATION);
        }, numbers2.FG_DEACTIVATION_MS);
      }
    };
    MDCRippleFoundation3.prototype.rmBoundedActivationClasses = function() {
      var FG_ACTIVATION = MDCRippleFoundation3.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded = false;
      this.adapter.computeBoundingRect();
    };
    MDCRippleFoundation3.prototype.resetActivationState = function() {
      var _this = this;
      this.previousActivationEvent = this.activationState.activationEvent;
      this.activationState = this.defaultActivationState();
      setTimeout(function() {
        return _this.previousActivationEvent = void 0;
      }, MDCRippleFoundation3.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation3.prototype.deactivateImpl = function() {
      var _this = this;
      var activationState = this.activationState;
      if (!activationState.isActivated) {
        return;
      }
      var state = __assign({}, activationState);
      if (activationState.isProgrammatic) {
        requestAnimationFrame(function() {
          _this.animateDeactivation(state);
        });
        this.resetActivationState();
      } else {
        this.deregisterDeactivationHandlers();
        requestAnimationFrame(function() {
          _this.activationState.hasDeactivationUXRun = true;
          _this.animateDeactivation(state);
          _this.resetActivationState();
        });
      }
    };
    MDCRippleFoundation3.prototype.animateDeactivation = function(_a2) {
      var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady();
      }
    };
    MDCRippleFoundation3.prototype.layoutInternal = function() {
      var _this = this;
      this.frame = this.adapter.computeBoundingRect();
      var maxDim = Math.max(this.frame.height, this.frame.width);
      var getBoundedRadius = function() {
        var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
        return hypotenuse + MDCRippleFoundation3.numbers.PADDING;
      };
      this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
      var initialSize = Math.floor(maxDim * MDCRippleFoundation3.numbers.INITIAL_ORIGIN_SCALE);
      if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
        this.initialSize = initialSize - 1;
      } else {
        this.initialSize = initialSize;
      }
      this.fgScale = "" + this.maxRadius / this.initialSize;
      this.updateLayoutCssVars();
    };
    MDCRippleFoundation3.prototype.updateLayoutCssVars = function() {
      var _a2 = MDCRippleFoundation3.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
      this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
      this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
      if (this.adapter.isUnbounded()) {
        this.unboundedCoords = {
          left: Math.round(this.frame.width / 2 - this.initialSize / 2),
          top: Math.round(this.frame.height / 2 - this.initialSize / 2)
        };
        this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
        this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
      }
    };
    return MDCRippleFoundation3;
  }(MDCFoundation2);
  var {applyPassive: applyPassive2} = events2;
  var {matches: matches2} = ponyfill2;
  function Ripple2(node, {ripple = true, surface = false, unbounded = false, disabled = false, color, active: active2, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name2, value) => node.style.setProperty(name2, value), initPromise = Promise.resolve()} = {}) {
    let instance7;
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let oldActive = active2;
    let oldEventTarget = eventTarget;
    let oldActiveTarget = activeTarget;
    function handleProps() {
      if (surface) {
        addClass("mdc-ripple-surface");
        if (color === "primary") {
          addClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        } else if (color === "secondary") {
          removeClass("smui-ripple-surface--primary");
          addClass("smui-ripple-surface--secondary");
        } else {
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
      } else {
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (instance7 && oldActive !== active2) {
        oldActive = active2;
        if (active2) {
          instance7.activate();
        } else if (active2 === false) {
          instance7.deactivate();
        }
      }
      if (ripple && !instance7) {
        instance7 = new MDCRippleFoundation2({
          addClass,
          browserSupportsCssVars: () => supportsCssVariables2(window),
          computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
          containsEventTarget: (target) => node.contains(target),
          deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive2()),
          deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive2()),
          deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
          getWindowPageOffset: () => ({
            x: window.pageXOffset,
            y: window.pageYOffset
          }),
          isSurfaceActive: () => active2 == null ? matches2(activeTarget || node, ":active") : active2,
          isSurfaceDisabled: () => !!disabled,
          isUnbounded: () => !!unbounded,
          registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive2()),
          registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive2()),
          registerResizeHandler: (handler) => window.addEventListener("resize", handler),
          removeClass,
          updateCssVariable: addStyle
        });
        initPromise.then(() => {
          if (instance7) {
            instance7.init();
            instance7.setUnbounded(unbounded);
          }
        });
      } else if (instance7 && !ripple) {
        initPromise.then(() => {
          if (instance7) {
            instance7.destroy();
            instance7 = void 0;
          }
        });
      }
      if (instance7 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
        oldEventTarget = eventTarget;
        oldActiveTarget = activeTarget;
        instance7.destroy();
        requestAnimationFrame(() => {
          if (instance7) {
            instance7.init();
            instance7.setUnbounded(unbounded);
          }
        });
      }
      if (!ripple && unbounded) {
        addClass("mdc-ripple-upgraded--unbounded");
      }
    }
    handleProps();
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    function layout() {
      if (instance7) {
        instance7.layout();
      }
    }
    return {
      update(props) {
        ({
          ripple,
          surface,
          unbounded,
          disabled,
          color,
          active: active2,
          rippleElement,
          eventTarget,
          activeTarget,
          addClass,
          removeClass,
          addStyle,
          initPromise
        } = Object.assign({ripple: true, surface: false, unbounded: false, disabled: false, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name2, value) => node.style.setProperty(name2, value), initPromise: Promise.resolve()}, props));
        handleProps();
      },
      destroy() {
        if (instance7) {
          instance7.destroy();
          instance7 = void 0;
          removeClass("mdc-ripple-surface");
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      }
    };
  }
  var file4 = "node_modules/@smui/slider/dist/Slider.svelte";
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[90] = list[i];
    return child_ctx;
  }
  function create_else_block_1(ctx) {
    let input_1;
    let input_1_class_value;
    let mounted;
    let dispose;
    let input_1_levels = [
      {
        class: input_1_class_value = classMap2({
          [ctx[12]]: true,
          "mdc-slider__input": true
        })
      },
      {type: "range"},
      {disabled: ctx[5]},
      {step: ctx[9]},
      {min: ctx[10]},
      {max: ctx[11]},
      ctx[32],
      ctx[23],
      prefixFilter(ctx[36], "input$")
    ];
    let input_1_data = {};
    for (let i = 0; i < input_1_levels.length; i += 1) {
      input_1_data = assign(input_1_data, input_1_levels[i]);
    }
    const block = {
      c: function create2() {
        input_1 = element("input");
        set_attributes(input_1, input_1_data);
        add_location(input_1, file4, 55, 4, 1211);
      },
      m: function mount(target, anchor) {
        insert_dev(target, input_1, anchor);
        if (input_1.autofocus)
          input_1.focus();
        ctx[60](input_1);
        set_input_value(input_1, ctx[0]);
        if (!mounted) {
          dispose = [
            listen_dev(input_1, "change", ctx[61]),
            listen_dev(input_1, "input", ctx[61]),
            listen_dev(input_1, "blur", ctx[54], false, false, false),
            listen_dev(input_1, "focus", ctx[55], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
          dirty[0] & 4096 && input_1_class_value !== (input_1_class_value = classMap2({
            [ctx2[12]]: true,
            "mdc-slider__input": true
          })) && {class: input_1_class_value},
          {type: "range"},
          dirty[0] & 32 && {disabled: ctx2[5]},
          dirty[0] & 512 && {step: ctx2[9]},
          dirty[0] & 1024 && {min: ctx2[10]},
          dirty[0] & 2048 && {max: ctx2[11]},
          ctx2[32],
          dirty[0] & 8388608 && ctx2[23],
          dirty[1] & 32 && prefixFilter(ctx2[36], "input$")
        ]));
        if (dirty[0] & 1) {
          set_input_value(input_1, ctx2[0]);
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(input_1);
        ctx[60](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block_1.name,
      type: "else",
      source: "(55:2) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block_5(ctx) {
    let input0;
    let input0_class_value;
    let t;
    let input1;
    let input1_class_value;
    let mounted;
    let dispose;
    let input0_levels = [
      {
        class: input0_class_value = classMap2({
          [ctx[12]]: true,
          "mdc-slider__input": true
        })
      },
      {type: "range"},
      {disabled: ctx[5]},
      {step: ctx[9]},
      {min: ctx[10]},
      {max: ctx[2]},
      ctx[24],
      prefixFilter(ctx[36], "input$")
    ];
    let input0_data = {};
    for (let i = 0; i < input0_levels.length; i += 1) {
      input0_data = assign(input0_data, input0_levels[i]);
    }
    let input1_levels = [
      {
        class: input1_class_value = classMap2({
          [ctx[12]]: true,
          "mdc-slider__input": true
        })
      },
      {type: "range"},
      {disabled: ctx[5]},
      {step: ctx[9]},
      {min: ctx[1]},
      {max: ctx[11]},
      ctx[32],
      ctx[23],
      prefixFilter(ctx[36], "input$")
    ];
    let input1_data = {};
    for (let i = 0; i < input1_levels.length; i += 1) {
      input1_data = assign(input1_data, input1_levels[i]);
    }
    const block = {
      c: function create2() {
        input0 = element("input");
        t = space();
        input1 = element("input");
        set_attributes(input0, input0_data);
        add_location(input0, file4, 19, 4, 489);
        set_attributes(input1, input1_data);
        add_location(input1, file4, 36, 4, 839);
      },
      m: function mount(target, anchor) {
        insert_dev(target, input0, anchor);
        if (input0.autofocus)
          input0.focus();
        ctx[56](input0);
        set_input_value(input0, ctx[1]);
        insert_dev(target, t, anchor);
        insert_dev(target, input1, anchor);
        if (input1.autofocus)
          input1.focus();
        ctx[58](input1);
        set_input_value(input1, ctx[2]);
        if (!mounted) {
          dispose = [
            listen_dev(input0, "change", ctx[57]),
            listen_dev(input0, "input", ctx[57]),
            listen_dev(input0, "blur", ctx[52], false, false, false),
            listen_dev(input0, "focus", ctx[53], false, false, false),
            listen_dev(input1, "change", ctx[59]),
            listen_dev(input1, "input", ctx[59]),
            listen_dev(input1, "blur", ctx[50], false, false, false),
            listen_dev(input1, "focus", ctx[51], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        set_attributes(input0, input0_data = get_spread_update(input0_levels, [
          dirty[0] & 4096 && input0_class_value !== (input0_class_value = classMap2({
            [ctx2[12]]: true,
            "mdc-slider__input": true
          })) && {class: input0_class_value},
          {type: "range"},
          dirty[0] & 32 && {disabled: ctx2[5]},
          dirty[0] & 512 && {step: ctx2[9]},
          dirty[0] & 1024 && {min: ctx2[10]},
          dirty[0] & 4 && {max: ctx2[2]},
          dirty[0] & 16777216 && ctx2[24],
          dirty[1] & 32 && prefixFilter(ctx2[36], "input$")
        ]));
        if (dirty[0] & 2) {
          set_input_value(input0, ctx2[1]);
        }
        set_attributes(input1, input1_data = get_spread_update(input1_levels, [
          dirty[0] & 4096 && input1_class_value !== (input1_class_value = classMap2({
            [ctx2[12]]: true,
            "mdc-slider__input": true
          })) && {class: input1_class_value},
          {type: "range"},
          dirty[0] & 32 && {disabled: ctx2[5]},
          dirty[0] & 512 && {step: ctx2[9]},
          dirty[0] & 2 && {min: ctx2[1]},
          dirty[0] & 2048 && {max: ctx2[11]},
          ctx2[32],
          dirty[0] & 8388608 && ctx2[23],
          dirty[1] & 32 && prefixFilter(ctx2[36], "input$")
        ]));
        if (dirty[0] & 4) {
          set_input_value(input1, ctx2[2]);
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(input0);
        ctx[56](null);
        if (detaching)
          detach_dev(t);
        if (detaching)
          detach_dev(input1);
        ctx[58](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_5.name,
      type: "if",
      source: "(19:2) {#if range}",
      ctx
    });
    return block;
  }
  function create_if_block_4(ctx) {
    let div;
    let each_value = ctx[30];
    validate_each_argument(each_value);
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    const block = {
      c: function create2() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr_dev(div, "class", "mdc-slider__tick-marks");
        add_location(div, file4, 86, 6, 1947);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div, null);
        }
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 1073741824) {
          each_value = ctx2[30];
          validate_each_argument(each_value);
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        destroy_each(each_blocks, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_4.name,
      type: "if",
      source: "(86:4) {#if discrete && tickMarks && step > 0}",
      ctx
    });
    return block;
  }
  function create_each_block(ctx) {
    let div;
    let div_class_value;
    const block = {
      c: function create2() {
        div = element("div");
        attr_dev(div, "class", div_class_value = ctx[90] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive");
        add_location(div, file4, 88, 10, 2039);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 1073741824 && div_class_value !== (div_class_value = ctx2[90] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive")) {
          attr_dev(div, "class", div_class_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_each_block.name,
      type: "each",
      source: "(88:8) {#each currentTickMarks as tickMark}",
      ctx
    });
    return block;
  }
  function create_else_block(ctx) {
    let div1;
    let t;
    let div0;
    let div1_class_value;
    let div1_style_value;
    let Ripple_action;
    let mounted;
    let dispose;
    let if_block = ctx[7] && create_if_block_3(ctx);
    const block = {
      c: function create2() {
        div1 = element("div");
        if (if_block)
          if_block.c();
        t = space();
        div0 = element("div");
        attr_dev(div0, "class", "mdc-slider__thumb-knob");
        add_location(div0, file4, 184, 6, 5187);
        attr_dev(div1, "class", div1_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx[22]
        }));
        attr_dev(div1, "style", div1_style_value = Object.entries(ctx[26]).map(func_3).join(" "));
        add_location(div1, file4, 157, 4, 4281);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        if (if_block)
          if_block.m(div1, null);
        append_dev(div1, t);
        append_dev(div1, div0);
        ctx[72](div0);
        ctx[73](div1);
        if (!mounted) {
          dispose = action_destroyer(Ripple_action = Ripple2.call(null, div1, {
            unbounded: true,
            disabled: ctx[5],
            active: ctx[28],
            eventTarget: ctx[14],
            activeTarget: ctx[14],
            addClass: ctx[74],
            removeClass: ctx[75],
            addStyle: ctx[76]
          }));
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[7]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_3(ctx2);
            if_block.c();
            if_block.m(div1, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty[0] & 4194304 && div1_class_value !== (div1_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx2[22]
        }))) {
          attr_dev(div1, "class", div1_class_value);
        }
        if (dirty[0] & 67108864 && div1_style_value !== (div1_style_value = Object.entries(ctx2[26]).map(func_3).join(" "))) {
          attr_dev(div1, "style", div1_style_value);
        }
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 268451872)
          Ripple_action.update.call(null, {
            unbounded: true,
            disabled: ctx2[5],
            active: ctx2[28],
            eventTarget: ctx2[14],
            activeTarget: ctx2[14],
            addClass: ctx2[74],
            removeClass: ctx2[75],
            addStyle: ctx2[76]
          });
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div1);
        if (if_block)
          if_block.d();
        ctx[72](null);
        ctx[73](null);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block.name,
      type: "else",
      source: "(157:2) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block2(ctx) {
    let div1;
    let t0;
    let div0;
    let div1_class_value;
    let div1_style_value;
    let Ripple_action;
    let t1;
    let div3;
    let t2;
    let div2;
    let div3_class_value;
    let div3_style_value;
    let Ripple_action_1;
    let mounted;
    let dispose;
    let if_block0 = ctx[7] && create_if_block_2(ctx);
    let if_block1 = ctx[7] && create_if_block_1(ctx);
    const block = {
      c: function create2() {
        div1 = element("div");
        if (if_block0)
          if_block0.c();
        t0 = space();
        div0 = element("div");
        t1 = space();
        div3 = element("div");
        if (if_block1)
          if_block1.c();
        t2 = space();
        div2 = element("div");
        attr_dev(div0, "class", "mdc-slider__thumb-knob");
        add_location(div0, file4, 125, 6, 3210);
        attr_dev(div1, "class", div1_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx[21]
        }));
        attr_dev(div1, "style", div1_style_value = Object.entries(ctx[27]).map(func_1).join(" "));
        add_location(div1, file4, 98, 4, 2270);
        attr_dev(div2, "class", "mdc-slider__thumb-knob");
        add_location(div2, file4, 154, 6, 4195);
        attr_dev(div3, "class", div3_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx[22]
        }));
        attr_dev(div3, "style", div3_style_value = Object.entries(ctx[26]).map(func_2).join(" "));
        add_location(div3, file4, 127, 4, 3291);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        if (if_block0)
          if_block0.m(div1, null);
        append_dev(div1, t0);
        append_dev(div1, div0);
        ctx[62](div0);
        ctx[63](div1);
        insert_dev(target, t1, anchor);
        insert_dev(target, div3, anchor);
        if (if_block1)
          if_block1.m(div3, null);
        append_dev(div3, t2);
        append_dev(div3, div2);
        ctx[67](div2);
        ctx[68](div3);
        if (!mounted) {
          dispose = [
            action_destroyer(Ripple_action = Ripple2.call(null, div1, {
              unbounded: true,
              disabled: ctx[5],
              active: ctx[29],
              eventTarget: ctx[15],
              activeTarget: ctx[15],
              addClass: ctx[64],
              removeClass: ctx[65],
              addStyle: ctx[66]
            })),
            action_destroyer(Ripple_action_1 = Ripple2.call(null, div3, {
              unbounded: true,
              disabled: ctx[5],
              active: ctx[28],
              eventTarget: ctx[14],
              activeTarget: ctx[14],
              addClass: ctx[69],
              removeClass: ctx[70],
              addStyle: ctx[71]
            }))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[7]) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_2(ctx2);
            if_block0.c();
            if_block0.m(div1, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (dirty[0] & 2097152 && div1_class_value !== (div1_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx2[21]
        }))) {
          attr_dev(div1, "class", div1_class_value);
        }
        if (dirty[0] & 134217728 && div1_style_value !== (div1_style_value = Object.entries(ctx2[27]).map(func_1).join(" "))) {
          attr_dev(div1, "style", div1_style_value);
        }
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 536903712)
          Ripple_action.update.call(null, {
            unbounded: true,
            disabled: ctx2[5],
            active: ctx2[29],
            eventTarget: ctx2[15],
            activeTarget: ctx2[15],
            addClass: ctx2[64],
            removeClass: ctx2[65],
            addStyle: ctx2[66]
          });
        if (ctx2[7]) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_1(ctx2);
            if_block1.c();
            if_block1.m(div3, t2);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (dirty[0] & 4194304 && div3_class_value !== (div3_class_value = classMap2({
          "mdc-slider__thumb": true,
          ...ctx2[22]
        }))) {
          attr_dev(div3, "class", div3_class_value);
        }
        if (dirty[0] & 67108864 && div3_style_value !== (div3_style_value = Object.entries(ctx2[26]).map(func_2).join(" "))) {
          attr_dev(div3, "style", div3_style_value);
        }
        if (Ripple_action_1 && is_function(Ripple_action_1.update) && dirty[0] & 268451872)
          Ripple_action_1.update.call(null, {
            unbounded: true,
            disabled: ctx2[5],
            active: ctx2[28],
            eventTarget: ctx2[14],
            activeTarget: ctx2[14],
            addClass: ctx2[69],
            removeClass: ctx2[70],
            addStyle: ctx2[71]
          });
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div1);
        if (if_block0)
          if_block0.d();
        ctx[62](null);
        ctx[63](null);
        if (detaching)
          detach_dev(t1);
        if (detaching)
          detach_dev(div3);
        if (if_block1)
          if_block1.d();
        ctx[67](null);
        ctx[68](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block2.name,
      type: "if",
      source: "(98:2) {#if range}",
      ctx
    });
    return block;
  }
  function create_if_block_3(ctx) {
    let div1;
    let div0;
    let span;
    let t;
    const block = {
      c: function create2() {
        div1 = element("div");
        div0 = element("div");
        span = element("span");
        t = text(ctx[0]);
        attr_dev(span, "class", "mdc-slider__value-indicator-text");
        add_location(span, file4, 180, 12, 5075);
        attr_dev(div0, "class", "mdc-slider__value-indicator");
        add_location(div0, file4, 179, 10, 5021);
        attr_dev(div1, "class", "mdc-slider__value-indicator-container");
        attr_dev(div1, "aria-hidden", "true");
        add_location(div1, file4, 178, 8, 4940);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, div0);
        append_dev(div0, span);
        append_dev(span, t);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 1)
          set_data_dev(t, ctx2[0]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div1);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_3.name,
      type: "if",
      source: "(178:6) {#if discrete}",
      ctx
    });
    return block;
  }
  function create_if_block_2(ctx) {
    let div1;
    let div0;
    let span;
    let t;
    const block = {
      c: function create2() {
        div1 = element("div");
        div0 = element("div");
        span = element("span");
        t = text(ctx[1]);
        attr_dev(span, "class", "mdc-slider__value-indicator-text");
        add_location(span, file4, 121, 12, 3098);
        attr_dev(div0, "class", "mdc-slider__value-indicator");
        add_location(div0, file4, 120, 10, 3044);
        attr_dev(div1, "class", "mdc-slider__value-indicator-container");
        attr_dev(div1, "aria-hidden", "true");
        add_location(div1, file4, 119, 8, 2963);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, div0);
        append_dev(div0, span);
        append_dev(span, t);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 2)
          set_data_dev(t, ctx2[1]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div1);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_2.name,
      type: "if",
      source: "(119:6) {#if discrete}",
      ctx
    });
    return block;
  }
  function create_if_block_1(ctx) {
    let div1;
    let div0;
    let span;
    let t;
    const block = {
      c: function create2() {
        div1 = element("div");
        div0 = element("div");
        span = element("span");
        t = text(ctx[2]);
        attr_dev(span, "class", "mdc-slider__value-indicator-text");
        add_location(span, file4, 150, 12, 4085);
        attr_dev(div0, "class", "mdc-slider__value-indicator");
        add_location(div0, file4, 149, 10, 4031);
        attr_dev(div1, "class", "mdc-slider__value-indicator-container");
        attr_dev(div1, "aria-hidden", "true");
        add_location(div1, file4, 148, 8, 3950);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, div0);
        append_dev(div0, span);
        append_dev(span, t);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 4)
          set_data_dev(t, ctx2[2]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div1);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_1.name,
      type: "if",
      source: "(148:6) {#if discrete}",
      ctx
    });
    return block;
  }
  function create_fragment4(ctx) {
    let div4;
    let t0;
    let div3;
    let div0;
    let t1;
    let div2;
    let div1;
    let div1_style_value;
    let t2;
    let t3;
    let div4_class_value;
    let useActions_action;
    let mounted;
    let dispose;
    function select_block_type(ctx2, dirty) {
      if (ctx2[6])
        return create_if_block_5;
      return create_else_block_1;
    }
    let current_block_type = select_block_type(ctx);
    let if_block0 = current_block_type(ctx);
    let if_block1 = ctx[7] && ctx[8] && ctx[9] > 0 && create_if_block_4(ctx);
    function select_block_type_1(ctx2, dirty) {
      if (ctx2[6])
        return create_if_block2;
      return create_else_block;
    }
    let current_block_type_1 = select_block_type_1(ctx);
    let if_block2 = current_block_type_1(ctx);
    let div4_levels = [
      {
        class: div4_class_value = Object.entries({
          [ctx[4]]: true,
          "mdc-slider": true,
          "mdc-slider--range": ctx[6],
          "mdc-slider--discrete": ctx[7],
          "mdc-slider--tick-marks": ctx[7] && ctx[8],
          "mdc-slider--disabled": ctx[5],
          ...ctx[20]
        }).filter(func_4).map(func_5).join(" ")
      },
      exclude(ctx[36], ["input$"])
    ];
    let div4_data = {};
    for (let i = 0; i < div4_levels.length; i += 1) {
      div4_data = assign(div4_data, div4_levels[i]);
    }
    const block = {
      c: function create2() {
        div4 = element("div");
        if_block0.c();
        t0 = space();
        div3 = element("div");
        div0 = element("div");
        t1 = space();
        div2 = element("div");
        div1 = element("div");
        t2 = space();
        if (if_block1)
          if_block1.c();
        t3 = space();
        if_block2.c();
        attr_dev(div0, "class", "mdc-slider__track--inactive");
        add_location(div0, file4, 76, 4, 1604);
        attr_dev(div1, "class", "mdc-slider__track--active_fill");
        attr_dev(div1, "style", div1_style_value = Object.entries(ctx[25]).map(func2).join(" "));
        add_location(div1, file4, 78, 6, 1698);
        attr_dev(div2, "class", "mdc-slider__track--active");
        add_location(div2, file4, 77, 4, 1652);
        attr_dev(div3, "class", "mdc-slider__track");
        add_location(div3, file4, 75, 2, 1568);
        set_attributes(div4, div4_data);
        add_location(div4, file4, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div4, anchor);
        if_block0.m(div4, null);
        append_dev(div4, t0);
        append_dev(div4, div3);
        append_dev(div3, div0);
        append_dev(div3, t1);
        append_dev(div3, div2);
        append_dev(div2, div1);
        append_dev(div3, t2);
        if (if_block1)
          if_block1.m(div3, null);
        append_dev(div4, t3);
        if_block2.m(div4, null);
        ctx[77](div4);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions2.call(null, div4, ctx[3])),
            action_destroyer(ctx[31].call(null, div4))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx2);
          if (if_block0) {
            if_block0.c();
            if_block0.m(div4, t0);
          }
        }
        if (dirty[0] & 33554432 && div1_style_value !== (div1_style_value = Object.entries(ctx2[25]).map(func2).join(" "))) {
          attr_dev(div1, "style", div1_style_value);
        }
        if (ctx2[7] && ctx2[8] && ctx2[9] > 0) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
          } else {
            if_block1 = create_if_block_4(ctx2);
            if_block1.c();
            if_block1.m(div3, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
        if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2.d(1);
          if_block2 = current_block_type_1(ctx2);
          if (if_block2) {
            if_block2.c();
            if_block2.m(div4, null);
          }
        }
        set_attributes(div4, div4_data = get_spread_update(div4_levels, [
          dirty[0] & 1049072 && div4_class_value !== (div4_class_value = Object.entries({
            [ctx2[4]]: true,
            "mdc-slider": true,
            "mdc-slider--range": ctx2[6],
            "mdc-slider--discrete": ctx2[7],
            "mdc-slider--tick-marks": ctx2[7] && ctx2[8],
            "mdc-slider--disabled": ctx2[5],
            ...ctx2[20]
          }).filter(func_4).map(func_5).join(" ")) && {class: div4_class_value},
          dirty[1] & 32 && exclude(ctx2[36], ["input$"])
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 8)
          useActions_action.update.call(null, ctx2[3]);
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div4);
        if_block0.d();
        if (if_block1)
          if_block1.d();
        if_block2.d();
        ctx[77](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment4.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func2 = ([name2, value]) => `${name2}: ${value};`;
  var func_1 = ([name2, value]) => `${name2}: ${value};`;
  var func_2 = ([name2, value]) => `${name2}: ${value};`;
  var func_3 = ([name2, value]) => `${name2}: ${value};`;
  var func_4 = ([name2, value]) => name2 !== "" && value;
  var func_5 = ([name2]) => name2;
  function instance_1($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "disabled",
      "range",
      "discrete",
      "tickMarks",
      "step",
      "min",
      "max",
      "value",
      "start",
      "end",
      "valueToAriaValueTextFn",
      "input$class",
      "layout",
      "getId",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Slider", slots, []);
    var _a2;
    const forwardEvents = forwardEventsBuilder2(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {disabled = false} = $$props;
    let {range = false} = $$props;
    let {discrete = false} = $$props;
    let {tickMarks = false} = $$props;
    let {step = 1} = $$props;
    let {min = 0} = $$props;
    let {max = 100} = $$props;
    let {value = void 0} = $$props;
    let {start = void 0} = $$props;
    let {end = void 0} = $$props;
    let {valueToAriaValueTextFn = (value2) => `${value2}`} = $$props;
    let {input$class = ""} = $$props;
    let element2;
    let instance7;
    let input;
    let inputStart = void 0;
    let thumbEl;
    let thumbStart = void 0;
    let thumbKnob;
    let thumbKnobStart = void 0;
    let internalClasses = {};
    let thumbStartClasses = {};
    let thumbClasses = {};
    let inputAttrs = {};
    let inputStartAttrs = {};
    let trackActiveStyles = {};
    let thumbStyles = {};
    let thumbStartStyles = {};
    let thumbRippleActive = false;
    let thumbStartRippleActive = false;
    let currentTickMarks;
    let inputProps = (_a2 = getContext("SMUI:generic:input:props")) !== null && _a2 !== void 0 ? _a2 : {};
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let previousMin = min;
    let previousMax = max;
    let previousStep = step;
    let previousDiscrete = discrete;
    let previousTickMarks = tickMarks;
    if (tickMarks && step > 0) {
      const absMax = max + Math.abs(min);
      if (range && typeof start === "number" && typeof end === "number") {
        const absStart = start + Math.abs(min);
        const absEnd = end + Math.abs(min);
        currentTickMarks = [
          ...Array(absStart / step).map(() => TickMark.INACTIVE),
          ...Array(absMax / step - absStart / step - (absMax - absEnd) / step + 1).map(() => TickMark.ACTIVE),
          ...Array((absMax - absEnd) / step).map(() => TickMark.INACTIVE)
        ];
      } else if (typeof value === "number") {
        const absValue = value + Math.abs(min);
        currentTickMarks = [
          ...Array(absValue / step + 1).map(() => TickMark.ACTIVE),
          ...Array((absMax - absValue) / step).map(() => TickMark.INACTIVE)
        ];
      }
    }
    if (range && typeof start === "number" && typeof end === "number") {
      const percent = (end - start) / (max - min);
      const percentStart = start / (max - min);
      const percentEnd = end / (max - min);
      trackActiveStyles.transform = `scaleX(${percent})`;
      thumbStyles.left = `calc(${percentEnd * 100}% -24px)`;
      thumbStartStyles.left = `calc(${percentStart * 100}% -24px)`;
    } else if (typeof value === "number") {
      const percent = value / (max - min);
      trackActiveStyles.transform = `scaleX(${percent})`;
      thumbStyles.left = `calc(${percent * 100}% -24px)`;
    }
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    let previousValue = value;
    let previousStart = start;
    let previousEnd = end;
    onMount(() => {
      $$invalidate(41, instance7 = new MDCSliderFoundation({
        hasClass,
        addClass,
        removeClass,
        addThumbClass,
        removeThumbClass,
        getAttribute: (attribute) => getElement().getAttribute(attribute),
        getInputValue: (thumb) => {
          var _a3;
          return `${(_a3 = range ? thumb === Thumb.START ? start : end : value) !== null && _a3 !== void 0 ? _a3 : 0}`;
        },
        setInputValue: (val, thumb) => {
          if (range) {
            if (thumb === Thumb.START) {
              $$invalidate(1, start = Number(val));
              $$invalidate(48, previousStart = start);
            } else {
              $$invalidate(2, end = Number(val));
              $$invalidate(49, previousEnd = end);
            }
          } else {
            $$invalidate(0, value = Number(val));
            $$invalidate(47, previousValue = value);
          }
        },
        getInputAttribute: getInputAttr,
        setInputAttribute: addInputAttr,
        removeInputAttribute: removeInputAttr,
        focusInput: (thumb) => {
          if (range && thumb === Thumb.START && inputStart) {
            inputStart.focus();
          } else {
            input.focus();
          }
        },
        isInputFocused: (thumb) => (range && thumb === Thumb.START ? inputStart : input) === document.activeElement,
        getThumbKnobWidth: (thumb) => {
          var _a3;
          return ((_a3 = range && thumb === Thumb.START ? thumbKnobStart : thumbKnob) !== null && _a3 !== void 0 ? _a3 : thumbKnob).getBoundingClientRect().width;
        },
        getThumbBoundingClientRect: (thumb) => {
          var _a3;
          return ((_a3 = range && thumb === Thumb.START ? thumbStart : thumbEl) !== null && _a3 !== void 0 ? _a3 : thumbEl).getBoundingClientRect();
        },
        getBoundingClientRect: () => getElement().getBoundingClientRect(),
        isRTL: () => getComputedStyle(getElement()).direction === "rtl",
        setThumbStyleProperty: addThumbStyle,
        removeThumbStyleProperty: removeThumbStyle,
        setTrackActiveStyleProperty: addTrackActiveStyle,
        removeTrackActiveStyleProperty: removeTrackActiveStyle,
        setValueIndicatorText: (_value, _thumb) => void 0,
        getValueToAriaValueTextFn: () => valueToAriaValueTextFn,
        updateTickMarks: (tickMarks2) => {
          $$invalidate(30, currentTickMarks = tickMarks2);
        },
        setPointerCapture: (pointerId) => {
          getElement().setPointerCapture(pointerId);
        },
        emitChangeEvent: (value2, thumb) => {
          dispatch2(getElement(), "SMUISlider:change", {value: value2, thumb}, void 0, true);
        },
        emitInputEvent: (value2, thumb) => {
          dispatch2(getElement(), "SMUISlider:input", {value: value2, thumb}, void 0, true);
        },
        emitDragStartEvent: (_2, thumb) => {
          if (range && thumb === Thumb.START) {
            $$invalidate(29, thumbStartRippleActive = true);
          } else {
            $$invalidate(28, thumbRippleActive = true);
          }
        },
        emitDragEndEvent: (_2, thumb) => {
          if (range && thumb === Thumb.START) {
            $$invalidate(29, thumbStartRippleActive = false);
          } else {
            $$invalidate(28, thumbRippleActive = false);
          }
        },
        registerEventHandler: (evtType, handler) => {
          getElement().addEventListener(evtType, handler);
        },
        deregisterEventHandler: (evtType, handler) => {
          getElement().removeEventListener(evtType, handler);
        },
        registerThumbEventHandler: (thumb, evtType, handler) => {
          var _a3;
          (_a3 = range && thumb === Thumb.START ? thumbStart : thumbEl) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(evtType, handler);
        },
        deregisterThumbEventHandler: (thumb, evtType, handler) => {
          var _a3;
          (_a3 = range && thumb === Thumb.START ? thumbStart : thumbEl) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(evtType, handler);
        },
        registerInputEventHandler: (thumb, evtType, handler) => {
          var _a3;
          (_a3 = range && thumb === Thumb.START ? inputStart : input) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(evtType, handler);
        },
        deregisterInputEventHandler: (thumb, evtType, handler) => {
          var _a3;
          (_a3 = range && thumb === Thumb.START ? inputStart : input) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener(evtType, handler);
        },
        registerBodyEventHandler: (evtType, handler) => {
          document.body.addEventListener(evtType, handler);
        },
        deregisterBodyEventHandler: (evtType, handler) => {
          document.body.removeEventListener(evtType, handler);
        },
        registerWindowEventHandler: (evtType, handler) => {
          window.addEventListener(evtType, handler);
        },
        deregisterWindowEventHandler: (evtType, handler) => {
          window.removeEventListener(evtType, handler);
        }
      }));
      const accessor = {
        get element() {
          return getElement();
        },
        activateRipple() {
          if (!disabled) {
            $$invalidate(28, thumbRippleActive = true);
          }
        },
        deactivateRipple() {
          $$invalidate(28, thumbRippleActive = false);
        }
      };
      dispatch2(element2, "SMUIGenericInput:mount", accessor);
      instance7.init();
      instance7.layout({skipUpdateUI: true});
      return () => {
        dispatch2(element2, "SMUIGenericInput:unmount", accessor);
        instance7.destroy();
      };
    });
    onDestroy(() => {
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(20, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(20, internalClasses[className2] = false, internalClasses);
      }
    }
    function addThumbClass(className2, thumb) {
      if (range && thumb === Thumb.START) {
        if (!thumbStartClasses[className2]) {
          $$invalidate(21, thumbStartClasses[className2] = true, thumbStartClasses);
        }
      } else {
        if (!thumbClasses[className2]) {
          $$invalidate(22, thumbClasses[className2] = true, thumbClasses);
        }
      }
    }
    function removeThumbClass(className2, thumb) {
      if (range && thumb === Thumb.START) {
        if (!(className2 in thumbStartClasses) || thumbStartClasses[className2]) {
          $$invalidate(21, thumbStartClasses[className2] = false, thumbStartClasses);
        }
      } else {
        if (!(className2 in thumbClasses) || thumbClasses[className2]) {
          $$invalidate(22, thumbClasses[className2] = false, thumbClasses);
        }
      }
    }
    function addThumbStyle(name2, value2, thumb) {
      if (range && thumb === Thumb.START) {
        if (thumbStartStyles[name2] != value2) {
          if (value2 === "" || value2 == null) {
            delete thumbStartStyles[name2];
            $$invalidate(27, thumbStartStyles);
          } else {
            $$invalidate(27, thumbStartStyles[name2] = value2, thumbStartStyles);
          }
        }
      } else {
        if (thumbStyles[name2] != value2) {
          if (value2 === "" || value2 == null) {
            delete thumbStyles[name2];
            $$invalidate(26, thumbStyles);
          } else {
            $$invalidate(26, thumbStyles[name2] = value2, thumbStyles);
          }
        }
      }
    }
    function removeThumbStyle(name2, thumb) {
      if (range && thumb === Thumb.START) {
        if (name2 in thumbStartStyles) {
          delete thumbStartStyles[name2];
          $$invalidate(27, thumbStartStyles);
        }
      } else {
        if (name2 in thumbStyles) {
          delete thumbStyles[name2];
          $$invalidate(26, thumbStyles);
        }
      }
    }
    function getInputAttr(name2, thumb) {
      var _a3, _b2, _c;
      if (range && thumb === Thumb.START) {
        if (name2 === "value") {
          return `${start}`;
        }
        return name2 in inputStartAttrs ? (_a3 = inputStartAttrs[name2]) !== null && _a3 !== void 0 ? _a3 : null : (_b2 = inputStart === null || inputStart === void 0 ? void 0 : inputStart.getAttribute(name2)) !== null && _b2 !== void 0 ? _b2 : null;
      } else {
        if (name2 === "value") {
          return `${range ? end : value}`;
        }
        return name2 in inputAttrs ? (_c = inputAttrs[name2]) !== null && _c !== void 0 ? _c : null : input.getAttribute(name2);
      }
    }
    function addInputAttr(name2, value2, thumb) {
      if (range && thumb === Thumb.START) {
        if (inputStartAttrs[name2] !== value2) {
          $$invalidate(24, inputStartAttrs[name2] = value2, inputStartAttrs);
        }
      } else {
        if (inputAttrs[name2] !== value2) {
          $$invalidate(23, inputAttrs[name2] = value2, inputAttrs);
        }
      }
    }
    function removeInputAttr(name2, thumb) {
      if (range && thumb === Thumb.START) {
        if (!(name2 in inputStartAttrs) || inputStartAttrs[name2] != null) {
          $$invalidate(24, inputStartAttrs[name2] = void 0, inputStartAttrs);
        }
      } else {
        if (!(name2 in inputAttrs) || inputAttrs[name2] != null) {
          $$invalidate(23, inputAttrs[name2] = void 0, inputAttrs);
        }
      }
    }
    function addTrackActiveStyle(name2, value2) {
      if (trackActiveStyles[name2] != value2) {
        if (value2 === "" || value2 == null) {
          delete trackActiveStyles[name2];
          $$invalidate(25, trackActiveStyles);
        } else {
          $$invalidate(25, trackActiveStyles[name2] = value2, trackActiveStyles);
        }
      }
    }
    function removeTrackActiveStyle(name2) {
      if (name2 in trackActiveStyles) {
        delete trackActiveStyles[name2];
        $$invalidate(25, trackActiveStyles);
      }
    }
    function layout() {
      return instance7.layout();
    }
    function getId() {
      return inputProps && inputProps.id;
    }
    function getElement() {
      return element2;
    }
    function blur_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function blur_handler(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler(event) {
      bubble.call(this, $$self, event);
    }
    function blur_handler_2(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler_2(event) {
      bubble.call(this, $$self, event);
    }
    function input0_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        inputStart = $$value;
        $$invalidate(15, inputStart);
      });
    }
    function input0_change_input_handler() {
      start = to_number(this.value);
      $$invalidate(1, start);
    }
    function input1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(14, input);
      });
    }
    function input1_change_input_handler() {
      end = to_number(this.value);
      $$invalidate(2, end);
    }
    function input_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(14, input);
      });
    }
    function input_1_change_input_handler() {
      value = to_number(this.value);
      $$invalidate(0, value);
    }
    function div0_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbKnobStart = $$value;
        $$invalidate(19, thumbKnobStart);
      });
    }
    function div1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbStart = $$value;
        $$invalidate(17, thumbStart);
      });
    }
    const Ripple_function = (className2) => addThumbClass(className2, Thumb.START);
    const Ripple_function_1 = (className2) => removeThumbClass(className2, Thumb.START);
    const Ripple_function_2 = (name2, value2) => addThumbStyle(name2, value2, Thumb.START);
    function div2_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbKnob = $$value;
        $$invalidate(18, thumbKnob);
      });
    }
    function div3_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbEl = $$value;
        $$invalidate(16, thumbEl);
      });
    }
    const Ripple_function_3 = (className2) => addThumbClass(className2, Thumb.END);
    const Ripple_function_4 = (className2) => removeThumbClass(className2, Thumb.END);
    const Ripple_function_5 = (name2, value2) => addThumbStyle(name2, value2, Thumb.END);
    function div0_binding_1($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbKnob = $$value;
        $$invalidate(18, thumbKnob);
      });
    }
    function div1_binding_1($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        thumbEl = $$value;
        $$invalidate(16, thumbEl);
      });
    }
    const Ripple_function_6 = (className2) => addThumbClass(className2, Thumb.END);
    const Ripple_function_7 = (className2) => removeThumbClass(className2, Thumb.END);
    const Ripple_function_8 = (name2, value2) => addThumbStyle(name2, value2, Thumb.END);
    function div4_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(13, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(36, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(3, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(4, className = $$new_props.class);
      if ("disabled" in $$new_props)
        $$invalidate(5, disabled = $$new_props.disabled);
      if ("range" in $$new_props)
        $$invalidate(6, range = $$new_props.range);
      if ("discrete" in $$new_props)
        $$invalidate(7, discrete = $$new_props.discrete);
      if ("tickMarks" in $$new_props)
        $$invalidate(8, tickMarks = $$new_props.tickMarks);
      if ("step" in $$new_props)
        $$invalidate(9, step = $$new_props.step);
      if ("min" in $$new_props)
        $$invalidate(10, min = $$new_props.min);
      if ("max" in $$new_props)
        $$invalidate(11, max = $$new_props.max);
      if ("value" in $$new_props)
        $$invalidate(0, value = $$new_props.value);
      if ("start" in $$new_props)
        $$invalidate(1, start = $$new_props.start);
      if ("end" in $$new_props)
        $$invalidate(2, end = $$new_props.end);
      if ("valueToAriaValueTextFn" in $$new_props)
        $$invalidate(37, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
      if ("input$class" in $$new_props)
        $$invalidate(12, input$class = $$new_props.input$class);
    };
    $$self.$capture_state = () => ({
      _a: _a2,
      MDCSliderFoundation,
      Thumb,
      TickMark,
      onMount,
      onDestroy,
      getContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder2,
      classMap: classMap2,
      exclude,
      prefixFilter,
      useActions: useActions2,
      dispatch: dispatch2,
      Ripple: Ripple2,
      forwardEvents,
      use: use2,
      className,
      disabled,
      range,
      discrete,
      tickMarks,
      step,
      min,
      max,
      value,
      start,
      end,
      valueToAriaValueTextFn,
      input$class,
      element: element2,
      instance: instance7,
      input,
      inputStart,
      thumbEl,
      thumbStart,
      thumbKnob,
      thumbKnobStart,
      internalClasses,
      thumbStartClasses,
      thumbClasses,
      inputAttrs,
      inputStartAttrs,
      trackActiveStyles,
      thumbStyles,
      thumbStartStyles,
      thumbRippleActive,
      thumbStartRippleActive,
      currentTickMarks,
      inputProps,
      addLayoutListener,
      removeLayoutListener,
      previousMin,
      previousMax,
      previousStep,
      previousDiscrete,
      previousTickMarks,
      previousValue,
      previousStart,
      previousEnd,
      hasClass,
      addClass,
      removeClass,
      addThumbClass,
      removeThumbClass,
      addThumbStyle,
      removeThumbStyle,
      getInputAttr,
      addInputAttr,
      removeInputAttr,
      addTrackActiveStyle,
      removeTrackActiveStyle,
      layout,
      getId,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("_a" in $$props)
        _a2 = $$new_props._a;
      if ("use" in $$props)
        $$invalidate(3, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(4, className = $$new_props.className);
      if ("disabled" in $$props)
        $$invalidate(5, disabled = $$new_props.disabled);
      if ("range" in $$props)
        $$invalidate(6, range = $$new_props.range);
      if ("discrete" in $$props)
        $$invalidate(7, discrete = $$new_props.discrete);
      if ("tickMarks" in $$props)
        $$invalidate(8, tickMarks = $$new_props.tickMarks);
      if ("step" in $$props)
        $$invalidate(9, step = $$new_props.step);
      if ("min" in $$props)
        $$invalidate(10, min = $$new_props.min);
      if ("max" in $$props)
        $$invalidate(11, max = $$new_props.max);
      if ("value" in $$props)
        $$invalidate(0, value = $$new_props.value);
      if ("start" in $$props)
        $$invalidate(1, start = $$new_props.start);
      if ("end" in $$props)
        $$invalidate(2, end = $$new_props.end);
      if ("valueToAriaValueTextFn" in $$props)
        $$invalidate(37, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
      if ("input$class" in $$props)
        $$invalidate(12, input$class = $$new_props.input$class);
      if ("element" in $$props)
        $$invalidate(13, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(41, instance7 = $$new_props.instance);
      if ("input" in $$props)
        $$invalidate(14, input = $$new_props.input);
      if ("inputStart" in $$props)
        $$invalidate(15, inputStart = $$new_props.inputStart);
      if ("thumbEl" in $$props)
        $$invalidate(16, thumbEl = $$new_props.thumbEl);
      if ("thumbStart" in $$props)
        $$invalidate(17, thumbStart = $$new_props.thumbStart);
      if ("thumbKnob" in $$props)
        $$invalidate(18, thumbKnob = $$new_props.thumbKnob);
      if ("thumbKnobStart" in $$props)
        $$invalidate(19, thumbKnobStart = $$new_props.thumbKnobStart);
      if ("internalClasses" in $$props)
        $$invalidate(20, internalClasses = $$new_props.internalClasses);
      if ("thumbStartClasses" in $$props)
        $$invalidate(21, thumbStartClasses = $$new_props.thumbStartClasses);
      if ("thumbClasses" in $$props)
        $$invalidate(22, thumbClasses = $$new_props.thumbClasses);
      if ("inputAttrs" in $$props)
        $$invalidate(23, inputAttrs = $$new_props.inputAttrs);
      if ("inputStartAttrs" in $$props)
        $$invalidate(24, inputStartAttrs = $$new_props.inputStartAttrs);
      if ("trackActiveStyles" in $$props)
        $$invalidate(25, trackActiveStyles = $$new_props.trackActiveStyles);
      if ("thumbStyles" in $$props)
        $$invalidate(26, thumbStyles = $$new_props.thumbStyles);
      if ("thumbStartStyles" in $$props)
        $$invalidate(27, thumbStartStyles = $$new_props.thumbStartStyles);
      if ("thumbRippleActive" in $$props)
        $$invalidate(28, thumbRippleActive = $$new_props.thumbRippleActive);
      if ("thumbStartRippleActive" in $$props)
        $$invalidate(29, thumbStartRippleActive = $$new_props.thumbStartRippleActive);
      if ("currentTickMarks" in $$props)
        $$invalidate(30, currentTickMarks = $$new_props.currentTickMarks);
      if ("inputProps" in $$props)
        $$invalidate(32, inputProps = $$new_props.inputProps);
      if ("addLayoutListener" in $$props)
        addLayoutListener = $$new_props.addLayoutListener;
      if ("removeLayoutListener" in $$props)
        removeLayoutListener = $$new_props.removeLayoutListener;
      if ("previousMin" in $$props)
        $$invalidate(42, previousMin = $$new_props.previousMin);
      if ("previousMax" in $$props)
        $$invalidate(43, previousMax = $$new_props.previousMax);
      if ("previousStep" in $$props)
        $$invalidate(44, previousStep = $$new_props.previousStep);
      if ("previousDiscrete" in $$props)
        $$invalidate(45, previousDiscrete = $$new_props.previousDiscrete);
      if ("previousTickMarks" in $$props)
        $$invalidate(46, previousTickMarks = $$new_props.previousTickMarks);
      if ("previousValue" in $$props)
        $$invalidate(47, previousValue = $$new_props.previousValue);
      if ("previousStart" in $$props)
        $$invalidate(48, previousStart = $$new_props.previousStart);
      if ("previousEnd" in $$props)
        $$invalidate(49, previousEnd = $$new_props.previousEnd);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 1024 | $$self.$$.dirty[1] & 3072) {
        if (min !== previousMin) {
          if (instance7) {
            instance7.setMin(min);
          }
          $$invalidate(42, previousMin = min);
        }
      }
      if ($$self.$$.dirty[0] & 2048 | $$self.$$.dirty[1] & 5120) {
        if (max !== previousMax) {
          if (instance7) {
            instance7.setMax(max);
          }
          $$invalidate(43, previousMax = max);
        }
      }
      if ($$self.$$.dirty[0] & 512 | $$self.$$.dirty[1] & 9216) {
        if (step !== previousStep) {
          if (instance7) {
            instance7.setStep(step);
          }
          $$invalidate(44, previousStep = step);
        }
      }
      if ($$self.$$.dirty[0] & 128 | $$self.$$.dirty[1] & 17408) {
        if (discrete !== previousDiscrete) {
          if (instance7) {
            instance7.setIsDiscrete(discrete);
          }
          $$invalidate(45, previousDiscrete = discrete);
        }
      }
      if ($$self.$$.dirty[0] & 256 | $$self.$$.dirty[1] & 33792) {
        if (tickMarks !== previousTickMarks) {
          if (instance7) {
            instance7.setHasTickMarks(tickMarks);
          }
          $$invalidate(46, previousTickMarks = tickMarks);
        }
      }
      if ($$self.$$.dirty[0] & 7 | $$self.$$.dirty[1] & 459776) {
        if (instance7) {
          if (previousValue !== value && typeof value === "number") {
            instance7.setValue(value);
          }
          if (previousStart !== start && typeof start === "number") {
            instance7.setValueStart(start);
          }
          if (previousEnd !== end && typeof end === "number") {
            instance7.setValue(end);
          }
          $$invalidate(47, previousValue = value);
          $$invalidate(48, previousStart = start);
          $$invalidate(49, previousEnd = end);
          instance7.layout();
        }
      }
    };
    return [
      value,
      start,
      end,
      use2,
      className,
      disabled,
      range,
      discrete,
      tickMarks,
      step,
      min,
      max,
      input$class,
      element2,
      input,
      inputStart,
      thumbEl,
      thumbStart,
      thumbKnob,
      thumbKnobStart,
      internalClasses,
      thumbStartClasses,
      thumbClasses,
      inputAttrs,
      inputStartAttrs,
      trackActiveStyles,
      thumbStyles,
      thumbStartStyles,
      thumbRippleActive,
      thumbStartRippleActive,
      currentTickMarks,
      forwardEvents,
      inputProps,
      addThumbClass,
      removeThumbClass,
      addThumbStyle,
      $$restProps,
      valueToAriaValueTextFn,
      layout,
      getId,
      getElement,
      instance7,
      previousMin,
      previousMax,
      previousStep,
      previousDiscrete,
      previousTickMarks,
      previousValue,
      previousStart,
      previousEnd,
      blur_handler_1,
      focus_handler_1,
      blur_handler,
      focus_handler,
      blur_handler_2,
      focus_handler_2,
      input0_binding,
      input0_change_input_handler,
      input1_binding,
      input1_change_input_handler,
      input_1_binding,
      input_1_change_input_handler,
      div0_binding,
      div1_binding,
      Ripple_function,
      Ripple_function_1,
      Ripple_function_2,
      div2_binding,
      div3_binding,
      Ripple_function_3,
      Ripple_function_4,
      Ripple_function_5,
      div0_binding_1,
      div1_binding_1,
      Ripple_function_6,
      Ripple_function_7,
      Ripple_function_8,
      div4_binding
    ];
  }
  var Slider = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1, create_fragment4, safe_not_equal, {
        use: 3,
        class: 4,
        disabled: 5,
        range: 6,
        discrete: 7,
        tickMarks: 8,
        step: 9,
        min: 10,
        max: 11,
        value: 0,
        start: 1,
        end: 2,
        valueToAriaValueTextFn: 37,
        input$class: 12,
        layout: 38,
        getId: 39,
        getElement: 40
      }, null, [-1, -1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Slider",
        options,
        id: create_fragment4.name
      });
    }
    get use() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get disabled() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set disabled(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get range() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set range(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get discrete() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set discrete(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get tickMarks() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set tickMarks(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get step() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set step(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get min() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set min(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get max() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set max(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get start() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set start(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get end() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set end(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get valueToAriaValueTextFn() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set valueToAriaValueTextFn(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get input$class() {
      throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set input$class(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get layout() {
      return this.$$.ctx[38];
    }
    set layout(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getId() {
      return this.$$.ctx[39];
    }
    set getId(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[40];
    }
    set getElement(value) {
      throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/util.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var KEY = {
    UNKNOWN: "Unknown",
    BACKSPACE: "Backspace",
    ENTER: "Enter",
    SPACEBAR: "Spacebar",
    PAGE_UP: "PageUp",
    PAGE_DOWN: "PageDown",
    END: "End",
    HOME: "Home",
    ARROW_LEFT: "ArrowLeft",
    ARROW_UP: "ArrowUp",
    ARROW_RIGHT: "ArrowRight",
    ARROW_DOWN: "ArrowDown",
    DELETE: "Delete",
    ESCAPE: "Escape",
    TAB: "Tab"
  };
  var normalizedKeys = new Set();
  normalizedKeys.add(KEY.BACKSPACE);
  normalizedKeys.add(KEY.ENTER);
  normalizedKeys.add(KEY.SPACEBAR);
  normalizedKeys.add(KEY.PAGE_UP);
  normalizedKeys.add(KEY.PAGE_DOWN);
  normalizedKeys.add(KEY.END);
  normalizedKeys.add(KEY.HOME);
  normalizedKeys.add(KEY.ARROW_LEFT);
  normalizedKeys.add(KEY.ARROW_UP);
  normalizedKeys.add(KEY.ARROW_RIGHT);
  normalizedKeys.add(KEY.ARROW_DOWN);
  normalizedKeys.add(KEY.DELETE);
  normalizedKeys.add(KEY.ESCAPE);
  normalizedKeys.add(KEY.TAB);
  var KEY_CODE = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46,
    ESCAPE: 27,
    TAB: 9
  };
  var mappedKeyCodes = new Map();
  mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
  mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
  mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
  mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
  mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
  mappedKeyCodes.set(KEY_CODE.END, KEY.END);
  mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
  mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
  mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
  mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
  mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
  mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
  mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
  mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
  var navigationKeys = new Set();
  navigationKeys.add(KEY.PAGE_UP);
  navigationKeys.add(KEY.PAGE_DOWN);
  navigationKeys.add(KEY.END);
  navigationKeys.add(KEY.HOME);
  navigationKeys.add(KEY.ARROW_LEFT);
  navigationKeys.add(KEY.ARROW_UP);
  navigationKeys.add(KEY.ARROW_RIGHT);
  navigationKeys.add(KEY.ARROW_DOWN);
  function normalizeKey(evt) {
    var key = evt.key;
    if (normalizedKeys.has(key)) {
      return key;
    }
    var mappedKey = mappedKeyCodes.get(evt.keyCode);
    if (mappedKey) {
      return mappedKey;
    }
    return KEY.UNKNOWN;
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssPropertyNameMap2 = {
    animation: {
      prefixed: "-webkit-animation",
      standard: "animation"
    },
    transform: {
      prefixed: "-webkit-transform",
      standard: "transform"
    },
    transition: {
      prefixed: "-webkit-transition",
      standard: "transition"
    }
  };
  function isWindow2(windowObj) {
    return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
  }
  function getCorrectPropertyName2(windowObj, cssProperty) {
    if (isWindow2(windowObj) && cssProperty in cssPropertyNameMap2) {
      var el = windowObj.document.createElement("div");
      var _a2 = cssPropertyNameMap2[cssProperty], standard = _a2.standard, prefixed = _a2.prefixed;
      var isStandard = standard in el.style;
      return isStandard ? standard : prefixed;
    }
    return cssProperty;
  }

  // dist/build/Subheader.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$2 = {
    ANCHOR: "mdc-menu-surface--anchor",
    ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
    ANIMATING_OPEN: "mdc-menu-surface--animating-open",
    FIXED: "mdc-menu-surface--fixed",
    IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
    OPEN: "mdc-menu-surface--open",
    ROOT: "mdc-menu-surface"
  };
  var strings$2 = {
    CLOSED_EVENT: "MDCMenuSurface:closed",
    CLOSING_EVENT: "MDCMenuSurface:closing",
    OPENED_EVENT: "MDCMenuSurface:opened",
    FOCUSABLE_ELEMENTS: [
      "button:not(:disabled)",
      '[href]:not([aria-disabled="true"])',
      "input:not(:disabled)",
      "select:not(:disabled)",
      "textarea:not(:disabled)",
      '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
    ].join(", ")
  };
  var numbers$2 = {
    TRANSITION_OPEN_DURATION: 120,
    TRANSITION_CLOSE_DURATION: 75,
    MARGIN_TO_EDGE: 32,
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
  };
  var CornerBit;
  (function(CornerBit2) {
    CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
    CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
    CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
    CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
  })(CornerBit || (CornerBit = {}));
  var Corner;
  (function(Corner2) {
    Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
    Corner2[Corner2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
    Corner2[Corner2["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
    Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
    Corner2[Corner2["TOP_START"] = 8] = "TOP_START";
    Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
    Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
    Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
  })(Corner || (Corner = {}));
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var _a;
  var _b;
  var cssClasses$12 = {
    LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
    LIST_ITEM_CLASS: "mdc-list-item",
    LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
    LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
    LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
    LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
    ROOT: "mdc-list"
  };
  _a = {}, _a["" + cssClasses$12.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses$12.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses$12.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses$12.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses$12.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses$12.ROOT] = "mdc-list", _a;
  var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses$12.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b["" + cssClasses$12.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b["" + cssClasses$12.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b["" + cssClasses$12.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b["" + cssClasses$12.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b["" + cssClasses$12.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b["" + cssClasses$12.ROOT] = "mdc-deprecated-list", _b);
  var strings$1 = {
    ACTION_EVENT: "MDCList:action",
    ARIA_CHECKED: "aria-checked",
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: "aria-current",
    ARIA_DISABLED: "aria-disabled",
    ARIA_ORIENTATION: "aria-orientation",
    ARIA_ORIENTATION_HORIZONTAL: "horizontal",
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: "aria-selected",
    ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
    ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$12.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$12.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + " a\n  ",
    DEPRECATED_SELECTOR: ".mdc-deprecated-list",
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$12.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$12.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$12.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses$12.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$12.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
    RADIO_SELECTOR: 'input[type="radio"]',
    SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
  };
  var numbers$12 = {
    UNSET_INDEX: -1,
    TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
  };
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
  var preventDefaultEvent = function(evt) {
    var target = evt.target;
    if (!target) {
      return;
    }
    var tagName = ("" + target.tagName).toLowerCase();
    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
      evt.preventDefault();
    }
  };
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function initState() {
    var state = {
      bufferClearTimeout: 0,
      currentFirstChar: "",
      sortedIndexCursor: 0,
      typeaheadBuffer: ""
    };
    return state;
  }
  function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
    var sortedIndexByFirstChar = new Map();
    for (var i = 0; i < listItemCount; i++) {
      var primaryText = getPrimaryTextByItemIndex(i).trim();
      if (!primaryText) {
        continue;
      }
      var firstChar = primaryText[0].toLowerCase();
      if (!sortedIndexByFirstChar.has(firstChar)) {
        sortedIndexByFirstChar.set(firstChar, []);
      }
      sortedIndexByFirstChar.get(firstChar).push({text: primaryText.toLowerCase(), index: i});
    }
    sortedIndexByFirstChar.forEach(function(values) {
      values.sort(function(first, second) {
        return first.index - second.index;
      });
    });
    return sortedIndexByFirstChar;
  }
  function matchItem(opts, state) {
    var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    clearTimeout(state.bufferClearTimeout);
    state.bufferClearTimeout = setTimeout(function() {
      clearBuffer(state);
    }, numbers$12.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
    state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
    var index;
    if (state.typeaheadBuffer.length === 1) {
      index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
    } else {
      index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
    }
    if (index !== -1 && !skipFocus) {
      focusItemAtIndex(index);
    }
    return index;
  }
  function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
      return -1;
    }
    if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
      state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
      var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
      if (!isItemAtIndexDisabled(newIndex)) {
        return newIndex;
      }
    }
    state.currentFirstChar = firstChar;
    var newCursorPosition = -1;
    var cursorPosition;
    for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
      if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
        newCursorPosition = cursorPosition;
        break;
      }
    }
    for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
      if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
        newCursorPosition = cursorPosition;
        break;
      }
    }
    if (newCursorPosition !== -1) {
      state.sortedIndexCursor = newCursorPosition;
      return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
  }
  function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
      return -1;
    }
    var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
    if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
      return startingItem.index;
    }
    var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var nextCursorPosition = -1;
    while (cursorPosition !== state.sortedIndexCursor) {
      var currentItem = itemsMatchingFirstChar[cursorPosition];
      var matches3 = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
      var isEnabled = !isItemAtIndexDisabled(currentItem.index);
      if (matches3 && isEnabled) {
        nextCursorPosition = cursorPosition;
        break;
      }
      cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
    }
    if (nextCursorPosition !== -1) {
      state.sortedIndexCursor = nextCursorPosition;
      return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
  }
  function isTypingInProgress(state) {
    return state.typeaheadBuffer.length > 0;
  }
  function clearBuffer(state) {
    state.typeaheadBuffer = "";
  }
  function handleKeydown(opts, state) {
    var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    var isArrowLeft = normalizeKey(event) === "ArrowLeft";
    var isArrowUp = normalizeKey(event) === "ArrowUp";
    var isArrowRight = normalizeKey(event) === "ArrowRight";
    var isArrowDown = normalizeKey(event) === "ArrowDown";
    var isHome = normalizeKey(event) === "Home";
    var isEnd = normalizeKey(event) === "End";
    var isEnter = normalizeKey(event) === "Enter";
    var isSpace = normalizeKey(event) === "Spacebar";
    if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
      return -1;
    }
    var isCharacterKey = !isSpace && event.key.length === 1;
    if (isCharacterKey) {
      preventDefaultEvent(event);
      var matchItemOpts = {
        focusItemAtIndex,
        focusedItemIndex,
        nextChar: event.key.toLowerCase(),
        sortedIndexByFirstChar,
        skipFocus: false,
        isItemAtIndexDisabled
      };
      return matchItem(matchItemOpts, state);
    }
    if (!isSpace) {
      return -1;
    }
    if (isTargetListItem) {
      preventDefaultEvent(event);
    }
    var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
    if (typeaheadOnListItem) {
      var matchItemOpts = {
        focusItemAtIndex,
        focusedItemIndex,
        nextChar: " ",
        sortedIndexByFirstChar,
        skipFocus: false,
        isItemAtIndexDisabled
      };
      return matchItem(matchItemOpts, state);
    }
    return -1;
  }
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function isNumberArray(selectedIndex) {
    return selectedIndex instanceof Array;
  }
  var MDCListFoundation = function(_super) {
    __extends(MDCListFoundation2, _super);
    function MDCListFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
      _this.wrapFocus_ = false;
      _this.isVertical_ = true;
      _this.isSingleSelectionList_ = false;
      _this.selectedIndex_ = numbers$12.UNSET_INDEX;
      _this.focusedItemIndex = numbers$12.UNSET_INDEX;
      _this.useActivatedClass_ = false;
      _this.useSelectedAttr_ = false;
      _this.ariaCurrentAttrValue_ = null;
      _this.isCheckboxList_ = false;
      _this.isRadioList_ = false;
      _this.hasTypeahead = false;
      _this.typeaheadState = initState();
      _this.sortedIndexByFirstChar = new Map();
      return _this;
    }
    Object.defineProperty(MDCListFoundation2, "strings", {
      get: function() {
        return strings$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$12;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "numbers", {
      get: function() {
        return numbers$12;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassForElementIndex: function() {
            return void 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          getAttributeForElementIndex: function() {
            return null;
          },
          getFocusedElementIndex: function() {
            return 0;
          },
          getListItemCount: function() {
            return 0;
          },
          hasCheckboxAtIndex: function() {
            return false;
          },
          hasRadioAtIndex: function() {
            return false;
          },
          isCheckboxCheckedAtIndex: function() {
            return false;
          },
          isFocusInsideList: function() {
            return false;
          },
          isRootFocused: function() {
            return false;
          },
          listItemAtIndexHasClass: function() {
            return false;
          },
          notifyAction: function() {
            return void 0;
          },
          removeClassForElementIndex: function() {
            return void 0;
          },
          setAttributeForElementIndex: function() {
            return void 0;
          },
          setCheckedCheckboxOrRadioAtIndex: function() {
            return void 0;
          },
          setTabIndexForListItemChildren: function() {
            return void 0;
          },
          getPrimaryTextAtIndex: function() {
            return "";
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCListFoundation2.prototype.layout = function() {
      if (this.adapter.getListItemCount() === 0) {
        return;
      }
      if (this.adapter.hasCheckboxAtIndex(0)) {
        this.isCheckboxList_ = true;
      } else if (this.adapter.hasRadioAtIndex(0)) {
        this.isRadioList_ = true;
      } else {
        this.maybeInitializeSingleSelection();
      }
      if (this.hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.setWrapFocus = function(value) {
      this.wrapFocus_ = value;
    };
    MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
      this.isVertical_ = value;
    };
    MDCListFoundation2.prototype.setSingleSelection = function(value) {
      this.isSingleSelectionList_ = value;
      if (value) {
        this.maybeInitializeSingleSelection();
      }
    };
    MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
      var listItemsCount = this.adapter.getListItemCount();
      for (var i = 0; i < listItemsCount; i++) {
        var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$12.LIST_ITEM_SELECTED_CLASS);
        var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$12.LIST_ITEM_ACTIVATED_CLASS);
        if (!(hasSelectedClass || hasActivatedClass)) {
          continue;
        }
        if (hasActivatedClass) {
          this.setUseActivatedClass(true);
        }
        this.isSingleSelectionList_ = true;
        this.selectedIndex_ = i;
        return;
      }
    };
    MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
      this.hasTypeahead = hasTypeahead;
      if (hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
      return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
    };
    MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
      this.useActivatedClass_ = useActivated;
    };
    MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
      this.useSelectedAttr_ = useSelected;
    };
    MDCListFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex_;
    };
    MDCListFoundation2.prototype.setSelectedIndex = function(index) {
      if (!this.isIndexValid_(index)) {
        return;
      }
      if (this.isCheckboxList_) {
        this.setCheckboxAtIndex_(index);
      } else if (this.isRadioList_) {
        this.setRadioAtIndex_(index);
      } else {
        this.setSingleSelectionAtIndex_(index);
      }
    };
    MDCListFoundation2.prototype.handleFocusIn = function(_2, listItemIndex) {
      if (listItemIndex >= 0) {
        this.focusedItemIndex = listItemIndex;
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
      }
    };
    MDCListFoundation2.prototype.handleFocusOut = function(_2, listItemIndex) {
      var _this = this;
      if (listItemIndex >= 0) {
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
      }
      setTimeout(function() {
        if (!_this.adapter.isFocusInsideList()) {
          _this.setTabindexToFirstSelectedOrFocusedItem();
        }
      }, 0);
    };
    MDCListFoundation2.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
      var _this = this;
      var isArrowLeft = normalizeKey(event) === "ArrowLeft";
      var isArrowUp = normalizeKey(event) === "ArrowUp";
      var isArrowRight = normalizeKey(event) === "ArrowRight";
      var isArrowDown = normalizeKey(event) === "ArrowDown";
      var isHome = normalizeKey(event) === "Home";
      var isEnd = normalizeKey(event) === "End";
      var isEnter = normalizeKey(event) === "Enter";
      var isSpace = normalizeKey(event) === "Spacebar";
      var isLetterA = event.key === "A" || event.key === "a";
      if (this.adapter.isRootFocused()) {
        if (isArrowUp || isEnd) {
          event.preventDefault();
          this.focusLastElement();
        } else if (isArrowDown || isHome) {
          event.preventDefault();
          this.focusFirstElement();
        }
        if (this.hasTypeahead) {
          var handleKeydownOpts = {
            event,
            focusItemAtIndex: function(index) {
              _this.focusItemAtIndex(index);
            },
            focusedItemIndex: -1,
            isTargetListItem: isRootListItem,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: function(index) {
              return _this.adapter.listItemAtIndexHasClass(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
            }
          };
          handleKeydown(handleKeydownOpts, this.typeaheadState);
        }
        return;
      }
      var currentIndex = this.adapter.getFocusedElementIndex();
      if (currentIndex === -1) {
        currentIndex = listItemIndex;
        if (currentIndex < 0) {
          return;
        }
      }
      if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
        preventDefaultEvent(event);
        this.focusNextElement(currentIndex);
      } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
        preventDefaultEvent(event);
        this.focusPrevElement(currentIndex);
      } else if (isHome) {
        preventDefaultEvent(event);
        this.focusFirstElement();
      } else if (isEnd) {
        preventDefaultEvent(event);
        this.focusLastElement();
      } else if (isLetterA && event.ctrlKey && this.isCheckboxList_) {
        event.preventDefault();
        this.toggleAll(this.selectedIndex_ === numbers$12.UNSET_INDEX ? [] : this.selectedIndex_);
      } else if (isEnter || isSpace) {
        if (isRootListItem) {
          var target = event.target;
          if (target && target.tagName === "A" && isEnter) {
            return;
          }
          preventDefaultEvent(event);
          if (this.adapter.listItemAtIndexHasClass(currentIndex, cssClasses$12.LIST_ITEM_DISABLED_CLASS)) {
            return;
          }
          if (!this.isTypeaheadInProgress()) {
            if (this.isSelectableList_()) {
              this.setSelectedIndexOnAction_(currentIndex);
            }
            this.adapter.notifyAction(currentIndex);
          }
        }
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event,
          focusItemAtIndex: function(index) {
            _this.focusItemAtIndex(index);
          },
          focusedItemIndex: this.focusedItemIndex,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index) {
            return _this.adapter.listItemAtIndexHasClass(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
    };
    MDCListFoundation2.prototype.handleClick = function(index, toggleCheckbox) {
      if (index === numbers$12.UNSET_INDEX) {
        return;
      }
      if (this.adapter.listItemAtIndexHasClass(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS)) {
        return;
      }
      if (this.isSelectableList_()) {
        this.setSelectedIndexOnAction_(index, toggleCheckbox);
      }
      this.adapter.notifyAction(index);
    };
    MDCListFoundation2.prototype.focusNextElement = function(index) {
      var count = this.adapter.getListItemCount();
      var nextIndex = index + 1;
      if (nextIndex >= count) {
        if (this.wrapFocus_) {
          nextIndex = 0;
        } else {
          return index;
        }
      }
      this.focusItemAtIndex(nextIndex);
      return nextIndex;
    };
    MDCListFoundation2.prototype.focusPrevElement = function(index) {
      var prevIndex = index - 1;
      if (prevIndex < 0) {
        if (this.wrapFocus_) {
          prevIndex = this.adapter.getListItemCount() - 1;
        } else {
          return index;
        }
      }
      this.focusItemAtIndex(prevIndex);
      return prevIndex;
    };
    MDCListFoundation2.prototype.focusFirstElement = function() {
      this.focusItemAtIndex(0);
      return 0;
    };
    MDCListFoundation2.prototype.focusLastElement = function() {
      var lastIndex = this.adapter.getListItemCount() - 1;
      this.focusItemAtIndex(lastIndex);
      return lastIndex;
    };
    MDCListFoundation2.prototype.focusInitialElement = function() {
      var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.focusItemAtIndex(initialIndex);
      return initialIndex;
    };
    MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
      if (!this.isIndexValid_(itemIndex)) {
        return;
      }
      if (isEnabled) {
        this.adapter.removeClassForElementIndex(itemIndex, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$1.ARIA_DISABLED, "false");
      } else {
        this.adapter.addClassForElementIndex(itemIndex, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$1.ARIA_DISABLED, "true");
      }
    };
    MDCListFoundation2.prototype.setSingleSelectionAtIndex_ = function(index) {
      if (this.selectedIndex_ === index) {
        return;
      }
      var selectedClassName = cssClasses$12.LIST_ITEM_SELECTED_CLASS;
      if (this.useActivatedClass_) {
        selectedClassName = cssClasses$12.LIST_ITEM_ACTIVATED_CLASS;
      }
      if (this.selectedIndex_ !== numbers$12.UNSET_INDEX) {
        this.adapter.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
      }
      this.setAriaForSingleSelectionAtIndex_(index);
      this.setTabindexAtIndex(index);
      if (index !== numbers$12.UNSET_INDEX) {
        this.adapter.addClassForElementIndex(index, selectedClassName);
      }
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex_ = function(index) {
      if (this.selectedIndex_ === numbers$12.UNSET_INDEX) {
        this.ariaCurrentAttrValue_ = this.adapter.getAttributeForElementIndex(index, strings$1.ARIA_CURRENT);
      }
      var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
      var ariaAttribute = isAriaCurrent ? strings$1.ARIA_CURRENT : strings$1.ARIA_SELECTED;
      if (this.selectedIndex_ !== numbers$12.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, "false");
      }
      if (index !== numbers$12.UNSET_INDEX) {
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : "true";
        this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
      }
    };
    MDCListFoundation2.prototype.getSelectionAttribute = function() {
      return this.useSelectedAttr_ ? strings$1.ARIA_SELECTED : strings$1.ARIA_CHECKED;
    };
    MDCListFoundation2.prototype.setRadioAtIndex_ = function(index) {
      var selectionAttribute = this.getSelectionAttribute();
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
      if (this.selectedIndex_ !== numbers$12.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, selectionAttribute, "false");
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setCheckboxAtIndex_ = function(index) {
      var selectionAttribute = this.getSelectionAttribute();
      for (var i = 0; i < this.adapter.getListItemCount(); i++) {
        var isChecked = false;
        if (index.indexOf(i) >= 0) {
          isChecked = true;
        }
        this.adapter.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
        this.adapter.setAttributeForElementIndex(i, selectionAttribute, isChecked ? "true" : "false");
      }
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setTabindexAtIndex = function(index) {
      if (this.focusedItemIndex === numbers$12.UNSET_INDEX && index !== 0) {
        this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
      } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
        this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
      }
      if (!(this.selectedIndex_ instanceof Array) && this.selectedIndex_ !== index) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, "tabindex", "-1");
      }
      if (index !== numbers$12.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
      }
    };
    MDCListFoundation2.prototype.isSelectableList_ = function() {
      return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
    };
    MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
      var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.setTabindexAtIndex(targetIndex);
    };
    MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
      var targetIndex = this.focusedItemIndex >= 0 ? this.focusedItemIndex : 0;
      if (this.isSelectableList_()) {
        if (typeof this.selectedIndex_ === "number" && this.selectedIndex_ !== numbers$12.UNSET_INDEX) {
          targetIndex = this.selectedIndex_;
        } else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
          targetIndex = this.selectedIndex_.reduce(function(currentIndex, minIndex) {
            return Math.min(currentIndex, minIndex);
          });
        }
      }
      return targetIndex;
    };
    MDCListFoundation2.prototype.isIndexValid_ = function(index) {
      var _this = this;
      if (index instanceof Array) {
        if (!this.isCheckboxList_) {
          throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
        }
        if (index.length === 0) {
          return true;
        } else {
          return index.some(function(i) {
            return _this.isIndexInRange_(i);
          });
        }
      } else if (typeof index === "number") {
        if (this.isCheckboxList_) {
          throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
        }
        return this.isIndexInRange_(index) || this.isSingleSelectionList_ && index === numbers$12.UNSET_INDEX;
      } else {
        return false;
      }
    };
    MDCListFoundation2.prototype.isIndexInRange_ = function(index) {
      var listSize = this.adapter.getListItemCount();
      return index >= 0 && index < listSize;
    };
    MDCListFoundation2.prototype.setSelectedIndexOnAction_ = function(index, toggleCheckbox) {
      if (toggleCheckbox === void 0) {
        toggleCheckbox = true;
      }
      if (this.isCheckboxList_) {
        this.toggleCheckboxAtIndex_(index, toggleCheckbox);
      } else {
        this.setSelectedIndex(index);
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxAtIndex_ = function(index, toggleCheckbox) {
      var selectionAttribute = this.getSelectionAttribute();
      var isChecked = this.adapter.isCheckboxCheckedAtIndex(index);
      if (toggleCheckbox) {
        isChecked = !isChecked;
        this.adapter.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, isChecked ? "true" : "false");
      var selectedIndexes = this.selectedIndex_ === numbers$12.UNSET_INDEX ? [] : this.selectedIndex_.slice();
      if (isChecked) {
        selectedIndexes.push(index);
      } else {
        selectedIndexes = selectedIndexes.filter(function(i) {
          return i !== index;
        });
      }
      this.selectedIndex_ = selectedIndexes;
    };
    MDCListFoundation2.prototype.focusItemAtIndex = function(index) {
      this.adapter.focusItemAtIndex(index);
      this.focusedItemIndex = index;
    };
    MDCListFoundation2.prototype.toggleAll = function(currentlySelectedIndexes) {
      var count = this.adapter.getListItemCount();
      if (currentlySelectedIndexes.length === count) {
        this.setCheckboxAtIndex_([]);
      } else {
        var allIndexes = [];
        for (var i = 0; i < count; i++) {
          if (!this.adapter.listItemAtIndexHasClass(i, cssClasses$12.LIST_ITEM_DISABLED_CLASS) || currentlySelectedIndexes.indexOf(i) > -1) {
            allIndexes.push(i);
          }
        }
        this.setCheckboxAtIndex_(allIndexes);
      }
    };
    MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
      var _this = this;
      if (skipFocus === void 0) {
        skipFocus = false;
      }
      var opts = {
        focusItemAtIndex: function(index) {
          _this.focusItemAtIndex(index);
        },
        focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
        nextChar,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        skipFocus,
        isItemAtIndexDisabled: function(index) {
          return _this.adapter.listItemAtIndexHasClass(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
        }
      };
      return matchItem(opts, this.typeaheadState);
    };
    MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
      return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
    };
    MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
      clearBuffer(this.typeaheadState);
    };
    return MDCListFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCMenuSurfaceFoundation = function(_super) {
    __extends(MDCMenuSurfaceFoundation2, _super);
    function MDCMenuSurfaceFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation2.defaultAdapter), adapter)) || this;
      _this.isSurfaceOpen = false;
      _this.isQuickOpen = false;
      _this.isHoistedElement = false;
      _this.isFixedPosition = false;
      _this.isHorizontallyCenteredOnViewport = false;
      _this.maxHeight = 0;
      _this.openAnimationEndTimerId = 0;
      _this.closeAnimationEndTimerId = 0;
      _this.animationRequestId = 0;
      _this.anchorCorner = Corner.TOP_START;
      _this.originCorner = Corner.TOP_START;
      _this.anchorMargin = {top: 0, right: 0, bottom: 0, left: 0};
      _this.position = {x: 0, y: 0};
      return _this;
    }
    Object.defineProperty(MDCMenuSurfaceFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "strings", {
      get: function() {
        return strings$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "numbers", {
      get: function() {
        return numbers$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "Corner", {
      get: function() {
        return Corner;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          hasAnchor: function() {
            return false;
          },
          isElementInContainer: function() {
            return false;
          },
          isFocused: function() {
            return false;
          },
          isRtl: function() {
            return false;
          },
          getInnerDimensions: function() {
            return {height: 0, width: 0};
          },
          getAnchorDimensions: function() {
            return null;
          },
          getWindowDimensions: function() {
            return {height: 0, width: 0};
          },
          getBodyDimensions: function() {
            return {height: 0, width: 0};
          },
          getWindowScroll: function() {
            return {x: 0, y: 0};
          },
          setPosition: function() {
            return void 0;
          },
          setMaxHeight: function() {
            return void 0;
          },
          setTransformOrigin: function() {
            return void 0;
          },
          saveFocus: function() {
            return void 0;
          },
          restoreFocus: function() {
            return void 0;
          },
          notifyClose: function() {
            return void 0;
          },
          notifyOpen: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuSurfaceFoundation2.prototype.init = function() {
      var _a2 = MDCMenuSurfaceFoundation2.cssClasses, ROOT = _a2.ROOT, OPEN = _a2.OPEN;
      if (!this.adapter.hasClass(ROOT)) {
        throw new Error(ROOT + " class required in root element.");
      }
      if (this.adapter.hasClass(OPEN)) {
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.destroy = function() {
      clearTimeout(this.openAnimationEndTimerId);
      clearTimeout(this.closeAnimationEndTimerId);
      cancelAnimationFrame(this.animationRequestId);
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorCorner = function(corner) {
      this.anchorCorner = corner;
    };
    MDCMenuSurfaceFoundation2.prototype.flipCornerHorizontally = function() {
      this.originCorner = this.originCorner ^ CornerBit.RIGHT;
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorMargin = function(margin) {
      this.anchorMargin.top = margin.top || 0;
      this.anchorMargin.right = margin.right || 0;
      this.anchorMargin.bottom = margin.bottom || 0;
      this.anchorMargin.left = margin.left || 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHoisted = function(isHoisted) {
      this.isHoistedElement = isHoisted;
    };
    MDCMenuSurfaceFoundation2.prototype.setFixedPosition = function(isFixedPosition) {
      this.isFixedPosition = isFixedPosition;
    };
    MDCMenuSurfaceFoundation2.prototype.setAbsolutePosition = function(x, y) {
      this.position.x = this.isFinite(x) ? x : 0;
      this.position.y = this.isFinite(y) ? y : 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHorizontallyCenteredOnViewport = function(isCentered) {
      this.isHorizontallyCenteredOnViewport = isCentered;
    };
    MDCMenuSurfaceFoundation2.prototype.setQuickOpen = function(quickOpen) {
      this.isQuickOpen = quickOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.setMaxHeight = function(maxHeight) {
      this.maxHeight = maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.isOpen = function() {
      return this.isSurfaceOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.open = function() {
      var _this = this;
      if (this.isSurfaceOpen) {
        return;
      }
      this.adapter.saveFocus();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = true;
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.dimensions = this.adapter.getInnerDimensions();
        this.autoposition();
        this.adapter.notifyOpen();
      } else {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
        this.animationRequestId = requestAnimationFrame(function() {
          _this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
          _this.dimensions = _this.adapter.getInnerDimensions();
          _this.autoposition();
          _this.openAnimationEndTimerId = setTimeout(function() {
            _this.openAnimationEndTimerId = 0;
            _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
            _this.adapter.notifyOpen();
          }, numbers$2.TRANSITION_OPEN_DURATION);
        });
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.close = function(skipRestoreFocus) {
      var _this = this;
      if (skipRestoreFocus === void 0) {
        skipRestoreFocus = false;
      }
      if (!this.isSurfaceOpen) {
        return;
      }
      this.adapter.notifyClosing();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = false;
        if (!skipRestoreFocus) {
          this.maybeRestoreFocus();
        }
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        this.adapter.notifyClose();
        return;
      }
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
      requestAnimationFrame(function() {
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        _this.closeAnimationEndTimerId = setTimeout(function() {
          _this.closeAnimationEndTimerId = 0;
          _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
          _this.adapter.notifyClose();
        }, numbers$2.TRANSITION_CLOSE_DURATION);
      });
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.handleBodyClick = function(evt) {
      var el = evt.target;
      if (this.adapter.isElementInContainer(el)) {
        return;
      }
      this.close();
    };
    MDCMenuSurfaceFoundation2.prototype.handleKeydown = function(evt) {
      var keyCode = evt.keyCode, key = evt.key;
      var isEscape = key === "Escape" || keyCode === 27;
      if (isEscape) {
        this.close();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.autoposition = function() {
      var _a2;
      this.measurements = this.getAutoLayoutmeasurements();
      var corner = this.getoriginCorner();
      var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
      var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
      var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
      var horizontalOffset = this.getHorizontalOriginOffset(corner);
      var verticalOffset = this.getVerticalOriginOffset(corner);
      var _b2 = this.measurements, anchorSize = _b2.anchorSize, surfaceSize = _b2.surfaceSize;
      var position = (_a2 = {}, _a2[horizontalAlignment] = horizontalOffset, _a2[verticalAlignment] = verticalOffset, _a2);
      if (anchorSize.width / surfaceSize.width > numbers$2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
        horizontalAlignment = "center";
      }
      if (this.isHoistedElement || this.isFixedPosition) {
        this.adjustPositionForHoistedElement(position);
      }
      this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
      this.adapter.setPosition(position);
      this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
      if (!this.hasBit(corner, CornerBit.BOTTOM)) {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      }
    };
    MDCMenuSurfaceFoundation2.prototype.getAutoLayoutmeasurements = function() {
      var anchorRect = this.adapter.getAnchorDimensions();
      var bodySize = this.adapter.getBodyDimensions();
      var viewportSize = this.adapter.getWindowDimensions();
      var windowScroll = this.adapter.getWindowScroll();
      if (!anchorRect) {
        anchorRect = {
          top: this.position.y,
          right: this.position.x,
          bottom: this.position.y,
          left: this.position.x,
          width: 0,
          height: 0
        };
      }
      return {
        anchorSize: anchorRect,
        bodySize,
        surfaceSize: this.dimensions,
        viewportDistance: {
          top: anchorRect.top,
          right: viewportSize.width - anchorRect.right,
          bottom: viewportSize.height - anchorRect.bottom,
          left: anchorRect.left
        },
        viewportSize,
        windowScroll
      };
    };
    MDCMenuSurfaceFoundation2.prototype.getoriginCorner = function() {
      var corner = this.originCorner;
      var _a2 = this.measurements, viewportDistance = _a2.viewportDistance, anchorSize = _a2.anchorSize, surfaceSize = _a2.surfaceSize;
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var availableTop;
      var availableBottom;
      if (isAnchoredToBottom) {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
      } else {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
      }
      var isAvailableBottom = availableBottom - surfaceSize.height > 0;
      if (!isAvailableBottom && availableTop > availableBottom) {
        corner = this.setBit(corner, CornerBit.BOTTOM);
      }
      var isRtl = this.adapter.isRtl();
      var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
      var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
      var isAnchoredToRight = false;
      if (isRtl && isFlipRtl) {
        isAnchoredToRight = !hasRightBit;
      } else {
        isAnchoredToRight = hasRightBit;
      }
      var availableLeft;
      var availableRight;
      if (isAnchoredToRight) {
        availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
        availableRight = viewportDistance.right - this.anchorMargin.right;
      } else {
        availableLeft = viewportDistance.left + this.anchorMargin.left;
        availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
      }
      var isAvailableLeft = availableLeft - surfaceSize.width > 0;
      var isAvailableRight = availableRight - surfaceSize.width > 0;
      var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
      if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
        corner = this.unsetBit(corner, CornerBit.RIGHT);
      } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
        corner = this.setBit(corner, CornerBit.RIGHT);
      }
      return corner;
    };
    MDCMenuSurfaceFoundation2.prototype.getMenuSurfaceMaxHeight = function(corner) {
      if (this.maxHeight > 0) {
        return this.maxHeight;
      }
      var viewportDistance = this.measurements.viewportDistance;
      var maxHeight = 0;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      if (isBottomAligned) {
        maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
        if (!isBottomAnchored) {
          maxHeight += this.measurements.anchorSize.height;
        }
      } else {
        maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
        if (isBottomAnchored) {
          maxHeight -= this.measurements.anchorSize.height;
        }
      }
      return maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.getHorizontalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
      var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
        if (this.isHoistedElement || this.isFixedPosition) {
          return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
        }
        return rightOffset;
      }
      return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
    };
    MDCMenuSurfaceFoundation2.prototype.getVerticalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var y = 0;
      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
      } else {
        y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
      }
      return y;
    };
    MDCMenuSurfaceFoundation2.prototype.adjustPositionForHoistedElement = function(position) {
      var e_1, _a2;
      var _b2 = this.measurements, windowScroll = _b2.windowScroll, viewportDistance = _b2.viewportDistance, surfaceSize = _b2.surfaceSize, viewportSize = _b2.viewportSize;
      var props = Object.keys(position);
      try {
        for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
          var prop = props_1_1.value;
          var value = position[prop] || 0;
          if (this.isHorizontallyCenteredOnViewport && (prop === "left" || prop === "right")) {
            position[prop] = (viewportSize.width - surfaceSize.width) / 2;
            continue;
          }
          value += viewportDistance[prop];
          if (!this.isFixedPosition) {
            if (prop === "top") {
              value += windowScroll.y;
            } else if (prop === "bottom") {
              value -= windowScroll.y;
            } else if (prop === "left") {
              value += windowScroll.x;
            } else {
              value -= windowScroll.x;
            }
          }
          position[prop] = value;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (props_1_1 && !props_1_1.done && (_a2 = props_1.return))
            _a2.call(props_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCMenuSurfaceFoundation2.prototype.maybeRestoreFocus = function() {
      var isRootFocused = this.adapter.isFocused();
      var childHasFocus = document.activeElement && this.adapter.isElementInContainer(document.activeElement);
      if (isRootFocused || childHasFocus) {
        this.adapter.restoreFocus();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.hasBit = function(corner, bit) {
      return Boolean(corner & bit);
    };
    MDCMenuSurfaceFoundation2.prototype.setBit = function(corner, bit) {
      return corner | bit;
    };
    MDCMenuSurfaceFoundation2.prototype.unsetBit = function(corner, bit) {
      return corner ^ bit;
    };
    MDCMenuSurfaceFoundation2.prototype.isFinite = function(num) {
      return typeof num === "number" && isFinite(num);
    };
    return MDCMenuSurfaceFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses3 = {
    MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
    MENU_SELECTION_GROUP: "mdc-menu__selection-group",
    ROOT: "mdc-menu"
  };
  var strings3 = {
    ARIA_CHECKED_ATTR: "aria-checked",
    ARIA_DISABLED_ATTR: "aria-disabled",
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
    SELECTED_EVENT: "MDCMenu:selected"
  };
  var numbers3 = {
    FOCUS_ROOT_INDEX: -1
  };
  var DefaultFocusState;
  (function(DefaultFocusState2) {
    DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
    DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
    DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
    DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
  })(DefaultFocusState || (DefaultFocusState = {}));
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCMenuFoundation = function(_super) {
    __extends(MDCMenuFoundation2, _super);
    function MDCMenuFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
      _this.closeAnimationEndTimerId_ = 0;
      _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
      return _this;
    }
    Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
      get: function() {
        return cssClasses3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "strings", {
      get: function() {
        return strings3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "numbers", {
      get: function() {
        return numbers3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassToElementAtIndex: function() {
            return void 0;
          },
          removeClassFromElementAtIndex: function() {
            return void 0;
          },
          addAttributeToElementAtIndex: function() {
            return void 0;
          },
          removeAttributeFromElementAtIndex: function() {
            return void 0;
          },
          elementContainsClass: function() {
            return false;
          },
          closeSurface: function() {
            return void 0;
          },
          getElementIndex: function() {
            return -1;
          },
          notifySelected: function() {
            return void 0;
          },
          getMenuItemCount: function() {
            return 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          focusListRoot: function() {
            return void 0;
          },
          getSelectedSiblingOfItemAtIndex: function() {
            return -1;
          },
          isSelectableItemAtIndex: function() {
            return false;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuFoundation2.prototype.destroy = function() {
      if (this.closeAnimationEndTimerId_) {
        clearTimeout(this.closeAnimationEndTimerId_);
      }
      this.adapter.closeSurface();
    };
    MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
      var key = evt.key, keyCode = evt.keyCode;
      var isTab = key === "Tab" || keyCode === 9;
      if (isTab) {
        this.adapter.closeSurface(true);
      }
    };
    MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
      var _this = this;
      var index = this.adapter.getElementIndex(listItem);
      if (index < 0) {
        return;
      }
      this.adapter.notifySelected({index});
      this.adapter.closeSurface();
      this.closeAnimationEndTimerId_ = setTimeout(function() {
        var recomputedIndex = _this.adapter.getElementIndex(listItem);
        if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
          _this.setSelectedIndex(recomputedIndex);
        }
      }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
      switch (this.defaultFocusState_) {
        case DefaultFocusState.FIRST_ITEM:
          this.adapter.focusItemAtIndex(0);
          break;
        case DefaultFocusState.LAST_ITEM:
          this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
          break;
        case DefaultFocusState.NONE:
          break;
        default:
          this.adapter.focusListRoot();
          break;
      }
    };
    MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
      this.defaultFocusState_ = focusState;
    };
    MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
      this.validatedIndex_(index);
      if (!this.adapter.isSelectableItemAtIndex(index)) {
        throw new Error("MDCMenuFoundation: No selection group at specified index.");
      }
      var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
      if (prevSelectedIndex >= 0) {
        this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings3.ARIA_CHECKED_ATTR);
        this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses3.MENU_SELECTED_LIST_ITEM);
      }
      this.adapter.addClassToElementAtIndex(index, cssClasses3.MENU_SELECTED_LIST_ITEM);
      this.adapter.addAttributeToElementAtIndex(index, strings3.ARIA_CHECKED_ATTR, "true");
    };
    MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
      this.validatedIndex_(index);
      if (isEnabled) {
        this.adapter.removeClassFromElementAtIndex(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings3.ARIA_DISABLED_ATTR, "false");
      } else {
        this.adapter.addClassToElementAtIndex(index, cssClasses$12.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings3.ARIA_DISABLED_ATTR, "true");
      }
    };
    MDCMenuFoundation2.prototype.validatedIndex_ = function(index) {
      var menuSize = this.adapter.getMenuItemCount();
      var isIndexInRange = index >= 0 && index < menuSize;
      if (!isIndexInRange) {
        throw new Error("MDCMenuFoundation: No list item at specified index.");
      }
    };
    return MDCMenuFoundation2;
  }(MDCFoundation);
  var {document: document_1} = globals;
  var file$5 = "node_modules/@smui/menu-surface/MenuSurface.svelte";
  function create_fragment$7(ctx) {
    let t;
    let div;
    let div_class_value;
    let div_style_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[26].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
    let div_levels = [
      {
        class: div_class_value = classMap({
          [ctx[2]]: true,
          "mdc-menu-surface": true,
          "mdc-menu-surface--fixed": ctx[5],
          "mdc-menu-surface--open": ctx[4],
          "smui-menu-surface--static": ctx[4],
          "mdc-menu-surface--fullwidth": ctx[6],
          ...ctx[9]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[10]).map(func$1).concat([ctx[3]]).join(" ")
      },
      ctx[12]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        t = space();
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$5, 4, 0, 105);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[28](div);
        current = true;
        if (!mounted) {
          dispose = [
            listen_dev(document_1.body, "click", ctx[27], true, false, false),
            action_destroyer(useActions_action = useActions.call(null, div, ctx[1])),
            action_destroyer(ctx[11].call(null, div)),
            listen_dev(div, "keydown", ctx[29], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty[0] & 33554432)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[25], !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty[0] & 628 && div_class_value !== (div_class_value = classMap({
            [ctx2[2]]: true,
            "mdc-menu-surface": true,
            "mdc-menu-surface--fixed": ctx2[5],
            "mdc-menu-surface--open": ctx2[4],
            "smui-menu-surface--static": ctx2[4],
            "mdc-menu-surface--fullwidth": ctx2[6],
            ...ctx2[9]
          }))) && {class: div_class_value},
          (!current || dirty[0] & 1032 && div_style_value !== (div_style_value = Object.entries(ctx2[10]).map(func$1).concat([ctx2[3]]).join(" "))) && {style: div_style_value},
          dirty[0] & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
          useActions_action.update.call(null, ctx2[1]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[28](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$7.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$1 = ([name2, value]) => `${name2}: ${value};`;
  function instance_1$2($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "static",
      "anchor",
      "fixed",
      "open",
      "fullWidth",
      "quickOpen",
      "anchorElement",
      "anchorCorner",
      "anchorMargin",
      "maxHeight",
      "horizontallyCenteredOnViewport",
      "isOpen",
      "setOpen",
      "setAbsolutePosition",
      "setIsHoisted",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("MenuSurface", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {static: isStatic = false} = $$props;
    let {anchor = true} = $$props;
    let {fixed = false} = $$props;
    let {open = isStatic} = $$props;
    let {fullWidth = false} = $$props;
    let {quickOpen = false} = $$props;
    let {anchorElement = null} = $$props;
    let {anchorCorner = null} = $$props;
    let {anchorMargin = {top: 0, right: 0, bottom: 0, left: 0}} = $$props;
    let {maxHeight = 0} = $$props;
    let {horizontallyCenteredOnViewport = false} = $$props;
    let element2;
    let instance7;
    let internalClasses = {};
    let internalStyles = {};
    let previousFocus;
    setContext("SMUI:list:role", "menu");
    setContext("SMUI:list:item:role", "menuitem");
    const iCorner = Corner;
    const iCornerBit = CornerBit;
    onMount(() => {
      $$invalidate(8, instance7 = new MDCMenuSurfaceFoundation({
        addClass,
        removeClass,
        hasClass,
        hasAnchor: () => !!anchorElement,
        notifyClose: () => {
          $$invalidate(0, open = isStatic);
          if (!open) {
            dispatch(element2, "MDCMenuSurface:closed");
          }
        },
        notifyClosing: () => {
          $$invalidate(0, open = isStatic);
          if (!open) {
            dispatch(element2, "MDCMenuSurface:closing");
          }
        },
        notifyOpen: () => {
          $$invalidate(0, open = true);
          dispatch(element2, "MDCMenuSurface:opened");
        },
        isElementInContainer: (el) => element2.contains(el),
        isRtl: () => getComputedStyle(element2).getPropertyValue("direction") === "rtl",
        setTransformOrigin: (origin) => {
          const propertyName = `${getCorrectPropertyName2(window, "transform")}-origin`;
          $$invalidate(10, internalStyles[propertyName] = origin, internalStyles);
        },
        isFocused: () => document.activeElement === element2,
        saveFocus: () => {
          previousFocus = document.activeElement;
        },
        restoreFocus: () => {
          if (element2.contains(document.activeElement) && previousFocus && previousFocus.focus) {
            previousFocus.focus();
          }
        },
        getInnerDimensions: () => {
          return {
            width: element2.offsetWidth,
            height: element2.offsetHeight
          };
        },
        getAnchorDimensions: () => anchorElement ? anchorElement.getBoundingClientRect() : null,
        getWindowDimensions: () => {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getBodyDimensions: () => {
          return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
          };
        },
        getWindowScroll: () => {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        },
        setPosition: (position) => {
          $$invalidate(10, internalStyles.left = "left" in position ? `${position.left}px` : "", internalStyles);
          $$invalidate(10, internalStyles.right = "right" in position ? `${position.right}px` : "", internalStyles);
          $$invalidate(10, internalStyles.top = "top" in position ? `${position.top}px` : "", internalStyles);
          $$invalidate(10, internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "", internalStyles);
        },
        setMaxHeight: (height) => {
          $$invalidate(10, internalStyles.maxHeight = height, internalStyles);
        }
      }));
      dispatch(element2, "SMUI:menu-surface:mount", {
        get open() {
          return open;
        },
        set open(value) {
          $$invalidate(0, open = value);
        },
        closeProgrammatic
      });
      instance7.init();
      return () => {
        const isHoisted = instance7.isHoistedElement;
        instance7.destroy();
        if (isHoisted) {
          element2.parentNode.removeChild(element2);
        }
      };
    });
    onDestroy(() => {
      if (anchor) {
        element2 && element2.parentNode.classList.remove("mdc-menu-surface--anchor");
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(9, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(9, internalClasses[className2] = false, internalClasses);
      }
    }
    function closeProgrammatic(skipRestoreFocus) {
      instance7.close(skipRestoreFocus);
      $$invalidate(0, open = false);
    }
    function isOpen() {
      return open;
    }
    function setOpen(value) {
      $$invalidate(0, open = value);
    }
    function setAbsolutePosition(...args) {
      return instance7.setAbsolutePosition(...args);
    }
    function setIsHoisted(...args) {
      return instance7.setIsHoisted(...args);
    }
    function getElement() {
      return element2;
    }
    const click_handler = (event) => instance7 && open && instance7.handleBodyClick(event);
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    const keydown_handler = (event) => instance7 && instance7.handleKeydown(event);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("static" in $$new_props)
        $$invalidate(4, isStatic = $$new_props.static);
      if ("anchor" in $$new_props)
        $$invalidate(14, anchor = $$new_props.anchor);
      if ("fixed" in $$new_props)
        $$invalidate(5, fixed = $$new_props.fixed);
      if ("open" in $$new_props)
        $$invalidate(0, open = $$new_props.open);
      if ("fullWidth" in $$new_props)
        $$invalidate(6, fullWidth = $$new_props.fullWidth);
      if ("quickOpen" in $$new_props)
        $$invalidate(15, quickOpen = $$new_props.quickOpen);
      if ("anchorElement" in $$new_props)
        $$invalidate(13, anchorElement = $$new_props.anchorElement);
      if ("anchorCorner" in $$new_props)
        $$invalidate(16, anchorCorner = $$new_props.anchorCorner);
      if ("anchorMargin" in $$new_props)
        $$invalidate(17, anchorMargin = $$new_props.anchorMargin);
      if ("maxHeight" in $$new_props)
        $$invalidate(18, maxHeight = $$new_props.maxHeight);
      if ("horizontallyCenteredOnViewport" in $$new_props)
        $$invalidate(19, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
      if ("$$scope" in $$new_props)
        $$invalidate(25, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      Corner,
      CornerBit,
      MDCMenuSurfaceFoundation,
      getCorrectPropertyName: getCorrectPropertyName2,
      onMount,
      onDestroy,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      dispatch,
      forwardEvents,
      use: use2,
      className,
      style,
      isStatic,
      anchor,
      fixed,
      open,
      fullWidth,
      quickOpen,
      anchorElement,
      anchorCorner,
      anchorMargin,
      maxHeight,
      horizontallyCenteredOnViewport,
      element: element2,
      instance: instance7,
      internalClasses,
      internalStyles,
      previousFocus,
      iCorner,
      iCornerBit,
      hasClass,
      addClass,
      removeClass,
      closeProgrammatic,
      isOpen,
      setOpen,
      setAbsolutePosition,
      setIsHoisted,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("isStatic" in $$props)
        $$invalidate(4, isStatic = $$new_props.isStatic);
      if ("anchor" in $$props)
        $$invalidate(14, anchor = $$new_props.anchor);
      if ("fixed" in $$props)
        $$invalidate(5, fixed = $$new_props.fixed);
      if ("open" in $$props)
        $$invalidate(0, open = $$new_props.open);
      if ("fullWidth" in $$props)
        $$invalidate(6, fullWidth = $$new_props.fullWidth);
      if ("quickOpen" in $$props)
        $$invalidate(15, quickOpen = $$new_props.quickOpen);
      if ("anchorElement" in $$props)
        $$invalidate(13, anchorElement = $$new_props.anchorElement);
      if ("anchorCorner" in $$props)
        $$invalidate(16, anchorCorner = $$new_props.anchorCorner);
      if ("anchorMargin" in $$props)
        $$invalidate(17, anchorMargin = $$new_props.anchorMargin);
      if ("maxHeight" in $$props)
        $$invalidate(18, maxHeight = $$new_props.maxHeight);
      if ("horizontallyCenteredOnViewport" in $$props)
        $$invalidate(19, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
      if ("element" in $$props)
        $$invalidate(7, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(8, instance7 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(9, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(10, internalStyles = $$new_props.internalStyles);
      if ("previousFocus" in $$props)
        previousFocus = $$new_props.previousFocus;
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 16512) {
        if (element2 && anchor && !element2.parentNode.classList.contains("mdc-menu-surface--anchor")) {
          element2.parentNode.classList.add("mdc-menu-surface--anchor");
          $$invalidate(13, anchorElement = element2.parentNode);
        }
      }
      if ($$self.$$.dirty[0] & 257) {
        if (instance7 && instance7.isOpen() !== open) {
          if (open) {
            instance7.open();
          } else {
            instance7.close();
          }
        }
      }
      if ($$self.$$.dirty[0] & 33024) {
        if (instance7) {
          instance7.setQuickOpen(quickOpen);
        }
      }
      if ($$self.$$.dirty[0] & 288) {
        if (instance7) {
          instance7.setFixedPosition(fixed);
        }
      }
      if ($$self.$$.dirty[0] & 262400) {
        if (instance7 && maxHeight > 0) {
          instance7.setMaxHeight(maxHeight);
        }
      }
      if ($$self.$$.dirty[0] & 524544) {
        if (instance7) {
          instance7.setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport);
        }
      }
      if ($$self.$$.dirty[0] & 65792) {
        if (instance7 && anchorCorner != null) {
          if (iCorner.hasOwnProperty(anchorCorner)) {
            instance7.setAnchorCorner(iCorner[anchorCorner]);
          } else if (iCornerBit.hasOwnProperty(anchorCorner)) {
            instance7.setAnchorCorner(iCornerBit[anchorCorner]);
          } else {
            instance7.setAnchorCorner(anchorCorner);
          }
        }
      }
      if ($$self.$$.dirty[0] & 131328) {
        if (instance7) {
          instance7.setAnchorMargin(anchorMargin);
        }
      }
    };
    return [
      open,
      use2,
      className,
      style,
      isStatic,
      fixed,
      fullWidth,
      element2,
      instance7,
      internalClasses,
      internalStyles,
      forwardEvents,
      $$restProps,
      anchorElement,
      anchor,
      quickOpen,
      anchorCorner,
      anchorMargin,
      maxHeight,
      horizontallyCenteredOnViewport,
      isOpen,
      setOpen,
      setAbsolutePosition,
      setIsHoisted,
      getElement,
      $$scope,
      slots,
      click_handler,
      div_binding,
      keydown_handler
    ];
  }
  var MenuSurface = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$2, create_fragment$7, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        static: 4,
        anchor: 14,
        fixed: 5,
        open: 0,
        fullWidth: 6,
        quickOpen: 15,
        anchorElement: 13,
        anchorCorner: 16,
        anchorMargin: 17,
        maxHeight: 18,
        horizontallyCenteredOnViewport: 19,
        isOpen: 20,
        setOpen: 21,
        setAbsolutePosition: 22,
        setIsHoisted: 23,
        getElement: 24
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "MenuSurface",
        options,
        id: create_fragment$7.name
      });
    }
    get use() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get static() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set static(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchor() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchor(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get fixed() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set fixed(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get open() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set open(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get fullWidth() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set fullWidth(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get quickOpen() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set quickOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorElement() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorElement(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorCorner() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorCorner(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorMargin() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorMargin(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get maxHeight() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set maxHeight(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get horizontallyCenteredOnViewport() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set horizontallyCenteredOnViewport(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get isOpen() {
      return this.$$.ctx[20];
    }
    set isOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setOpen() {
      return this.$$.ctx[21];
    }
    set setOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setAbsolutePosition() {
      return this.$$.ctx[22];
    }
    set setAbsolutePosition(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setIsHoisted() {
      return this.$$.ctx[23];
    }
    set setIsHoisted(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[24];
    }
    set getElement(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$2(ctx) {
    let current;
    const default_slot_template = ctx[14].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1048576)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[20], !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$2.name,
      type: "slot",
      source: "(1:0) <MenuSurface   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-menu': true,   })}   bind:open   on:SMUI:menu-surface:mount={handleMenuSurfaceAccessor}   on:SMUI:list:mount={handleListAccessor}   on:MDCMenuSurface:opened={() =>     instance && instance.handleMenuSurfaceOpened()}   on:keydown={(event) => instance && instance.handleKeydown(event)}   on:MDCList:action={(event) =>     instance &&     instance.handleItemAction(       listAccessor.getOrderedList()[event.detail.index].element     )}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$6(ctx) {
    let menusurface;
    let updating_open;
    let current;
    const menusurface_spread_levels = [
      {
        use: [ctx[6], ...ctx[1]]
      },
      {
        class: classMap({
          [ctx[2]]: true,
          "mdc-menu": true
        })
      },
      ctx[9]
    ];
    function menusurface_open_binding(value) {
      ctx[16](value);
    }
    let menusurface_props = {
      $$slots: {default: [create_default_slot$2]},
      $$scope: {ctx}
    };
    for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
      menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      menusurface_props.open = ctx[0];
    }
    menusurface = new MenuSurface({props: menusurface_props, $$inline: true});
    ctx[15](menusurface);
    binding_callbacks.push(() => bind3(menusurface, "open", menusurface_open_binding));
    menusurface.$on("SMUI:menu-surface:mount", ctx[7]);
    menusurface.$on("SMUI:list:mount", ctx[8]);
    menusurface.$on("MDCMenuSurface:opened", ctx[17]);
    menusurface.$on("keydown", ctx[18]);
    menusurface.$on("MDCList:action", ctx[19]);
    const block = {
      c: function create2() {
        create_component(menusurface.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        mount_component(menusurface, target, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const menusurface_changes = dirty & 582 ? get_spread_update(menusurface_spread_levels, [
          dirty & 66 && {
            use: [ctx2[6], ...ctx2[1]]
          },
          dirty & 4 && {
            class: classMap({
              [ctx2[2]]: true,
              "mdc-menu": true
            })
          },
          dirty & 512 && get_spread_object(ctx2[9])
        ]) : {};
        if (dirty & 1048576) {
          menusurface_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (!updating_open && dirty & 1) {
          updating_open = true;
          menusurface_changes.open = ctx2[0];
          add_flush_callback(() => updating_open = false);
        }
        menusurface.$set(menusurface_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(menusurface.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(menusurface.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[15](null);
        destroy_component(menusurface, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$6.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance_1$1($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "open", "isOpen", "setOpen", "setDefaultFocusState", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Menu", slots, ["default"]);
    const {closest: closest3} = ponyfill;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {open = false} = $$props;
    let element2;
    let instance7;
    let menuSurfaceAccessor;
    let listAccessor;
    onMount(() => {
      $$invalidate(4, instance7 = new MDCMenuFoundation({
        addClassToElementAtIndex: (index, className2) => {
          listAccessor.addClassForElementIndex(index, className2);
        },
        removeClassFromElementAtIndex: (index, className2) => {
          listAccessor.removeClassForElementIndex(index, className2);
        },
        addAttributeToElementAtIndex: (index, attr2, value) => {
          listAccessor.setAttributeForElementIndex(index, attr2, value);
        },
        removeAttributeFromElementAtIndex: (index, attr2) => {
          listAccessor.removeAttributeForElementIndex(index, attr2);
        },
        elementContainsClass: (element3, className2) => element3.classList.contains(className2),
        closeSurface: (skipRestoreFocus) => menuSurfaceAccessor.closeProgrammatic(skipRestoreFocus),
        getElementIndex: (element3) => listAccessor.getOrderedList().map((accessor) => accessor.element).indexOf(element3),
        notifySelected: (evtData) => dispatch(element2, "MDCMenu:selected", {
          index: evtData.index,
          item: listAccessor.getOrderedList()[evtData.index].element
        }),
        getMenuItemCount: () => listAccessor.items.length,
        focusItemAtIndex: (index) => listAccessor.focusItemAtIndex(index),
        focusListRoot: () => listAccessor.element.focus(),
        isSelectableItemAtIndex: (index) => !!closest3(listAccessor.getOrderedList()[index].element, `.${cssClasses3.MENU_SELECTION_GROUP}`),
        getSelectedSiblingOfItemAtIndex: (index) => {
          const orderedList = listAccessor.getOrderedList();
          const selectionGroupEl = closest3(orderedList[index].element, `.${cssClasses3.MENU_SELECTION_GROUP}`);
          const selectedItemEl = selectionGroupEl.querySelector(`.${cssClasses3.MENU_SELECTED_LIST_ITEM}`);
          return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
        }
      }));
      dispatch(element2, "SMUI:menu:mount", instance7);
      instance7.init();
      return () => {
        instance7.destroy();
      };
    });
    function handleMenuSurfaceAccessor(event) {
      if (!menuSurfaceAccessor) {
        menuSurfaceAccessor = event.detail;
      }
    }
    function handleListAccessor(event) {
      if (!listAccessor) {
        $$invalidate(5, listAccessor = event.detail);
      }
    }
    function isOpen() {
      return open;
    }
    function setOpen(value) {
      $$invalidate(0, open = value);
    }
    function setDefaultFocusState(focusState) {
      instance7.setDefaultFocusState(focusState);
    }
    function getElement() {
      return element2.getElement();
    }
    function menusurface_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    function menusurface_open_binding(value) {
      open = value;
      $$invalidate(0, open);
    }
    const MDCMenuSurface_opened_handler = () => instance7 && instance7.handleMenuSurfaceOpened();
    const keydown_handler = (event) => instance7 && instance7.handleKeydown(event);
    const MDCList_action_handler = (event) => instance7 && instance7.handleItemAction(listAccessor.getOrderedList()[event.detail.index].element);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("open" in $$new_props)
        $$invalidate(0, open = $$new_props.open);
      if ("$$scope" in $$new_props)
        $$invalidate(20, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCMenuFoundation,
      cssClasses: cssClasses3,
      ponyfill,
      onMount,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      dispatch,
      MenuSurface,
      closest: closest3,
      forwardEvents,
      use: use2,
      className,
      open,
      element: element2,
      instance: instance7,
      menuSurfaceAccessor,
      listAccessor,
      handleMenuSurfaceAccessor,
      handleListAccessor,
      isOpen,
      setOpen,
      setDefaultFocusState,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("open" in $$props)
        $$invalidate(0, open = $$new_props.open);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(4, instance7 = $$new_props.instance);
      if ("menuSurfaceAccessor" in $$props)
        menuSurfaceAccessor = $$new_props.menuSurfaceAccessor;
      if ("listAccessor" in $$props)
        $$invalidate(5, listAccessor = $$new_props.listAccessor);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      open,
      use2,
      className,
      element2,
      instance7,
      listAccessor,
      forwardEvents,
      handleMenuSurfaceAccessor,
      handleListAccessor,
      $$restProps,
      isOpen,
      setOpen,
      setDefaultFocusState,
      getElement,
      slots,
      menusurface_binding,
      menusurface_open_binding,
      MDCMenuSurface_opened_handler,
      keydown_handler,
      MDCList_action_handler,
      $$scope
    ];
  }
  var Menu = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$1, create_fragment$6, safe_not_equal, {
        use: 1,
        class: 2,
        open: 0,
        isOpen: 10,
        setOpen: 11,
        setDefaultFocusState: 12,
        getElement: 13
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Menu",
        options,
        id: create_fragment$6.name
      });
    }
    get use() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get open() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set open(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get isOpen() {
      return this.$$.ctx[10];
    }
    set isOpen(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setOpen() {
      return this.$$.ctx[11];
    }
    set setOpen(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setDefaultFocusState() {
      return this.$$.ctx[12];
    }
    set setDefaultFocusState(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[13];
    }
    set getElement(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$4 = "node_modules/@smui/common/Ul.svelte";
  function create_fragment$5(ctx) {
    let ul;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let ul_levels = [ctx[3]];
    let ul_data = {};
    for (let i = 0; i < ul_levels.length; i += 1) {
      ul_data = assign(ul_data, ul_levels[i]);
    }
    const block = {
      c: function create2() {
        ul = element("ul");
        if (default_slot)
          default_slot.c();
        set_attributes(ul, ul_data);
        add_location(ul, file$4, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, ul, anchor);
        if (default_slot) {
          default_slot.m(ul, null);
        }
        ctx[7](ul);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, ul, ctx[0])),
            action_destroyer(ctx[2].call(null, ul))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(ul);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$5.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$4($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Ul", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function ul_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      ul_binding
    ];
  }
  var Ul = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$4, create_fragment$5, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Ul",
        options,
        id: create_fragment$5.name
      });
    }
    get use() {
      throw new Error("<Ul>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$3 = "node_modules/@smui/common/Nav.svelte";
  function create_fragment$4(ctx) {
    let nav;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let nav_levels = [ctx[3]];
    let nav_data = {};
    for (let i = 0; i < nav_levels.length; i += 1) {
      nav_data = assign(nav_data, nav_levels[i]);
    }
    const block = {
      c: function create2() {
        nav = element("nav");
        if (default_slot)
          default_slot.c();
        set_attributes(nav, nav_data);
        add_location(nav, file$3, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, nav, anchor);
        if (default_slot) {
          default_slot.m(nav, null);
        }
        ctx[7](nav);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, nav, ctx[0])),
            action_destroyer(ctx[2].call(null, nav))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(nav, nav_data = get_spread_update(nav_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(nav);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$4.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$32($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Nav", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function nav_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      nav_binding
    ];
  }
  var Nav = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$32, create_fragment$4, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Nav",
        options,
        id: create_fragment$4.name
      });
    }
    get use() {
      throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$12(ctx) {
    let current;
    const default_slot_template = ctx[38].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[44], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty[1] & 8192)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[44], !current ? get_all_dirty_from_scope(ctx2[44]) : get_slot_changes(default_slot_template, ctx2[44], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$12.name,
      type: "slot",
      source: `(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-deprecated-list': true,     'mdc-deprecated-list--non-interactive': nonInteractive,     'mdc-deprecated-list--dense': dense,     'mdc-deprecated-list--textual-list': textualList,     'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,     'mdc-deprecated-list--icon-list': iconList,     'mdc-deprecated-list--image-list': imageList,     'mdc-deprecated-list--thumbnail-list': thumbnailList,     'mdc-deprecated-list--video-list': videoList,     'mdc-deprecated-list--two-line': twoLine,     'smui-list--three-line': threeLine && !twoLine,   })}   {role}   on:keydown={(event) =>     instance &&     instance.handleKeydown(       event,       event.target.classList.contains('mdc-deprecated-list-item'),       getListItemIndex(event.target)     )}   on:focusin={(event) =>     instance && instance.handleFocusIn(event, getListItemIndex(event.target))}   on:focusout={(event) =>     instance && instance.handleFocusOut(event, getListItemIndex(event.target))}   on:click={(event) =>     instance &&     instance.handleClick(       getListItemIndex(event.target),       !matches(event.target, 'input[type=\\"checkbox\\"], input[type=\\"radio\\"]')     )}   on:SMUI:list:item:mount={handleItemMount}   on:SMUI:list:item:unmount={handleItemUnmount}   on:SMUI:action={handleAction}   {...$$restProps} >`,
      ctx
    });
    return block;
  }
  function create_fragment$32(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[17], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-deprecated-list": true,
          "mdc-deprecated-list--non-interactive": ctx[2],
          "mdc-deprecated-list--dense": ctx[3],
          "mdc-deprecated-list--textual-list": ctx[4],
          "mdc-deprecated-list--avatar-list": ctx[5] || ctx[18],
          "mdc-deprecated-list--icon-list": ctx[6],
          "mdc-deprecated-list--image-list": ctx[7],
          "mdc-deprecated-list--thumbnail-list": ctx[8],
          "mdc-deprecated-list--video-list": ctx[9],
          "mdc-deprecated-list--two-line": ctx[10],
          "smui-list--three-line": ctx[11] && !ctx[10]
        })
      },
      {role: ctx[15]},
      ctx[23]
    ];
    var switch_value = ctx[12];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$12]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[39](switch_instance);
      switch_instance.$on("keydown", ctx[40]);
      switch_instance.$on("focusin", ctx[41]);
      switch_instance.$on("focusout", ctx[42]);
      switch_instance.$on("click", ctx[43]);
      switch_instance.$on("SMUI:list:item:mount", ctx[19]);
      switch_instance.$on("SMUI:list:item:unmount", ctx[20]);
      switch_instance.$on("SMUI:action", ctx[21]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty[0] & 8818687 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & 131073 && {
            use: [ctx2[17], ...ctx2[0]]
          },
          dirty[0] & 266238 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-deprecated-list": true,
              "mdc-deprecated-list--non-interactive": ctx2[2],
              "mdc-deprecated-list--dense": ctx2[3],
              "mdc-deprecated-list--textual-list": ctx2[4],
              "mdc-deprecated-list--avatar-list": ctx2[5] || ctx2[18],
              "mdc-deprecated-list--icon-list": ctx2[6],
              "mdc-deprecated-list--image-list": ctx2[7],
              "mdc-deprecated-list--thumbnail-list": ctx2[8],
              "mdc-deprecated-list--video-list": ctx2[9],
              "mdc-deprecated-list--two-line": ctx2[10],
              "smui-list--three-line": ctx2[11] && !ctx2[10]
            })
          },
          dirty[0] & 32768 && {role: ctx2[15]},
          dirty[0] & 8388608 && get_spread_object(ctx2[23])
        ]) : {};
        if (dirty[1] & 8192) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[12])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[39](switch_instance);
            switch_instance.$on("keydown", ctx2[40]);
            switch_instance.$on("focusin", ctx2[41]);
            switch_instance.$on("focusout", ctx2[42]);
            switch_instance.$on("click", ctx2[43]);
            switch_instance.$on("SMUI:list:item:mount", ctx2[19]);
            switch_instance.$on("SMUI:list:item:unmount", ctx2[20]);
            switch_instance.$on("SMUI:action", ctx2[21]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[39](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$32.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance_12($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "nonInteractive",
      "dense",
      "textualList",
      "avatarList",
      "iconList",
      "imageList",
      "thumbnailList",
      "videoList",
      "twoLine",
      "threeLine",
      "vertical",
      "wrapFocus",
      "singleSelection",
      "selectedIndex",
      "radioList",
      "checkList",
      "hasTypeahead",
      "radiolist",
      "checklist",
      "component",
      "layout",
      "setEnabled",
      "getTypeaheadInProgress",
      "getSelectedIndex",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("List", slots, ["default"]);
    const {closest: closest3, matches: matches3} = ponyfill;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {nonInteractive = false} = $$props;
    let {dense = false} = $$props;
    let {textualList = false} = $$props;
    let {avatarList = false} = $$props;
    let {iconList = false} = $$props;
    let {imageList = false} = $$props;
    let {thumbnailList = false} = $$props;
    let {videoList = false} = $$props;
    let {twoLine = false} = $$props;
    let {threeLine = false} = $$props;
    let {vertical = true} = $$props;
    let {wrapFocus = getContext("SMUI:list:wrapFocus") || false} = $$props;
    let {singleSelection = false} = $$props;
    let {selectedIndex = -1} = $$props;
    let {radioList = false} = $$props;
    let {checkList = false} = $$props;
    let {hasTypeahead = false} = $$props;
    let {radiolist = false} = $$props;
    if (radiolist) {
      radioList = true;
    }
    let {checklist = false} = $$props;
    if (checklist) {
      checkList = true;
    }
    let element2;
    let instance7;
    let items = [];
    let role = getContext("SMUI:list:role");
    let nav = getContext("SMUI:list:nav");
    const itemAccessorMap = new WeakMap();
    let selectionDialog = getContext("SMUI:dialog:selection");
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let {component = nav ? Nav : Ul} = $$props;
    setContext("SMUI:list:nonInteractive", nonInteractive);
    setContext("SMUI:separator:context", "list");
    if (!role) {
      if (singleSelection) {
        role = "listbox";
        setContext("SMUI:list:item:role", "option");
      } else if (radioList) {
        role = "radiogroup";
        setContext("SMUI:list:item:role", "radio");
      } else if (checkList) {
        role = "group";
        setContext("SMUI:list:item:role", "checkbox");
      } else {
        role = "list";
        setContext("SMUI:list:item:role", void 0);
      }
    }
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    onMount(() => {
      $$invalidate(13, instance7 = new MDCListFoundation({
        addClassForElementIndex,
        focusItemAtIndex,
        getAttributeForElementIndex: (index, name2) => getOrderedList()[index].getAttr(name2),
        getFocusedElementIndex: () => getOrderedList().map((accessor) => accessor.element).indexOf(document.activeElement),
        getListItemCount: () => items.length,
        getPrimaryTextAtIndex,
        hasCheckboxAtIndex: (index) => getOrderedList()[index].hasCheckbox,
        hasRadioAtIndex: (index) => getOrderedList()[index].hasRadio,
        isCheckboxCheckedAtIndex: (index) => {
          const listItem = getOrderedList()[index];
          return listItem.hasCheckbox && listItem.checked;
        },
        isFocusInsideList: () => getElement() !== document.activeElement && getElement().contains(document.activeElement),
        isRootFocused: () => document.activeElement === getElement(),
        listItemAtIndexHasClass,
        notifyAction: (index) => {
          $$invalidate(24, selectedIndex = index);
          dispatch(element2, "MDCList:action", {index});
        },
        removeClassForElementIndex,
        setAttributeForElementIndex,
        setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
          getOrderedList()[index].checked = isChecked;
        },
        setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
          const listItem = getOrderedList()[listItemIndex];
          const selector = "button:not(:disabled), a";
          Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
            el.setAttribute("tabindex", tabIndexValue);
          });
        }
      }));
      dispatch(element2, "SMUI:list:mount", {
        get element() {
          return getElement();
        },
        get items() {
          return items;
        },
        get typeaheadInProgress() {
          return instance7.isTypeaheadInProgress();
        },
        typeaheadMatchItem(nextChar, startingIndex) {
          return instance7.typeaheadMatchItem(nextChar, startingIndex, true);
        },
        getOrderedList,
        focusItemAtIndex,
        addClassForElementIndex,
        removeClassForElementIndex,
        setAttributeForElementIndex,
        removeAttributeForElementIndex,
        getPrimaryTextAtIndex
      });
      instance7.init();
      return () => {
        instance7.destroy();
      };
    });
    onDestroy(() => {
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    });
    function handleItemMount(event) {
      items.push(event.detail);
      itemAccessorMap.set(event.detail.element, event.detail);
      if (singleSelection && event.detail.selected) {
        $$invalidate(24, selectedIndex = getListItemIndex(event.detail.element));
      }
      event.stopPropagation();
    }
    function handleItemUnmount(event) {
      const idx = items.indexOf(event.detail);
      if (idx !== -1) {
        items.splice(idx, 1);
        items = items;
      }
      itemAccessorMap.delete(event.detail.element);
      event.stopPropagation();
    }
    function handleAction(event) {
      if (radioList || checkList) {
        const index = getListItemIndex(event.target);
        if (index !== -1) {
          const item = getOrderedList()[index];
          if (radioList && !item.checked || checkList) {
            item.checked = !item.checked;
            item.activateRipple();
            window.requestAnimationFrame(() => {
              item.deactivateRipple();
            });
          }
        }
      }
    }
    function getOrderedList() {
      return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
    }
    function focusItemAtIndex(index) {
      const accessor = getOrderedList()[index];
      accessor && accessor.element.focus();
    }
    function listItemAtIndexHasClass(index, className2) {
      const accessor = getOrderedList()[index];
      return accessor && accessor.hasClass(className2);
    }
    function addClassForElementIndex(index, className2) {
      const accessor = getOrderedList()[index];
      accessor && accessor.addClass(className2);
    }
    function removeClassForElementIndex(index, className2) {
      const accessor = getOrderedList()[index];
      accessor && accessor.removeClass(className2);
    }
    function setAttributeForElementIndex(index, name2, value) {
      const accessor = getOrderedList()[index];
      accessor && accessor.addAttr(name2, value);
    }
    function removeAttributeForElementIndex(index, name2) {
      const accessor = getOrderedList()[index];
      accessor && accessor.removeAttr(name2);
    }
    function getPrimaryTextAtIndex(index) {
      const accessor = getOrderedList()[index];
      return accessor && accessor.getPrimaryText();
    }
    function getListItemIndex(element3) {
      const nearestParent = closest3(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
      if (nearestParent && matches3(nearestParent, ".mdc-deprecated-list-item")) {
        return getOrderedList().map((item) => item.element).indexOf(nearestParent);
      }
      return -1;
    }
    function layout() {
      return instance7.layout();
    }
    function setEnabled(...args) {
      return instance7.setEnabled(...args);
    }
    function getTypeaheadInProgress() {
      return instance7.isTypeaheadInProgress();
    }
    function getSelectedIndex() {
      return instance7.getSelectedIndex();
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(14, element2);
      });
    }
    const keydown_handler = (event) => instance7 && instance7.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
    const focusin_handler = (event) => instance7 && instance7.handleFocusIn(event, getListItemIndex(event.target));
    const focusout_handler = (event) => instance7 && instance7.handleFocusOut(event, getListItemIndex(event.target));
    const click_handler = (event) => instance7 && instance7.handleClick(getListItemIndex(event.target), !matches3(event.target, 'input[type="checkbox"], input[type="radio"]'));
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("nonInteractive" in $$new_props)
        $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
      if ("dense" in $$new_props)
        $$invalidate(3, dense = $$new_props.dense);
      if ("textualList" in $$new_props)
        $$invalidate(4, textualList = $$new_props.textualList);
      if ("avatarList" in $$new_props)
        $$invalidate(5, avatarList = $$new_props.avatarList);
      if ("iconList" in $$new_props)
        $$invalidate(6, iconList = $$new_props.iconList);
      if ("imageList" in $$new_props)
        $$invalidate(7, imageList = $$new_props.imageList);
      if ("thumbnailList" in $$new_props)
        $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
      if ("videoList" in $$new_props)
        $$invalidate(9, videoList = $$new_props.videoList);
      if ("twoLine" in $$new_props)
        $$invalidate(10, twoLine = $$new_props.twoLine);
      if ("threeLine" in $$new_props)
        $$invalidate(11, threeLine = $$new_props.threeLine);
      if ("vertical" in $$new_props)
        $$invalidate(27, vertical = $$new_props.vertical);
      if ("wrapFocus" in $$new_props)
        $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
      if ("singleSelection" in $$new_props)
        $$invalidate(29, singleSelection = $$new_props.singleSelection);
      if ("selectedIndex" in $$new_props)
        $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
      if ("radioList" in $$new_props)
        $$invalidate(25, radioList = $$new_props.radioList);
      if ("checkList" in $$new_props)
        $$invalidate(26, checkList = $$new_props.checkList);
      if ("hasTypeahead" in $$new_props)
        $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
      if ("radiolist" in $$new_props)
        $$invalidate(31, radiolist = $$new_props.radiolist);
      if ("checklist" in $$new_props)
        $$invalidate(32, checklist = $$new_props.checklist);
      if ("component" in $$new_props)
        $$invalidate(12, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(44, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCListFoundation,
      ponyfill,
      onMount,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      dispatch,
      Ul,
      Nav,
      closest: closest3,
      matches: matches3,
      forwardEvents,
      use: use2,
      className,
      nonInteractive,
      dense,
      textualList,
      avatarList,
      iconList,
      imageList,
      thumbnailList,
      videoList,
      twoLine,
      threeLine,
      vertical,
      wrapFocus,
      singleSelection,
      selectedIndex,
      radioList,
      checkList,
      hasTypeahead,
      radiolist,
      checklist,
      element: element2,
      instance: instance7,
      items,
      role,
      nav,
      itemAccessorMap,
      selectionDialog,
      addLayoutListener,
      removeLayoutListener,
      component,
      handleItemMount,
      handleItemUnmount,
      handleAction,
      getOrderedList,
      focusItemAtIndex,
      listItemAtIndexHasClass,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getPrimaryTextAtIndex,
      getListItemIndex,
      layout,
      setEnabled,
      getTypeaheadInProgress,
      getSelectedIndex,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("nonInteractive" in $$props)
        $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
      if ("dense" in $$props)
        $$invalidate(3, dense = $$new_props.dense);
      if ("textualList" in $$props)
        $$invalidate(4, textualList = $$new_props.textualList);
      if ("avatarList" in $$props)
        $$invalidate(5, avatarList = $$new_props.avatarList);
      if ("iconList" in $$props)
        $$invalidate(6, iconList = $$new_props.iconList);
      if ("imageList" in $$props)
        $$invalidate(7, imageList = $$new_props.imageList);
      if ("thumbnailList" in $$props)
        $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
      if ("videoList" in $$props)
        $$invalidate(9, videoList = $$new_props.videoList);
      if ("twoLine" in $$props)
        $$invalidate(10, twoLine = $$new_props.twoLine);
      if ("threeLine" in $$props)
        $$invalidate(11, threeLine = $$new_props.threeLine);
      if ("vertical" in $$props)
        $$invalidate(27, vertical = $$new_props.vertical);
      if ("wrapFocus" in $$props)
        $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
      if ("singleSelection" in $$props)
        $$invalidate(29, singleSelection = $$new_props.singleSelection);
      if ("selectedIndex" in $$props)
        $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
      if ("radioList" in $$props)
        $$invalidate(25, radioList = $$new_props.radioList);
      if ("checkList" in $$props)
        $$invalidate(26, checkList = $$new_props.checkList);
      if ("hasTypeahead" in $$props)
        $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
      if ("radiolist" in $$props)
        $$invalidate(31, radiolist = $$new_props.radiolist);
      if ("checklist" in $$props)
        $$invalidate(32, checklist = $$new_props.checklist);
      if ("element" in $$props)
        $$invalidate(14, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(13, instance7 = $$new_props.instance);
      if ("items" in $$props)
        items = $$new_props.items;
      if ("role" in $$props)
        $$invalidate(15, role = $$new_props.role);
      if ("nav" in $$props)
        nav = $$new_props.nav;
      if ("selectionDialog" in $$props)
        $$invalidate(18, selectionDialog = $$new_props.selectionDialog);
      if ("addLayoutListener" in $$props)
        addLayoutListener = $$new_props.addLayoutListener;
      if ("removeLayoutListener" in $$props)
        removeLayoutListener = $$new_props.removeLayoutListener;
      if ("component" in $$props)
        $$invalidate(12, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 134225920) {
        if (instance7) {
          instance7.setVerticalOrientation(vertical);
        }
      }
      if ($$self.$$.dirty[0] & 268443648) {
        if (instance7) {
          instance7.setWrapFocus(wrapFocus);
        }
      }
      if ($$self.$$.dirty[0] & 1073750016) {
        if (instance7) {
          instance7.setHasTypeahead(hasTypeahead);
        }
      }
      if ($$self.$$.dirty[0] & 536879104) {
        if (instance7) {
          instance7.setSingleSelection(singleSelection);
        }
      }
      if ($$self.$$.dirty[0] & 553656320) {
        if (instance7 && singleSelection && getSelectedIndex() !== selectedIndex) {
          instance7.setSelectedIndex(selectedIndex);
        }
      }
    };
    return [
      use2,
      className,
      nonInteractive,
      dense,
      textualList,
      avatarList,
      iconList,
      imageList,
      thumbnailList,
      videoList,
      twoLine,
      threeLine,
      component,
      instance7,
      element2,
      role,
      matches3,
      forwardEvents,
      selectionDialog,
      handleItemMount,
      handleItemUnmount,
      handleAction,
      getListItemIndex,
      $$restProps,
      selectedIndex,
      radioList,
      checkList,
      vertical,
      wrapFocus,
      singleSelection,
      hasTypeahead,
      radiolist,
      checklist,
      layout,
      setEnabled,
      getTypeaheadInProgress,
      getSelectedIndex,
      getElement,
      slots,
      switch_instance_binding,
      keydown_handler,
      focusin_handler,
      focusout_handler,
      click_handler,
      $$scope
    ];
  }
  var List = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_12, create_fragment$32, safe_not_equal, {
        use: 0,
        class: 1,
        nonInteractive: 2,
        dense: 3,
        textualList: 4,
        avatarList: 5,
        iconList: 6,
        imageList: 7,
        thumbnailList: 8,
        videoList: 9,
        twoLine: 10,
        threeLine: 11,
        vertical: 27,
        wrapFocus: 28,
        singleSelection: 29,
        selectedIndex: 24,
        radioList: 25,
        checkList: 26,
        hasTypeahead: 30,
        radiolist: 31,
        checklist: 32,
        component: 12,
        layout: 33,
        setEnabled: 34,
        getTypeaheadInProgress: 35,
        getSelectedIndex: 36,
        getElement: 37
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "List",
        options,
        id: create_fragment$32.name
      });
    }
    get use() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get nonInteractive() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nonInteractive(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dense() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dense(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get textualList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set textualList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get avatarList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set avatarList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get iconList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set iconList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get imageList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set imageList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get thumbnailList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set thumbnailList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get videoList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set videoList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get twoLine() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set twoLine(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get threeLine() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set threeLine(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get vertical() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set vertical(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get wrapFocus() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set wrapFocus(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get singleSelection() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set singleSelection(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get selectedIndex() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set selectedIndex(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get radioList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set radioList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get checkList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set checkList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get hasTypeahead() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set hasTypeahead(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get radiolist() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set radiolist(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get checklist() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set checklist(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get layout() {
      return this.$$.ctx[33];
    }
    set layout(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setEnabled() {
      return this.$$.ctx[34];
    }
    set setEnabled(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getTypeaheadInProgress() {
      return this.$$.ctx[35];
    }
    set getTypeaheadInProgress(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getSelectedIndex() {
      return this.$$.ctx[36];
    }
    set getSelectedIndex(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[37];
    }
    set getElement(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$23 = "node_modules/@smui/common/Li.svelte";
  function create_fragment$24(ctx) {
    let li;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let li_levels = [ctx[3]];
    let li_data = {};
    for (let i = 0; i < li_levels.length; i += 1) {
      li_data = assign(li_data, li_levels[i]);
    }
    const block = {
      c: function create2() {
        li = element("li");
        if (default_slot)
          default_slot.c();
        set_attributes(li, li_data);
        add_location(li, file$23, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        if (default_slot) {
          default_slot.m(li, null);
        }
        ctx[7](li);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, li, ctx[0])),
            action_destroyer(ctx[2].call(null, li))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(li);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$24.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$24($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Li", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function li_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      li_binding
    ];
  }
  var Li = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$24, create_fragment$24, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Li",
        options,
        id: create_fragment$24.name
      });
    }
    get use() {
      throw new Error("<Li>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Li>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Li>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$14 = "node_modules/@smui/list/Item.svelte";
  function create_if_block3(ctx) {
    let span;
    const block = {
      c: function create2() {
        span = element("span");
        attr_dev(span, "class", "mdc-deprecated-list-item__ripple");
        add_location(span, file$14, 55, 15, 1654);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block3.name,
      type: "if",
      source: "(56:3) {#if ripple}",
      ctx
    });
    return block;
  }
  function create_default_slot3(ctx) {
    let if_block_anchor;
    let current;
    let if_block = ctx[6] && create_if_block3(ctx);
    const default_slot_template = ctx[30].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[34], null);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[6]) {
          if (if_block)
            ;
          else {
            if_block = create_if_block3(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (default_slot) {
          if (default_slot.p && (!current || dirty[1] & 8)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[34], !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(default_slot_template, ctx2[34], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot3.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     ...(nonInteractive       ? []       : [           [             Ripple,             {               ripple: !input,               unbounded: false,               color:                 (activated || selected) && color == null ? 'primary' : color,               disabled,               addClass,               removeClass,               addStyle,             },           ],         ]),     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-deprecated-list-item': true,     'mdc-deprecated-list-item--activated': activated,     'mdc-deprecated-list-item--selected': selected,     'mdc-deprecated-list-item--disabled': disabled,     'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,     'smui-menu-item--non-interactive': nonInteractive,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...nav && activated ? { 'aria-current': 'page' } : {}}   {...!nav ? { role } : {}}   {...!nav && role === 'option'     ? { 'aria-selected': selected ? 'true' : 'false' }     : {}}   {...!nav && (role === 'radio' || role === 'checkbox')     ? { 'aria-checked': input && input.checked ? 'true' : 'false' }     : {}}   {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}   {tabindex}   on:click={action}   on:keydown={handleKeydown}   on:SMUI:generic:input:mount={(event) => (input = event.detail)}   on:SMUI:generic:input:unmount={() => (input = undefined)}   {href}   {...internalAttrs}   {...$$restProps}   >",
      ctx
    });
    return block;
  }
  function create_fragment$14(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [
          ...ctx[5] ? [] : [
            [
              Ripple,
              {
                ripple: !ctx[12],
                unbounded: false,
                color: (ctx[7] || ctx[0]) && ctx[4] == null ? "primary" : ctx[4],
                disabled: ctx[9],
                addClass: ctx[20],
                removeClass: ctx[21],
                addStyle: ctx[22]
              }
            ]
          ],
          ctx[18],
          ...ctx[1]
        ]
      },
      {
        class: classMap({
          [ctx[2]]: true,
          "mdc-deprecated-list-item": true,
          "mdc-deprecated-list-item--activated": ctx[7],
          "mdc-deprecated-list-item--selected": ctx[0],
          "mdc-deprecated-list-item--disabled": ctx[9],
          "mdc-menu-item--selected": !ctx[19] && ctx[8] === "menuitem" && ctx[0],
          "smui-menu-item--non-interactive": ctx[5],
          ...ctx[14]
        })
      },
      {
        style: Object.entries(ctx[15]).map(func3).concat([ctx[3]]).join(" ")
      },
      ctx[19] && ctx[7] ? {"aria-current": "page"} : {},
      !ctx[19] ? {role: ctx[8]} : {},
      !ctx[19] && ctx[8] === "option" ? {
        "aria-selected": ctx[0] ? "true" : "false"
      } : {},
      !ctx[19] && (ctx[8] === "radio" || ctx[8] === "checkbox") ? {
        "aria-checked": ctx[12] && ctx[12].checked ? "true" : "false"
      } : {},
      !ctx[19] ? {
        "aria-disabled": ctx[9] ? "true" : "false"
      } : {},
      {tabindex: ctx[17]},
      {href: ctx[10]},
      ctx[16],
      ctx[25]
    ];
    var switch_value = ctx[11];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot3]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[31](switch_instance);
      switch_instance.$on("click", ctx[23]);
      switch_instance.$on("keydown", ctx[24]);
      switch_instance.$on("SMUI:generic:input:mount", ctx[32]);
      switch_instance.$on("SMUI:generic:input:unmount", ctx[33]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty[0] & 41932735 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & 7606963 && {
            use: [
              ...ctx2[5] ? [] : [
                [
                  Ripple,
                  {
                    ripple: !ctx2[12],
                    unbounded: false,
                    color: (ctx2[7] || ctx2[0]) && ctx2[4] == null ? "primary" : ctx2[4],
                    disabled: ctx2[9],
                    addClass: ctx2[20],
                    removeClass: ctx2[21],
                    addStyle: ctx2[22]
                  }
                ]
              ],
              ctx2[18],
              ...ctx2[1]
            ]
          },
          dirty[0] & 541605 && {
            class: classMap({
              [ctx2[2]]: true,
              "mdc-deprecated-list-item": true,
              "mdc-deprecated-list-item--activated": ctx2[7],
              "mdc-deprecated-list-item--selected": ctx2[0],
              "mdc-deprecated-list-item--disabled": ctx2[9],
              "mdc-menu-item--selected": !ctx2[19] && ctx2[8] === "menuitem" && ctx2[0],
              "smui-menu-item--non-interactive": ctx2[5],
              ...ctx2[14]
            })
          },
          dirty[0] & 32776 && {
            style: Object.entries(ctx2[15]).map(func3).concat([ctx2[3]]).join(" ")
          },
          dirty[0] & 524416 && get_spread_object(ctx2[19] && ctx2[7] ? {"aria-current": "page"} : {}),
          dirty[0] & 524544 && get_spread_object(!ctx2[19] ? {role: ctx2[8]} : {}),
          dirty[0] & 524545 && get_spread_object(!ctx2[19] && ctx2[8] === "option" ? {
            "aria-selected": ctx2[0] ? "true" : "false"
          } : {}),
          dirty[0] & 528640 && get_spread_object(!ctx2[19] && (ctx2[8] === "radio" || ctx2[8] === "checkbox") ? {
            "aria-checked": ctx2[12] && ctx2[12].checked ? "true" : "false"
          } : {}),
          dirty[0] & 524800 && get_spread_object(!ctx2[19] ? {
            "aria-disabled": ctx2[9] ? "true" : "false"
          } : {}),
          dirty[0] & 131072 && {tabindex: ctx2[17]},
          dirty[0] & 1024 && {href: ctx2[10]},
          dirty[0] & 65536 && get_spread_object(ctx2[16]),
          dirty[0] & 33554432 && get_spread_object(ctx2[25])
        ]) : {};
        if (dirty[0] & 64 | dirty[1] & 8) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[11])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[31](switch_instance);
            switch_instance.$on("click", ctx2[23]);
            switch_instance.$on("keydown", ctx2[24]);
            switch_instance.$on("SMUI:generic:input:mount", ctx2[32]);
            switch_instance.$on("SMUI:generic:input:unmount", ctx2[33]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[31](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$14.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var counter = 0;
  var func3 = ([name2, value]) => `${name2}: ${value};`;
  function instance$14($$self, $$props, $$invalidate) {
    let tabindex;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "color",
      "nonInteractive",
      "ripple",
      "activated",
      "role",
      "selected",
      "disabled",
      "tabindex",
      "inputId",
      "href",
      "component",
      "getPrimaryText",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Item", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let uninitializedValue = () => {
    };
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {color = null} = $$props;
    let {nonInteractive = getContext("SMUI:list:nonInteractive")} = $$props;
    setContext("SMUI:list:nonInteractive", void 0);
    let {ripple = !nonInteractive} = $$props;
    let {activated = false} = $$props;
    let {role = getContext("SMUI:list:item:role")} = $$props;
    setContext("SMUI:list:item:role", void 0);
    let {selected = false} = $$props;
    let {disabled = false} = $$props;
    let {tabindex: tabindexProp = uninitializedValue} = $$props;
    let {inputId = "SMUI-form-field-list-" + counter++} = $$props;
    let {href = null} = $$props;
    let element2;
    let internalClasses = {};
    let internalStyles = {};
    let internalAttrs = {};
    let input;
    let addTabindexIfNoItemsSelectedRaf;
    let nav = getContext("SMUI:list:item:nav");
    let {component = nav ? href ? A : Span : Li} = $$props;
    setContext("SMUI:generic:input:props", {id: inputId});
    setContext("SMUI:separator:context", void 0);
    onMount(() => {
      if (!selected && !nonInteractive) {
        let first = true;
        let el = element2;
        while (el.previousSibling) {
          el = el.previousSibling;
          if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
            first = false;
            break;
          }
        }
        if (first) {
          addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
        }
      }
      const accessor = {
        _smui_list_item_accessor: true,
        get element() {
          return getElement();
        },
        get selected() {
          return selected;
        },
        set selected(value) {
          $$invalidate(0, selected = value);
        },
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getPrimaryText,
        get checked() {
          return input && input.checked;
        },
        set checked(value) {
          if (input) {
            $$invalidate(12, input.checked = value, input);
          }
        },
        get hasCheckbox() {
          return !!(input && input._smui_checkbox_accessor);
        },
        get hasRadio() {
          return !!(input && input._smui_radio_accessor);
        },
        activateRipple() {
          if (input) {
            input.activateRipple();
          }
        },
        deactivateRipple() {
          if (input) {
            input.deactivateRipple();
          }
        },
        getValue() {
          return $$restProps.value;
        }
      };
      dispatch(element2, "SMUI:list:item:mount", accessor);
      return () => {
        dispatch(element2, "SMUI:list:item:unmount", accessor);
      };
    });
    onDestroy(() => {
      if (addTabindexIfNoItemsSelectedRaf) {
        window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(14, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(14, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name2, value) {
      if (internalStyles[name2] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name2];
          $$invalidate(15, internalStyles);
        } else {
          $$invalidate(15, internalStyles[name2] = value, internalStyles);
        }
      }
    }
    function getAttr(name2) {
      return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
    }
    function addAttr(name2, value) {
      if (internalAttrs[name2] !== value) {
        $$invalidate(16, internalAttrs[name2] = value, internalAttrs);
      }
    }
    function removeAttr(name2) {
      if (!(name2 in internalAttrs) || internalAttrs[name2] != null) {
        $$invalidate(16, internalAttrs[name2] = void 0, internalAttrs);
      }
    }
    function addTabindexIfNoItemsSelected() {
      let noneSelected = true;
      let el = element2;
      while (el.nextSibling) {
        el = el.nextSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && el.attributes["tabindex"] && el.attributes["tabindex"].value === "0") {
          noneSelected = false;
          break;
        }
      }
      if (noneSelected) {
        $$invalidate(17, tabindex = "0");
      }
    }
    function action(e) {
      if (!disabled) {
        dispatch(element2, "SMUI:action", e);
      }
    }
    function handleKeydown2(e) {
      const isEnter = e.key === "Enter" || e.keyCode === 13;
      const isSpace = e.key === "Space" || e.keyCode === 32;
      if (isEnter || isSpace) {
        action(e);
      }
    }
    function getPrimaryText() {
      const element3 = getElement();
      const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
      if (primaryText) {
        return primaryText.textContent;
      }
      const text2 = element3.querySelector(".mdc-deprecated-list-item__text");
      if (text2) {
        return text2.textContent;
      }
      return element3.textContent;
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(13, element2);
      });
    }
    const SMUI_generic_input_mount_handler = (event) => $$invalidate(12, input = event.detail);
    const SMUI_generic_input_unmount_handler = () => $$invalidate(12, input = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("color" in $$new_props)
        $$invalidate(4, color = $$new_props.color);
      if ("nonInteractive" in $$new_props)
        $$invalidate(5, nonInteractive = $$new_props.nonInteractive);
      if ("ripple" in $$new_props)
        $$invalidate(6, ripple = $$new_props.ripple);
      if ("activated" in $$new_props)
        $$invalidate(7, activated = $$new_props.activated);
      if ("role" in $$new_props)
        $$invalidate(8, role = $$new_props.role);
      if ("selected" in $$new_props)
        $$invalidate(0, selected = $$new_props.selected);
      if ("disabled" in $$new_props)
        $$invalidate(9, disabled = $$new_props.disabled);
      if ("tabindex" in $$new_props)
        $$invalidate(26, tabindexProp = $$new_props.tabindex);
      if ("inputId" in $$new_props)
        $$invalidate(27, inputId = $$new_props.inputId);
      if ("href" in $$new_props)
        $$invalidate(10, href = $$new_props.href);
      if ("component" in $$new_props)
        $$invalidate(11, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(34, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      counter,
      onMount,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      dispatch,
      Ripple,
      A,
      Span,
      Li,
      forwardEvents,
      uninitializedValue,
      use: use2,
      className,
      style,
      color,
      nonInteractive,
      ripple,
      activated,
      role,
      selected,
      disabled,
      tabindexProp,
      inputId,
      href,
      element: element2,
      internalClasses,
      internalStyles,
      internalAttrs,
      input,
      addTabindexIfNoItemsSelectedRaf,
      nav,
      component,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      getAttr,
      addAttr,
      removeAttr,
      addTabindexIfNoItemsSelected,
      action,
      handleKeydown: handleKeydown2,
      getPrimaryText,
      getElement,
      tabindex
    });
    $$self.$inject_state = ($$new_props) => {
      if ("uninitializedValue" in $$props)
        $$invalidate(36, uninitializedValue = $$new_props.uninitializedValue);
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("color" in $$props)
        $$invalidate(4, color = $$new_props.color);
      if ("nonInteractive" in $$props)
        $$invalidate(5, nonInteractive = $$new_props.nonInteractive);
      if ("ripple" in $$props)
        $$invalidate(6, ripple = $$new_props.ripple);
      if ("activated" in $$props)
        $$invalidate(7, activated = $$new_props.activated);
      if ("role" in $$props)
        $$invalidate(8, role = $$new_props.role);
      if ("selected" in $$props)
        $$invalidate(0, selected = $$new_props.selected);
      if ("disabled" in $$props)
        $$invalidate(9, disabled = $$new_props.disabled);
      if ("tabindexProp" in $$props)
        $$invalidate(26, tabindexProp = $$new_props.tabindexProp);
      if ("inputId" in $$props)
        $$invalidate(27, inputId = $$new_props.inputId);
      if ("href" in $$props)
        $$invalidate(10, href = $$new_props.href);
      if ("element" in $$props)
        $$invalidate(13, element2 = $$new_props.element);
      if ("internalClasses" in $$props)
        $$invalidate(14, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(15, internalStyles = $$new_props.internalStyles);
      if ("internalAttrs" in $$props)
        $$invalidate(16, internalAttrs = $$new_props.internalAttrs);
      if ("input" in $$props)
        $$invalidate(12, input = $$new_props.input);
      if ("addTabindexIfNoItemsSelectedRaf" in $$props)
        addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
      if ("nav" in $$props)
        $$invalidate(19, nav = $$new_props.nav);
      if ("component" in $$props)
        $$invalidate(11, component = $$new_props.component);
      if ("tabindex" in $$props)
        $$invalidate(17, tabindex = $$new_props.tabindex);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 67113505) {
        $$invalidate(17, tabindex = tabindexProp == uninitializedValue ? !nonInteractive && !disabled && (selected || input && input.checked) && "0" || "-1" : tabindexProp);
      }
    };
    return [
      selected,
      use2,
      className,
      style,
      color,
      nonInteractive,
      ripple,
      activated,
      role,
      disabled,
      href,
      component,
      input,
      element2,
      internalClasses,
      internalStyles,
      internalAttrs,
      tabindex,
      forwardEvents,
      nav,
      addClass,
      removeClass,
      addStyle,
      action,
      handleKeydown2,
      $$restProps,
      tabindexProp,
      inputId,
      getPrimaryText,
      getElement,
      slots,
      switch_instance_binding,
      SMUI_generic_input_mount_handler,
      SMUI_generic_input_unmount_handler,
      $$scope
    ];
  }
  var Item = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$14, create_fragment$14, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        color: 4,
        nonInteractive: 5,
        ripple: 6,
        activated: 7,
        role: 8,
        selected: 0,
        disabled: 9,
        tabindex: 26,
        inputId: 27,
        href: 10,
        component: 11,
        getPrimaryText: 28,
        getElement: 29
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Item",
        options,
        id: create_fragment$14.name
      });
    }
    get use() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get nonInteractive() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nonInteractive(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get activated() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set activated(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get role() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set role(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get selected() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set selected(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get disabled() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set disabled(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get tabindex() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set tabindex(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get inputId() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set inputId(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get href() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getPrimaryText() {
      return this.$$.ctx[28];
    }
    set getPrimaryText(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[29];
    }
    set getElement(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Text = classAdderBuilder({
    class: "mdc-deprecated-list-item__text",
    component: Span
  });
  classAdderBuilder({
    class: "mdc-deprecated-list-item__primary-text",
    component: Span
  });
  classAdderBuilder({
    class: "mdc-deprecated-list-item__secondary-text",
    component: Span
  });
  classAdderBuilder({
    class: "mdc-deprecated-list-item__meta",
    component: Span
  });
  classAdderBuilder({
    class: "mdc-deprecated-list-group",
    component: Div
  });
  var file5 = "node_modules/@smui/common/H3.svelte";
  function create_fragment5(ctx) {
    let h3;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h3_levels = [ctx[3]];
    let h3_data = {};
    for (let i = 0; i < h3_levels.length; i += 1) {
      h3_data = assign(h3_data, h3_levels[i]);
    }
    const block = {
      c: function create2() {
        h3 = element("h3");
        if (default_slot)
          default_slot.c();
        set_attributes(h3, h3_data);
        add_location(h3, file5, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h3, anchor);
        if (default_slot) {
          default_slot.m(h3, null);
        }
        ctx[7](h3);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h3, ctx[0])),
            action_destroyer(ctx[2].call(null, h3))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h3);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment5.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance4($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H3", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h3_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h3_binding
    ];
  }
  var H3 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance4, create_fragment5, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H3",
        options,
        id: create_fragment5.name
      });
    }
    get use() {
      throw new Error("<H3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Subheader = classAdderBuilder({
    class: "mdc-deprecated-list-group__subheader",
    component: H3
  });

  // dist/build/NotchedOutline.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  function exclude2(obj, keys) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name2 = names[i];
      const cashIndex = name2.indexOf("$");
      if (cashIndex !== -1 && keys.indexOf(name2.substring(0, cashIndex + 1)) !== -1) {
        continue;
      }
      if (keys.indexOf(name2) !== -1) {
        continue;
      }
      newObj[name2] = obj[name2];
    }
    return newObj;
  }
  function prefixFilter2(obj, prefix) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name2 = names[i];
      if (name2.substring(0, prefix.length) === prefix) {
        newObj[name2.substring(prefix.length)] = obj[name2];
      }
    }
    return newObj;
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$22 = {
    LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
    LABEL_REQUIRED: "mdc-floating-label--required",
    LABEL_SHAKE: "mdc-floating-label--shake",
    ROOT: "mdc-floating-label"
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFloatingLabelFoundation = function(_super) {
    __extends(MDCFloatingLabelFoundation2, _super);
    function MDCFloatingLabelFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
      _this.shakeAnimationEndHandler_ = function() {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          getWidth: function() {
            return 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFloatingLabelFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation2.prototype.getWidth = function() {
      return this.adapter.getWidth();
    };
    MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      if (shouldShake) {
        this.adapter.addClass(LABEL_SHAKE);
      } else {
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
      var _a2 = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a2.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a2.LABEL_SHAKE;
      if (shouldFloat) {
        this.adapter.addClass(LABEL_FLOAT_ABOVE);
      } else {
        this.adapter.removeClass(LABEL_FLOAT_ABOVE);
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
      var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
      if (isRequired) {
        this.adapter.addClass(LABEL_REQUIRED);
      } else {
        this.adapter.removeClass(LABEL_REQUIRED);
      }
    };
    MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd_ = function() {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      this.adapter.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$13 = {
    LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
    LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
  };
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCLineRippleFoundation = function(_super) {
    __extends(MDCLineRippleFoundation2, _super);
    function MDCLineRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.transitionEndHandler_ = function(evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$13;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          setStyle: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCLineRippleFoundation2.prototype.init = function() {
      this.adapter.registerEventHandler("transitionend", this.transitionEndHandler_);
    };
    MDCLineRippleFoundation2.prototype.destroy = function() {
      this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler_);
    };
    MDCLineRippleFoundation2.prototype.activate = function() {
      this.adapter.removeClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
      this.adapter.addClass(cssClasses$13.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
      this.adapter.setStyle("transform-origin", xCoordinate + "px center");
    };
    MDCLineRippleFoundation2.prototype.deactivate = function() {
      this.adapter.addClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
      var isDeactivating = this.adapter.hasClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
      if (evt.propertyName === "opacity") {
        if (isDeactivating) {
          this.adapter.removeClass(cssClasses$13.LINE_RIPPLE_ACTIVE);
          this.adapter.removeClass(cssClasses$13.LINE_RIPPLE_DEACTIVATING);
        }
      }
    };
    return MDCLineRippleFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var strings4 = {
    NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
  };
  var numbers4 = {
    NOTCH_ELEMENT_PADDING: 8
  };
  var cssClasses4 = {
    NO_LABEL: "mdc-notched-outline--no-label",
    OUTLINE_NOTCHED: "mdc-notched-outline--notched",
    OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCNotchedOutlineFoundation = function(_super) {
    __extends(MDCNotchedOutlineFoundation2, _super);
    function MDCNotchedOutlineFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
      get: function() {
        return strings4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
      get: function() {
        return cssClasses4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
      get: function() {
        return numbers4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setNotchWidthProperty: function() {
            return void 0;
          },
          removeNotchWidthProperty: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      if (notchWidth > 0) {
        notchWidth += numbers4.NOTCH_ELEMENT_PADDING;
      }
      this.adapter.setNotchWidthProperty(notchWidth);
      this.adapter.addClass(OUTLINE_NOTCHED);
    };
    MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      this.adapter.removeClass(OUTLINE_NOTCHED);
      this.adapter.removeNotchWidthProperty();
    };
    return MDCNotchedOutlineFoundation2;
  }(MDCFoundation);
  var file$24 = "node_modules/@smui/floating-label/FloatingLabel.svelte";
  function create_else_block2(ctx) {
    let label;
    let label_class_value;
    let label_style_value;
    let label_for_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[22].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
    let label_levels = [
      {
        class: label_class_value = classMap({
          [ctx[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx[0],
          "mdc-floating-label--required": ctx[1],
          ...ctx[8]
        })
      },
      {
        style: label_style_value = Object.entries(ctx[9]).map(func_12).concat([ctx[4]]).join(" ")
      },
      {
        for: label_for_value = ctx[5] || (ctx[11] ? ctx[11].id : null)
      },
      ctx[12]
    ];
    let label_data = {};
    for (let i = 0; i < label_levels.length; i += 1) {
      label_data = assign(label_data, label_levels[i]);
    }
    const block = {
      c: function create2() {
        label = element("label");
        if (default_slot)
          default_slot.c();
        set_attributes(label, label_data);
        add_location(label, file$24, 19, 2, 494);
      },
      m: function mount(target, anchor) {
        insert_dev(target, label, anchor);
        if (default_slot) {
          default_slot.m(label, null);
        }
        ctx[24](label);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, label, ctx[2])),
            action_destroyer(ctx[10].call(null, label))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2097152)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
          }
        }
        set_attributes(label, label_data = get_spread_update(label_levels, [
          (!current || dirty & 267 && label_class_value !== (label_class_value = classMap({
            [ctx2[3]]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": ctx2[0],
            "mdc-floating-label--required": ctx2[1],
            ...ctx2[8]
          }))) && {class: label_class_value},
          (!current || dirty & 528 && label_style_value !== (label_style_value = Object.entries(ctx2[9]).map(func_12).concat([ctx2[4]]).join(" "))) && {style: label_style_value},
          (!current || dirty & 32 && label_for_value !== (label_for_value = ctx2[5] || (ctx2[11] ? ctx2[11].id : null))) && {for: label_for_value},
          dirty & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 4)
          useActions_action.update.call(null, ctx2[2]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(label);
        if (default_slot)
          default_slot.d(detaching);
        ctx[24](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block2.name,
      type: "else",
      source: "(19:0) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block$1(ctx) {
    let span;
    let span_class_value;
    let span_style_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[22].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
    let span_levels = [
      {
        class: span_class_value = classMap({
          [ctx[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx[0],
          "mdc-floating-label--required": ctx[1],
          ...ctx[8]
        })
      },
      {
        style: span_style_value = Object.entries(ctx[9]).map(func$2).concat([ctx[4]]).join(" ")
      },
      ctx[12]
    ];
    let span_data = {};
    for (let i = 0; i < span_levels.length; i += 1) {
      span_data = assign(span_data, span_levels[i]);
    }
    const block = {
      c: function create2() {
        span = element("span");
        if (default_slot)
          default_slot.c();
        set_attributes(span, span_data);
        add_location(span, file$24, 1, 2, 16);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        if (default_slot) {
          default_slot.m(span, null);
        }
        ctx[23](span);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, span, ctx[2])),
            action_destroyer(ctx[10].call(null, span))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2097152)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
          }
        }
        set_attributes(span, span_data = get_spread_update(span_levels, [
          (!current || dirty & 267 && span_class_value !== (span_class_value = classMap({
            [ctx2[3]]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": ctx2[0],
            "mdc-floating-label--required": ctx2[1],
            ...ctx2[8]
          }))) && {class: span_class_value},
          (!current || dirty & 528 && span_style_value !== (span_style_value = Object.entries(ctx2[9]).map(func$2).concat([ctx2[4]]).join(" "))) && {style: span_style_value},
          dirty & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 4)
          useActions_action.update.call(null, ctx2[2]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        if (default_slot)
          default_slot.d(detaching);
        ctx[23](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block$1.name,
      type: "if",
      source: "(1:0) {#if wrapped}",
      ctx
    });
    return block;
  }
  function create_fragment$25(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block$1, create_else_block2];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[6])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    const block = {
      c: function create2() {
        if_block.c();
        if_block_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if_blocks[current_block_type_index].d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$25.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$2 = ([name2, value]) => `${name2}: ${value};`;
  var func_12 = ([name2, value]) => `${name2}: ${value};`;
  function instance_1$22($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "for",
      "floatAbove",
      "required",
      "wrapped",
      "shake",
      "float",
      "setRequired",
      "getWidth",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("FloatingLabel", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {for: forId = null} = $$props;
    let {floatAbove = false} = $$props;
    let {required = false} = $$props;
    let {wrapped = false} = $$props;
    let element2;
    let instance7;
    let internalClasses = {};
    let internalStyles = {};
    let inputProps = getContext("SMUI:generic:input:props") || {};
    let previousFloatAbove = floatAbove;
    let previousRequired = required;
    onMount(() => {
      $$invalidate(18, instance7 = new MDCFloatingLabelFoundation({
        addClass,
        removeClass,
        getWidth: () => {
          const el = getElement();
          const clone2 = el.cloneNode(true);
          el.parentNode.appendChild(clone2);
          clone2.classList.add("smui-floating-label--remove-transition");
          clone2.classList.add("smui-floating-label--force-size");
          clone2.classList.remove("mdc-floating-label--float-above");
          const scrollWidth = clone2.scrollWidth;
          el.parentNode.removeChild(clone2);
          return scrollWidth;
        },
        registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
      }));
      const accessor = {
        get element() {
          return getElement();
        },
        addStyle,
        removeStyle
      };
      dispatch(element2, "SMUI:floating-label:mount", accessor);
      instance7.init();
      return () => {
        dispatch(element2, "SMUI:floating-label:unmount", accessor);
        instance7.destroy();
      };
    });
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(8, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(8, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name2, value) {
      if (internalStyles[name2] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name2];
          $$invalidate(9, internalStyles);
        } else {
          $$invalidate(9, internalStyles[name2] = value, internalStyles);
        }
      }
    }
    function removeStyle(name2) {
      if (name2 in internalStyles) {
        delete internalStyles[name2];
        $$invalidate(9, internalStyles);
      }
    }
    function shake(shouldShake) {
      instance7.shake(shouldShake);
    }
    function float(shouldFloat) {
      $$invalidate(0, floatAbove = shouldFloat);
    }
    function setRequired(isRequired) {
      $$invalidate(1, required = isRequired);
    }
    function getWidth() {
      return instance7.getWidth();
    }
    function getElement() {
      return element2;
    }
    function span_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    function label_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(2, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(3, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(4, style = $$new_props.style);
      if ("for" in $$new_props)
        $$invalidate(5, forId = $$new_props.for);
      if ("floatAbove" in $$new_props)
        $$invalidate(0, floatAbove = $$new_props.floatAbove);
      if ("required" in $$new_props)
        $$invalidate(1, required = $$new_props.required);
      if ("wrapped" in $$new_props)
        $$invalidate(6, wrapped = $$new_props.wrapped);
      if ("$$scope" in $$new_props)
        $$invalidate(21, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCFloatingLabelFoundation,
      onMount,
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      dispatch,
      forwardEvents,
      use: use2,
      className,
      style,
      forId,
      floatAbove,
      required,
      wrapped,
      element: element2,
      instance: instance7,
      internalClasses,
      internalStyles,
      inputProps,
      previousFloatAbove,
      previousRequired,
      addClass,
      removeClass,
      addStyle,
      removeStyle,
      shake,
      float,
      setRequired,
      getWidth,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(2, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(3, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(4, style = $$new_props.style);
      if ("forId" in $$props)
        $$invalidate(5, forId = $$new_props.forId);
      if ("floatAbove" in $$props)
        $$invalidate(0, floatAbove = $$new_props.floatAbove);
      if ("required" in $$props)
        $$invalidate(1, required = $$new_props.required);
      if ("wrapped" in $$props)
        $$invalidate(6, wrapped = $$new_props.wrapped);
      if ("element" in $$props)
        $$invalidate(7, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(18, instance7 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(8, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(9, internalStyles = $$new_props.internalStyles);
      if ("inputProps" in $$props)
        $$invalidate(11, inputProps = $$new_props.inputProps);
      if ("previousFloatAbove" in $$props)
        $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
      if ("previousRequired" in $$props)
        $$invalidate(20, previousRequired = $$new_props.previousRequired);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 786433) {
        if (previousFloatAbove !== floatAbove) {
          $$invalidate(19, previousFloatAbove = floatAbove);
          instance7.float(floatAbove);
        }
      }
      if ($$self.$$.dirty & 1310722) {
        if (previousRequired !== required) {
          $$invalidate(20, previousRequired = required);
          instance7.setRequired(required);
        }
      }
    };
    return [
      floatAbove,
      required,
      use2,
      className,
      style,
      forId,
      wrapped,
      element2,
      internalClasses,
      internalStyles,
      forwardEvents,
      inputProps,
      $$restProps,
      shake,
      float,
      setRequired,
      getWidth,
      getElement,
      instance7,
      previousFloatAbove,
      previousRequired,
      $$scope,
      slots,
      span_binding,
      label_binding
    ];
  }
  var FloatingLabel = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$22, create_fragment$25, safe_not_equal, {
        use: 2,
        class: 3,
        style: 4,
        for: 5,
        floatAbove: 0,
        required: 1,
        wrapped: 6,
        shake: 13,
        float: 14,
        setRequired: 15,
        getWidth: 16,
        getElement: 17
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "FloatingLabel",
        options,
        id: create_fragment$25.name
      });
    }
    get use() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get for() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set for(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get floatAbove() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set floatAbove(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get required() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set required(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get wrapped() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set wrapped(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get shake() {
      return this.$$.ctx[13];
    }
    set shake(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get float() {
      return this.$$.ctx[14];
    }
    set float(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setRequired() {
      return this.$$.ctx[15];
    }
    set setRequired(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getWidth() {
      return this.$$.ctx[16];
    }
    set getWidth(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[17];
    }
    set getElement(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$15 = "node_modules/@smui/line-ripple/LineRipple.svelte";
  function create_fragment$15(ctx) {
    let div;
    let div_class_value;
    let div_style_value;
    let useActions_action;
    let mounted;
    let dispose;
    let div_levels = [
      {
        class: div_class_value = classMap({
          [ctx[1]]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": ctx[3],
          ...ctx[5]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[6]).map(func$12).concat([ctx[2]]).join(" ")
      },
      ctx[8]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        set_attributes(div, div_data);
        add_location(div, file$15, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        ctx[13](div);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
            action_destroyer(ctx[7].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(div, div_data = get_spread_update(div_levels, [
          dirty & 42 && div_class_value !== (div_class_value = classMap({
            [ctx2[1]]: true,
            "mdc-line-ripple": true,
            "mdc-line-ripple--active": ctx2[3],
            ...ctx2[5]
          })) && {class: div_class_value},
          dirty & 68 && div_style_value !== (div_style_value = Object.entries(ctx2[6]).map(func$12).concat([ctx2[2]]).join(" ")) && {style: div_style_value},
          dirty & 256 && ctx2[8]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        ctx[13](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$15.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$12 = ([name2, value]) => `${name2}: ${value};`;
  function instance_1$12($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "active",
      "activate",
      "deactivate",
      "setRippleCenter",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("LineRipple", slots, []);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {active: active2 = false} = $$props;
    let element2;
    let instance7;
    let internalClasses = {};
    let internalStyles = {};
    onMount(() => {
      instance7 = new MDCLineRippleFoundation({
        addClass,
        removeClass,
        hasClass,
        setStyle: addStyle,
        registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
      });
      instance7.init();
      return () => {
        instance7.destroy();
      };
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(5, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(5, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name2, value) {
      if (internalStyles[name2] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name2];
          $$invalidate(6, internalStyles);
        } else {
          $$invalidate(6, internalStyles[name2] = value, internalStyles);
        }
      }
    }
    function activate() {
      instance7.activate();
    }
    function deactivate() {
      instance7.deactivate();
    }
    function setRippleCenter(xCoordinate) {
      instance7.setRippleCenter(xCoordinate);
    }
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(4, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(2, style = $$new_props.style);
      if ("active" in $$new_props)
        $$invalidate(3, active2 = $$new_props.active);
    };
    $$self.$capture_state = () => ({
      MDCLineRippleFoundation,
      onMount,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      forwardEvents,
      use: use2,
      className,
      style,
      active: active2,
      element: element2,
      instance: instance7,
      internalClasses,
      internalStyles,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      activate,
      deactivate,
      setRippleCenter,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(2, style = $$new_props.style);
      if ("active" in $$props)
        $$invalidate(3, active2 = $$new_props.active);
      if ("element" in $$props)
        $$invalidate(4, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance7 = $$new_props.instance;
      if ("internalClasses" in $$props)
        $$invalidate(5, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(6, internalStyles = $$new_props.internalStyles);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      style,
      active2,
      element2,
      internalClasses,
      internalStyles,
      forwardEvents,
      $$restProps,
      activate,
      deactivate,
      setRippleCenter,
      getElement,
      div_binding
    ];
  }
  var LineRipple = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$12, create_fragment$15, safe_not_equal, {
        use: 0,
        class: 1,
        style: 2,
        active: 3,
        activate: 9,
        deactivate: 10,
        setRippleCenter: 11,
        getElement: 12
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "LineRipple",
        options,
        id: create_fragment$15.name
      });
    }
    get use() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get active() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set active(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get activate() {
      return this.$$.ctx[9];
    }
    set activate(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get deactivate() {
      return this.$$.ctx[10];
    }
    set deactivate(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setRippleCenter() {
      return this.$$.ctx[11];
    }
    set setRippleCenter(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[12];
    }
    set getElement(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file6 = "node_modules/@smui/notched-outline/NotchedOutline.svelte";
  function create_if_block4(ctx) {
    let div;
    let div_style_value;
    let current;
    const default_slot_template = ctx[14].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        attr_dev(div, "class", "mdc-notched-outline__notch");
        attr_dev(div, "style", div_style_value = Object.entries(ctx[7]).map(func4).join(" "));
        add_location(div, file6, 17, 4, 500);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 8192)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null), null);
          }
        }
        if (!current || dirty & 128 && div_style_value !== (div_style_value = Object.entries(ctx2[7]).map(func4).join(" "))) {
          attr_dev(div, "style", div_style_value);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block4.name,
      type: "if",
      source: "(17:2) {#if !noLabel}",
      ctx
    });
    return block;
  }
  function create_fragment6(ctx) {
    let div2;
    let div0;
    let t0;
    let t1;
    let div1;
    let div2_class_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    let if_block = !ctx[3] && create_if_block4(ctx);
    let div2_levels = [
      {
        class: div2_class_value = classMap({
          [ctx[1]]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": ctx[2],
          "mdc-notched-outline--no-label": ctx[3],
          ...ctx[6]
        })
      },
      ctx[9]
    ];
    let div2_data = {};
    for (let i = 0; i < div2_levels.length; i += 1) {
      div2_data = assign(div2_data, div2_levels[i]);
    }
    const block = {
      c: function create2() {
        div2 = element("div");
        div0 = element("div");
        t0 = space();
        if (if_block)
          if_block.c();
        t1 = space();
        div1 = element("div");
        attr_dev(div0, "class", "mdc-notched-outline__leading");
        add_location(div0, file6, 15, 2, 434);
        attr_dev(div1, "class", "mdc-notched-outline__trailing");
        add_location(div1, file6, 26, 2, 703);
        set_attributes(div2, div2_data);
        add_location(div2, file6, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        append_dev(div2, t0);
        if (if_block)
          if_block.m(div2, null);
        append_dev(div2, t1);
        append_dev(div2, div1);
        ctx[15](div2);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, div2, ctx[0])),
            action_destroyer(ctx[8].call(null, div2)),
            listen_dev(div2, "SMUI:floating-label:mount", ctx[16], false, false, false),
            listen_dev(div2, "SMUI:floating-label:unmount", ctx[17], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (!ctx2[3]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 8) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block4(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div2, t1);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        set_attributes(div2, div2_data = get_spread_update(div2_levels, [
          (!current || dirty & 78 && div2_class_value !== (div2_class_value = classMap({
            [ctx2[1]]: true,
            "mdc-notched-outline": true,
            "mdc-notched-outline--notched": ctx2[2],
            "mdc-notched-outline--no-label": ctx2[3],
            ...ctx2[6]
          }))) && {class: div2_class_value},
          dirty & 512 && ctx2[9]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div2);
        if (if_block)
          if_block.d();
        ctx[15](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment6.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func4 = ([name2, value]) => `${name2}: ${value};`;
  function instance_13($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("NotchedOutline", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {notched = false} = $$props;
    let {noLabel = false} = $$props;
    let element2;
    let instance7;
    let floatingLabel;
    let internalClasses = {};
    let notchStyles = {};
    onMount(() => {
      instance7 = new MDCNotchedOutlineFoundation({
        addClass,
        removeClass,
        setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
        removeNotchWidthProperty: () => removeNotchStyle("width")
      });
      instance7.init();
      return () => {
        instance7.destroy();
      };
    });
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(6, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(6, internalClasses[className2] = false, internalClasses);
      }
    }
    function addNotchStyle(name2, value) {
      if (notchStyles[name2] != value) {
        if (value === "" || value == null) {
          delete notchStyles[name2];
          $$invalidate(7, notchStyles);
        } else {
          $$invalidate(7, notchStyles[name2] = value, notchStyles);
        }
      }
    }
    function removeNotchStyle(name2) {
      if (name2 in notchStyles) {
        delete notchStyles[name2];
        $$invalidate(7, notchStyles);
      }
    }
    function notch(notchWidth) {
      instance7.notch(notchWidth);
    }
    function closeNotch() {
      instance7.closeNotch();
    }
    function getElement() {
      return element2;
    }
    function div2_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    const SMUI_floating_label_mount_handler = (event) => $$invalidate(4, floatingLabel = event.detail);
    const SMUI_floating_label_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("notched" in $$new_props)
        $$invalidate(2, notched = $$new_props.notched);
      if ("noLabel" in $$new_props)
        $$invalidate(3, noLabel = $$new_props.noLabel);
      if ("$$scope" in $$new_props)
        $$invalidate(13, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCNotchedOutlineFoundation,
      onMount,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      forwardEvents,
      use: use2,
      className,
      notched,
      noLabel,
      element: element2,
      instance: instance7,
      floatingLabel,
      internalClasses,
      notchStyles,
      addClass,
      removeClass,
      addNotchStyle,
      removeNotchStyle,
      notch,
      closeNotch,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("notched" in $$props)
        $$invalidate(2, notched = $$new_props.notched);
      if ("noLabel" in $$props)
        $$invalidate(3, noLabel = $$new_props.noLabel);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance7 = $$new_props.instance;
      if ("floatingLabel" in $$props)
        $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
      if ("internalClasses" in $$props)
        $$invalidate(6, internalClasses = $$new_props.internalClasses);
      if ("notchStyles" in $$props)
        $$invalidate(7, notchStyles = $$new_props.notchStyles);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 16) {
        if (floatingLabel) {
          floatingLabel.addStyle("transition-duration", "0s");
          addClass("mdc-notched-outline--upgraded");
          requestAnimationFrame(() => {
            floatingLabel.removeStyle("transition-duration");
          });
        } else {
          removeClass("mdc-notched-outline--upgraded");
        }
      }
    };
    return [
      use2,
      className,
      notched,
      noLabel,
      floatingLabel,
      element2,
      internalClasses,
      notchStyles,
      forwardEvents,
      $$restProps,
      notch,
      closeNotch,
      getElement,
      $$scope,
      slots,
      div2_binding,
      SMUI_floating_label_mount_handler,
      SMUI_floating_label_unmount_handler
    ];
  }
  var NotchedOutline = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_13, create_fragment6, safe_not_equal, {
        use: 0,
        class: 1,
        notched: 2,
        noLabel: 3,
        notch: 10,
        closeNotch: 11,
        getElement: 12
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "NotchedOutline",
        options,
        id: create_fragment6.name
      });
    }
    get use() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notched() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set notched(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noLabel() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noLabel(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notch() {
      return this.$$.ctx[10];
    }
    set notch(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get closeNotch() {
      return this.$$.ctx[11];
    }
    set closeNotch(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[12];
    }
    set getElement(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/Textfield.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var file$42 = "node_modules/@smui/common/I.svelte";
  function create_fragment$62(ctx) {
    let i;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let i_levels = [ctx[3]];
    let i_data = {};
    for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
      i_data = assign(i_data, i_levels[i2]);
    }
    const block = {
      c: function create2() {
        i = element("i");
        if (default_slot)
          default_slot.c();
        set_attributes(i, i_data);
        add_location(i, file$42, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, i, anchor);
        if (default_slot) {
          default_slot.m(i, null);
        }
        ctx[7](i);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, i, ctx[0])),
            action_destroyer(ctx[2].call(null, i))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(i, i_data = get_spread_update(i_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(i);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$62.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$5($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("I", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function i_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      i_binding
    ];
  }
  var I = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$5, create_fragment$62, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "I",
        options,
        id: create_fragment$62.name
      });
    }
    get use() {
      throw new Error("<I>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$32 = "node_modules/@smui/common/Svg.svelte";
  function create_fragment$52(ctx) {
    let svg;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let svg_levels = [ctx[3]];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    const block = {
      c: function create2() {
        svg = svg_element("svg");
        if (default_slot)
          default_slot.c();
        set_svg_attributes(svg, svg_data);
        add_location(svg, file$32, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, svg, anchor);
        if (default_slot) {
          default_slot.m(svg, null);
        }
        ctx[7](svg);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, svg, ctx[0])),
            action_destroyer(ctx[2].call(null, svg))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(svg);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$52.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$42($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Svg", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function svg_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      svg_binding
    ];
  }
  var Svg = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$42, create_fragment$52, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Svg",
        options,
        id: create_fragment$52.name
      });
    }
    get use() {
      throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$13(ctx) {
    let current;
    const default_slot_template = ctx[9].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2048)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$13.name,
      type: "slot",
      source: `(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden=\\"true\\"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>`,
      ctx
    });
    return block;
  }
  function create_fragment$42(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[5], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-button__icon": ctx[6] === "button",
          "mdc-fab__icon": ctx[6] === "fab",
          "mdc-icon-button__icon": ctx[6] === "icon-button",
          "mdc-icon-button__icon--on": ctx[6] === "icon-button" && ctx[2],
          "mdc-tab__icon": ctx[6] === "tab",
          "mdc-banner__icon": ctx[6] === "banner",
          "mdc-segmented-button__icon": ctx[6] === "segmented-button"
        })
      },
      {"aria-hidden": "true"},
      ctx[3] === Svg ? {focusable: "false", tabindex: "-1"} : {},
      ctx[7]
    ];
    var switch_value = ctx[3];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$13]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[10](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 239 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 33 && {
            use: [ctx2[5], ...ctx2[0]]
          },
          dirty & 70 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-button__icon": ctx2[6] === "button",
              "mdc-fab__icon": ctx2[6] === "fab",
              "mdc-icon-button__icon": ctx2[6] === "icon-button",
              "mdc-icon-button__icon--on": ctx2[6] === "icon-button" && ctx2[2],
              "mdc-tab__icon": ctx2[6] === "tab",
              "mdc-banner__icon": ctx2[6] === "banner",
              "mdc-segmented-button__icon": ctx2[6] === "segmented-button"
            })
          },
          switch_instance_spread_levels[2],
          dirty & 8 && get_spread_object(ctx2[3] === Svg ? {focusable: "false", tabindex: "-1"} : {}),
          dirty & 128 && get_spread_object(ctx2[7])
        ]) : {};
        if (dirty & 2048) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[3])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[10](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[10](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$42.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$33($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "on", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("CommonIcon", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {on = false} = $$props;
    let element2;
    let {component = I} = $$props;
    const context = getContext("SMUI:icon:context");
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(4, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("on" in $$new_props)
        $$invalidate(2, on = $$new_props.on);
      if ("component" in $$new_props)
        $$invalidate(3, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(11, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      I,
      Svg,
      forwardEvents,
      use: use2,
      className,
      on,
      element: element2,
      component,
      context,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("on" in $$props)
        $$invalidate(2, on = $$new_props.on);
      if ("element" in $$props)
        $$invalidate(4, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(3, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      on,
      component,
      element2,
      forwardEvents,
      context,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var CommonIcon = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$33, create_fragment$42, safe_not_equal, {
        use: 0,
        class: 1,
        on: 2,
        component: 3,
        getElement: 8
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "CommonIcon",
        options,
        id: create_fragment$42.name
      });
    }
    get use() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get on() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set on(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[8];
    }
    set getElement(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var strings5 = {
    ARIA_CONTROLS: "aria-controls",
    ARIA_DESCRIBEDBY: "aria-describedby",
    INPUT_SELECTOR: ".mdc-text-field__input",
    LABEL_SELECTOR: ".mdc-floating-label",
    LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
    LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
    OUTLINE_SELECTOR: ".mdc-notched-outline",
    PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
    SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
    TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
  };
  var cssClasses5 = {
    DISABLED: "mdc-text-field--disabled",
    FOCUSED: "mdc-text-field--focused",
    HELPER_LINE: "mdc-text-field-helper-line",
    INVALID: "mdc-text-field--invalid",
    LABEL_FLOATING: "mdc-text-field--label-floating",
    NO_LABEL: "mdc-text-field--no-label",
    OUTLINED: "mdc-text-field--outlined",
    ROOT: "mdc-text-field",
    TEXTAREA: "mdc-text-field--textarea",
    WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
    WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon"
  };
  var numbers5 = {
    LABEL_SCALE: 0.75
  };
  var VALIDATION_ATTR_WHITELIST = [
    "pattern",
    "min",
    "max",
    "required",
    "step",
    "minlength",
    "maxlength"
  ];
  var ALWAYS_FLOAT_TYPES = [
    "color",
    "date",
    "datetime-local",
    "month",
    "range",
    "time",
    "week"
  ];
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var POINTERDOWN_EVENTS = ["mousedown", "touchstart"];
  var INTERACTION_EVENTS = ["click", "keydown"];
  var MDCTextFieldFoundation = function(_super) {
    __extends(MDCTextFieldFoundation2, _super);
    function MDCTextFieldFoundation2(adapter, foundationMap) {
      if (foundationMap === void 0) {
        foundationMap = {};
      }
      var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation2.defaultAdapter), adapter)) || this;
      _this.isFocused_ = false;
      _this.receivedUserInput_ = false;
      _this.isValid_ = true;
      _this.useNativeValidation_ = true;
      _this.validateOnValueChange_ = true;
      _this.helperText_ = foundationMap.helperText;
      _this.characterCounter_ = foundationMap.characterCounter;
      _this.leadingIcon_ = foundationMap.leadingIcon;
      _this.trailingIcon_ = foundationMap.trailingIcon;
      _this.inputFocusHandler_ = function() {
        return _this.activateFocus();
      };
      _this.inputBlurHandler_ = function() {
        return _this.deactivateFocus();
      };
      _this.inputInputHandler_ = function() {
        return _this.handleInput();
      };
      _this.setPointerXOffset_ = function(evt) {
        return _this.setTransformOrigin(evt);
      };
      _this.textFieldInteractionHandler_ = function() {
        return _this.handleTextFieldInteraction();
      };
      _this.validationAttributeChangeHandler_ = function(attributesList) {
        return _this.handleValidationAttributeChange(attributesList);
      };
      return _this;
    }
    Object.defineProperty(MDCTextFieldFoundation2, "cssClasses", {
      get: function() {
        return cssClasses5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "strings", {
      get: function() {
        return strings5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "numbers", {
      get: function() {
        return numbers5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldAlwaysFloat_", {
      get: function() {
        var type = this.getNativeInput_().type;
        return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldFloat", {
      get: function() {
        return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldShake", {
      get: function() {
        return !this.isFocused_ && !this.isValid() && !!this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return true;
          },
          setInputAttr: function() {
            return void 0;
          },
          removeInputAttr: function() {
            return void 0;
          },
          registerTextFieldInteractionHandler: function() {
            return void 0;
          },
          deregisterTextFieldInteractionHandler: function() {
            return void 0;
          },
          registerInputInteractionHandler: function() {
            return void 0;
          },
          deregisterInputInteractionHandler: function() {
            return void 0;
          },
          registerValidationAttributeChangeHandler: function() {
            return new MutationObserver(function() {
              return void 0;
            });
          },
          deregisterValidationAttributeChangeHandler: function() {
            return void 0;
          },
          getNativeInput: function() {
            return null;
          },
          isFocused: function() {
            return false;
          },
          activateLineRipple: function() {
            return void 0;
          },
          deactivateLineRipple: function() {
            return void 0;
          },
          setLineRippleTransformOrigin: function() {
            return void 0;
          },
          shakeLabel: function() {
            return void 0;
          },
          floatLabel: function() {
            return void 0;
          },
          setLabelRequired: function() {
            return void 0;
          },
          hasLabel: function() {
            return false;
          },
          getLabelWidth: function() {
            return 0;
          },
          hasOutline: function() {
            return false;
          },
          notchOutline: function() {
            return void 0;
          },
          closeOutline: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTextFieldFoundation2.prototype.init = function() {
      var _this = this;
      if (this.adapter.hasLabel() && this.getNativeInput_().required) {
        this.adapter.setLabelRequired(true);
      }
      if (this.adapter.isFocused()) {
        this.inputFocusHandler_();
      } else if (this.adapter.hasLabel() && this.shouldFloat) {
        this.notchOutline(true);
        this.adapter.floatLabel(true);
        this.styleFloating_(true);
      }
      this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler_);
      this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler_);
      this.adapter.registerInputInteractionHandler("input", this.inputInputHandler_);
      POINTERDOWN_EVENTS.forEach(function(evtType) {
        _this.adapter.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
      });
      INTERACTION_EVENTS.forEach(function(evtType) {
        _this.adapter.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
      });
      this.validationObserver_ = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation2.prototype.destroy = function() {
      var _this = this;
      this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler_);
      this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler_);
      this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler_);
      POINTERDOWN_EVENTS.forEach(function(evtType) {
        _this.adapter.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
      });
      INTERACTION_EVENTS.forEach(function(evtType) {
        _this.adapter.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
      });
      this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver_);
    };
    MDCTextFieldFoundation2.prototype.handleTextFieldInteraction = function() {
      var nativeInput = this.adapter.getNativeInput();
      if (nativeInput && nativeInput.disabled) {
        return;
      }
      this.receivedUserInput_ = true;
    };
    MDCTextFieldFoundation2.prototype.handleValidationAttributeChange = function(attributesList) {
      var _this = this;
      attributesList.some(function(attributeName) {
        if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
          _this.styleValidity_(true);
          _this.adapter.setLabelRequired(_this.getNativeInput_().required);
          return true;
        }
        return false;
      });
      if (attributesList.indexOf("maxlength") > -1) {
        this.setCharacterCounter_(this.getValue().length);
      }
    };
    MDCTextFieldFoundation2.prototype.notchOutline = function(openNotch) {
      if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
        return;
      }
      if (openNotch) {
        var labelWidth = this.adapter.getLabelWidth() * numbers5.LABEL_SCALE;
        this.adapter.notchOutline(labelWidth);
      } else {
        this.adapter.closeOutline();
      }
    };
    MDCTextFieldFoundation2.prototype.activateFocus = function() {
      this.isFocused_ = true;
      this.styleFocused_(this.isFocused_);
      this.adapter.activateLineRipple();
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        this.adapter.shakeLabel(this.shouldShake);
      }
      if (this.helperText_ && (this.helperText_.isPersistent() || !this.helperText_.isValidation() || !this.isValid_)) {
        this.helperText_.showToScreenReader();
      }
    };
    MDCTextFieldFoundation2.prototype.setTransformOrigin = function(evt) {
      if (this.isDisabled() || this.adapter.hasOutline()) {
        return;
      }
      var touches = evt.touches;
      var targetEvent = touches ? touches[0] : evt;
      var targetClientRect = targetEvent.target.getBoundingClientRect();
      var normalizedX = targetEvent.clientX - targetClientRect.left;
      this.adapter.setLineRippleTransformOrigin(normalizedX);
    };
    MDCTextFieldFoundation2.prototype.handleInput = function() {
      this.autoCompleteFocus();
      this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation2.prototype.autoCompleteFocus = function() {
      if (!this.receivedUserInput_) {
        this.activateFocus();
      }
    };
    MDCTextFieldFoundation2.prototype.deactivateFocus = function() {
      this.isFocused_ = false;
      this.adapter.deactivateLineRipple();
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      this.styleFocused_(this.isFocused_);
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        this.adapter.shakeLabel(this.shouldShake);
      }
      if (!this.shouldFloat) {
        this.receivedUserInput_ = false;
      }
    };
    MDCTextFieldFoundation2.prototype.getValue = function() {
      return this.getNativeInput_().value;
    };
    MDCTextFieldFoundation2.prototype.setValue = function(value) {
      if (this.getValue() !== value) {
        this.getNativeInput_().value = value;
      }
      this.setCharacterCounter_(value.length);
      if (this.validateOnValueChange_) {
        var isValid = this.isValid();
        this.styleValidity_(isValid);
      }
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        if (this.validateOnValueChange_) {
          this.adapter.shakeLabel(this.shouldShake);
        }
      }
    };
    MDCTextFieldFoundation2.prototype.isValid = function() {
      return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
    };
    MDCTextFieldFoundation2.prototype.setValid = function(isValid) {
      this.isValid_ = isValid;
      this.styleValidity_(isValid);
      var shouldShake = !isValid && !this.isFocused_ && !!this.getValue();
      if (this.adapter.hasLabel()) {
        this.adapter.shakeLabel(shouldShake);
      }
    };
    MDCTextFieldFoundation2.prototype.setValidateOnValueChange = function(shouldValidate) {
      this.validateOnValueChange_ = shouldValidate;
    };
    MDCTextFieldFoundation2.prototype.getValidateOnValueChange = function() {
      return this.validateOnValueChange_;
    };
    MDCTextFieldFoundation2.prototype.setUseNativeValidation = function(useNativeValidation) {
      this.useNativeValidation_ = useNativeValidation;
    };
    MDCTextFieldFoundation2.prototype.isDisabled = function() {
      return this.getNativeInput_().disabled;
    };
    MDCTextFieldFoundation2.prototype.setDisabled = function(disabled) {
      this.getNativeInput_().disabled = disabled;
      this.styleDisabled_(disabled);
    };
    MDCTextFieldFoundation2.prototype.setHelperTextContent = function(content) {
      if (this.helperText_) {
        this.helperText_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
      if (this.leadingIcon_) {
        this.leadingIcon_.setAriaLabel(label);
      }
    };
    MDCTextFieldFoundation2.prototype.setLeadingIconContent = function(content) {
      if (this.leadingIcon_) {
        this.leadingIcon_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setTrailingIconAriaLabel = function(label) {
      if (this.trailingIcon_) {
        this.trailingIcon_.setAriaLabel(label);
      }
    };
    MDCTextFieldFoundation2.prototype.setTrailingIconContent = function(content) {
      if (this.trailingIcon_) {
        this.trailingIcon_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setCharacterCounter_ = function(currentLength) {
      if (!this.characterCounter_) {
        return;
      }
      var maxLength = this.getNativeInput_().maxLength;
      if (maxLength === -1) {
        throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
      }
      this.characterCounter_.setCounterValue(currentLength, maxLength);
    };
    MDCTextFieldFoundation2.prototype.isBadInput_ = function() {
      return this.getNativeInput_().validity.badInput || false;
    };
    MDCTextFieldFoundation2.prototype.isNativeInputValid_ = function() {
      return this.getNativeInput_().validity.valid;
    };
    MDCTextFieldFoundation2.prototype.styleValidity_ = function(isValid) {
      var INVALID = MDCTextFieldFoundation2.cssClasses.INVALID;
      if (isValid) {
        this.adapter.removeClass(INVALID);
      } else {
        this.adapter.addClass(INVALID);
      }
      if (this.helperText_) {
        this.helperText_.setValidity(isValid);
        var helperTextValidation = this.helperText_.isValidation();
        if (!helperTextValidation) {
          return;
        }
        var helperTextVisible = this.helperText_.isVisible();
        var helperTextId = this.helperText_.getId();
        if (helperTextVisible && helperTextId) {
          this.adapter.setInputAttr(strings5.ARIA_DESCRIBEDBY, helperTextId);
        } else {
          this.adapter.removeInputAttr(strings5.ARIA_DESCRIBEDBY);
        }
      }
    };
    MDCTextFieldFoundation2.prototype.styleFocused_ = function(isFocused) {
      var FOCUSED = MDCTextFieldFoundation2.cssClasses.FOCUSED;
      if (isFocused) {
        this.adapter.addClass(FOCUSED);
      } else {
        this.adapter.removeClass(FOCUSED);
      }
    };
    MDCTextFieldFoundation2.prototype.styleDisabled_ = function(isDisabled) {
      var _a2 = MDCTextFieldFoundation2.cssClasses, DISABLED = _a2.DISABLED, INVALID = _a2.INVALID;
      if (isDisabled) {
        this.adapter.addClass(DISABLED);
        this.adapter.removeClass(INVALID);
      } else {
        this.adapter.removeClass(DISABLED);
      }
      if (this.leadingIcon_) {
        this.leadingIcon_.setDisabled(isDisabled);
      }
      if (this.trailingIcon_) {
        this.trailingIcon_.setDisabled(isDisabled);
      }
    };
    MDCTextFieldFoundation2.prototype.styleFloating_ = function(isFloating) {
      var LABEL_FLOATING = MDCTextFieldFoundation2.cssClasses.LABEL_FLOATING;
      if (isFloating) {
        this.adapter.addClass(LABEL_FLOATING);
      } else {
        this.adapter.removeClass(LABEL_FLOATING);
      }
    };
    MDCTextFieldFoundation2.prototype.getNativeInput_ = function() {
      var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
      return nativeInput || {
        disabled: false,
        maxLength: -1,
        required: false,
        type: "input",
        validity: {
          badInput: false,
          valid: true
        },
        value: ""
      };
    };
    return MDCTextFieldFoundation2;
  }(MDCFoundation);
  function create_fragment$33(ctx) {
    let current;
    const default_slot_template = ctx[4].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 8)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$33.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$25($$self, $$props, $$invalidate) {
    let $storeValue;
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ContextFragment", slots, ["default"]);
    let {key} = $$props;
    let {value} = $$props;
    const storeValue = writable(value);
    validate_store(storeValue, "storeValue");
    component_subscribe($$self, storeValue, (value2) => $$invalidate(5, $storeValue = value2));
    setContext(key, storeValue);
    onDestroy(() => {
      storeValue.set(void 0);
    });
    const writable_props = ["key", "value"];
    Object.keys($$props).forEach((key2) => {
      if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
        console.warn(`<ContextFragment> was created with unknown prop '${key2}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("key" in $$props2)
        $$invalidate(1, key = $$props2.key);
      if ("value" in $$props2)
        $$invalidate(2, value = $$props2.value);
      if ("$$scope" in $$props2)
        $$invalidate(3, $$scope = $$props2.$$scope);
    };
    $$self.$capture_state = () => ({
      onDestroy,
      setContext,
      writable,
      key,
      value,
      storeValue,
      $storeValue
    });
    $$self.$inject_state = ($$props2) => {
      if ("key" in $$props2)
        $$invalidate(1, key = $$props2.key);
      if ("value" in $$props2)
        $$invalidate(2, value = $$props2.value);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        set_store_value(storeValue, $storeValue = value, $storeValue);
      }
    };
    return [storeValue, key, value, $$scope, slots];
  }
  var ContextFragment = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$25, create_fragment$33, safe_not_equal, {key: 1, value: 2});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ContextFragment",
        options,
        id: create_fragment$33.name
      });
      const {ctx} = this.$$;
      const props = options.props || {};
      if (ctx[1] === void 0 && !("key" in props)) {
        console.warn("<ContextFragment> was created without expected prop 'key'");
      }
      if (ctx[2] === void 0 && !("value" in props)) {
        console.warn("<ContextFragment> was created without expected prop 'value'");
      }
    }
    get key() {
      throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set key(value) {
      throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var HelperLine = classAdderBuilder({
    class: "mdc-text-field-helper-line",
    component: Div
  });
  var Prefix = classAdderBuilder({
    class: "mdc-text-field__affix mdc-text-field__affix--prefix",
    component: Span
  });
  var Suffix = classAdderBuilder({
    class: "mdc-text-field__affix mdc-text-field__affix--suffix",
    component: Span
  });
  var file$25 = "node_modules/@smui/textfield/Input.svelte";
  function create_fragment$26(ctx) {
    let input;
    let input_class_value;
    let useActions_action;
    let mounted;
    let dispose;
    let input_levels = [
      {
        class: input_class_value = classMap({
          [ctx[1]]: true,
          "mdc-text-field__input": true
        })
      },
      {type: ctx[2]},
      {placeholder: ctx[3]},
      ctx[4],
      ctx[6],
      ctx[10]
    ];
    let input_data = {};
    for (let i = 0; i < input_levels.length; i += 1) {
      input_data = assign(input_data, input_levels[i]);
    }
    const block = {
      c: function create2() {
        input = element("input");
        set_attributes(input, input_data);
        add_location(input, file$25, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, input, anchor);
        if (input.autofocus)
          input.focus();
        ctx[21](input);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, input, ctx[0])),
            action_destroyer(ctx[7].call(null, input)),
            listen_dev(input, "change", ctx[22], false, false, false),
            listen_dev(input, "input", ctx[23], false, false, false),
            listen_dev(input, "change", ctx[9], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(input, input_data = get_spread_update(input_levels, [
          dirty & 2 && input_class_value !== (input_class_value = classMap({
            [ctx2[1]]: true,
            "mdc-text-field__input": true
          })) && {class: input_class_value},
          dirty & 4 && {type: ctx2[2]},
          dirty & 8 && {placeholder: ctx2[3]},
          dirty & 16 && ctx2[4],
          dirty & 64 && ctx2[6],
          dirty & 1024 && ctx2[10]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(input);
        ctx[21](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$26.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function toNumber(value) {
    if (value === "") {
      const nan = new Number(Number.NaN);
      nan.length = 0;
      return nan;
    }
    return +value;
  }
  function instance$15($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "type",
      "placeholder",
      "value",
      "files",
      "dirty",
      "invalid",
      "updateInvalid",
      "getAttr",
      "addAttr",
      "removeAttr",
      "focus",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Input", slots, []);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {type = "text"} = $$props;
    let {placeholder = " "} = $$props;
    let {value = ""} = $$props;
    let {files = void 0} = $$props;
    let {dirty = false} = $$props;
    let {invalid = false} = $$props;
    let {updateInvalid = true} = $$props;
    let element2;
    let internalAttrs = {};
    let valueProp = {};
    onMount(() => {
      if (updateInvalid) {
        $$invalidate(14, invalid = element2.matches(":invalid"));
      }
    });
    function valueUpdater(e) {
      switch (type) {
        case "number":
        case "range":
          $$invalidate(11, value = toNumber(e.target.value));
          break;
        case "file":
          $$invalidate(12, files = e.target.files);
        default:
          $$invalidate(11, value = e.target.value);
          break;
      }
    }
    function changeHandler(e) {
      $$invalidate(13, dirty = true);
      if (updateInvalid) {
        $$invalidate(14, invalid = element2.matches(":invalid"));
      }
    }
    function getAttr(name2) {
      return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
    }
    function addAttr(name2, value2) {
      if (internalAttrs[name2] !== value2) {
        $$invalidate(6, internalAttrs[name2] = value2, internalAttrs);
      }
    }
    function removeAttr(name2) {
      if (!(name2 in internalAttrs) || internalAttrs[name2] != null) {
        $$invalidate(6, internalAttrs[name2] = void 0, internalAttrs);
      }
    }
    function focus() {
      getElement().focus();
    }
    function getElement() {
      return element2;
    }
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    const change_handler = (e) => (type === "file" || type === "range") && valueUpdater(e);
    const input_handler = (e) => type !== "file" && valueUpdater(e);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("type" in $$new_props)
        $$invalidate(2, type = $$new_props.type);
      if ("placeholder" in $$new_props)
        $$invalidate(3, placeholder = $$new_props.placeholder);
      if ("value" in $$new_props)
        $$invalidate(11, value = $$new_props.value);
      if ("files" in $$new_props)
        $$invalidate(12, files = $$new_props.files);
      if ("dirty" in $$new_props)
        $$invalidate(13, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(14, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$new_props)
        $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    };
    $$self.$capture_state = () => ({
      onMount,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      forwardEvents,
      use: use2,
      className,
      type,
      placeholder,
      value,
      files,
      dirty,
      invalid,
      updateInvalid,
      element: element2,
      internalAttrs,
      valueProp,
      toNumber,
      valueUpdater,
      changeHandler,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("type" in $$props)
        $$invalidate(2, type = $$new_props.type);
      if ("placeholder" in $$props)
        $$invalidate(3, placeholder = $$new_props.placeholder);
      if ("value" in $$props)
        $$invalidate(11, value = $$new_props.value);
      if ("files" in $$props)
        $$invalidate(12, files = $$new_props.files);
      if ("dirty" in $$props)
        $$invalidate(13, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(14, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$props)
        $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("internalAttrs" in $$props)
        $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
      if ("valueProp" in $$props)
        $$invalidate(4, valueProp = $$new_props.valueProp);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2068) {
        if (type === "file") {
          delete valueProp.value;
          $$invalidate(4, valueProp), $$invalidate(2, type), $$invalidate(11, value);
        } else {
          $$invalidate(4, valueProp.value = value == null ? "" : value, valueProp);
        }
      }
    };
    return [
      use2,
      className,
      type,
      placeholder,
      valueProp,
      element2,
      internalAttrs,
      forwardEvents,
      valueUpdater,
      changeHandler,
      $$restProps,
      value,
      files,
      dirty,
      invalid,
      updateInvalid,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement,
      input_binding,
      change_handler,
      input_handler
    ];
  }
  var Input = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$15, create_fragment$26, safe_not_equal, {
        use: 0,
        class: 1,
        type: 2,
        placeholder: 3,
        value: 11,
        files: 12,
        dirty: 13,
        invalid: 14,
        updateInvalid: 15,
        getAttr: 16,
        addAttr: 17,
        removeAttr: 18,
        focus: 19,
        getElement: 20
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Input",
        options,
        id: create_fragment$26.name
      });
    }
    get use() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get type() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set type(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get placeholder() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set placeholder(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get files() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set files(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getAttr() {
      return this.$$.ctx[16];
    }
    set getAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get addAttr() {
      return this.$$.ctx[17];
    }
    set addAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get removeAttr() {
      return this.$$.ctx[18];
    }
    set removeAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[19];
    }
    set focus(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[20];
    }
    set getElement(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$16 = "node_modules/@smui/textfield/Textarea.svelte";
  function create_fragment$16(ctx) {
    let textarea;
    let textarea_class_value;
    let textarea_style_value;
    let useActions_action;
    let mounted;
    let dispose;
    let textarea_levels = [
      {
        class: textarea_class_value = classMap({
          [ctx[2]]: true,
          "mdc-text-field__input": true
        })
      },
      {
        style: textarea_style_value = `${ctx[4] ? "" : "resize: none; "}${ctx[3]}`
      },
      ctx[6],
      ctx[9]
    ];
    let textarea_data = {};
    for (let i = 0; i < textarea_levels.length; i += 1) {
      textarea_data = assign(textarea_data, textarea_levels[i]);
    }
    const block = {
      c: function create2() {
        textarea = element("textarea");
        set_attributes(textarea, textarea_data);
        add_location(textarea, file$16, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, textarea, anchor);
        if (textarea.autofocus)
          textarea.focus();
        ctx[18](textarea);
        set_input_value(textarea, ctx[0]);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, textarea, ctx[1])),
            action_destroyer(ctx[7].call(null, textarea)),
            listen_dev(textarea, "change", ctx[8], false, false, false),
            listen_dev(textarea, "input", ctx[19])
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
          dirty & 4 && textarea_class_value !== (textarea_class_value = classMap({
            [ctx2[2]]: true,
            "mdc-text-field__input": true
          })) && {class: textarea_class_value},
          dirty & 24 && textarea_style_value !== (textarea_style_value = `${ctx2[4] ? "" : "resize: none; "}${ctx2[3]}`) && {style: textarea_style_value},
          dirty & 64 && ctx2[6],
          dirty & 512 && ctx2[9]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 2)
          useActions_action.update.call(null, ctx2[1]);
        if (dirty & 1) {
          set_input_value(textarea, ctx2[0]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(textarea);
        ctx[18](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$16.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance5($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "value",
      "dirty",
      "invalid",
      "updateInvalid",
      "resizable",
      "getAttr",
      "addAttr",
      "removeAttr",
      "focus",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Textarea", slots, []);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {value = ""} = $$props;
    let {dirty = false} = $$props;
    let {invalid = false} = $$props;
    let {updateInvalid = true} = $$props;
    let {resizable = true} = $$props;
    let element2;
    let internalAttrs = {};
    onMount(() => {
      if (updateInvalid) {
        $$invalidate(11, invalid = element2.matches(":invalid"));
      }
    });
    function changeHandler() {
      $$invalidate(10, dirty = true);
      if (updateInvalid) {
        $$invalidate(11, invalid = element2.matches(":invalid"));
      }
    }
    function getAttr(name2) {
      return name2 in internalAttrs ? internalAttrs[name2] : getElement().getAttribute(name2);
    }
    function addAttr(name2, value2) {
      if (internalAttrs[name2] !== value2) {
        $$invalidate(6, internalAttrs[name2] = value2, internalAttrs);
      }
    }
    function removeAttr(name2) {
      if (!(name2 in internalAttrs) || internalAttrs[name2] != null) {
        $$invalidate(6, internalAttrs[name2] = void 0, internalAttrs);
      }
    }
    function focus() {
      getElement().focus();
    }
    function getElement() {
      return element2;
    }
    function textarea_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    function textarea_input_handler() {
      value = this.value;
      $$invalidate(0, value);
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("value" in $$new_props)
        $$invalidate(0, value = $$new_props.value);
      if ("dirty" in $$new_props)
        $$invalidate(10, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(11, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$new_props)
        $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
      if ("resizable" in $$new_props)
        $$invalidate(4, resizable = $$new_props.resizable);
    };
    $$self.$capture_state = () => ({
      onMount,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      forwardEvents,
      use: use2,
      className,
      style,
      value,
      dirty,
      invalid,
      updateInvalid,
      resizable,
      element: element2,
      internalAttrs,
      changeHandler,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("value" in $$props)
        $$invalidate(0, value = $$new_props.value);
      if ("dirty" in $$props)
        $$invalidate(10, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(11, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$props)
        $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
      if ("resizable" in $$props)
        $$invalidate(4, resizable = $$new_props.resizable);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("internalAttrs" in $$props)
        $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      value,
      use2,
      className,
      style,
      resizable,
      element2,
      internalAttrs,
      forwardEvents,
      changeHandler,
      $$restProps,
      dirty,
      invalid,
      updateInvalid,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement,
      textarea_binding,
      textarea_input_handler
    ];
  }
  var Textarea = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance5, create_fragment$16, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        value: 0,
        dirty: 10,
        invalid: 11,
        updateInvalid: 12,
        resizable: 4,
        getAttr: 13,
        addAttr: 14,
        removeAttr: 15,
        focus: 16,
        getElement: 17
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Textarea",
        options,
        id: create_fragment$16.name
      });
    }
    get use() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get resizable() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set resizable(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getAttr() {
      return this.$$.ctx[13];
    }
    set getAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get addAttr() {
      return this.$$.ctx[14];
    }
    set addAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get removeAttr() {
      return this.$$.ctx[15];
    }
    set removeAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[16];
    }
    set focus(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[17];
    }
    set getElement(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file7 = "node_modules/@smui/textfield/Textfield.svelte";
  var get_helper_slot_changes = (dirty) => ({});
  var get_helper_slot_context = (ctx) => ({});
  var get_ripple_slot_changes = (dirty) => ({});
  var get_ripple_slot_context = (ctx) => ({});
  var get_trailingIcon_slot_changes_1 = (dirty) => ({});
  var get_trailingIcon_slot_context_1 = (ctx) => ({});
  var get_leadingIcon_slot_changes_1 = (dirty) => ({});
  var get_leadingIcon_slot_context_1 = (ctx) => ({});
  var get_label_slot_changes_2 = (dirty) => ({});
  var get_label_slot_context_2 = (ctx) => ({});
  var get_trailingIcon_slot_changes = (dirty) => ({});
  var get_trailingIcon_slot_context = (ctx) => ({});
  var get_suffix_slot_changes = (dirty) => ({});
  var get_suffix_slot_context = (ctx) => ({});
  var get_prefix_slot_changes = (dirty) => ({});
  var get_prefix_slot_context = (ctx) => ({});
  var get_internalCounter_slot_changes = (dirty) => ({});
  var get_internalCounter_slot_context = (ctx) => ({});
  var get_leadingIcon_slot_changes = (dirty) => ({});
  var get_leadingIcon_slot_context = (ctx) => ({});
  var get_label_slot_changes_1 = (dirty) => ({});
  var get_label_slot_context_1 = (ctx) => ({});
  var get_label_slot_changes = (dirty) => ({});
  var get_label_slot_context = (ctx) => ({});
  function create_else_block_12(ctx) {
    let div;
    let t0;
    let contextfragment0;
    let t1;
    let t2;
    let contextfragment1;
    let t3;
    let div_class_value;
    let div_style_value;
    let Ripple_action;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context_2);
    contextfragment0 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: true,
        $$slots: {default: [create_default_slot_9]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const default_slot_template = ctx[50].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[89], null);
    contextfragment1 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: false,
        $$slots: {default: [create_default_slot_8]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const ripple_slot_template = ctx[50].ripple;
    const ripple_slot = create_slot(ripple_slot_template, ctx, ctx[89], get_ripple_slot_context);
    let div_levels = [
      {
        class: div_class_value = classMap({
          [ctx[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx[12],
          "mdc-text-field--textarea": ctx[14],
          "mdc-text-field--filled": ctx[15] === "filled",
          "mdc-text-field--outlined": ctx[15] === "outlined",
          "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
          "mdc-text-field--no-label": ctx[16] || !ctx[41].label,
          "mdc-text-field--with-leading-icon": ctx[41].leadingIcon,
          "mdc-text-field--with-trailing-icon": ctx[41].trailingIcon,
          "mdc-text-field--invalid": ctx[2] !== ctx[36] && ctx[2],
          ...ctx[26]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[27]).map(func_13).concat([ctx[10]]).join(" ")
      },
      exclude2(ctx[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (label_slot)
          label_slot.c();
        t0 = space();
        create_component(contextfragment0.$$.fragment);
        t1 = space();
        if (default_slot)
          default_slot.c();
        t2 = space();
        create_component(contextfragment1.$$.fragment);
        t3 = space();
        if (ripple_slot)
          ripple_slot.c();
        set_attributes(div, div_data);
        add_location(div, file7, 164, 2, 5265);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (label_slot) {
          label_slot.m(div, null);
        }
        append_dev(div, t0);
        mount_component(contextfragment0, div, null);
        append_dev(div, t1);
        if (default_slot) {
          default_slot.m(div, null);
        }
        append_dev(div, t2);
        mount_component(contextfragment1, div, null);
        append_dev(div, t3);
        if (ripple_slot) {
          ripple_slot.m(div, null);
        }
        ctx[79](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(Ripple_action = Ripple.call(null, div, {
              ripple: ctx[11],
              unbounded: false,
              addClass: ctx[38],
              removeClass: ctx[39],
              addStyle: ctx[40]
            })),
            action_destroyer(useActions_action = useActions.call(null, div, ctx[8])),
            action_destroyer(ctx[35].call(null, div)),
            listen_dev(div, "SMUI:textfield:leading-icon:mount", ctx[80], false, false, false),
            listen_dev(div, "SMUI:textfield:leading-icon:unmount", ctx[81], false, false, false),
            listen_dev(div, "SMUI:textfield:trailing-icon:mount", ctx[82], false, false, false),
            listen_dev(div, "SMUI:textfield:trailing-icon:unmount", ctx[83], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes_2), get_label_slot_context_2);
          }
        }
        const contextfragment0_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment0_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment0.$set(contextfragment0_changes);
        if (default_slot) {
          if (default_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(default_slot_template, ctx2[89], dirty, null), null);
          }
        }
        const contextfragment1_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment1_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment1.$set(contextfragment1_changes);
        if (ripple_slot) {
          if (ripple_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(ripple_slot, ripple_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(ripple_slot_template, ctx2[89], dirty, get_ripple_slot_changes), get_ripple_slot_context);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty[0] & 67228164 | dirty[1] & 1024 && div_class_value !== (div_class_value = classMap({
            [ctx2[9]]: true,
            "mdc-text-field": true,
            "mdc-text-field--disabled": ctx2[12],
            "mdc-text-field--textarea": ctx2[14],
            "mdc-text-field--filled": ctx2[15] === "filled",
            "mdc-text-field--outlined": ctx2[15] === "outlined",
            "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
            "mdc-text-field--no-label": ctx2[16] || !ctx2[41].label,
            "mdc-text-field--with-leading-icon": ctx2[41].leadingIcon,
            "mdc-text-field--with-trailing-icon": ctx2[41].trailingIcon,
            "mdc-text-field--invalid": ctx2[2] !== ctx2[36] && ctx2[2],
            ...ctx2[26]
          }))) && {class: div_class_value},
          (!current || dirty[0] & 134218752 && div_style_value !== (div_style_value = Object.entries(ctx2[27]).map(func_13).concat([ctx2[10]]).join(" "))) && {style: div_style_value},
          dirty[1] & 2048 && exclude2(ctx2[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
        ]));
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 2048)
          Ripple_action.update.call(null, {
            ripple: ctx2[11],
            unbounded: false,
            addClass: ctx2[38],
            removeClass: ctx2[39],
            addStyle: ctx2[40]
          });
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
          useActions_action.update.call(null, ctx2[8]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        transition_in(contextfragment0.$$.fragment, local);
        transition_in(default_slot, local);
        transition_in(contextfragment1.$$.fragment, local);
        transition_in(ripple_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        transition_out(contextfragment0.$$.fragment, local);
        transition_out(default_slot, local);
        transition_out(contextfragment1.$$.fragment, local);
        transition_out(ripple_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (label_slot)
          label_slot.d(detaching);
        destroy_component(contextfragment0);
        if (default_slot)
          default_slot.d(detaching);
        destroy_component(contextfragment1);
        if (ripple_slot)
          ripple_slot.d(detaching);
        ctx[79](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block_12.name,
      type: "else",
      source: "(164:0) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block_12(ctx) {
    let label_1;
    let t0;
    let t1;
    let contextfragment0;
    let t2;
    let t3;
    let current_block_type_index;
    let if_block2;
    let t4;
    let contextfragment1;
    let t5;
    let label_1_class_value;
    let label_1_style_value;
    let label_1_for_value;
    let Ripple_action;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    let if_block0 = !ctx[14] && ctx[15] !== "outlined" && create_if_block_8(ctx);
    let if_block1 = (ctx[14] || ctx[15] === "outlined") && create_if_block_6(ctx);
    contextfragment0 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: true,
        $$slots: {default: [create_default_slot_4]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const default_slot_template = ctx[50].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[89], null);
    const if_block_creators = [create_if_block_32, create_else_block3];
    const if_blocks = [];
    function select_block_type_1(ctx2, dirty) {
      if (ctx2[14])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type_1(ctx);
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    contextfragment1 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: false,
        $$slots: {default: [create_default_slot_1]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    let if_block3 = !ctx[14] && ctx[15] !== "outlined" && ctx[11] && create_if_block_22(ctx);
    let label_1_levels = [
      {
        class: label_1_class_value = classMap({
          [ctx[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx[12],
          "mdc-text-field--textarea": ctx[14],
          "mdc-text-field--filled": ctx[15] === "filled",
          "mdc-text-field--outlined": ctx[15] === "outlined",
          "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
          "mdc-text-field--no-label": ctx[16] || ctx[17] == null && !ctx[41].label,
          "mdc-text-field--label-floating": ctx[29] || ctx[0] != null && ctx[0] !== "",
          "mdc-text-field--with-leading-icon": ctx[22] === ctx[36] ? ctx[41].leadingIcon : ctx[22],
          "mdc-text-field--with-trailing-icon": ctx[23] === ctx[36] ? ctx[41].trailingIcon : ctx[23],
          "mdc-text-field--with-internal-counter": ctx[14] && ctx[41].internalCounter,
          "mdc-text-field--invalid": ctx[2] !== ctx[36] && ctx[2],
          ...ctx[26]
        })
      },
      {
        style: label_1_style_value = Object.entries(ctx[27]).map(func5).concat([ctx[10]]).join(" ")
      },
      {
        for: label_1_for_value = null
      },
      exclude2(ctx[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
    ];
    let label_1_data = {};
    for (let i = 0; i < label_1_levels.length; i += 1) {
      label_1_data = assign(label_1_data, label_1_levels[i]);
    }
    const block = {
      c: function create2() {
        label_1 = element("label");
        if (if_block0)
          if_block0.c();
        t0 = space();
        if (if_block1)
          if_block1.c();
        t1 = space();
        create_component(contextfragment0.$$.fragment);
        t2 = space();
        if (default_slot)
          default_slot.c();
        t3 = space();
        if_block2.c();
        t4 = space();
        create_component(contextfragment1.$$.fragment);
        t5 = space();
        if (if_block3)
          if_block3.c();
        set_attributes(label_1, label_1_data);
        add_location(label_1, file7, 1, 2, 15);
      },
      m: function mount(target, anchor) {
        insert_dev(target, label_1, anchor);
        if (if_block0)
          if_block0.m(label_1, null);
        append_dev(label_1, t0);
        if (if_block1)
          if_block1.m(label_1, null);
        append_dev(label_1, t1);
        mount_component(contextfragment0, label_1, null);
        append_dev(label_1, t2);
        if (default_slot) {
          default_slot.m(label_1, null);
        }
        append_dev(label_1, t3);
        if_blocks[current_block_type_index].m(label_1, null);
        append_dev(label_1, t4);
        mount_component(contextfragment1, label_1, null);
        append_dev(label_1, t5);
        if (if_block3)
          if_block3.m(label_1, null);
        ctx[72](label_1);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(Ripple_action = Ripple.call(null, label_1, {
              ripple: !ctx[14] && ctx[15] === "filled",
              unbounded: false,
              addClass: ctx[38],
              removeClass: ctx[39],
              addStyle: ctx[40],
              eventTarget: ctx[34],
              activeTarget: ctx[34],
              initPromise: ctx[37]
            })),
            action_destroyer(useActions_action = useActions.call(null, label_1, ctx[8])),
            action_destroyer(ctx[35].call(null, label_1)),
            listen_dev(label_1, "SMUI:textfield:leading-icon:mount", ctx[73], false, false, false),
            listen_dev(label_1, "SMUI:textfield:leading-icon:unmount", ctx[74], false, false, false),
            listen_dev(label_1, "SMUI:textfield:trailing-icon:mount", ctx[75], false, false, false),
            listen_dev(label_1, "SMUI:textfield:trailing-icon:unmount", ctx[76], false, false, false),
            listen_dev(label_1, "SMUI:textfield:character-counter:mount", ctx[77], false, false, false),
            listen_dev(label_1, "SMUI:textfield:character-counter:unmount", ctx[78], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (!ctx2[14] && ctx2[15] !== "outlined") {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty[0] & 49152) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_8(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(label_1, t0);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (ctx2[14] || ctx2[15] === "outlined") {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 49152) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_6(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(label_1, t1);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        const contextfragment0_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment0_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment0.$set(contextfragment0_changes);
        if (default_slot) {
          if (default_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(default_slot_template, ctx2[89], dirty, null), null);
          }
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_1(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(label_1, t4);
        }
        const contextfragment1_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment1_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment1.$set(contextfragment1_changes);
        if (!ctx2[14] && ctx2[15] !== "outlined" && ctx2[11]) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty[0] & 51200) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_22(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(label_1, null);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
          (!current || dirty[0] & 616813061 | dirty[1] & 1024 && label_1_class_value !== (label_1_class_value = classMap({
            [ctx2[9]]: true,
            "mdc-text-field": true,
            "mdc-text-field--disabled": ctx2[12],
            "mdc-text-field--textarea": ctx2[14],
            "mdc-text-field--filled": ctx2[15] === "filled",
            "mdc-text-field--outlined": ctx2[15] === "outlined",
            "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
            "mdc-text-field--no-label": ctx2[16] || ctx2[17] == null && !ctx2[41].label,
            "mdc-text-field--label-floating": ctx2[29] || ctx2[0] != null && ctx2[0] !== "",
            "mdc-text-field--with-leading-icon": ctx2[22] === ctx2[36] ? ctx2[41].leadingIcon : ctx2[22],
            "mdc-text-field--with-trailing-icon": ctx2[23] === ctx2[36] ? ctx2[41].trailingIcon : ctx2[23],
            "mdc-text-field--with-internal-counter": ctx2[14] && ctx2[41].internalCounter,
            "mdc-text-field--invalid": ctx2[2] !== ctx2[36] && ctx2[2],
            ...ctx2[26]
          }))) && {class: label_1_class_value},
          (!current || dirty[0] & 134218752 && label_1_style_value !== (label_1_style_value = Object.entries(ctx2[27]).map(func5).concat([ctx2[10]]).join(" "))) && {style: label_1_style_value},
          {for: label_1_for_value},
          dirty[1] & 2048 && exclude2(ctx2[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
        ]));
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 49152 | dirty[1] & 8)
          Ripple_action.update.call(null, {
            ripple: !ctx2[14] && ctx2[15] === "filled",
            unbounded: false,
            addClass: ctx2[38],
            removeClass: ctx2[39],
            addStyle: ctx2[40],
            eventTarget: ctx2[34],
            activeTarget: ctx2[34],
            initPromise: ctx2[37]
          });
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
          useActions_action.update.call(null, ctx2[8]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(contextfragment0.$$.fragment, local);
        transition_in(default_slot, local);
        transition_in(if_block2);
        transition_in(contextfragment1.$$.fragment, local);
        transition_in(if_block3);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(contextfragment0.$$.fragment, local);
        transition_out(default_slot, local);
        transition_out(if_block2);
        transition_out(contextfragment1.$$.fragment, local);
        transition_out(if_block3);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(label_1);
        if (if_block0)
          if_block0.d();
        if (if_block1)
          if_block1.d();
        destroy_component(contextfragment0);
        if (default_slot)
          default_slot.d(detaching);
        if_blocks[current_block_type_index].d();
        destroy_component(contextfragment1);
        if (if_block3)
          if_block3.d();
        ctx[72](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_12.name,
      type: "if",
      source: "(1:0) {#if valued}",
      ctx
    });
    return block;
  }
  function create_default_slot_9(ctx) {
    let current;
    const leadingIcon_slot_template = ctx[50].leadingIcon;
    const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[89], get_leadingIcon_slot_context_1);
    const block = {
      c: function create2() {
        if (leadingIcon_slot)
          leadingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (leadingIcon_slot) {
          leadingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (leadingIcon_slot) {
          if (leadingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(leadingIcon_slot_template, ctx2[89], dirty, get_leadingIcon_slot_changes_1), get_leadingIcon_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(leadingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(leadingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (leadingIcon_slot)
          leadingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_9.name,
      type: "slot",
      source: '(209:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
      ctx
    });
    return block;
  }
  function create_default_slot_8(ctx) {
    let current;
    const trailingIcon_slot_template = ctx[50].trailingIcon;
    const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[89], get_trailingIcon_slot_context_1);
    const block = {
      c: function create2() {
        if (trailingIcon_slot)
          trailingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (trailingIcon_slot) {
          trailingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (trailingIcon_slot) {
          if (trailingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(trailingIcon_slot_template, ctx2[89], dirty, get_trailingIcon_slot_changes_1), get_trailingIcon_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(trailingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(trailingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (trailingIcon_slot)
          trailingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_8.name,
      type: "slot",
      source: '(213:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
      ctx
    });
    return block;
  }
  function create_if_block_8(ctx) {
    let t;
    let if_block1_anchor;
    let current;
    let if_block0 = ctx[15] === "filled" && create_if_block_10(ctx);
    let if_block1 = !ctx[16] && (ctx[17] != null || ctx[41].label) && create_if_block_9(ctx);
    const block = {
      c: function create2() {
        if (if_block0)
          if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[15] === "filled") {
          if (if_block0)
            ;
          else {
            if_block0 = create_if_block_10(ctx2);
            if_block0.c();
            if_block0.m(t.parentNode, t);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (!ctx2[16] && (ctx2[17] != null || ctx2[41].label)) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 196608 | dirty[1] & 1024) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_9(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_8.name,
      type: "if",
      source: "(63:4) {#if !textarea && variant !== 'outlined'}",
      ctx
    });
    return block;
  }
  function create_if_block_10(ctx) {
    let span;
    const block = {
      c: function create2() {
        span = element("span");
        attr_dev(span, "class", "mdc-text-field__ripple");
        add_location(span, file7, 64, 8, 2304);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_10.name,
      type: "if",
      source: "(64:6) {#if variant === 'filled'}",
      ctx
    });
    return block;
  }
  function create_if_block_9(ctx) {
    let floatinglabel;
    let current;
    const floatinglabel_spread_levels = [
      {
        floatAbove: ctx[29] || ctx[0] != null && ctx[0] !== ""
      },
      {required: ctx[13]},
      {wrapped: true},
      prefixFilter2(ctx[42], "label$")
    ];
    let floatinglabel_props = {
      $$slots: {default: [create_default_slot_7]},
      $$scope: {ctx}
    };
    for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
      floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    }
    floatinglabel = new FloatingLabel({
      props: floatinglabel_props,
      $$inline: true
    });
    ctx[51](floatinglabel);
    const block = {
      c: function create2() {
        create_component(floatinglabel.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(floatinglabel, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const floatinglabel_changes = dirty[0] & 536879105 | dirty[1] & 2048 ? get_spread_update(floatinglabel_spread_levels, [
          dirty[0] & 536870913 && {
            floatAbove: ctx2[29] || ctx2[0] != null && ctx2[0] !== ""
          },
          dirty[0] & 8192 && {required: ctx2[13]},
          floatinglabel_spread_levels[2],
          dirty[1] & 2048 && get_spread_object(prefixFilter2(ctx2[42], "label$"))
        ]) : {};
        if (dirty[0] & 131072 | dirty[2] & 134217728) {
          floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
        }
        floatinglabel.$set(floatinglabel_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(floatinglabel.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(floatinglabel.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[51](null);
        destroy_component(floatinglabel, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_9.name,
      type: "if",
      source: "(67:6) {#if !noLabel && (label != null || $$slots.label)}",
      ctx
    });
    return block;
  }
  function create_default_slot_7(ctx) {
    let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
    let t;
    let current;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context);
    const block = {
      c: function create2() {
        t = text(t_value);
        if (label_slot)
          label_slot.c();
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        if (label_slot) {
          label_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
          set_data_dev(t, t_value);
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes), get_label_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (label_slot)
          label_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_7.name,
      type: "slot",
      source: "(68:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >",
      ctx
    });
    return block;
  }
  function create_if_block_6(ctx) {
    let notchedoutline;
    let current;
    const notchedoutline_spread_levels = [
      {
        noLabel: ctx[16] || ctx[17] == null && !ctx[41].label
      },
      prefixFilter2(ctx[42], "outline$")
    ];
    let notchedoutline_props = {
      $$slots: {default: [create_default_slot_5]},
      $$scope: {ctx}
    };
    for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
      notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
    }
    notchedoutline = new NotchedOutline({
      props: notchedoutline_props,
      $$inline: true
    });
    ctx[53](notchedoutline);
    const block = {
      c: function create2() {
        create_component(notchedoutline.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(notchedoutline, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const notchedoutline_changes = dirty[0] & 196608 | dirty[1] & 3072 ? get_spread_update(notchedoutline_spread_levels, [
          dirty[0] & 196608 | dirty[1] & 1024 && {
            noLabel: ctx2[16] || ctx2[17] == null && !ctx2[41].label
          },
          dirty[1] & 2048 && get_spread_object(prefixFilter2(ctx2[42], "outline$"))
        ]) : {};
        if (dirty[0] & 537075745 | dirty[1] & 3072 | dirty[2] & 134217728) {
          notchedoutline_changes.$$scope = {dirty, ctx: ctx2};
        }
        notchedoutline.$set(notchedoutline_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(notchedoutline.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(notchedoutline.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[53](null);
        destroy_component(notchedoutline, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_6.name,
      type: "if",
      source: "(78:4) {#if textarea || variant === 'outlined'}",
      ctx
    });
    return block;
  }
  function create_if_block_7(ctx) {
    let floatinglabel;
    let current;
    const floatinglabel_spread_levels = [
      {
        floatAbove: ctx[29] || ctx[0] != null && ctx[0] !== ""
      },
      {required: ctx[13]},
      {wrapped: true},
      prefixFilter2(ctx[42], "label$")
    ];
    let floatinglabel_props = {
      $$slots: {default: [create_default_slot_6]},
      $$scope: {ctx}
    };
    for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
      floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    }
    floatinglabel = new FloatingLabel({
      props: floatinglabel_props,
      $$inline: true
    });
    ctx[52](floatinglabel);
    const block = {
      c: function create2() {
        create_component(floatinglabel.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(floatinglabel, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const floatinglabel_changes = dirty[0] & 536879105 | dirty[1] & 2048 ? get_spread_update(floatinglabel_spread_levels, [
          dirty[0] & 536870913 && {
            floatAbove: ctx2[29] || ctx2[0] != null && ctx2[0] !== ""
          },
          dirty[0] & 8192 && {required: ctx2[13]},
          floatinglabel_spread_levels[2],
          dirty[1] & 2048 && get_spread_object(prefixFilter2(ctx2[42], "label$"))
        ]) : {};
        if (dirty[0] & 131072 | dirty[2] & 134217728) {
          floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
        }
        floatinglabel.$set(floatinglabel_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(floatinglabel.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(floatinglabel.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[52](null);
        destroy_component(floatinglabel, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_7.name,
      type: "if",
      source: "(84:8) {#if !noLabel && (label != null || $$slots.label)}",
      ctx
    });
    return block;
  }
  function create_default_slot_6(ctx) {
    let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
    let t;
    let current;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context_1);
    const block = {
      c: function create2() {
        t = text(t_value);
        if (label_slot)
          label_slot.c();
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        if (label_slot) {
          label_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
          set_data_dev(t, t_value);
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes_1), get_label_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (label_slot)
          label_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_6.name,
      type: "slot",
      source: "(85:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >",
      ctx
    });
    return block;
  }
  function create_default_slot_5(ctx) {
    let if_block_anchor;
    let current;
    let if_block = !ctx[16] && (ctx[17] != null || ctx[41].label) && create_if_block_7(ctx);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (!ctx2[16] && (ctx2[17] != null || ctx2[41].label)) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty[0] & 196608 | dirty[1] & 1024) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_7(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_5.name,
      type: "slot",
      source: "(79:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
      ctx
    });
    return block;
  }
  function create_default_slot_4(ctx) {
    let current;
    const leadingIcon_slot_template = ctx[50].leadingIcon;
    const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[89], get_leadingIcon_slot_context);
    const block = {
      c: function create2() {
        if (leadingIcon_slot)
          leadingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (leadingIcon_slot) {
          leadingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (leadingIcon_slot) {
          if (leadingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(leadingIcon_slot_template, ctx2[89], dirty, get_leadingIcon_slot_changes), get_leadingIcon_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(leadingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(leadingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (leadingIcon_slot)
          leadingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_4.name,
      type: "slot",
      source: '(96:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
      ctx
    });
    return block;
  }
  function create_else_block3(ctx) {
    let t0;
    let t1;
    let input_1;
    let updating_value;
    let updating_files;
    let updating_dirty;
    let updating_invalid;
    let t2;
    let t3;
    let current;
    const prefix_slot_template = ctx[50].prefix;
    const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[89], get_prefix_slot_context);
    let if_block0 = ctx[19] != null && create_if_block_52(ctx);
    const input_1_spread_levels = [
      {type: ctx[18]},
      {disabled: ctx[12]},
      {required: ctx[13]},
      {updateInvalid: ctx[21]},
      {"aria-controls": ctx[28]},
      {"aria-describedby": ctx[28]},
      ctx[16] && ctx[17] != null ? {placeholder: ctx[17]} : {},
      prefixFilter2(ctx[42], "input$")
    ];
    function input_1_value_binding(value) {
      ctx[63](value);
    }
    function input_1_files_binding(value) {
      ctx[64](value);
    }
    function input_1_dirty_binding(value) {
      ctx[65](value);
    }
    function input_1_invalid_binding(value) {
      ctx[66](value);
    }
    let input_1_props = {};
    for (let i = 0; i < input_1_spread_levels.length; i += 1) {
      input_1_props = assign(input_1_props, input_1_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      input_1_props.value = ctx[0];
    }
    if (ctx[1] !== void 0) {
      input_1_props.files = ctx[1];
    }
    if (ctx[4] !== void 0) {
      input_1_props.dirty = ctx[4];
    }
    if (ctx[2] !== void 0) {
      input_1_props.invalid = ctx[2];
    }
    input_1 = new Input({props: input_1_props, $$inline: true});
    ctx[62](input_1);
    binding_callbacks.push(() => bind3(input_1, "value", input_1_value_binding));
    binding_callbacks.push(() => bind3(input_1, "files", input_1_files_binding));
    binding_callbacks.push(() => bind3(input_1, "dirty", input_1_dirty_binding));
    binding_callbacks.push(() => bind3(input_1, "invalid", input_1_invalid_binding));
    input_1.$on("blur", ctx[67]);
    input_1.$on("focus", ctx[68]);
    input_1.$on("blur", ctx[69]);
    input_1.$on("focus", ctx[70]);
    let if_block1 = ctx[20] != null && create_if_block_42(ctx);
    const suffix_slot_template = ctx[50].suffix;
    const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[89], get_suffix_slot_context);
    const block = {
      c: function create2() {
        if (prefix_slot)
          prefix_slot.c();
        t0 = space();
        if (if_block0)
          if_block0.c();
        t1 = space();
        create_component(input_1.$$.fragment);
        t2 = space();
        if (if_block1)
          if_block1.c();
        t3 = space();
        if (suffix_slot)
          suffix_slot.c();
      },
      m: function mount(target, anchor) {
        if (prefix_slot) {
          prefix_slot.m(target, anchor);
        }
        insert_dev(target, t0, anchor);
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t1, anchor);
        mount_component(input_1, target, anchor);
        insert_dev(target, t2, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, t3, anchor);
        if (suffix_slot) {
          suffix_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (prefix_slot) {
          if (prefix_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(prefix_slot, prefix_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(prefix_slot_template, ctx2[89], dirty, get_prefix_slot_changes), get_prefix_slot_context);
          }
        }
        if (ctx2[19] != null) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty[0] & 524288) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_52(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t1.parentNode, t1);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        const input_1_changes = dirty[0] & 271003648 | dirty[1] & 2048 ? get_spread_update(input_1_spread_levels, [
          dirty[0] & 262144 && {type: ctx2[18]},
          dirty[0] & 4096 && {disabled: ctx2[12]},
          dirty[0] & 8192 && {required: ctx2[13]},
          dirty[0] & 2097152 && {updateInvalid: ctx2[21]},
          dirty[0] & 268435456 && {"aria-controls": ctx2[28]},
          dirty[0] & 268435456 && {"aria-describedby": ctx2[28]},
          dirty[0] & 196608 && get_spread_object(ctx2[16] && ctx2[17] != null ? {placeholder: ctx2[17]} : {}),
          dirty[1] & 2048 && get_spread_object(prefixFilter2(ctx2[42], "input$"))
        ]) : {};
        if (!updating_value && dirty[0] & 1) {
          updating_value = true;
          input_1_changes.value = ctx2[0];
          add_flush_callback(() => updating_value = false);
        }
        if (!updating_files && dirty[0] & 2) {
          updating_files = true;
          input_1_changes.files = ctx2[1];
          add_flush_callback(() => updating_files = false);
        }
        if (!updating_dirty && dirty[0] & 16) {
          updating_dirty = true;
          input_1_changes.dirty = ctx2[4];
          add_flush_callback(() => updating_dirty = false);
        }
        if (!updating_invalid && dirty[0] & 4) {
          updating_invalid = true;
          input_1_changes.invalid = ctx2[2];
          add_flush_callback(() => updating_invalid = false);
        }
        input_1.$set(input_1_changes);
        if (ctx2[20] != null) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 1048576) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_42(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(t3.parentNode, t3);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (suffix_slot) {
          if (suffix_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(suffix_slot, suffix_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(suffix_slot_template, ctx2[89], dirty, get_suffix_slot_changes), get_suffix_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(prefix_slot, local);
        transition_in(if_block0);
        transition_in(input_1.$$.fragment, local);
        transition_in(if_block1);
        transition_in(suffix_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(prefix_slot, local);
        transition_out(if_block0);
        transition_out(input_1.$$.fragment, local);
        transition_out(if_block1);
        transition_out(suffix_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (prefix_slot)
          prefix_slot.d(detaching);
        if (detaching)
          detach_dev(t0);
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t1);
        ctx[62](null);
        destroy_component(input_1, detaching);
        if (detaching)
          detach_dev(t2);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(t3);
        if (suffix_slot)
          suffix_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block3.name,
      type: "else",
      source: "(125:4) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block_32(ctx) {
    let span;
    let textarea_1;
    let updating_value;
    let updating_dirty;
    let updating_invalid;
    let t;
    let span_class_value;
    let current;
    const textarea_1_spread_levels = [
      {disabled: ctx[12]},
      {required: ctx[13]},
      {updateInvalid: ctx[21]},
      {"aria-controls": ctx[28]},
      {"aria-describedby": ctx[28]},
      prefixFilter2(ctx[42], "input$")
    ];
    function textarea_1_value_binding(value) {
      ctx[55](value);
    }
    function textarea_1_dirty_binding(value) {
      ctx[56](value);
    }
    function textarea_1_invalid_binding(value) {
      ctx[57](value);
    }
    let textarea_1_props = {};
    for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
      textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      textarea_1_props.value = ctx[0];
    }
    if (ctx[4] !== void 0) {
      textarea_1_props.dirty = ctx[4];
    }
    if (ctx[2] !== void 0) {
      textarea_1_props.invalid = ctx[2];
    }
    textarea_1 = new Textarea({props: textarea_1_props, $$inline: true});
    ctx[54](textarea_1);
    binding_callbacks.push(() => bind3(textarea_1, "value", textarea_1_value_binding));
    binding_callbacks.push(() => bind3(textarea_1, "dirty", textarea_1_dirty_binding));
    binding_callbacks.push(() => bind3(textarea_1, "invalid", textarea_1_invalid_binding));
    textarea_1.$on("blur", ctx[58]);
    textarea_1.$on("focus", ctx[59]);
    textarea_1.$on("blur", ctx[60]);
    textarea_1.$on("focus", ctx[61]);
    const internalCounter_slot_template = ctx[50].internalCounter;
    const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, ctx[89], get_internalCounter_slot_context);
    const block = {
      c: function create2() {
        span = element("span");
        create_component(textarea_1.$$.fragment);
        t = space();
        if (internalCounter_slot)
          internalCounter_slot.c();
        attr_dev(span, "class", span_class_value = classMap({
          "mdc-text-field__resizer": !("input$resizable" in ctx[42]) || ctx[42].input$resizable
        }));
        add_location(span, file7, 100, 6, 3548);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        mount_component(textarea_1, span, null);
        append_dev(span, t);
        if (internalCounter_slot) {
          internalCounter_slot.m(span, null);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const textarea_1_changes = dirty[0] & 270544896 | dirty[1] & 2048 ? get_spread_update(textarea_1_spread_levels, [
          dirty[0] & 4096 && {disabled: ctx2[12]},
          dirty[0] & 8192 && {required: ctx2[13]},
          dirty[0] & 2097152 && {updateInvalid: ctx2[21]},
          dirty[0] & 268435456 && {"aria-controls": ctx2[28]},
          dirty[0] & 268435456 && {"aria-describedby": ctx2[28]},
          dirty[1] & 2048 && get_spread_object(prefixFilter2(ctx2[42], "input$"))
        ]) : {};
        if (!updating_value && dirty[0] & 1) {
          updating_value = true;
          textarea_1_changes.value = ctx2[0];
          add_flush_callback(() => updating_value = false);
        }
        if (!updating_dirty && dirty[0] & 16) {
          updating_dirty = true;
          textarea_1_changes.dirty = ctx2[4];
          add_flush_callback(() => updating_dirty = false);
        }
        if (!updating_invalid && dirty[0] & 4) {
          updating_invalid = true;
          textarea_1_changes.invalid = ctx2[2];
          add_flush_callback(() => updating_invalid = false);
        }
        textarea_1.$set(textarea_1_changes);
        if (internalCounter_slot) {
          if (internalCounter_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(internalCounter_slot, internalCounter_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(internalCounter_slot_template, ctx2[89], dirty, get_internalCounter_slot_changes), get_internalCounter_slot_context);
          }
        }
        if (!current || dirty[1] & 2048 && span_class_value !== (span_class_value = classMap({
          "mdc-text-field__resizer": !("input$resizable" in ctx2[42]) || ctx2[42].input$resizable
        }))) {
          attr_dev(span, "class", span_class_value);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(textarea_1.$$.fragment, local);
        transition_in(internalCounter_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(textarea_1.$$.fragment, local);
        transition_out(internalCounter_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        ctx[54](null);
        destroy_component(textarea_1);
        if (internalCounter_slot)
          internalCounter_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_32.name,
      type: "if",
      source: "(100:4) {#if textarea}",
      ctx
    });
    return block;
  }
  function create_if_block_52(ctx) {
    let prefix_1;
    let current;
    prefix_1 = new Prefix({
      props: {
        $$slots: {default: [create_default_slot_3]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(prefix_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(prefix_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const prefix_1_changes = {};
        if (dirty[0] & 524288 | dirty[2] & 134217728) {
          prefix_1_changes.$$scope = {dirty, ctx: ctx2};
        }
        prefix_1.$set(prefix_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(prefix_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(prefix_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(prefix_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_52.name,
      type: "if",
      source: "(127:6) {#if prefix != null}",
      ctx
    });
    return block;
  }
  function create_default_slot_3(ctx) {
    let t;
    const block = {
      c: function create2() {
        t = text(ctx[19]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 524288)
          set_data_dev(t, ctx2[19]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_3.name,
      type: "slot",
      source: "(128:8) <Prefix>",
      ctx
    });
    return block;
  }
  function create_if_block_42(ctx) {
    let suffix_1;
    let current;
    suffix_1 = new Suffix({
      props: {
        $$slots: {default: [create_default_slot_2]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(suffix_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(suffix_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const suffix_1_changes = {};
        if (dirty[0] & 1048576 | dirty[2] & 134217728) {
          suffix_1_changes.$$scope = {dirty, ctx: ctx2};
        }
        suffix_1.$set(suffix_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(suffix_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(suffix_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(suffix_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_42.name,
      type: "if",
      source: "(149:6) {#if suffix != null}",
      ctx
    });
    return block;
  }
  function create_default_slot_2(ctx) {
    let t;
    const block = {
      c: function create2() {
        t = text(ctx[20]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 1048576)
          set_data_dev(t, ctx2[20]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_2.name,
      type: "slot",
      source: "(150:8) <Suffix>",
      ctx
    });
    return block;
  }
  function create_default_slot_1(ctx) {
    let current;
    const trailingIcon_slot_template = ctx[50].trailingIcon;
    const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[89], get_trailingIcon_slot_context);
    const block = {
      c: function create2() {
        if (trailingIcon_slot)
          trailingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (trailingIcon_slot) {
          trailingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (trailingIcon_slot) {
          if (trailingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(trailingIcon_slot_template, ctx2[89], dirty, get_trailingIcon_slot_changes), get_trailingIcon_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(trailingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(trailingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (trailingIcon_slot)
          trailingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_1.name,
      type: "slot",
      source: '(154:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
      ctx
    });
    return block;
  }
  function create_if_block_22(ctx) {
    let lineripple;
    let current;
    const lineripple_spread_levels = [prefixFilter2(ctx[42], "ripple$")];
    let lineripple_props = {};
    for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
      lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
    }
    lineripple = new LineRipple({props: lineripple_props, $$inline: true});
    ctx[71](lineripple);
    const block = {
      c: function create2() {
        create_component(lineripple.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(lineripple, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const lineripple_changes = dirty[1] & 2048 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter2(ctx2[42], "ripple$"))]) : {};
        lineripple.$set(lineripple_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(lineripple.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(lineripple.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[71](null);
        destroy_component(lineripple, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_22.name,
      type: "if",
      source: "(157:4) {#if !textarea && variant !== 'outlined' && ripple}",
      ctx
    });
    return block;
  }
  function create_if_block5(ctx) {
    let helperline;
    let current;
    const helperline_spread_levels = [prefixFilter2(ctx[42], "helperLine$")];
    let helperline_props = {
      $$slots: {default: [create_default_slot4]},
      $$scope: {ctx}
    };
    for (let i = 0; i < helperline_spread_levels.length; i += 1) {
      helperline_props = assign(helperline_props, helperline_spread_levels[i]);
    }
    helperline = new HelperLine({props: helperline_props, $$inline: true});
    helperline.$on("SMUI:textfield:helper-text:id", ctx[84]);
    helperline.$on("SMUI:textfield:helper-text:mount", ctx[85]);
    helperline.$on("SMUI:textfield:helper-text:unmount", ctx[86]);
    helperline.$on("SMUI:textfield:character-counter:mount", ctx[87]);
    helperline.$on("SMUI:textfield:character-counter:unmount", ctx[88]);
    const block = {
      c: function create2() {
        create_component(helperline.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(helperline, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const helperline_changes = dirty[1] & 2048 ? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter2(ctx2[42], "helperLine$"))]) : {};
        if (dirty[2] & 134217728) {
          helperline_changes.$$scope = {dirty, ctx: ctx2};
        }
        helperline.$set(helperline_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(helperline.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(helperline.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(helperline, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block5.name,
      type: "if",
      source: "(219:0) {#if $$slots.helper}",
      ctx
    });
    return block;
  }
  function create_default_slot4(ctx) {
    let current;
    const helper_slot_template = ctx[50].helper;
    const helper_slot = create_slot(helper_slot_template, ctx, ctx[89], get_helper_slot_context);
    const block = {
      c: function create2() {
        if (helper_slot)
          helper_slot.c();
      },
      m: function mount(target, anchor) {
        if (helper_slot) {
          helper_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (helper_slot) {
          if (helper_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(helper_slot, helper_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(helper_slot_template, ctx2[89], dirty, get_helper_slot_changes), get_helper_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(helper_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(helper_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (helper_slot)
          helper_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot4.name,
      type: "slot",
      source: "(220:2) <HelperLine     on:SMUI:textfield:helper-text:id={(event) => (helperId = event.detail)}     on:SMUI:textfield:helper-text:mount={(event) => (helperText = event.detail)}     on:SMUI:textfield:helper-text:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUI:textfield:character-counter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUI:textfield:character-counter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >",
      ctx
    });
    return block;
  }
  function create_fragment7(ctx) {
    let current_block_type_index;
    let if_block0;
    let t;
    let if_block1_anchor;
    let current;
    const if_block_creators = [create_if_block_12, create_else_block_12];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[24])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    let if_block1 = ctx[41].helper && create_if_block5(ctx);
    const block = {
      c: function create2() {
        if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
        if (ctx2[41].helper) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[1] & 1024) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block5(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if_blocks[current_block_type_index].d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment7.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func5 = ([name2, value]) => `${name2}: ${value};`;
  var func_13 = ([name2, value]) => `${name2}: ${value};`;
  function instance_14($$self, $$props, $$invalidate) {
    let valued;
    let inputElement;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "ripple",
      "disabled",
      "required",
      "textarea",
      "variant",
      "noLabel",
      "label",
      "type",
      "value",
      "files",
      "dirty",
      "invalid",
      "prefix",
      "suffix",
      "updateInvalid",
      "validateOnValueChange",
      "useNativeValidation",
      "withLeadingIcon",
      "withTrailingIcon",
      "input",
      "floatingLabel",
      "lineRipple",
      "notchedOutline",
      "focus",
      "layout",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Textfield", slots, [
      "label",
      "leadingIcon",
      "default",
      "internalCounter",
      "prefix",
      "suffix",
      "trailingIcon",
      "ripple",
      "helper"
    ]);
    const $$slots = compute_slots(slots);
    const {applyPassive: applyPassive3} = events;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let uninitializedValue = () => {
    };
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {ripple = true} = $$props;
    let {disabled = false} = $$props;
    let {required = false} = $$props;
    let {textarea = false} = $$props;
    let {variant = textarea ? "outlined" : "standard"} = $$props;
    let {noLabel = false} = $$props;
    let {label = null} = $$props;
    let {type = "text"} = $$props;
    let {value = uninitializedValue} = $$props;
    let {files = uninitializedValue} = $$props;
    let {dirty = false} = $$props;
    let {invalid = uninitializedValue} = $$props;
    let {prefix = null} = $$props;
    let {suffix = null} = $$props;
    let {updateInvalid = invalid === uninitializedValue} = $$props;
    let {validateOnValueChange = updateInvalid} = $$props;
    let {useNativeValidation = updateInvalid} = $$props;
    let {withLeadingIcon = uninitializedValue} = $$props;
    let {withTrailingIcon = uninitializedValue} = $$props;
    let {input = void 0} = $$props;
    let {floatingLabel = void 0} = $$props;
    let {lineRipple = void 0} = $$props;
    let {notchedOutline = void 0} = $$props;
    let element2;
    let instance7;
    let internalClasses = {};
    let internalStyles = {};
    let helperId;
    let focused = false;
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let initPromiseResolve;
    let initPromise = new Promise((resolve) => initPromiseResolve = resolve);
    let leadingIcon;
    let trailingIcon;
    let helperText;
    let characterCounter;
    let previousValue = value;
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    onMount(() => {
      $$invalidate(48, instance7 = new MDCTextFieldFoundation({
        addClass,
        removeClass,
        hasClass,
        registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
        registerValidationAttributeChangeHandler: (handler) => {
          const getAttributesList = (mutationsList) => {
            return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
          };
          const observer = new MutationObserver((mutationsList) => {
            if (useNativeValidation) {
              handler(getAttributesList(mutationsList));
            }
          });
          const config = {attributes: true};
          observer.observe(input.getElement(), config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: (observer) => {
          observer.disconnect();
        },
        getNativeInput: () => input.getElement(),
        setInputAttr: (name2, value2) => {
          input.addAttr(name2, value2);
        },
        removeInputAttr: (name2) => {
          input.removeAttr(name2);
        },
        isFocused: () => document.activeElement === input.getElement(),
        registerInputInteractionHandler: (evtType, handler) => {
          input.getElement().addEventListener(evtType, handler, applyPassive3());
        },
        deregisterInputInteractionHandler: (evtType, handler) => {
          input.getElement().removeEventListener(evtType, handler, applyPassive3());
        },
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        hasLabel: () => !!floatingLabel,
        shakeLabel: (shouldShake) => floatingLabel && floatingLabel.shake(shouldShake),
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired),
        activateLineRipple: () => lineRipple && lineRipple.activate(),
        deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
        setLineRippleTransformOrigin: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth)
      }, {
        get helperText() {
          return helperText;
        },
        get characterCounter() {
          return characterCounter;
        },
        get leadingIcon() {
          return leadingIcon;
        },
        get trailingIcon() {
          return trailingIcon;
        }
      }));
      if (valued) {
        instance7.init();
      } else {
        tick().then(() => {
          instance7.init();
        });
      }
      initPromiseResolve();
      return () => {
        instance7.destroy();
      };
    });
    onDestroy(() => {
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(26, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(26, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name2, value2) {
      if (internalStyles[name2] != value2) {
        if (value2 === "" || value2 == null) {
          delete internalStyles[name2];
          $$invalidate(27, internalStyles);
        } else {
          $$invalidate(27, internalStyles[name2] = value2, internalStyles);
        }
      }
    }
    function focus() {
      input.focus();
    }
    function layout() {
      if (instance7) {
        const openNotch = instance7.shouldFloat;
        instance7.notchOutline(openNotch);
      }
    }
    function getElement() {
      return element2;
    }
    function floatinglabel_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        floatingLabel = $$value;
        $$invalidate(5, floatingLabel);
      });
    }
    function floatinglabel_binding_1($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        floatingLabel = $$value;
        $$invalidate(5, floatingLabel);
      });
    }
    function notchedoutline_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        notchedOutline = $$value;
        $$invalidate(7, notchedOutline);
      });
    }
    function textarea_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(3, input);
      });
    }
    function textarea_1_value_binding(value$1) {
      value = value$1;
      $$invalidate(0, value);
    }
    function textarea_1_dirty_binding(value2) {
      dirty = value2;
      $$invalidate(4, dirty);
    }
    function textarea_1_invalid_binding(value2) {
      invalid = value2;
      $$invalidate(2, invalid), $$invalidate(48, instance7), $$invalidate(21, updateInvalid);
    }
    const blur_handler_2 = () => $$invalidate(29, focused = false);
    const focus_handler_2 = () => $$invalidate(29, focused = true);
    function blur_handler(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler(event) {
      bubble.call(this, $$self, event);
    }
    function input_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(3, input);
      });
    }
    function input_1_value_binding(value$1) {
      value = value$1;
      $$invalidate(0, value);
    }
    function input_1_files_binding(value2) {
      files = value2;
      $$invalidate(1, files);
    }
    function input_1_dirty_binding(value2) {
      dirty = value2;
      $$invalidate(4, dirty);
    }
    function input_1_invalid_binding(value2) {
      invalid = value2;
      $$invalidate(2, invalid), $$invalidate(48, instance7), $$invalidate(21, updateInvalid);
    }
    const blur_handler_3 = () => $$invalidate(29, focused = false);
    const focus_handler_3 = () => $$invalidate(29, focused = true);
    function blur_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function lineripple_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        lineRipple = $$value;
        $$invalidate(6, lineRipple);
      });
    }
    function label_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(25, element2);
      });
    }
    const SMUI_textfield_leading_icon_mount_handler = (event) => $$invalidate(30, leadingIcon = event.detail);
    const SMUI_textfield_leading_icon_unmount_handler = () => $$invalidate(30, leadingIcon = void 0);
    const SMUI_textfield_trailing_icon_mount_handler = (event) => $$invalidate(31, trailingIcon = event.detail);
    const SMUI_textfield_trailing_icon_unmount_handler = () => $$invalidate(31, trailingIcon = void 0);
    const SMUI_textfield_character_counter_mount_handler = (event) => $$invalidate(33, characterCounter = event.detail);
    const SMUI_textfield_character_counter_unmount_handler = () => $$invalidate(33, characterCounter = void 0);
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(25, element2);
      });
    }
    const SMUI_textfield_leading_icon_mount_handler_1 = (event) => $$invalidate(30, leadingIcon = event.detail);
    const SMUI_textfield_leading_icon_unmount_handler_1 = () => $$invalidate(30, leadingIcon = void 0);
    const SMUI_textfield_trailing_icon_mount_handler_1 = (event) => $$invalidate(31, trailingIcon = event.detail);
    const SMUI_textfield_trailing_icon_unmount_handler_1 = () => $$invalidate(31, trailingIcon = void 0);
    const SMUI_textfield_helper_text_id_handler = (event) => $$invalidate(28, helperId = event.detail);
    const SMUI_textfield_helper_text_mount_handler = (event) => $$invalidate(32, helperText = event.detail);
    const SMUI_textfield_helper_text_unmount_handler = () => {
      $$invalidate(28, helperId = void 0);
      $$invalidate(32, helperText = void 0);
    };
    const SMUI_textfield_character_counter_mount_handler_1 = (event) => $$invalidate(33, characterCounter = event.detail);
    const SMUI_textfield_character_counter_unmount_handler_1 = () => $$invalidate(33, characterCounter = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(42, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(8, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(9, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(10, style = $$new_props.style);
      if ("ripple" in $$new_props)
        $$invalidate(11, ripple = $$new_props.ripple);
      if ("disabled" in $$new_props)
        $$invalidate(12, disabled = $$new_props.disabled);
      if ("required" in $$new_props)
        $$invalidate(13, required = $$new_props.required);
      if ("textarea" in $$new_props)
        $$invalidate(14, textarea = $$new_props.textarea);
      if ("variant" in $$new_props)
        $$invalidate(15, variant = $$new_props.variant);
      if ("noLabel" in $$new_props)
        $$invalidate(16, noLabel = $$new_props.noLabel);
      if ("label" in $$new_props)
        $$invalidate(17, label = $$new_props.label);
      if ("type" in $$new_props)
        $$invalidate(18, type = $$new_props.type);
      if ("value" in $$new_props)
        $$invalidate(0, value = $$new_props.value);
      if ("files" in $$new_props)
        $$invalidate(1, files = $$new_props.files);
      if ("dirty" in $$new_props)
        $$invalidate(4, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(2, invalid = $$new_props.invalid);
      if ("prefix" in $$new_props)
        $$invalidate(19, prefix = $$new_props.prefix);
      if ("suffix" in $$new_props)
        $$invalidate(20, suffix = $$new_props.suffix);
      if ("updateInvalid" in $$new_props)
        $$invalidate(21, updateInvalid = $$new_props.updateInvalid);
      if ("validateOnValueChange" in $$new_props)
        $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
      if ("useNativeValidation" in $$new_props)
        $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
      if ("withLeadingIcon" in $$new_props)
        $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
      if ("withTrailingIcon" in $$new_props)
        $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
      if ("input" in $$new_props)
        $$invalidate(3, input = $$new_props.input);
      if ("floatingLabel" in $$new_props)
        $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
      if ("lineRipple" in $$new_props)
        $$invalidate(6, lineRipple = $$new_props.lineRipple);
      if ("notchedOutline" in $$new_props)
        $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
      if ("$$scope" in $$new_props)
        $$invalidate(89, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCTextFieldFoundation,
      events,
      onMount,
      onDestroy,
      getContext,
      tick,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      exclude: exclude2,
      prefixFilter: prefixFilter2,
      useActions,
      ContextFragment,
      Ripple,
      FloatingLabel,
      LineRipple,
      NotchedOutline,
      HelperLine,
      Prefix,
      Suffix,
      Input,
      Textarea,
      applyPassive: applyPassive3,
      forwardEvents,
      uninitializedValue,
      use: use2,
      className,
      style,
      ripple,
      disabled,
      required,
      textarea,
      variant,
      noLabel,
      label,
      type,
      value,
      files,
      dirty,
      invalid,
      prefix,
      suffix,
      updateInvalid,
      validateOnValueChange,
      useNativeValidation,
      withLeadingIcon,
      withTrailingIcon,
      input,
      floatingLabel,
      lineRipple,
      notchedOutline,
      element: element2,
      instance: instance7,
      internalClasses,
      internalStyles,
      helperId,
      focused,
      addLayoutListener,
      removeLayoutListener,
      initPromiseResolve,
      initPromise,
      leadingIcon,
      trailingIcon,
      helperText,
      characterCounter,
      previousValue,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      focus,
      layout,
      getElement,
      valued,
      inputElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("uninitializedValue" in $$props)
        $$invalidate(36, uninitializedValue = $$new_props.uninitializedValue);
      if ("use" in $$props)
        $$invalidate(8, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(9, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(10, style = $$new_props.style);
      if ("ripple" in $$props)
        $$invalidate(11, ripple = $$new_props.ripple);
      if ("disabled" in $$props)
        $$invalidate(12, disabled = $$new_props.disabled);
      if ("required" in $$props)
        $$invalidate(13, required = $$new_props.required);
      if ("textarea" in $$props)
        $$invalidate(14, textarea = $$new_props.textarea);
      if ("variant" in $$props)
        $$invalidate(15, variant = $$new_props.variant);
      if ("noLabel" in $$props)
        $$invalidate(16, noLabel = $$new_props.noLabel);
      if ("label" in $$props)
        $$invalidate(17, label = $$new_props.label);
      if ("type" in $$props)
        $$invalidate(18, type = $$new_props.type);
      if ("value" in $$props)
        $$invalidate(0, value = $$new_props.value);
      if ("files" in $$props)
        $$invalidate(1, files = $$new_props.files);
      if ("dirty" in $$props)
        $$invalidate(4, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(2, invalid = $$new_props.invalid);
      if ("prefix" in $$props)
        $$invalidate(19, prefix = $$new_props.prefix);
      if ("suffix" in $$props)
        $$invalidate(20, suffix = $$new_props.suffix);
      if ("updateInvalid" in $$props)
        $$invalidate(21, updateInvalid = $$new_props.updateInvalid);
      if ("validateOnValueChange" in $$props)
        $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
      if ("useNativeValidation" in $$props)
        $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
      if ("withLeadingIcon" in $$props)
        $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
      if ("withTrailingIcon" in $$props)
        $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
      if ("input" in $$props)
        $$invalidate(3, input = $$new_props.input);
      if ("floatingLabel" in $$props)
        $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
      if ("lineRipple" in $$props)
        $$invalidate(6, lineRipple = $$new_props.lineRipple);
      if ("notchedOutline" in $$props)
        $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
      if ("element" in $$props)
        $$invalidate(25, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(48, instance7 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(26, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(27, internalStyles = $$new_props.internalStyles);
      if ("helperId" in $$props)
        $$invalidate(28, helperId = $$new_props.helperId);
      if ("focused" in $$props)
        $$invalidate(29, focused = $$new_props.focused);
      if ("addLayoutListener" in $$props)
        addLayoutListener = $$new_props.addLayoutListener;
      if ("removeLayoutListener" in $$props)
        removeLayoutListener = $$new_props.removeLayoutListener;
      if ("initPromiseResolve" in $$props)
        initPromiseResolve = $$new_props.initPromiseResolve;
      if ("initPromise" in $$props)
        $$invalidate(37, initPromise = $$new_props.initPromise);
      if ("leadingIcon" in $$props)
        $$invalidate(30, leadingIcon = $$new_props.leadingIcon);
      if ("trailingIcon" in $$props)
        $$invalidate(31, trailingIcon = $$new_props.trailingIcon);
      if ("helperText" in $$props)
        $$invalidate(32, helperText = $$new_props.helperText);
      if ("characterCounter" in $$props)
        $$invalidate(33, characterCounter = $$new_props.characterCounter);
      if ("previousValue" in $$props)
        $$invalidate(49, previousValue = $$new_props.previousValue);
      if ("valued" in $$props)
        $$invalidate(24, valued = $$new_props.valued);
      if ("inputElement" in $$props)
        $$invalidate(34, inputElement = $$new_props.inputElement);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 3) {
        $$invalidate(24, valued = value !== uninitializedValue || files !== uninitializedValue);
      }
      if ($$self.$$.dirty[0] & 8) {
        $$invalidate(34, inputElement = input && input.getElement());
      }
      if ($$self.$$.dirty[0] & 2097156 | $$self.$$.dirty[1] & 131072) {
        if (instance7 && instance7.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(2, invalid = !instance7.isValid());
          } else {
            instance7.setValid(!invalid);
          }
        }
      }
      if ($$self.$$.dirty[1] & 135168) {
        if (instance7 && instance7.getValidateOnValueChange() !== validateOnValueChange) {
          instance7.setValidateOnValueChange(validateOnValueChange === uninitializedValue ? false : validateOnValueChange);
        }
      }
      if ($$self.$$.dirty[1] & 139264) {
        if (instance7) {
          instance7.setUseNativeValidation(useNativeValidation);
        }
      }
      if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 131072) {
        if (instance7) {
          instance7.setDisabled(disabled);
        }
      }
      if ($$self.$$.dirty[0] & 16777217 | $$self.$$.dirty[1] & 393216) {
        if (instance7 && valued && previousValue !== value) {
          $$invalidate(49, previousValue = value);
          if (instance7.getValue() !== value) {
            instance7.setValue(value);
          }
        }
      }
    };
    return [
      value,
      files,
      invalid,
      input,
      dirty,
      floatingLabel,
      lineRipple,
      notchedOutline,
      use2,
      className,
      style,
      ripple,
      disabled,
      required,
      textarea,
      variant,
      noLabel,
      label,
      type,
      prefix,
      suffix,
      updateInvalid,
      withLeadingIcon,
      withTrailingIcon,
      valued,
      element2,
      internalClasses,
      internalStyles,
      helperId,
      focused,
      leadingIcon,
      trailingIcon,
      helperText,
      characterCounter,
      inputElement,
      forwardEvents,
      uninitializedValue,
      initPromise,
      addClass,
      removeClass,
      addStyle,
      $$slots,
      $$restProps,
      validateOnValueChange,
      useNativeValidation,
      focus,
      layout,
      getElement,
      instance7,
      previousValue,
      slots,
      floatinglabel_binding,
      floatinglabel_binding_1,
      notchedoutline_binding,
      textarea_1_binding,
      textarea_1_value_binding,
      textarea_1_dirty_binding,
      textarea_1_invalid_binding,
      blur_handler_2,
      focus_handler_2,
      blur_handler,
      focus_handler,
      input_1_binding,
      input_1_value_binding,
      input_1_files_binding,
      input_1_dirty_binding,
      input_1_invalid_binding,
      blur_handler_3,
      focus_handler_3,
      blur_handler_1,
      focus_handler_1,
      lineripple_binding,
      label_1_binding,
      SMUI_textfield_leading_icon_mount_handler,
      SMUI_textfield_leading_icon_unmount_handler,
      SMUI_textfield_trailing_icon_mount_handler,
      SMUI_textfield_trailing_icon_unmount_handler,
      SMUI_textfield_character_counter_mount_handler,
      SMUI_textfield_character_counter_unmount_handler,
      div_binding,
      SMUI_textfield_leading_icon_mount_handler_1,
      SMUI_textfield_leading_icon_unmount_handler_1,
      SMUI_textfield_trailing_icon_mount_handler_1,
      SMUI_textfield_trailing_icon_unmount_handler_1,
      SMUI_textfield_helper_text_id_handler,
      SMUI_textfield_helper_text_mount_handler,
      SMUI_textfield_helper_text_unmount_handler,
      SMUI_textfield_character_counter_mount_handler_1,
      SMUI_textfield_character_counter_unmount_handler_1,
      $$scope
    ];
  }
  var Textfield = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_14, create_fragment7, safe_not_equal, {
        use: 8,
        class: 9,
        style: 10,
        ripple: 11,
        disabled: 12,
        required: 13,
        textarea: 14,
        variant: 15,
        noLabel: 16,
        label: 17,
        type: 18,
        value: 0,
        files: 1,
        dirty: 4,
        invalid: 2,
        prefix: 19,
        suffix: 20,
        updateInvalid: 21,
        validateOnValueChange: 43,
        useNativeValidation: 44,
        withLeadingIcon: 22,
        withTrailingIcon: 23,
        input: 3,
        floatingLabel: 5,
        lineRipple: 6,
        notchedOutline: 7,
        focus: 45,
        layout: 46,
        getElement: 47
      }, null, [-1, -1, -1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Textfield",
        options,
        id: create_fragment7.name
      });
    }
    get use() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get disabled() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set disabled(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get required() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set required(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get textarea() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set textarea(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get variant() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set variant(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noLabel() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noLabel(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get label() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set label(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get type() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set type(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get files() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set files(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get prefix() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set prefix(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get suffix() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set suffix(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get validateOnValueChange() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set validateOnValueChange(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get useNativeValidation() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set useNativeValidation(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get withLeadingIcon() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set withLeadingIcon(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get withTrailingIcon() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set withTrailingIcon(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get input() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set input(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get floatingLabel() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set floatingLabel(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get lineRipple() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set lineRipple(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notchedOutline() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set notchedOutline(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[45];
    }
    set focus(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get layout() {
      return this.$$.ctx[46];
    }
    set layout(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[47];
    }
    set getElement(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/_commonjsHelpers.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

  // dist/build/FormField.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses6 = {
    ROOT: "mdc-form-field"
  };
  var strings6 = {
    LABEL_SELECTOR: ".mdc-form-field > label"
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFormFieldFoundation = function(_super) {
    __extends(MDCFormFieldFoundation2, _super);
    function MDCFormFieldFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFormFieldFoundation2.defaultAdapter), adapter)) || this;
      _this.click = function() {
        _this.handleClick();
      };
      return _this;
    }
    Object.defineProperty(MDCFormFieldFoundation2, "cssClasses", {
      get: function() {
        return cssClasses6;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "strings", {
      get: function() {
        return strings6;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "defaultAdapter", {
      get: function() {
        return {
          activateInputRipple: function() {
            return void 0;
          },
          deactivateInputRipple: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFormFieldFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.handleClick = function() {
      var _this = this;
      this.adapter.activateInputRipple();
      requestAnimationFrame(function() {
        _this.adapter.deactivateInputRipple();
      });
    };
    return MDCFormFieldFoundation2;
  }(MDCFoundation);
  var file8 = "node_modules/@smui/form-field/FormField.svelte";
  var get_label_slot_changes2 = (dirty) => ({});
  var get_label_slot_context2 = (ctx) => ({});
  function create_fragment8(ctx) {
    let div;
    let t;
    let label_1;
    let useActions_action;
    let div_class_value;
    let useActions_action_1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[13].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const label_slot_template = ctx[13].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context2);
    let label_1_levels = [{for: ctx[4]}, prefixFilter2(ctx[10], "label$")];
    let label_1_data = {};
    for (let i = 0; i < label_1_levels.length; i += 1) {
      label_1_data = assign(label_1_data, label_1_levels[i]);
    }
    let div_levels = [
      {
        class: div_class_value = classMap({
          [ctx[1]]: true,
          "mdc-form-field": true,
          "mdc-form-field--align-end": ctx[2] === "end",
          "mdc-form-field--nowrap": ctx[3]
        })
      },
      exclude2(ctx[10], ["label$"])
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        t = space();
        label_1 = element("label");
        if (label_slot)
          label_slot.c();
        set_attributes(label_1, label_1_data);
        add_location(label_1, file8, 15, 2, 416);
        set_attributes(div, div_data);
        add_location(div, file8, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        append_dev(div, t);
        append_dev(div, label_1);
        if (label_slot) {
          label_slot.m(label_1, null);
        }
        ctx[14](label_1);
        ctx[15](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, label_1, ctx[5])),
            action_destroyer(useActions_action_1 = useActions.call(null, div, ctx[0])),
            action_destroyer(ctx[9].call(null, div)),
            listen_dev(div, "SMUI:generic:input:mount", ctx[16], false, false, false),
            listen_dev(div, "SMUI:generic:input:unmount", ctx[17], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
        if (label_slot) {
          if (label_slot.p && (!current || dirty & 4096)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes2), get_label_slot_context2);
          }
        }
        set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
          (!current || dirty & 16) && {for: ctx2[4]},
          dirty & 1024 && prefixFilter2(ctx2[10], "label$")
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 32)
          useActions_action.update.call(null, ctx2[5]);
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty & 14 && div_class_value !== (div_class_value = classMap({
            [ctx2[1]]: true,
            "mdc-form-field": true,
            "mdc-form-field--align-end": ctx2[2] === "end",
            "mdc-form-field--nowrap": ctx2[3]
          }))) && {class: div_class_value},
          dirty & 1024 && exclude2(ctx2[10], ["label$"])
        ]));
        if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & 1)
          useActions_action_1.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        if (label_slot)
          label_slot.d(detaching);
        ctx[14](null);
        ctx[15](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment8.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var counter2 = 0;
  function instance_15($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "align", "noWrap", "inputId", "label$use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("FormField", slots, ["default", "label"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {align = "start"} = $$props;
    let {noWrap = false} = $$props;
    let {inputId = "SMUI-form-field-" + counter2++} = $$props;
    let {label$use = []} = $$props;
    let element2;
    let instance7;
    let label;
    let input;
    setContext("SMUI:generic:input:props", {id: inputId});
    onMount(() => {
      instance7 = new MDCFormFieldFoundation({
        activateInputRipple: () => {
          if (input) {
            input.activateRipple();
          }
        },
        deactivateInputRipple: () => {
          if (input) {
            input.deactivateRipple();
          }
        },
        deregisterInteractionHandler: (evtType, handler) => {
          label.removeEventListener(evtType, handler);
        },
        registerInteractionHandler: (evtType, handler) => {
          label.addEventListener(evtType, handler);
        }
      });
      instance7.init();
      return () => {
        instance7.destroy();
      };
    });
    function getElement() {
      return element2;
    }
    function label_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        label = $$value;
        $$invalidate(7, label);
      });
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(6, element2);
      });
    }
    const SMUI_generic_input_mount_handler = (event) => $$invalidate(8, input = event.detail);
    const SMUI_generic_input_unmount_handler = () => $$invalidate(8, input = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("align" in $$new_props)
        $$invalidate(2, align = $$new_props.align);
      if ("noWrap" in $$new_props)
        $$invalidate(3, noWrap = $$new_props.noWrap);
      if ("inputId" in $$new_props)
        $$invalidate(4, inputId = $$new_props.inputId);
      if ("label$use" in $$new_props)
        $$invalidate(5, label$use = $$new_props.label$use);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      counter: counter2,
      MDCFormFieldFoundation,
      onMount,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      exclude: exclude2,
      prefixFilter: prefixFilter2,
      useActions,
      forwardEvents,
      use: use2,
      className,
      align,
      noWrap,
      inputId,
      label$use,
      element: element2,
      instance: instance7,
      label,
      input,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("align" in $$props)
        $$invalidate(2, align = $$new_props.align);
      if ("noWrap" in $$props)
        $$invalidate(3, noWrap = $$new_props.noWrap);
      if ("inputId" in $$props)
        $$invalidate(4, inputId = $$new_props.inputId);
      if ("label$use" in $$props)
        $$invalidate(5, label$use = $$new_props.label$use);
      if ("element" in $$props)
        $$invalidate(6, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance7 = $$new_props.instance;
      if ("label" in $$props)
        $$invalidate(7, label = $$new_props.label);
      if ("input" in $$props)
        $$invalidate(8, input = $$new_props.input);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      align,
      noWrap,
      inputId,
      label$use,
      element2,
      label,
      input,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      label_1_binding,
      div_binding,
      SMUI_generic_input_mount_handler,
      SMUI_generic_input_unmount_handler
    ];
  }
  var FormField = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_15, create_fragment8, safe_not_equal, {
        use: 0,
        class: 1,
        align: 2,
        noWrap: 3,
        inputId: 4,
        label$use: 5,
        getElement: 11
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "FormField",
        options,
        id: create_fragment8.name
      });
    }
    get use() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get align() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set align(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noWrap() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noWrap(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get inputId() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set inputId(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get label$use() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set label$use(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[11];
    }
    set getElement(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/main.js
  var _tree = {
    name: "_layout",
    filepath: "/_layout.svelte",
    root: true,
    ownMeta: {},
    absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/_layout.svelte",
    children: [
      {
        isFile: true,
        isDir: false,
        file: "_fallback.svelte",
        filepath: "/_fallback.svelte",
        name: "_fallback",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/_fallback.svelte",
        importPath: "../src/pages/_fallback.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: true,
        isPage: false,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/_fallback",
        id: "__fallback",
        component: () => Promise.resolve().then(() => require_fallback()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "dashboard.svelte",
        filepath: "/dashboard.svelte",
        name: "dashboard",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/dashboard.svelte",
        importPath: "../src/pages/dashboard.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/dashboard",
        id: "_dashboard",
        component: () => Promise.resolve().then(() => require_dashboard()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "help.svelte",
        filepath: "/help.svelte",
        name: "help",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/help.svelte",
        importPath: "../src/pages/help.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/help",
        id: "_help",
        component: () => Promise.resolve().then(() => require_help()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "index.svelte",
        filepath: "/index.svelte",
        name: "index",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/index.svelte",
        importPath: "../src/pages/index.svelte",
        isLayout: false,
        isReset: false,
        isIndex: true,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/index",
        id: "_index",
        component: () => Promise.resolve().then(() => require_index2()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "settings.svelte",
        filepath: "/settings.svelte",
        name: "settings",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/settings.svelte",
        importPath: "../src/pages/settings.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/settings",
        id: "_settings",
        component: () => Promise.resolve().then(() => require_settings()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "signup.svelte",
        filepath: "/signup.svelte",
        name: "signup",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/signup.svelte",
        importPath: "../src/pages/signup.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/signup",
        id: "_signup",
        component: () => Promise.resolve().then(() => require_signup()).then((m) => m.default)
      }
    ],
    isLayout: true,
    isReset: false,
    isIndex: false,
    isFallback: false,
    isPage: false,
    isFile: true,
    file: "_layout.svelte",
    ext: "svelte",
    badExt: false,
    importPath: "../src/pages/_layout.svelte",
    meta: {
      recursive: true,
      preload: false,
      prerender: true
    },
    path: "/",
    id: "__layout",
    component: () => Promise.resolve().then(() => require_layout()).then((m) => m.default)
  };
  var {tree, routes} = buildClientTree(_tree);
  function add_css(target) {
    append_styles(target, "svelte-1udm2va", `*,::before,::after{box-sizing:border-box}html{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,
		-apple-system, /* Firefox supports this but not yet \`system-ui\` */
		'Segoe UI',
		Roboto,
		Helvetica,
		Arial,
		sans-serif,
		'Apple Color Emoji',
		'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,
		SFMono-Regular,
		Consolas,
		'Liberation Mono',
		Menlo,
		monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button,[type='button'],[type='reset'],[type='submit']{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}button{background-color:transparent;background-image:none}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::before,::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:currentColor}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role="button"]{cursor:pointer}:-moz-focusring{outline:auto}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}pre,code,kbd,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,::before,::after{--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-border-opacity:1;border-color:rgba(229, 231, 235, var(--tw-border-opacity));--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.container{width:100%}@media(min-width: 640px){.container{max-width:640px}}@media(min-width: 768px){.container{max-width:768px}}@media(min-width: 1024px){.container{max-width:1024px}}@media(min-width: 1280px){.container{max-width:1280px}}@media(min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-1{right:-0.25rem}.top-0{top:0px}.bottom-0{bottom:0px}.right-0{right:0px}.left-0{left:0px}.-right-full{right:-100%}.top-60{top:15rem}.right-full{right:100%}.right-8{right:2rem}.bottom-20{bottom:5rem}.z-40{z-index:40}.z-10{z-index:10}.z-20{z-index:20}.m-0{margin:0px}.mx-auto{margin-left:auto;margin-right:auto}.my-6{margin-top:1.5rem;margin-bottom:1.5rem}.mt-auto{margin-top:auto}.mt-12{margin-top:3rem}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.inline-table{display:inline-table}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row-group{display:table-row-group}.table-row{display:table-row}.flow-root{display:flow-root}.grid{display:grid}.inline-grid{display:inline-grid}.contents{display:contents}.list-item{display:list-item}.hidden{display:none}.h-screen{height:100vh}.h-full{height:100%}.h-96{height:24rem}.h-10{height:2.5rem}.max-h-32{max-height:8rem}.w-full{width:100%}.w-24{width:6rem}.w-screen{width:100vw}.transform{transform:var(--tw-transform)}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-4{gap:1rem}.gap-2{gap:0.5rem}.gap-8{gap:2rem}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.divide-gray-600>:not([hidden])~:not([hidden]){--tw-divide-opacity:1;border-color:rgba(75, 85, 99, var(--tw-divide-opacity))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.whitespace-nowrap{white-space:nowrap}.break-all{word-break:break-all}.rounded-md{border-radius:0.375rem}.rounded-sm{border-radius:0.125rem}.rounded{border-radius:0.25rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-black{--tw-border-opacity:1;border-color:rgba(0, 0, 0, var(--tw-border-opacity))}.bg-green-500{--tw-bg-opacity:1;background-color:rgba(16, 185, 129, var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgba(0, 0, 0, var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity:1;background-color:rgba(255, 255, 255, var(--tw-bg-opacity))}.bg-opacity-75{--tw-bg-opacity:0.75}.p-4{padding:1rem}.p-2{padding:0.5rem}.p-0{padding:0px}.px-\\[1\\.25rem\\]{padding-left:1.25rem;padding-right:1.25rem}.px-4{padding-left:1rem;padding-right:1rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.py-16{padding-top:4rem;padding-bottom:4rem}.px-8{padding-left:2rem;padding-right:2rem}.py-4{padding-top:1rem;padding-bottom:1rem}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.capitalize{text-transform:capitalize}.italic{font-style:italic}.tracking-widest{letter-spacing:0.1em}.text-gray-200{--tw-text-opacity:1;color:rgba(229, 231, 235, var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgba(107, 114, 128, var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgba(255, 255, 255, var(--tw-text-opacity))}.text-red-500{--tw-text-opacity:1;color:rgba(239, 68, 68, var(--tw-text-opacity))}.text-blue-500{--tw-text-opacity:1;color:rgba(59, 130, 246, var(--tw-text-opacity))}.text-black{--tw-text-opacity:1;color:rgba(0, 0, 0, var(--tw-text-opacity))}.underline{text-decoration:underline}.line-through{text-decoration:line-through}.shadow-xl{--tw-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.blur{--tw-blur:blur(8px);filter:var(--tw-filter)}.filter{filter:var(--tw-filter)}.transition{transition-property:background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input{width:auto}@media(min-width: 640px){.sm\\:flex{display:flex}}@media(min-width: 768px){.md\\:ml-auto{margin-left:auto}.md\\:w-10\\/12{width:83.333333%}.md\\:w-6\\/12{width:50%}.md\\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.md\\:flex-row{flex-direction:row}}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFpbHdpbmQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNDLENBQUEsQUFBQSxrQkNhQSxVQUFBLENBQUEsVUFBc0IsQURiUixDQUFkLEFBQUEsSUFBQSxBQUFBLENBQUEsQUNxQkEsYUFBQSxDQUFBLENBQWdCLENBQ2hCLFFBQUEsQ0FBQSxDQUFXLEFEdEJHLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBQytCQSxXQUFBLENBQUEsSUFBaUIsQ0FDakIsd0JBQUEsQ0FBQSxJQUE4QixBRGhDaEIsQ0FBZCxBQUFBLElBQUEsQUFBQSxDQUFBLEFDNkNBLE1BQUEsQ0FBQSxDQUFTLEFEN0NLLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBQ3FEQSxXQUFBOzs7Ozs7OztrQkFTaUIsQUQ5REgsQ0FBZCxBQUFBLEVBQUEsQUFBQSxDQUFBLEFDNEVBLE1BQUEsQ0FBQSxDQUFTLENBQ1QsS0FBQSxDQUFBLE9BQWMsQUQ3RUEsQ0FBZCxBQUFBLFdBQUEsQUFBQSxDQUFBLEFDMEZBLGVBQUEsQ0FBQSxTQUFBLENBQUEsTUFBaUMsQUQxRm5CLENBQWQsQUFBQSxDQUFBLEFBQUEsUUNtR0EsV0FBQSxDQUFBLE1BQW1CLEFEbkdMLENBQWQsQUFBQSxJQUFBLEFBQUEsY0MrR0EsV0FBQTs7Ozs7V0FNVSxDQUNWLFNBQUEsQ0FBQSxHQUFjLEFEdEhBLENBQWQsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBQzhIQSxTQUFBLENBQUEsR0FBYyxBRDlIQSxDQUFkLEFBQUEsR0FBQSxBQUFBLEtDdUlBLFNBQUEsQ0FBQSxHQUFjLENBQ2QsV0FBQSxDQUFBLENBQWMsQ0FDZCxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsY0FBQSxDQUFBLFFBQXdCLEFEMUlWLENBQWQsQUFBQSxHQUFBLEFBQUEsQ0FBQSxBQzhJQSxNQUFBLENBQUEsT0FBZSxBRDlJRCxDQUFkLEFBQUEsR0FBQSxBQUFBLENBQUEsQUNrSkEsR0FBQSxDQUFBLE1BQVcsQURsSkcsQ0FBZCxBQUFBLEtBQUEsQUFBQSxDQUFBLEFDZ0tBLFdBQUEsQ0FBQSxDQUFjLENBQ2QsWUFBQSxDQUFBLE9BQXFCLEFEaktQLENBQWQsQUFBQSxNQUFBLEFBQUEsZ0NDbUxBLFdBQUEsQ0FBQSxPQUFvQixDQUNwQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixNQUFBLENBQUEsQ0FBUyxBRHRMSyxDQUFkLEFBQUEsTUFBQSxBQUFBLFFDZ01BLGNBQUEsQ0FBQSxJQUFvQixBRGhNTixDQUFkLEFBQUEsTUFBQSxBQUFBLGdEQzJNQSxrQkFBQSxDQUFBLE1BQTBCLEFEM01aLENBQWQsQUFBQSxrQkFBQSxBQUFBLENBQUEsQUNtTkEsWUFBQSxDQUFBLElBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLEFEcE5JLENBQWQsQUFBQSxlQUFBLEFBQUEsQ0FBQSxBQzROQSxPQUFBLENBQUEsR0FBQSxDQUFBLE1BQUEsQ0FBQSxVQUE4QixBRDVOaEIsQ0FBZCxBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBQ3FPQSxVQUFBLENBQUEsSUFBZ0IsQURyT0YsQ0FBZCxBQUFBLE1BQUEsQUFBQSxDQUFBLEFDNk9BLE9BQUEsQ0FBQSxDQUFVLEFEN09JLENBQWQsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBQ3FQQSxjQUFBLENBQUEsUUFBd0IsQURyUFYsQ0FBZCxBQUFBLDJCQUFBLEFBQUEsNkJDOFBBLE1BQUEsQ0FBQSxJQUFZLEFEOVBFLENBQWQsQUFBQSxlQUFBLEFBQUEsQ0FBQSxBQ3VRQSxrQkFBQSxDQUFBLFNBQTZCLENBQzdCLGNBQUEsQ0FBQSxJQUFvQixBRHhRTixDQUFkLEFBQUEsMkJBQUEsQUFBQSxDQUFBLEFDZ1JBLGtCQUFBLENBQUEsSUFBd0IsQURoUlYsQ0FBZCxBQUFBLDRCQUFBLEFBQUEsQ0FBQSxBQ3lSQSxrQkFBQSxDQUFBLE1BQTBCLENBQzFCLElBQUEsQ0FBQSxPQUFhLEFEMVJDLENBQWQsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBQ3VTQSxPQUFBLENBQUEsU0FBa0IsQUR2U0osQ0FBZCxBQUFBLFVBQUEsQUFBQSx5Q0VzQkMsTUFBQSxDQUFBLENBQVMsQUZ0QkksQ0FBZCxBQUFBLE1BQUEsQUFBQSxDQUFBLEFFMEJDLGdCQUFBLENBQUEsV0FBNkIsQ0FDN0IsZ0JBQUEsQ0FBQSxJQUFzQixBRjNCVCxDQUFkLEFBQUEsUUFBQSxBQUFBLENBQUEsQUUrQkMsTUFBQSxDQUFBLENBQVMsQ0FDVCxPQUFBLENBQUEsQ0FBVSxBRmhDRyxDQUFkLEFBQUEsRUFBQSxBQUFBLElFcUNDLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixNQUFBLENBQUEsQ0FBUyxDQUNULE9BQUEsQ0FBQSxDQUFVLEFGdkNHLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBRXNEQyxXQUFBLENBQUEsYUFBQSxDQUFBLENBQUEsU0FBQSxDQUFBLENBQUEsYUFBQSxDQUFBLENBQUEsa0JBQUEsQ0FBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxtQkFBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQSxrQkFBc1AsQ0FDdFAsV0FBQSxDQUFBLEdBQWdCLEFGdkRILENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBRWlFQyxXQUFBLENBQUEsT0FBb0IsQ0FDcEIsV0FBQSxDQUFBLE9BQW9CLEFGbEVQLENBQWQsQUFBQSxDQUFBLEFBQUEsa0JFa0dDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixZQUFBLENBQUEsQ0FBZSxDQUNmLFlBQUEsQ0FBQSxLQUFtQixDQUNuQixZQUFBLENBQUEsWUFBMEIsQUZyR2IsQ0FBZCxBQUFBLEVBQUEsQUFBQSxDQUFBLEFFNkdDLGdCQUFBLENBQUEsR0FBcUIsQUY3R1IsQ0FBZCxBQUFBLEdBQUEsQUFBQSxDQUFBLEFFMkhDLFlBQUEsQ0FBQSxLQUFtQixBRjNITixDQUFkLEFBQUEsUUFBQSxBQUFBLENBQUEsQUUrSEMsTUFBQSxDQUFBLFFBQWdCLEFGL0hILENBQWQsQUFBQSxrQkFBQSxBQUFBLHVCRW9JQyxPQUFBLENBQUEsQ0FBVSxDQUNWLEtBQUEsQ0FBQSxPQUF3QyxBRnJJM0IsQ0FBZCxBQUFBLE1BQUEsQUFBQSxpQkUwSUMsTUFBQSxDQUFBLE9BQWUsQUYxSUYsQ0FBZCxBQUFBLGVBQUEsQUFBQSxDQUFBLEFFc0pBLE9BQUEsQ0FBQSxJQUFhLEFGdEpDLENBQWQsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBRTBKQyxlQUFBLENBQUEsUUFBeUIsQUYxSlosQ0FBZCxBQUFBLEVBQUEsQUFBQSxnQkVtS0MsU0FBQSxDQUFBLE9BQWtCLENBQ2xCLFdBQUEsQ0FBQSxPQUFvQixBRnBLUCxDQUFkLEFBQUEsQ0FBQSxBQUFBLENBQUEsQUU2S0MsS0FBQSxDQUFBLE9BQWMsQ0FDZCxlQUFBLENBQUEsT0FBd0IsQUY5S1gsQ0FBZCxBQUFBLE1BQUEsQUFBQSxnQ0U4TEMsT0FBQSxDQUFBLENBQVUsQ0FDVixXQUFBLENBQUEsT0FBb0IsQ0FDcEIsS0FBQSxDQUFBLE9BQWMsQUZoTUQsQ0FBZCxBQUFBLEdBQUEsQUFBQSxlRThNQyxXQUFBLENBQUEsWUFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBLGFBQUEsQ0FBQSxDQUFBLFNBQXlJLEFGOU01SCxDQUFkLEFBQUEsR0FBQSxBQUFBLDRDRTBPQyxPQUFBLENBQUEsS0FBYyxDQUNkLGNBQUEsQ0FBQSxNQUFzQixBRjNPVCxDQUFkLEFBQUEsR0FBQSxBQUFBLE9FdVBDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQUZ4UEMsQ0FBZCxBQUFBLFFBQUEsQUFBQSxDQUFBLEFFZ1FDLE9BQUEsQ0FBQSxJQUFhLEFGaFFBLENHRGYsQUFBQSxDQUFBLEFBQUEsQ0FBQSxRQUFBLEFBQUEsQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBLFdBQUEsQ0FBQSxDQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBLENBQUEsWUFBQSxDQUFBLENBQUEsQ0FBQSxjQUFBLENBQUEsZ01BQUEsQ0FBQSxtQkFBQSxDQUFBLENBQUEsQ0FBQSxZQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLG1CQUFBLENBQUEsQ0FBQSxDQUFBLHVCQUFBLENBQUEsU0FBQSxDQUFBLGdCQUFBLENBQUEsU0FBQSxDQUFBLFdBQUEsQ0FBQSxTQUFBLENBQUEsU0FBQSxDQUFBLDJCQUFBLENBQUEsZUFBQSxDQUFBLDJCQUFBLENBQUEsYUFBQSxDQUFBLDJCQUFBLENBQUEsY0FBQSxDQUFBLDJCQUFBLENBQUEsZUFBQSxDQUFBLDJCQUFBLENBQUEsV0FBQSxDQUFBLDJCQUFBLENBQUEsYUFBQSxDQUFBLDJCQUFBLENBQUEsVUFBQSxDQUFBLDJCQUFBLENBQUEsZ0JBQUEsQ0FBQSwyQkFBQSxDQUFBLFdBQUEsQ0FBQSx5S0FBQSxBQ3NZQSxDSnBZQyxBQUFBLFVBQUEsQUFBQSxDQUFBLEFHRkQsS0FBQSxDQUFBLElBQUEsQUhFcUIsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLEtBQUEsQUMwWUMsQ0FBQSxBSnhZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLEtBQUEsQUM2WUMsQ0FBQSxBSjNZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNnWkMsQ0FBQSxBSjlZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNtWkMsQ0FBQSxBSmpab0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNzWkMsQ0FBQSxBSnBab0IsQ0FDcEIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxPQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxRQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFFBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsU0FBQSxBQUFBLENBQUEsQUdIRCxRQUFBLENBQUEsUUFBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxHQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLEdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxJQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELEdBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsV0FBQSxBQUFBLENBQUEsQUdIRCxLQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELE1BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsRUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLEVBQUEsQUhHb0IsQ0FBbkIsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxFQUFBLEFIR29CLENBQW5CLEFBQUEsSUFBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxZQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLE1BQUEsQ0FBQSxhQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsS0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFlBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsWUFBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLGFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxVQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsWUFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxlQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFVBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFNBQUEsQUhHb0IsQ0FBbkIsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsWUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsV0FBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxTQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELE1BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsS0FBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxLQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxTQUFBLENBQUEsSUFBQSxjQUFBLENBQUEsQUhHb0IsQ0FBbkIsV0FBQSxBQUFBLElBQUEsQUFBQSxDR0hELEVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE9BQUEsTUFBQSxDQUFBLEFDdWdCQyxDQUFBLEFKcGdCbUIsQ0FBbkIsQUFBQSxhQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxJQUFBLENBQUEsRUFBQSxDQUFBLE1BQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsZUFBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQscUJBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxXQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLGVBQUEsQUFBQSxDQUFBLEFHSEQsZUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxnQkFBQSxBQUFBLENBQUEsQUdIRCxlQUFBLENBQUEsYUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsR0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELEdBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxHQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLGNBQUEsQUFBQSxDQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQscUJBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxtQkFBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLHFCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxjQUFBLEFBQUEsQ0FBQSxjQUFBLEFBQUEsQ0FBQSxBR0hELG1CQUFBLENBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLElBQUEsbUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxnQkFBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLGtCQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFdBQUEsQUFBQSxDQUFBLEFHSEQsYUFBQSxDQUFBLFFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGFBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsUUFBQSxBQUFBLENBQUEsQUdIRCxhQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLEdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELG1CQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsbUJBQUEsQ0FBQSxDQUFBLENBQUEsWUFBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxtQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxhQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxjQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsSUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLElBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLE9BQUEsQ0FBQSxhQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLElBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxjQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLElBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxjQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxNQUFBLENBQUEsV0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxPQUFBLENBQUEsV0FBQSxDQUFBLE9BQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxRQUFBLENBQUEsV0FBQSxDQUFBLE9BQUEsQUhHb0IsQ0FBbkIsQUFBQSxZQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxjQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFVBQUEsQUFBQSxDQUFBLEFHSEQsY0FBQSxDQUFBLFNBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxVQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsY0FBQSxBQUFBLENBQUEsQUdIRCxpQkFBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsaUJBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGlCQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxpQkFBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsaUJBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLEtBQUEsRUFBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGlCQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxlQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsZUFBQSxDQUFBLFlBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSx5RUFBQSxDQUFBLFVBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLCtEQUFBLENBQUEsVUFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsV0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxTQUFBLENBQUEsU0FBQSxDQUFBLE1BQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLElBQUEsV0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsV0FBQSxBQUFBLENBQUEsQUdIRCxtQkFBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxZQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxlQUFBLENBQUEsMEJBQUEsQ0FBQSxhQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLG1CQUFBLENBQUEsS0FBQSxBSEdvQixDR0hwQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFBQUEsS0FBQSxDQUFBLElBQUEsQUN5cEJBLENKenBCQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDR0FBLEFBQUEsU0FBQSxBQUFBLENBQUEsQUFBQSxPQUFBLENBQUEsSUFBQSxBQzJwQkMsQ0FBQSxBQUNELENKNXBCQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDR0FBLEFBQUEsWUFBQSxBQUFBLENBQUEsQUFBQSxXQUFBLENBQUEsSUFBQSxBQzhwQkMsQ0Q5cEJELEFBQUEsYUFBQSxBQUFBLENBQUEsQUFBQSxLQUFBLENBQUEsVUFBQSxBQ2dxQkMsQ0RocUJELEFBQUEsWUFBQSxBQUFBLENBQUEsQUFBQSxLQUFBLENBQUEsR0FBQSxBQ2txQkMsQ0RscUJELEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFBQUEscUJBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQUNvcUJDLENEcHFCRCxBQUFBLGFBQUEsQUFBQSxDQUFBLEFBQUEsY0FBQSxDQUFBLEdBQUEsQUNzcUJDLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbInNyYy9zcmMvVGFpbHdpbmQuc3ZlbHRlIiwic3JjLyUzQ2lucHV0JTIwY3NzJTIwWUZlMXExJTNFIiwic3JjLyUzQ2lucHV0JTIwY3NzJTIwZG1wSjlfJTNFIiwic3JjLyUzQ25vJTIwc291cmNlJTNFIiwic3JjL1RhaWx3aW5kLnN2ZWx0ZSJdfQ== */`);
  }
  function create_fragment$17(ctx) {
    const block = {
      c: noop,
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$17.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$16($$self, $$props) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Tailwind", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Tailwind> was created with unknown prop '${key}'`);
    });
    return [];
  }
  var Tailwind = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$16, create_fragment$17, safe_not_equal, {}, add_css);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Tailwind",
        options,
        id: create_fragment$17.name
      });
    }
  };
  function create_fragment9(ctx) {
    let serviceworker;
    let t0;
    let tailwind;
    let t1;
    let router;
    let current;
    serviceworker = new Serviceworker({$$inline: true});
    tailwind = new Tailwind({$$inline: true});
    router = new Router({props: {routes}, $$inline: true});
    const block = {
      c: function create2() {
        create_component(serviceworker.$$.fragment);
        t0 = space();
        create_component(tailwind.$$.fragment);
        t1 = space();
        create_component(router.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        mount_component(serviceworker, target, anchor);
        insert_dev(target, t0, anchor);
        mount_component(tailwind, target, anchor);
        insert_dev(target, t1, anchor);
        mount_component(router, target, anchor);
        current = true;
      },
      p: noop,
      i: function intro(local) {
        if (current)
          return;
        transition_in(serviceworker.$$.fragment, local);
        transition_in(tailwind.$$.fragment, local);
        transition_in(router.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(serviceworker.$$.fragment, local);
        transition_out(tailwind.$$.fragment, local);
        transition_out(router.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(serviceworker, detaching);
        if (detaching)
          detach_dev(t0);
        destroy_component(tailwind, detaching);
        if (detaching)
          detach_dev(t1);
        destroy_component(router, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment9.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance6($$self, $$props, $$invalidate) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("App", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<App> was created with unknown prop '${key}'`);
    });
    $$self.$capture_state = () => ({Serviceworker, Router, routes, Tailwind});
    return [];
  }
  var App = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance6, create_fragment9, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "App",
        options,
        id: create_fragment9.name
      });
    }
  };
  HMR(App, {target: document.body}, "routify-app");
})();
