(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __export = (target, all2) => {
    for (var name in all2)
      __defProp(target, name, {get: all2[name], enumerable: true});
  };

  // dist/build/workbox-window.prod.es5.js
  var require_workbox_window_prod_es5 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      Workbox: () => f,
      messageSW: () => n
    });
    (function(l, r2) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r2 = l.createElement("script");
      r2.async = 1;
      r2.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r2.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r2);
    })(self.document);
    try {
      self["workbox:window:5.1.4"] && _();
    } catch (n2) {
    }
    function n(n2, t2) {
      return new Promise(function(r2) {
        var e2 = new MessageChannel();
        e2.port1.onmessage = function(n3) {
          r2(n3.data);
        }, n2.postMessage(t2, [e2.port2]);
      });
    }
    function t(n2, t2) {
      for (var r2 = 0; r2 < t2.length; r2++) {
        var e2 = t2[r2];
        e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(n2, e2.key, e2);
      }
    }
    function r(n2, t2) {
      (t2 == null || t2 > n2.length) && (t2 = n2.length);
      for (var r2 = 0, e2 = new Array(t2); r2 < t2; r2++)
        e2[r2] = n2[r2];
      return e2;
    }
    function e(n2, t2) {
      var e2;
      if (typeof Symbol == "undefined" || n2[Symbol.iterator] == null) {
        if (Array.isArray(n2) || (e2 = function(n3, t3) {
          if (n3) {
            if (typeof n3 == "string")
              return r(n3, t3);
            var e3 = Object.prototype.toString.call(n3).slice(8, -1);
            return e3 === "Object" && n3.constructor && (e3 = n3.constructor.name), e3 === "Map" || e3 === "Set" ? Array.from(n3) : e3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3) ? r(n3, t3) : void 0;
          }
        }(n2)) || t2 && n2 && typeof n2.length == "number") {
          e2 && (n2 = e2);
          var i2 = 0;
          return function() {
            return i2 >= n2.length ? {done: true} : {done: false, value: n2[i2++]};
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      return (e2 = n2[Symbol.iterator]()).next.bind(e2);
    }
    try {
      self["workbox:core:5.1.4"] && _();
    } catch (n2) {
    }
    var i = function() {
      var n2 = this;
      this.promise = new Promise(function(t2, r2) {
        n2.resolve = t2, n2.reject = r2;
      });
    };
    function o(n2, t2) {
      var r2 = location.href;
      return new URL(n2, r2).href === new URL(t2, r2).href;
    }
    var u = function(n2, t2) {
      this.type = n2, Object.assign(this, t2);
    };
    function a(n2, t2, r2) {
      return r2 ? t2 ? t2(n2) : n2 : (n2 && n2.then || (n2 = Promise.resolve(n2)), t2 ? n2.then(t2) : n2);
    }
    function c() {
    }
    var f = function(r2) {
      var e2, c2;
      function f2(n2, t2) {
        var e3, c3;
        return t2 === void 0 && (t2 = {}), (e3 = r2.call(this) || this).t = {}, e3.i = 0, e3.o = new i(), e3.u = new i(), e3.s = new i(), e3.v = 0, e3.h = new Set(), e3.l = function() {
          var n3 = e3.m, t3 = n3.installing;
          e3.i > 0 || !o(t3.scriptURL, e3.g) || performance.now() > e3.v + 6e4 ? (e3.p = t3, n3.removeEventListener("updatefound", e3.l)) : (e3.P = t3, e3.h.add(t3), e3.o.resolve(t3)), ++e3.i, t3.addEventListener("statechange", e3.S);
        }, e3.S = function(n3) {
          var t3 = e3.m, r3 = n3.target, i2 = r3.state, o2 = r3 === e3.p, a2 = o2 ? "external" : "", c4 = {sw: r3, originalEvent: n3};
          !o2 && e3.j && (c4.isUpdate = true), e3.dispatchEvent(new u(a2 + i2, c4)), i2 === "installed" ? e3.A = self.setTimeout(function() {
            i2 === "installed" && t3.waiting === r3 && e3.dispatchEvent(new u(a2 + "waiting", c4));
          }, 200) : i2 === "activating" && (clearTimeout(e3.A), o2 || e3.u.resolve(r3));
        }, e3.O = function(n3) {
          var t3 = e3.P;
          t3 === navigator.serviceWorker.controller && (e3.dispatchEvent(new u("controlling", {sw: t3, originalEvent: n3, isUpdate: e3.j})), e3.s.resolve(t3));
        }, e3.U = (c3 = function(n3) {
          var t3 = n3.data, r3 = n3.source;
          return a(e3.getSW(), function() {
            e3.h.has(r3) && e3.dispatchEvent(new u("message", {data: t3, sw: r3, originalEvent: n3}));
          });
        }, function() {
          for (var n3 = [], t3 = 0; t3 < arguments.length; t3++)
            n3[t3] = arguments[t3];
          try {
            return Promise.resolve(c3.apply(this, n3));
          } catch (n4) {
            return Promise.reject(n4);
          }
        }), e3.g = n2, e3.t = t2, navigator.serviceWorker.addEventListener("message", e3.U), e3;
      }
      c2 = r2, (e2 = f2).prototype = Object.create(c2.prototype), e2.prototype.constructor = e2, e2.__proto__ = c2;
      var v, h, m = f2.prototype;
      return m.register = function(n2) {
        var t2 = (n2 === void 0 ? {} : n2).immediate, r3 = t2 !== void 0 && t2;
        try {
          var e3 = this;
          return function(n3, t3) {
            var r4 = n3();
            if (r4 && r4.then)
              return r4.then(t3);
            return t3(r4);
          }(function() {
            if (!r3 && document.readyState !== "complete")
              return s(new Promise(function(n3) {
                return window.addEventListener("load", n3);
              }));
          }, function() {
            return e3.j = Boolean(navigator.serviceWorker.controller), e3.I = e3.M(), a(e3.R(), function(n3) {
              e3.m = n3, e3.I && (e3.P = e3.I, e3.u.resolve(e3.I), e3.s.resolve(e3.I), e3.I.addEventListener("statechange", e3.S, {once: true}));
              var t3 = e3.m.waiting;
              return t3 && o(t3.scriptURL, e3.g) && (e3.P = t3, Promise.resolve().then(function() {
                e3.dispatchEvent(new u("waiting", {sw: t3, wasWaitingBeforeRegister: true}));
              }).then(function() {
              })), e3.P && (e3.o.resolve(e3.P), e3.h.add(e3.P)), e3.m.addEventListener("updatefound", e3.l), navigator.serviceWorker.addEventListener("controllerchange", e3.O, {once: true}), e3.m;
            });
          });
        } catch (n3) {
          return Promise.reject(n3);
        }
      }, m.update = function() {
        try {
          return this.m ? s(this.m.update()) : void 0;
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.getSW = function() {
        try {
          return this.P !== void 0 ? this.P : this.o.promise;
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.messageSW = function(t2) {
        try {
          return a(this.getSW(), function(r3) {
            return n(r3, t2);
          });
        } catch (n2) {
          return Promise.reject(n2);
        }
      }, m.M = function() {
        var n2 = navigator.serviceWorker.controller;
        return n2 && o(n2.scriptURL, this.g) ? n2 : void 0;
      }, m.R = function() {
        try {
          var n2 = this;
          return function(n3, t2) {
            try {
              var r3 = n3();
            } catch (n4) {
              return t2(n4);
            }
            if (r3 && r3.then)
              return r3.then(void 0, t2);
            return r3;
          }(function() {
            return a(navigator.serviceWorker.register(n2.g, n2.t), function(t2) {
              return n2.v = performance.now(), t2;
            });
          }, function(n3) {
            throw n3;
          });
        } catch (n3) {
          return Promise.reject(n3);
        }
      }, v = f2, (h = [{key: "active", get: function() {
        return this.u.promise;
      }}, {key: "controlling", get: function() {
        return this.s.promise;
      }}]) && t(v.prototype, h), f2;
    }(function() {
      function n2() {
        this.k = new Map();
      }
      var t2 = n2.prototype;
      return t2.addEventListener = function(n3, t3) {
        this.B(n3).add(t3);
      }, t2.removeEventListener = function(n3, t3) {
        this.B(n3).delete(t3);
      }, t2.dispatchEvent = function(n3) {
        n3.target = this;
        for (var t3, r2 = e(this.B(n3.type)); !(t3 = r2()).done; ) {
          (0, t3.value)(n3);
        }
      }, t2.B = function(n3) {
        return this.k.has(n3) || this.k.set(n3, new Set()), this.k.get(n3);
      }, n2;
    }());
    function s(n2, t2) {
      if (!t2)
        return n2 && n2.then ? n2.then(c) : Promise.resolve();
    }
  });

  // dist/build/_fallback.js
  var require_fallback = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Fallback
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var file9 = "src/pages/_fallback.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-viq1pm", ".huge.svelte-viq1pm{font-size:12rem}.e404.svelte-viq1pm{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2ZhbGxiYWNrLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFDRSxLQUFBLGNBQUEsQ0FBQSxBQUNFLFNBQUEsQ0FBQSxLQUFnQixBQUNsQixDQUFBLEFBQ0EsS0FBQSxjQUFBLENBQUEsQUFDRSxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsSUFBQSxDQUFBLEdBQVMsQ0FDVCxHQUFBLENBQUEsR0FBUSxDQUNSLFNBQUEsQ0FBQSxVQUFBLElBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBZ0MsQ0FDaEMsVUFBQSxDQUFBLE1BQWtCLEFBQ3BCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzL3NyYy9wYWdlcy9fZmFsbGJhY2suc3ZlbHRlIl19 */");
    }
    function create_fragment10(ctx) {
      let div2;
      let div0;
      let t1;
      let div1;
      let t2;
      let a;
      let t3;
      let a_href_value;
      const block = {
        c: function create2() {
          div2 = element("div");
          div0 = element("div");
          div0.textContent = "404";
          t1 = space();
          div1 = element("div");
          t2 = text("Seite nicht gefunden. \n  \n  ");
          a = element("a");
          t3 = text("zur\xFCck");
          attr_dev(div0, "class", "huge svelte-viq1pm");
          add_location(div0, file9, 18, 2, 264);
          attr_dev(a, "href", a_href_value = ctx[0]("../"));
          add_location(a, file9, 21, 2, 393);
          attr_dev(div1, "class", "big");
          add_location(div1, file9, 19, 2, 294);
          attr_dev(div2, "class", "e404 svelte-viq1pm");
          add_location(div2, file9, 17, 0, 243);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div2, t1);
          append_dev(div2, div1);
          append_dev(div1, t2);
          append_dev(div1, a);
          append_dev(a, t3);
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 1 && a_href_value !== (a_href_value = ctx2[0]("../"))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance8($$self, $$props, $$invalidate) {
      let $url;
      validate_store(url, "url");
      component_subscribe($$self, url, ($$value) => $$invalidate(0, $url = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Fallback", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Fallback> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({url, $url});
      return [$url];
    }
    var Fallback = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Fallback",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/help.js
  var require_help = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Help
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var {Object: Object_12} = globals;
    var file9 = "src/pages/help.svelte";
    function create_default_slot_42(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Hilfe";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file9, 21, 8, 581);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(22:1) <Title>",
        ctx
      });
      return block;
    }
    function create_if_block6(ctx) {
      let button;
      let t;
      let br;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[2]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
          t = space();
          br = element("br");
          add_location(br, file9, 36, 2, 1102);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, br, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 16) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
          if (detaching)
            detach_dev(t);
          if (detaching)
            detach_dev(br);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block6.name,
        type: "if",
        source: "(29:2) {#if !($user && Object.keys($user).length)}",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Jetzt registrieren");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(35:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 16) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: '(30:2) <Button    variant=\\"raised\\"    style=\\"background: var(--mdc-theme-callout)\\"    on:click={() => $goto(\\"/signup\\")}   >',
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let t0;
      let br0;
      let t1;
      let br1;
      let t2;
      let br2;
      let t3;
      let show_if = !(ctx[0] && Object.keys(ctx[0]).length);
      let t4;
      let h2;
      let t6;
      let br3;
      let br4;
      let t7;
      let ul;
      let li0;
      let t8;
      let p0;
      let t10;
      let br5;
      let t11;
      let li1;
      let t12;
      let br6;
      let t13;
      let p1;
      let t15;
      let br7;
      let t16;
      let li2;
      let t17;
      let p2;
      let t18;
      let br8;
      let t19;
      let br9;
      let t20;
      let br10;
      let t21;
      let t22;
      let br11;
      let t23;
      let li3;
      let t24;
      let p3;
      let t25;
      let br12;
      let t26;
      let t27;
      let br13;
      let t28;
      let li4;
      let t29;
      let p4;
      let t30;
      let br14;
      let t31;
      let br15;
      let t32;
      let t33;
      let br16;
      let current;
      let if_block = show_if && create_if_block6(ctx);
      const block = {
        c: function create2() {
          t0 = text("Willkommen bei foodsight - der App die es ganz leicht macht, den Einkauf\n		perfekt zu planen. ");
          br0 = element("br");
          t1 = text("\n		Foodsight sagt genau voraus, wieviel von welchem Produkt Du verkaufen wirst\n		- morgen, \xFCbermorgen und in den n\xE4chsten 7 Tagen. ");
          br1 = element("br");
          t2 = space();
          br2 = element("br");
          t3 = space();
          if (if_block)
            if_block.c();
          t4 = space();
          h2 = element("h2");
          h2.textContent = "Funktionen";
          t6 = text("\n		Im Men\xFC rechts oben findest Du folgende Optionen:");
          br3 = element("br");
          br4 = element("br");
          t7 = space();
          ul = element("ul");
          li0 = element("li");
          t8 = text("\u2022 Login / Logout\n				");
          p0 = element("p");
          p0.textContent = "Solange Du nicht angemeldet bist, l\xE4uft die App im\n					Demo-Modus mit Beispieldaten";
          t10 = space();
          br5 = element("br");
          t11 = space();
          li1 = element("li");
          t12 = text("\u2022 Hilfe");
          br6 = element("br");
          t13 = space();
          p1 = element("p");
          p1.textContent = "Diese Einf\xFChrung";
          t15 = space();
          br7 = element("br");
          t16 = space();
          li2 = element("li");
          t17 = text("\u2022 Planung\n				");
          p2 = element("p");
          t18 = text("Schau dir den erwarteten Absatz an und plane Deine\n					Bestellmengen.");
          br8 = element("br");
          t19 = text("\n					Du bekommst einen Bereich von-bis angezeigt, in dem Dein Absatz\n					liegen wird. Der eingetragene Bestellvorschlag ist der wahrscheinlichste\n					Wert. ");
          br9 = element("br");
          t20 = text("\n					Mit dieser Information kannst Du ganz einfach Deine Einkaufsplanung\n					erstellen.");
          br10 = element("br");
          t21 = text('\n					Wenn Du fertig bist, klicke unten auf "Bestellen". Du kannst\n					Deine Bestell-Liste in drei Formaten abrufen - als Excel, csv\n					oder pdf.');
          t22 = space();
          br11 = element("br");
          t23 = space();
          li3 = element("li");
          t24 = text("\u2022 Einstellungen\n				");
          p3 = element("p");
          t25 = text("Im oberen Teil siehst Du auf welcher Basis Deine Abs\xE4tze\n					vorhergesagt werden. Bitte lass uns wissen, wenn etwas nicht\n					stimmt.");
          br12 = element("br");
          t26 = text("\n					Unten kannst Du einstellen, welche Planung Du gerade machen m\xF6chtest:\n					Morgen, \xFCbermorgen oder n\xE4chste 7 Tage.");
          t27 = space();
          br13 = element("br");
          t28 = space();
          li4 = element("li");
          t29 = text("\u2022 Idee/Problem\n				");
          p4 = element("p");
          t30 = text("Foodsight ist ganz neu. Wenn Dir irgendwas auff\xE4llt, was\n					besser sein k\xF6nnte oder Du Ideen hast - bitte lass es uns\n					wissen!");
          br14 = element("br");
          t31 = text("\n					Du kannst auf jeder Seite den Briefumschlag oben im Men\xFC dr\xFCcken,\n					ein Bildschirmfoto machen und Dein Anliegen beschreiben.\n					");
          br15 = element("br");
          t32 = text("\n					Absenden - wir k\xFCmmern uns darum.");
          t33 = space();
          br16 = element("br");
          add_location(br0, file9, 24, 21, 733);
          add_location(br1, file9, 26, 52, 870);
          add_location(br2, file9, 27, 2, 879);
          attr_dev(h2, "class", "text-xl my-6");
          add_location(h2, file9, 38, 2, 1119);
          add_location(br3, file9, 39, 51, 1211);
          add_location(br4, file9, 39, 57, 1217);
          set_style(p0, "margin-left", "50px");
          add_location(p0, file9, 43, 4, 1264);
          add_location(li0, file9, 41, 3, 1234);
          add_location(br5, file9, 48, 3, 1405);
          add_location(br6, file9, 50, 11, 1431);
          set_style(p1, "margin-left", "50px");
          add_location(p1, file9, 51, 4, 1442);
          add_location(li1, file9, 49, 3, 1415);
          add_location(br7, file9, 53, 3, 1504);
          add_location(br8, file9, 58, 19, 1642);
          add_location(br9, file9, 61, 11, 1807);
          add_location(br10, file9, 63, 15, 1902);
          set_style(p2, "margin-left", "50px");
          add_location(p2, file9, 56, 4, 1537);
          add_location(li2, file9, 54, 3, 1514);
          add_location(br11, file9, 69, 3, 2078);
          add_location(br12, file9, 75, 12, 2287);
          set_style(p3, "margin-left", "50px");
          add_location(p3, file9, 72, 4, 2117);
          add_location(li3, file9, 70, 3, 2088);
          add_location(br13, file9, 80, 3, 2435);
          add_location(br14, file9, 86, 12, 2640);
          add_location(br15, file9, 89, 5, 2785);
          set_style(p4, "margin-left", "50px");
          add_location(p4, file9, 83, 4, 2473);
          add_location(li4, file9, 81, 3, 2445);
          add_location(br16, file9, 93, 3, 2852);
          add_location(ul, file9, 40, 2, 1226);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, br0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, br1, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, br2, anchor);
          insert_dev(target, t3, anchor);
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, h2, anchor);
          insert_dev(target, t6, anchor);
          insert_dev(target, br3, anchor);
          insert_dev(target, br4, anchor);
          insert_dev(target, t7, anchor);
          insert_dev(target, ul, anchor);
          append_dev(ul, li0);
          append_dev(li0, t8);
          append_dev(li0, p0);
          append_dev(ul, t10);
          append_dev(ul, br5);
          append_dev(ul, t11);
          append_dev(ul, li1);
          append_dev(li1, t12);
          append_dev(li1, br6);
          append_dev(li1, t13);
          append_dev(li1, p1);
          append_dev(ul, t15);
          append_dev(ul, br7);
          append_dev(ul, t16);
          append_dev(ul, li2);
          append_dev(li2, t17);
          append_dev(li2, p2);
          append_dev(p2, t18);
          append_dev(p2, br8);
          append_dev(p2, t19);
          append_dev(p2, br9);
          append_dev(p2, t20);
          append_dev(p2, br10);
          append_dev(p2, t21);
          append_dev(ul, t22);
          append_dev(ul, br11);
          append_dev(ul, t23);
          append_dev(ul, li3);
          append_dev(li3, t24);
          append_dev(li3, p3);
          append_dev(p3, t25);
          append_dev(p3, br12);
          append_dev(p3, t26);
          append_dev(ul, t27);
          append_dev(ul, br13);
          append_dev(ul, t28);
          append_dev(ul, li4);
          append_dev(li4, t29);
          append_dev(li4, p4);
          append_dev(p4, t30);
          append_dev(p4, br14);
          append_dev(p4, t31);
          append_dev(p4, br15);
          append_dev(p4, t32);
          append_dev(ul, t33);
          append_dev(ul, br16);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1)
            show_if = !(ctx2[0] && Object.keys(ctx2[0]).length);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block6(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t4.parentNode, t4);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(br0);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(br1);
          if (detaching)
            detach_dev(t2);
          if (detaching)
            detach_dev(br2);
          if (detaching)
            detach_dev(t3);
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(t4);
          if (detaching)
            detach_dev(h2);
          if (detaching)
            detach_dev(t6);
          if (detaching)
            detach_dev(br3);
          if (detaching)
            detach_dev(br4);
          if (detaching)
            detach_dev(t7);
          if (detaching)
            detach_dev(ul);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(23:1) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot8(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_42]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 16) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 19) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot8.name,
        type: "slot",
        source: '(21:0) <Paper elevation={1} class=\\"md:w-10/12 w-full mx-auto\\">',
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let div;
      let paper;
      let div_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          class: "md:w-10/12 w-full mx-auto",
          $$slots: {default: [create_default_slot8]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          create_component(paper.$$.fragment);
          add_location(div, file9, 19, 0, 503);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(paper, div, null);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const paper_changes = {};
          if (dirty & 19) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!div_intro) {
            add_render_callback(() => {
              div_intro = create_in_transition(div, fade, {});
              div_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance8($$self, $$props, $$invalidate) {
      let $redirect;
      let $user;
      let $goto;
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(3, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(0, $user = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(1, $goto = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Help", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Help> was created with unknown prop '${key}'`);
      });
      const click_handler = () => $goto("/signup");
      $$self.$capture_state = () => ({
        Paper,
        Title,
        Content,
        Button: Button_1,
        Label: CommonLabel,
        goto,
        user,
        fade,
        redirect,
        onMount,
        $redirect,
        $user,
        $goto
      });
      return [$user, $goto, click_handler];
    }
    var Help = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Help",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/index2.js
  var require_index2 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Pages
    });
    (function(l2, r2) {
      if (!l2 || l2.getElementById("livereloadscript"))
        return;
      r2 = l2.createElement("script");
      r2.async = 1;
      r2.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r2.id = "livereloadscript";
      l2.getElementsByTagName("head")[0].appendChild(r2);
    })(self.document);
    function useActions8(node, actions) {
      let objects = [];
      if (actions) {
        for (let i2 = 0; i2 < actions.length; i2++) {
          const isArray2 = Array.isArray(actions[i2]);
          const action = isArray2 ? actions[i2][0] : actions[i2];
          if (isArray2 && actions[i2].length > 1) {
            objects.push(action(node, actions[i2][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i2 = 0; i2 < actions2.length; i2++) {
              if (objects[i2] && "update" in objects[i2]) {
                const isArray2 = Array.isArray(actions2[i2]);
                if (isArray2 && actions2[i2].length > 1) {
                  objects[i2].update(actions2[i2][1]);
                } else {
                  objects[i2].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i2 = 0; i2 < objects.length; i2++) {
            if (objects[i2] && "destroy" in objects[i2]) {
              objects[i2].destroy();
            }
          }
        }
      };
    }
    var file$26 = "node_modules/@smui/button/Group.svelte";
    function create_fragment$28(ctx) {
      let div;
      let div_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let div_levels = [
        {
          class: div_class_value = classMap3({
            [ctx[1]]: true,
            "smui-button__group": true,
            "smui-button__group--raised": ctx[2] === "raised"
          })
        },
        ctx[5]
      ];
      let div_data = {};
      for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
        div_data = assign(div_data, div_levels[i2]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (default_slot) {
            default_slot.m(div, null);
          }
          ctx[9](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, div, ctx[0])),
              action_destroyer(ctx[4].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 6 && div_class_value !== (div_class_value = classMap3({
              [ctx2[1]]: true,
              "smui-button__group": true,
              "smui-button__group--raised": ctx2[2] === "raised"
            }))) && {class: div_class_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "variant", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Group", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder3(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {variant = "text"} = $$props;
      let element2;
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(3, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("variant" in $$new_props)
          $$invalidate(2, variant = $$new_props.variant);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder3,
        classMap: classMap3,
        useActions: useActions8,
        forwardEvents,
        use: use2,
        className,
        variant,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("variant" in $$props)
          $$invalidate(2, variant = $$new_props.variant);
        if ("element" in $$props)
          $$invalidate(3, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        variant,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var Group = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$28, safe_not_equal, {
          use: 0,
          class: 1,
          variant: 2,
          getElement: 6
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Group",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function GroupItem(node, {
      addClass = (className) => node.classList.add(className),
      removeClass = (className) => node.classList.remove(className)
    } = {}) {
      addClass("smui-button__group-item");
      return {
        destroy() {
          removeClass("smui-button__group-item");
        }
      };
    }
    var file$18 = "node_modules/@smui/list/Graphic.svelte";
    function create_fragment$18(ctx) {
      let span;
      let span_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let span_levels = [
        {
          class: span_class_value = classMap4({
            [ctx[1]]: true,
            "mdc-deprecated-list-item__graphic": true,
            "mdc-menu__selection-group-icon": ctx[4]
          })
        },
        ctx[5]
      ];
      let span_data = {};
      for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
        span_data = assign(span_data, span_levels[i2]);
      }
      const block = {
        c: function create2() {
          span = element("span");
          if (default_slot)
            default_slot.c();
          set_attributes(span, span_data);
          add_location(span, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          if (default_slot) {
            default_slot.m(span, null);
          }
          ctx[9](span);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions4.call(null, span, ctx[0])),
              action_destroyer(ctx[3].call(null, span))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(span, span_data = get_spread_update(span_levels, [
            (!current || dirty & 2 && span_class_value !== (span_class_value = classMap4({
              [ctx2[1]]: true,
              "mdc-deprecated-list-item__graphic": true,
              "mdc-menu__selection-group-icon": ctx2[4]
            }))) && {class: span_class_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Graphic", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder4(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let element2;
      let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
      function getElement() {
        return element2;
      }
      function span_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder4,
        classMap: classMap4,
        useActions: useActions4,
        forwardEvents,
        use: use2,
        className,
        element: element2,
        menuSelectionGroup,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("menuSelectionGroup" in $$props)
          $$invalidate(4, menuSelectionGroup = $$new_props.menuSelectionGroup);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        element2,
        forwardEvents,
        menuSelectionGroup,
        $$restProps,
        getElement,
        $$scope,
        slots,
        span_binding
      ];
    }
    var Graphic = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {use: 0, class: 1, getElement: 6});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Graphic",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    classAdderBuilder4({
      class: "mdc-menu__selection-group-icon",
      component: Graphic
    });
    var lib = {};
    var search;
    Object.defineProperty(lib, "__esModule", {value: true});
    var t = function(t2) {
      return function(r2) {
        return t2 == null ? void 0 : t2[r2];
      };
    }({\u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s"});
    var r = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
    var e = typeof r == "object" && r && r.Object === Object && r;
    var n = typeof self == "object" && self && self.Object === Object && self;
    var o = e || n || Function("return this")();
    var a = o.Symbol;
    var i = function(t2, r2) {
      for (var e2 = -1, n2 = t2 == null ? 0 : t2.length, o2 = Array(n2); ++e2 < n2; )
        o2[e2] = r2(t2[e2], e2, t2);
      return o2;
    };
    var u = Array.isArray;
    var c = Object.prototype;
    var s = c.hasOwnProperty;
    var f = c.toString;
    var l = a ? a.toStringTag : void 0;
    var p = function(t2) {
      var r2 = s.call(t2, l), e2 = t2[l];
      try {
        t2[l] = void 0;
        var n2 = true;
      } catch (t3) {
      }
      var o2 = f.call(t2);
      return n2 && (r2 ? t2[l] = e2 : delete t2[l]), o2;
    };
    var v = Object.prototype.toString;
    var h = function(t2) {
      return v.call(t2);
    };
    var y = a ? a.toStringTag : void 0;
    var d = function(t2) {
      return t2 == null ? t2 === void 0 ? "[object Undefined]" : "[object Null]" : y && y in Object(t2) ? p(t2) : h(t2);
    };
    var _2 = function(t2) {
      return t2 != null && typeof t2 == "object";
    };
    var g = function(t2) {
      return typeof t2 == "symbol" || _2(t2) && d(t2) == "[object Symbol]";
    };
    var b = a ? a.prototype : void 0;
    var O = b ? b.toString : void 0;
    var j = function t2(r2) {
      if (typeof r2 == "string")
        return r2;
      if (u(r2))
        return i(r2, t2) + "";
      if (g(r2))
        return O ? O.call(r2) : "";
      var e2 = r2 + "";
      return e2 == "0" && 1 / r2 == -1 / 0 ? "-0" : e2;
    };
    var m = function(t2) {
      return t2 == null ? "" : j(t2);
    };
    var x = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var w = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g");
    var A2 = function(r2) {
      return (r2 = m(r2)) && r2.replace(x, t).replace(w, "");
    };
    var S = /[\\^$.*+?()[\]{}|]/g;
    var z = RegExp(S.source);
    var E = function(t2) {
      return (t2 = m(t2)) && z.test(t2) ? t2.replace(S, "\\$&") : t2;
    };
    var $ = function(t2) {
      var r2 = typeof t2;
      return t2 != null && (r2 == "object" || r2 == "function");
    };
    var I2;
    var N = function(t2) {
      if (!$(t2))
        return false;
      var r2 = d(t2);
      return r2 == "[object Function]" || r2 == "[object GeneratorFunction]" || r2 == "[object AsyncFunction]" || r2 == "[object Proxy]";
    };
    var T = o["__core-js_shared__"];
    var U = (I2 = /[^.]+$/.exec(T && T.keys && T.keys.IE_PROTO || "")) ? "Symbol(src)_1." + I2 : "";
    var C = function(t2) {
      return !!U && U in t2;
    };
    var L = Function.prototype.toString;
    var P = function(t2) {
      if (t2 != null) {
        try {
          return L.call(t2);
        } catch (t3) {
        }
        try {
          return t2 + "";
        } catch (t3) {
        }
      }
      return "";
    };
    var R = /^\[object .+?Constructor\]$/;
    var F = Function.prototype;
    var k = Object.prototype;
    var G = F.toString;
    var D = k.hasOwnProperty;
    var M = RegExp("^" + G.call(D).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var J = function(t2) {
      return !(!$(t2) || C(t2)) && (N(t2) ? M : R).test(P(t2));
    };
    var Y = function(t2, r2) {
      return t2 == null ? void 0 : t2[r2];
    };
    var Z = function(t2, r2) {
      var e2 = Y(t2, r2);
      return J(e2) ? e2 : void 0;
    };
    var H = Z(Object, "create");
    var K = function() {
      this.__data__ = H ? H(null) : {}, this.size = 0;
    };
    var W = function(t2) {
      var r2 = this.has(t2) && delete this.__data__[t2];
      return this.size -= r2 ? 1 : 0, r2;
    };
    var q = Object.prototype.hasOwnProperty;
    var B = function(t2) {
      var r2 = this.__data__;
      if (H) {
        var e2 = r2[t2];
        return e2 === "__lodash_hash_undefined__" ? void 0 : e2;
      }
      return q.call(r2, t2) ? r2[t2] : void 0;
    };
    var Q = Object.prototype.hasOwnProperty;
    var V = function(t2) {
      var r2 = this.__data__;
      return H ? r2[t2] !== void 0 : Q.call(r2, t2);
    };
    var X = function(t2, r2) {
      var e2 = this.__data__;
      return this.size += this.has(t2) ? 0 : 1, e2[t2] = H && r2 === void 0 ? "__lodash_hash_undefined__" : r2, this;
    };
    function tt(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    tt.prototype.clear = K, tt.prototype.delete = W, tt.prototype.get = B, tt.prototype.has = V, tt.prototype.set = X;
    var rt = tt;
    var et = function() {
      this.__data__ = [], this.size = 0;
    };
    var nt = function(t2, r2) {
      return t2 === r2 || t2 != t2 && r2 != r2;
    };
    var ot = function(t2, r2) {
      for (var e2 = t2.length; e2--; )
        if (nt(t2[e2][0], r2))
          return e2;
      return -1;
    };
    var at = Array.prototype.splice;
    var it = function(t2) {
      var r2 = this.__data__, e2 = ot(r2, t2);
      return !(e2 < 0) && (e2 == r2.length - 1 ? r2.pop() : at.call(r2, e2, 1), --this.size, true);
    };
    var ut = function(t2) {
      var r2 = this.__data__, e2 = ot(r2, t2);
      return e2 < 0 ? void 0 : r2[e2][1];
    };
    var ct = function(t2) {
      return ot(this.__data__, t2) > -1;
    };
    var st = function(t2, r2) {
      var e2 = this.__data__, n2 = ot(e2, t2);
      return n2 < 0 ? (++this.size, e2.push([t2, r2])) : e2[n2][1] = r2, this;
    };
    function ft(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    ft.prototype.clear = et, ft.prototype.delete = it, ft.prototype.get = ut, ft.prototype.has = ct, ft.prototype.set = st;
    var lt = ft;
    var pt = Z(o, "Map");
    var vt = function() {
      this.size = 0, this.__data__ = {hash: new rt(), map: new (pt || lt)(), string: new rt()};
    };
    var ht = function(t2) {
      var r2 = typeof t2;
      return r2 == "string" || r2 == "number" || r2 == "symbol" || r2 == "boolean" ? t2 !== "__proto__" : t2 === null;
    };
    var yt = function(t2, r2) {
      var e2 = t2.__data__;
      return ht(r2) ? e2[typeof r2 == "string" ? "string" : "hash"] : e2.map;
    };
    var dt = function(t2) {
      var r2 = yt(this, t2).delete(t2);
      return this.size -= r2 ? 1 : 0, r2;
    };
    var _t = function(t2) {
      return yt(this, t2).get(t2);
    };
    var gt = function(t2) {
      return yt(this, t2).has(t2);
    };
    var bt = function(t2, r2) {
      var e2 = yt(this, t2), n2 = e2.size;
      return e2.set(t2, r2), this.size += e2.size == n2 ? 0 : 1, this;
    };
    function Ot(t2) {
      var r2 = -1, e2 = t2 == null ? 0 : t2.length;
      for (this.clear(); ++r2 < e2; ) {
        var n2 = t2[r2];
        this.set(n2[0], n2[1]);
      }
    }
    Ot.prototype.clear = vt, Ot.prototype.delete = dt, Ot.prototype.get = _t, Ot.prototype.has = gt, Ot.prototype.set = bt;
    var jt = Ot;
    function mt(t2, r2) {
      if (typeof t2 != "function" || r2 != null && typeof r2 != "function")
        throw new TypeError("Expected a function");
      var e2 = function() {
        var n2 = arguments, o2 = r2 ? r2.apply(this, n2) : n2[0], a2 = e2.cache;
        if (a2.has(o2))
          return a2.get(o2);
        var i2 = t2.apply(this, n2);
        return e2.cache = a2.set(o2, i2) || a2, i2;
      };
      return e2.cache = new (mt.Cache || jt)(), e2;
    }
    mt.Cache = jt;
    var xt = mt;
    var wt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var At = /^\w*$/;
    var St = function(t2, r2) {
      if (u(t2))
        return false;
      var e2 = typeof t2;
      return !(e2 != "number" && e2 != "symbol" && e2 != "boolean" && t2 != null && !g(t2)) || (At.test(t2) || !wt.test(t2) || r2 != null && t2 in Object(r2));
    };
    var zt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var Et = /\\(\\)?/g;
    var $t = function(t2) {
      var r2 = xt(t2, function(t3) {
        return e2.size === 500 && e2.clear(), t3;
      }), e2 = r2.cache;
      return r2;
    }(function(t2) {
      var r2 = [];
      return t2.charCodeAt(0) === 46 && r2.push(""), t2.replace(zt, function(t3, e2, n2, o2) {
        r2.push(n2 ? o2.replace(Et, "$1") : e2 || t3);
      }), r2;
    });
    var It = function(t2, r2) {
      return u(t2) ? t2 : St(t2, r2) ? [t2] : $t(m(t2));
    };
    var Nt = function(t2) {
      if (typeof t2 == "string" || g(t2))
        return t2;
      var r2 = t2 + "";
      return r2 == "0" && 1 / t2 == -1 / 0 ? "-0" : r2;
    };
    var Tt = function(t2, r2) {
      for (var e2 = 0, n2 = (r2 = It(r2, t2)).length; t2 != null && e2 < n2; )
        t2 = t2[Nt(r2[e2++])];
      return e2 && e2 == n2 ? t2 : void 0;
    };
    var Ut = function(t2, r2, e2) {
      var n2 = t2 == null ? void 0 : Tt(t2, r2);
      return n2 === void 0 ? e2 : n2;
    };
    var Ct = /\s/;
    var Lt = function(t2) {
      for (var r2 = t2.length; r2-- && Ct.test(t2.charAt(r2)); )
        ;
      return r2;
    };
    var Pt = /^\s+/;
    var Rt = function(t2) {
      return t2 ? t2.slice(0, Lt(t2) + 1).replace(Pt, "") : t2;
    };
    var Ft = /^[-+]0x[0-9a-f]+$/i;
    var kt = /^0b[01]+$/i;
    var Gt = /^0o[0-7]+$/i;
    var Dt = parseInt;
    var Mt = function(t2) {
      if (typeof t2 == "number")
        return t2;
      if (g(t2))
        return NaN;
      if ($(t2)) {
        var r2 = typeof t2.valueOf == "function" ? t2.valueOf() : t2;
        t2 = $(r2) ? r2 + "" : r2;
      }
      if (typeof t2 != "string")
        return t2 === 0 ? t2 : +t2;
      t2 = Rt(t2);
      var e2 = kt.test(t2);
      return e2 || Gt.test(t2) ? Dt(t2.slice(2), e2 ? 2 : 8) : Ft.test(t2) ? NaN : +t2;
    };
    var Jt = function(t2) {
      return t2 ? (t2 = Mt(t2)) === 1 / 0 || t2 === -1 / 0 ? 17976931348623157e292 * (t2 < 0 ? -1 : 1) : t2 == t2 ? t2 : 0 : t2 === 0 ? t2 : 0;
    };
    var Yt = function(t2) {
      var r2 = Jt(t2), e2 = r2 % 1;
      return r2 == r2 ? e2 ? r2 - e2 : r2 : 0;
    };
    var Zt = o.isFinite;
    var Ht = Math.min;
    var Kt = function(t2) {
      var r2 = Math[t2];
      return function(t3, e2) {
        if (t3 = Mt(t3), (e2 = e2 == null ? 0 : Ht(Yt(e2), 292)) && Zt(t3)) {
          var n2 = (m(t3) + "e").split("e"), o2 = r2(n2[0] + "e" + (+n2[1] + e2));
          return +((n2 = (m(o2) + "e").split("e"))[0] + "e" + (+n2[1] - e2));
        }
        return r2(t3);
      };
    }("round");
    function Wt(t2) {
      return A2(t2).replace(/[\u0300-\u036f]/g, "").toLocaleLowerCase().trim();
    }
    function qt(t2) {
      return Wt(E(t2)).match(/[\p{L}\d]+/gimu) || [];
    }
    var Bt = xt((t2, r2) => {
      if (!t2 || t2.length === 0 || !r2 || r2.length === 0)
        return [];
      const e2 = /\[(.*)]/;
      return t2.map((t3) => r2.map((r3) => {
        const n2 = Ut(e2.exec(r3), "1"), o2 = Ut(t3, r3.replace(e2, ""));
        return n2 || o2 != null && typeof o2 != "function" ? n2 ? o2.map((t4) => Ut(t4, n2)) : Array.isArray(o2) || typeof o2 == "object" ? JSON.stringify(o2) : o2 : "";
      }).reduce((t4, r3) => t4 + r3, "")).map((t3) => Wt(t3));
    });
    var Qt = Bt;
    var Vt = (t2, r2, e2) => {
      if (!t2)
        return 0;
      const n2 = e2.replace(/[^\p{L}\d]+/gimu, ""), o2 = r2.sort((t3, r3) => r3.length - t3.length).reduce((t3, r3) => t3.replace(new RegExp(r3, "gm"), ""), n2);
      return Kt(1 - o2.length / n2.length, 4);
    };
    lib.convertToSearchableStrings = Bt, lib.getScore = Vt, lib.indexDocuments = Qt, lib.normalize = Wt, search = lib.search = function(t2, r2, e2, n2 = {}) {
      if (!e2)
        return t2;
      const o2 = qt(e2);
      return Bt(t2, r2).map((r3, e3) => {
        const a2 = o2.filter((t3) => r3.indexOf(t3) > -1).length === o2.length;
        if (n2.withScore) {
          const n3 = Vt(a2, o2, r3);
          return {element: t2[e3], score: n3};
        }
        return a2 ? t2[e3] : null;
      }).filter((t3) => t3);
    }, lib.tokenize = qt;
    var {Object: Object_12, console: console_12} = globals;
    var file9 = "src/pages/index.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-6o1wow", "th,td{text-align:center;width:20000px}input{padding-top:0.5rem;padding-bottom:0.5rem;padding-left:1rem;padding-right:1rem;border-radius:0.25rem}:root{--table-head-bg:var(--mdc-theme-primary);--table-head-color:var(--mdc-theme-on-primary);--table-body-odd-bg:var(--mdc-theme-background);--table-body-odd-color:var(--mdc-theme-text-primary-on-background);--table-body-even-bg:var(--mdc-theme-2nd-background);--table-body-even-color:var(--mdc-theme-text-primary-on-background)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUFBLEVBQUEsQUFBQSxDQUFBLEVBQUEsQUFBQSxDQUFBLEFBQUEsVUFBQSxDQUFBLE1BQUEsQ0NJRSxLQUFBLENBQUEsT0FBQSxBQ0FGLENBQUEsQUZKQSxLQUFBLEFBQUEsQ0FBQSxBQUFBLFdBQUEsQ0FBQSxNQUFBLENBQUEsY0FBQSxDQUFBLE1BQUEsQ0FBQSxZQUFBLENBQUEsSUFBQSxDQUFBLGFBQUEsQ0FBQSxJQUFBLENBQUEsYUFBQSxDQUFBLE9BQUEsQUVXQSxDQUFBLEFEQUMsS0FBQSxBQUFBLENBQUEsQUFDQyxlQUFBLENBQUEsd0JBQXlDLENBQ3pDLGtCQUFBLENBQUEsMkJBQStDLENBQy9DLG1CQUFBLENBQUEsMkJBQWdELENBQ2hELHNCQUFBLENBQUEsMkNBQW1FLENBQ25FLG9CQUFBLENBQUEsK0JBQXFELENBQ3JELHVCQUFBLENBQUEsMkNBQW9FLEFBQ3JFLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzLyUzQ25vJTIwc291cmNlJTNFIiwic3JjL3BhZ2VzL3NyYy9wYWdlcy9pbmRleC5zdmVsdGUiLCJzcmMvcGFnZXMvaW5kZXguc3ZlbHRlIl19 */");
    }
    function get_each_context2(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[35] = list[i2];
      child_ctx[36] = list;
      child_ctx[37] = i2;
      return child_ctx;
    }
    function get_each_context_1(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[38] = list[i2];
      child_ctx[39] = list;
      child_ctx[40] = i2;
      return child_ctx;
    }
    function get_each_context_2(ctx, list, i2) {
      const child_ctx = ctx.slice();
      child_ctx[41] = list[i2];
      return child_ctx;
    }
    function create_default_slot_24(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Vorhersage und Planung";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file9, 273, 9, 7448);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_24.name,
        type: "slot",
        source: "(274:2) <Title>",
        ctx
      });
      return block;
    }
    function create_catch_block(ctx) {
      let t_value = ctx[44] + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 64 && t_value !== (t_value = ctx2[44] + ""))
            set_data_dev(t2, t_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_catch_block.name,
        type: "catch",
        source: "(529:4) {:catch error}",
        ctx
      });
      return block;
    }
    function create_then_block(ctx) {
      let div;
      let dataChanger_action;
      let autoCache_action;
      let t2;
      let show_if = Object.keys(ctx[0]).length;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block = show_if && create_if_block6(ctx);
      const block = {
        c: function create2() {
          div = element("div");
          t2 = space();
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
          add_location(div, file9, 294, 5, 8033);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          insert_dev(target, t2, anchor);
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(dataChanger_action = ctx[13].call(null, div, ctx[34])),
              action_destroyer(autoCache_action = ctx[14].call(null, div, ctx[0]))
            ];
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dataChanger_action && is_function(dataChanger_action.update) && dirty[0] & 64)
            dataChanger_action.update.call(null, ctx[34]);
          if (autoCache_action && is_function(autoCache_action.update) && dirty[0] & 1)
            autoCache_action.update.call(null, ctx[0]);
          if (dirty[0] & 1)
            show_if = Object.keys(ctx[0]).length;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty[0] & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block6(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t2);
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_then_block.name,
        type: "then",
        source: "(293:4) {:then returnVal}",
        ctx
      });
      return block;
    }
    function create_if_block6(ctx) {
      let section_1;
      let table;
      let thead;
      let t0;
      let tbody;
      let table_intro;
      let t1;
      let div1;
      let group0;
      let t2;
      let div0;
      let group1;
      let div1_intro;
      let current;
      let each_value_2 = ctx[0].head;
      validate_each_argument(each_value_2);
      let each_blocks_1 = [];
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        each_blocks_1[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
      }
      let each_value = ctx[0].body;
      validate_each_argument(each_value);
      let each_blocks = [];
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
      }
      const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
        each_blocks[i2] = null;
      });
      let each1_else = null;
      if (!each_value.length) {
        each1_else = create_else_block_12(ctx);
      }
      group0 = new Group({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      group1 = new Group({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_25]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section_1 = element("section");
          table = element("table");
          thead = element("thead");
          for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
            each_blocks_1[i2].c();
          }
          t0 = space();
          tbody = element("tbody");
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].c();
          }
          if (each1_else) {
            each1_else.c();
          }
          t1 = space();
          div1 = element("div");
          create_component(group0.$$.fragment);
          t2 = space();
          div0 = element("div");
          create_component(group1.$$.fragment);
          attr_dev(thead, "class", "border-b border-black");
          add_location(thead, file9, 304, 8, 8328);
          add_location(tbody, file9, 356, 8, 9900);
          attr_dev(table, "class", "w-full");
          add_location(table, file9, 302, 7, 8259);
          attr_dev(section_1, "class", "overflow-y-auto p-2");
          add_location(section_1, file9, 298, 6, 8173);
          attr_dev(div0, "class", "md:ml-auto ");
          add_location(div0, file9, 468, 7, 13223);
          attr_dev(div1, "class", "w-full flex flex-col md:flex-row gap-2");
          add_location(div1, file9, 420, 6, 11951);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section_1, anchor);
          append_dev(section_1, table);
          append_dev(table, thead);
          for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
            each_blocks_1[i2].m(thead, null);
          }
          append_dev(table, t0);
          append_dev(table, tbody);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].m(tbody, null);
          }
          if (each1_else) {
            each1_else.m(tbody, null);
          }
          ctx[23](section_1);
          insert_dev(target, t1, anchor);
          insert_dev(target, div1, anchor);
          mount_component(group0, div1, null);
          append_dev(div1, t2);
          append_dev(div1, div0);
          mount_component(group1, div0, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1053) {
            each_value_2 = ctx2[0].head;
            validate_each_argument(each_value_2);
            let i2;
            for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
              const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
              if (each_blocks_1[i2]) {
                each_blocks_1[i2].p(child_ctx, dirty);
              } else {
                each_blocks_1[i2] = create_each_block_2(child_ctx);
                each_blocks_1[i2].c();
                each_blocks_1[i2].m(thead, null);
              }
            }
            for (; i2 < each_blocks_1.length; i2 += 1) {
              each_blocks_1[i2].d(1);
            }
            each_blocks_1.length = each_value_2.length;
          }
          if (dirty[0] & 2695) {
            each_value = ctx2[0].body;
            validate_each_argument(each_value);
            let i2;
            for (i2 = 0; i2 < each_value.length; i2 += 1) {
              const child_ctx = get_each_context2(ctx2, each_value, i2);
              if (each_blocks[i2]) {
                each_blocks[i2].p(child_ctx, dirty);
                transition_in(each_blocks[i2], 1);
              } else {
                each_blocks[i2] = create_each_block2(child_ctx);
                each_blocks[i2].c();
                transition_in(each_blocks[i2], 1);
                each_blocks[i2].m(tbody, null);
              }
            }
            group_outros();
            for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
              out(i2);
            }
            check_outros();
            if (!each_value.length && each1_else) {
              each1_else.p(ctx2, dirty);
            } else if (!each_value.length) {
              each1_else = create_else_block_12(ctx2);
              each1_else.c();
              each1_else.m(tbody, null);
            } else if (each1_else) {
              each1_else.d(1);
              each1_else = null;
            }
          }
          const group0_changes = {};
          if (dirty[0] & 33 | dirty[1] & 16384) {
            group0_changes.$$scope = {dirty, ctx: ctx2};
          }
          group0.$set(group0_changes);
          const group1_changes = {};
          if (dirty[0] & 641 | dirty[1] & 16384) {
            group1_changes.$$scope = {dirty, ctx: ctx2};
          }
          group1.$set(group1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i2 = 0; i2 < each_value.length; i2 += 1) {
            transition_in(each_blocks[i2]);
          }
          if (!table_intro) {
            add_render_callback(() => {
              table_intro = create_in_transition(table, blur, {});
              table_intro.start();
            });
          }
          transition_in(group0.$$.fragment, local);
          transition_in(group1.$$.fragment, local);
          if (!div1_intro) {
            add_render_callback(() => {
              div1_intro = create_in_transition(div1, fade, {});
              div1_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            transition_out(each_blocks[i2]);
          }
          transition_out(group0.$$.fragment, local);
          transition_out(group1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section_1);
          destroy_each(each_blocks_1, detaching);
          destroy_each(each_blocks, detaching);
          if (each1_else)
            each1_else.d();
          ctx[23](null);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(div1);
          destroy_component(group0);
          destroy_component(group1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block6.name,
        type: "if",
        source: "(298:5) {#if Object.keys(data).length}",
        ctx
      });
      return block;
    }
    function create_if_block_92(ctx) {
      let th;
      let div1;
      let t0_value = (ctx[10].find(func_2)?.text || ctx[41]) + "";
      let t0;
      let t1;
      let div0;
      let span0;
      let t3;
      let span1;
      let t5;
      let mounted;
      let dispose;
      function func_2(...args) {
        return ctx[20](ctx[41], ...args);
      }
      function click_handler() {
        return ctx[21](ctx[41]);
      }
      const block = {
        c: function create2() {
          th = element("th");
          div1 = element("div");
          t0 = text(t0_value);
          t1 = space();
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "arrow_drop_up";
          t3 = space();
          span1 = element("span");
          span1.textContent = "arrow_drop_down";
          t5 = space();
          attr_dev(span0, "class", `material-icons absolute right-0 top-0 `);
          toggle_class(span0, "text-gray-200", ctx[3].col == ctx[41] && !ctx[3].ascending);
          toggle_class(span0, "text-gray-500", ctx[3].col != ctx[41] || ctx[3].ascending);
          add_location(span0, file9, 326, 14, 9037);
          attr_dev(span1, "class", "material-icons absolute right-0 bottom-0");
          toggle_class(span1, "text-gray-200", ctx[3].col == ctx[41] && ctx[3].ascending);
          toggle_class(span1, "text-gray-500", ctx[3].col != ctx[41] || !ctx[3].ascending);
          add_location(span1, file9, 337, 14, 9403);
          attr_dev(div0, "class", "absolute -right-1 top-0 bottom-0");
          add_location(div0, file9, 323, 13, 8948);
          attr_dev(div1, "class", "relative h-10 flex justify-center items-center px-[1.25rem] whitespace-nowrap");
          add_location(div1, file9, 316, 12, 8705);
          set_style(th, "background", "var(--table-head-bg)");
          set_style(th, "color", "var(--table-head-color)");
          add_location(th, file9, 307, 11, 8456);
        },
        m: function mount(target, anchor) {
          insert_dev(target, th, anchor);
          append_dev(th, div1);
          append_dev(div1, t0);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(div0, t3);
          append_dev(div0, span1);
          append_dev(th, t5);
          if (!mounted) {
            dispose = listen_dev(th, "click", click_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 1 && t0_value !== (t0_value = (ctx[10].find(func_2)?.text || ctx[41]) + ""))
            set_data_dev(t0, t0_value);
          if (dirty[0] & 9) {
            toggle_class(span0, "text-gray-200", ctx[3].col == ctx[41] && !ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span0, "text-gray-500", ctx[3].col != ctx[41] || ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span1, "text-gray-200", ctx[3].col == ctx[41] && ctx[3].ascending);
          }
          if (dirty[0] & 9) {
            toggle_class(span1, "text-gray-500", ctx[3].col != ctx[41] || !ctx[3].ascending);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(th);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_92.name,
        type: "if",
        source: "(307:10) {#if tableWhitelist.includes(col)}",
        ctx
      });
      return block;
    }
    function create_each_block_2(ctx) {
      let show_if = ctx[2].includes(ctx[41]);
      let if_block_anchor;
      let if_block = show_if && create_if_block_92(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 5)
            show_if = ctx2[2].includes(ctx2[41]);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block_92(ctx2);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(306:9) {#each data.head as col}",
        ctx
      });
      return block;
    }
    function create_else_block_12(ctx) {
      let div1;
      let div0;
      let t0;
      let t1;
      let t2;
      let t3;
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          t0 = text('Keine Daten zum Suchbegriff "');
          t1 = text(ctx[1]);
          t2 = text('"\n												gefunden');
          t3 = space();
          attr_dev(div0, "class", "absolute top-0 left-0 -right-full bottom-0 flex justify-center items-center");
          add_location(div0, file9, 409, 11, 11648);
          attr_dev(div1, "class", "h-96 relative");
          add_location(div1, file9, 408, 10, 11609);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, t0);
          append_dev(div0, t1);
          append_dev(div0, t2);
          append_dev(div1, t3);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2)
            set_data_dev(t1, ctx2[1]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_12.name,
        type: "else",
        source: "(407:9) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_52(ctx) {
      let tr;
      let t2;
      let current;
      let each_value_1 = Object.keys(ctx[35]);
      validate_each_argument(each_value_1);
      let each_blocks = [];
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
      }
      const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
        each_blocks[i2] = null;
      });
      const block = {
        c: function create2() {
          tr = element("tr");
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].c();
          }
          t2 = space();
          attr_dev(tr, "style", `background: ${ctx[37] % 2 ? "var(--table-body-odd-bg)" : "var(--table-body-even-bg)"};
									color: ${ctx[37] % 2 ? "var(--table-body-odd-color)" : "var(--table-body-even-color)"}`);
          add_location(tr, file9, 360, 11, 10090);
        },
        m: function mount(target, anchor) {
          insert_dev(target, tr, anchor);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            each_blocks[i2].m(tr, null);
          }
          append_dev(tr, t2);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2053) {
            each_value_1 = Object.keys(ctx2[35]);
            validate_each_argument(each_value_1);
            let i2;
            for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
              const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
              if (each_blocks[i2]) {
                each_blocks[i2].p(child_ctx, dirty);
                transition_in(each_blocks[i2], 1);
              } else {
                each_blocks[i2] = create_each_block_1(child_ctx);
                each_blocks[i2].c();
                transition_in(each_blocks[i2], 1);
                each_blocks[i2].m(tr, t2);
              }
            }
            group_outros();
            for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
              out(i2);
            }
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
            transition_in(each_blocks[i2]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
            transition_out(each_blocks[i2]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(tr);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_52.name,
        type: "if",
        source: "(360:10) {#if i < pageLength * currentPage && i >= pageLength * (currentPage - 1)}",
        ctx
      });
      return block;
    }
    function create_if_block_62(ctx) {
      let td;
      let show_if;
      let current_block_type_index;
      let if_block;
      let current;
      function func5(...args) {
        return ctx[17](ctx[38], ...args);
      }
      const if_block_creators = [create_if_block_72, create_else_block3];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (dirty[0] & 1)
          show_if = !!ctx2[11].find(func5);
        if (show_if)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx, [-1, -1]);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          td = element("td");
          if_block.c();
          attr_dev(td, "class", "whitespace-nowrap");
          add_location(td, file9, 375, 14, 10562);
        },
        m: function mount(target, anchor) {
          insert_dev(target, td, anchor);
          if_blocks[current_block_type_index].m(td, null);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx, dirty);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(td, null);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(td);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_62.name,
        type: "if",
        source: "(375:13) {#if tableWhitelist.includes(field)}",
        ctx
      });
      return block;
    }
    function create_else_block3(ctx) {
      let t_value = ctx[35][ctx[38]] + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1 && t_value !== (t_value = ctx2[35][ctx2[38]] + ""))
            set_data_dev(t2, t_value);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block3.name,
        type: "else",
        source: "(398:15) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_72(ctx) {
      let show_if = ctx[11].find(func_13).type == "number";
      let if_block_anchor;
      let current;
      function func_13(...args) {
        return ctx[18](ctx[38], ...args);
      }
      let if_block = show_if && create_if_block_82(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 1)
            show_if = ctx[11].find(func_13).type == "number";
          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty[0] & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_82(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_72.name,
        type: "if",
        source: "(381:15) {#if dataTypes.find((item) => item.key === field)}",
        ctx
      });
      return block;
    }
    function create_if_block_82(ctx) {
      let textfield;
      let updating_value;
      let current;
      function textfield_value_binding(value) {
        ctx[22](value, ctx[35], ctx[38]);
      }
      let textfield_props = {
        class: "shaped-outlined",
        variant: "outlined",
        type: "number"
      };
      if (ctx[35][ctx[38]] !== void 0) {
        textfield_props.value = ctx[35][ctx[38]];
      }
      textfield = new Textfield({props: textfield_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield, "value", textfield_value_binding));
      const block = {
        c: function create2() {
          create_component(textfield.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(textfield, target, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          const textfield_changes = {};
          if (!updating_value && dirty[0] & 1) {
            updating_value = true;
            textfield_changes.value = ctx[35][ctx[38]];
            add_flush_callback(() => updating_value = false);
          }
          textfield.$set(textfield_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(textfield, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_82.name,
        type: "if",
        source: '(382:16) {#if dataTypes.find((item) => item.key === field).type == \\"number\\"}',
        ctx
      });
      return block;
    }
    function create_each_block_1(ctx) {
      let show_if = ctx[2].includes(ctx[38]);
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block_62(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 5)
            show_if = ctx2[2].includes(ctx2[38]);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 5) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_62(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(373:12) {#each Object.keys(item) as field}",
        ctx
      });
      return block;
    }
    function create_each_block2(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[37] < ctx[9] * ctx[7] && ctx[37] >= ctx[9] * (ctx[7] - 1) && create_if_block_52(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[37] < ctx2[9] * ctx2[7] && ctx2[37] >= ctx2[9] * (ctx2[7] - 1)) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 640) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_52(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block2.name,
        type: "each",
        source: "(358:9) {#each data.body as item, i}",
        ctx
      });
      return block;
    }
    function create_default_slot_23(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("Bestellung abschliessen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_23.name,
        type: "slot",
        source: "(433:9) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_23]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: `(427:8) <Button          on:click={() => order(\\"xlsx\\", data.body)}          variant=\\"raised\\"          style=\\"background: {'var(--mdc-theme-callout)'}\\"          class=\\"whitespace-nowrap\\"         >`,
        ctx
      });
      return block;
    }
    function create_default_slot_21(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("arrow_drop_down");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_21.name,
        type: "slot",
        source: '(441:10) <Icon            class=\\"material-icons\\"            style=\\"margin: 0;\\"            >',
        ctx
      });
      return block;
    }
    function create_default_slot_20(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          class: "material-icons",
          style: "margin: 0;",
          $$slots: {default: [create_default_slot_21]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const icon_changes = {};
          if (dirty[1] & 16384) {
            icon_changes.$$scope = {dirty, ctx: ctx2};
          }
          icon.$set(icon_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_20.name,
        type: "slot",
        source: `(436:9) <Button           on:click={() => orderMenu.setOpen(true)}           variant=\\"raised\\"           style=\\"padding: 0; min-width: 36px; background: {'var(--mdc-theme-callout)'}\\"          >`,
        ctx
      });
      return block;
    }
    function create_default_slot_19(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("excel");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_19.name,
        type: "slot",
        source: "(456:12) <Text>",
        ctx
      });
      return block;
    }
    function create_default_slot_18(ctx) {
      let text_1;
      let current;
      text_1 = new Text({
        props: {
          $$slots: {default: [create_default_slot_19]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(text_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(text_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const text_1_changes = {};
          if (dirty[1] & 16384) {
            text_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          text_1.$set(text_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(text_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(text_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(text_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_18.name,
        type: "slot",
        source: '(452:11) <Item             on:SMUI:action={() =>              order(\\"xlsx\\", data.body)}            >',
        ctx
      });
      return block;
    }
    function create_default_slot_17(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text("csv");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_17.name,
        type: "slot",
        source: "(462:12) <Text>",
        ctx
      });
      return block;
    }
    function create_default_slot_16(ctx) {
      let text_1;
      let current;
      text_1 = new Text({
        props: {
          $$slots: {default: [create_default_slot_17]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(text_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(text_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const text_1_changes = {};
          if (dirty[1] & 16384) {
            text_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          text_1.$set(text_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(text_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(text_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(text_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_16.name,
        type: "slot",
        source: '(458:11) <Item             on:SMUI:action={() =>              order(\\"csv\\", data.body)}            >',
        ctx
      });
      return block;
    }
    function create_default_slot_15(ctx) {
      let item0;
      let t2;
      let item1;
      let current;
      item0 = new Item({
        props: {
          $$slots: {default: [create_default_slot_18]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      item0.$on("SMUI:action", ctx[26]);
      item1 = new Item({
        props: {
          $$slots: {default: [create_default_slot_16]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      item1.$on("SMUI:action", ctx[27]);
      const block = {
        c: function create2() {
          create_component(item0.$$.fragment);
          t2 = space();
          create_component(item1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(item0, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(item1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const item0_changes = {};
          if (dirty[1] & 16384) {
            item0_changes.$$scope = {dirty, ctx: ctx2};
          }
          item0.$set(item0_changes);
          const item1_changes = {};
          if (dirty[1] & 16384) {
            item1_changes.$$scope = {dirty, ctx: ctx2};
          }
          item1.$set(item1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(item0.$$.fragment, local);
          transition_in(item1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(item0.$$.fragment, local);
          transition_out(item1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(item0, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(item1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_15.name,
        type: "slot",
        source: "(451:10) <List>",
        ctx
      });
      return block;
    }
    function create_default_slot_14(ctx) {
      let list;
      let current;
      list = new List({
        props: {
          $$slots: {default: [create_default_slot_15]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(list.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_changes = {};
          if (dirty[0] & 1 | dirty[1] & 16384) {
            list_changes.$$scope = {dirty, ctx: ctx2};
          }
          list.$set(list_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_14.name,
        type: "slot",
        source: '(447:9) <Menu           bind:this={orderMenu}           anchorCorner=\\"TOP_LEFT\\"          >',
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let button0;
      let t0;
      let div;
      let button1;
      let t1;
      let menu;
      let current;
      let mounted;
      let dispose;
      button0 = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          class: "whitespace-nowrap",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button0.$on("click", ctx[24]);
      button1 = new Button_1({
        props: {
          variant: "raised",
          style: "padding: 0; min-width: 36px; background: var(--mdc-theme-callout)",
          $$slots: {default: [create_default_slot_20]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button1.$on("click", ctx[25]);
      let menu_props = {
        anchorCorner: "TOP_LEFT",
        $$slots: {default: [create_default_slot_14]},
        $$scope: {ctx}
      };
      menu = new Menu({props: menu_props, $$inline: true});
      ctx[28](menu);
      const block = {
        c: function create2() {
          create_component(button0.$$.fragment);
          t0 = space();
          div = element("div");
          create_component(button1.$$.fragment);
          t1 = space();
          create_component(menu.$$.fragment);
          add_location(div, file9, 434, 8, 12346);
        },
        m: function mount(target, anchor) {
          mount_component(button0, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          mount_component(button1, div, null);
          append_dev(div, t1);
          mount_component(menu, div, null);
          current = true;
          if (!mounted) {
            dispose = action_destroyer(GroupItem.call(null, div));
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          const button0_changes = {};
          if (dirty[1] & 16384) {
            button0_changes.$$scope = {dirty, ctx: ctx2};
          }
          button0.$set(button0_changes);
          const button1_changes = {};
          if (dirty[1] & 16384) {
            button1_changes.$$scope = {dirty, ctx: ctx2};
          }
          button1.$set(button1_changes);
          const menu_changes = {};
          if (dirty[0] & 1 | dirty[1] & 16384) {
            menu_changes.$$scope = {dirty, ctx: ctx2};
          }
          menu.$set(menu_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(menu.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(menu.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button0, detaching);
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(div);
          destroy_component(button1);
          ctx[28](null);
          destroy_component(menu);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(426:7) <Group>",
        ctx
      });
      return block;
    }
    function create_if_block_42(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[29]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_42.name,
        type: "if",
        source: "(471:9) {#if currentPage > 1}",
        ctx
      });
      return block;
    }
    function create_default_slot_122(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "arrow_back_ios_new";
          attr_dev(span, "class", "material-icons text-sm");
          add_location(span, file9, 476, 13, 13444);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: "(476:11) <Label             >",
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: '(472:10) <Button            on:click={() => currentPage--}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_if_block_32(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[30]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_32.name,
        type: "if",
        source: "(485:9) {#if currentPage - 1 > 0}",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let t_value = ctx[7] - 1 + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128 && t_value !== (t_value = ctx2[7] - 1 + ""))
            set_data_dev(t2, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: "(491:11) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: '(486:10) <Button            on:click={() =>             (currentPage = currentPage - 1)}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t2;
      const block = {
        c: function create2() {
          t2 = text(ctx[7]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128)
            set_data_dev(t2, ctx2[7]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(499:10) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(495:9) <Button           on:click={() => {}}           variant=\\"raised\\"          >',
        ctx
      });
      return block;
    }
    function create_if_block_23(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[31]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_23.name,
        type: "if",
        source: "(501:9) {#if currentPage + 1 <= Math.floor(data.body.length / pageLength) + 1}",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t_value = ctx[7] + 1 + "";
      let t2;
      const block = {
        c: function create2() {
          t2 = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t2, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 128 && t_value !== (t_value = ctx2[7] + 1 + ""))
            set_data_dev(t2, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: "(508:11) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: '(502:10) <Button            on:click={() => {             currentPage = currentPage + 1;            }}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_if_block_13(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", ctx[32]);
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(511:9) {#if data.body.length > pageLength * currentPage}",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "arrow_forward_ios";
          attr_dev(span, "class", "material-icons p-0 text-sm flex justify-center item");
          add_location(span, file9, 517, 13, 14513);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(517:11) <Label             >",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_42]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty[1] & 16384) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: '(511:58) <Button            on:click={() => {             currentPage++;            }}            variant=\\"raised\\"           >',
        ctx
      });
      return block;
    }
    function create_default_slot_25(ctx) {
      let t0;
      let t1;
      let button;
      let t2;
      let show_if = ctx[7] + 1 <= Math.floor(ctx[0].body.length / ctx[9]) + 1;
      let t3;
      let if_block3_anchor;
      let current;
      let if_block0 = ctx[7] > 1 && create_if_block_42(ctx);
      let if_block1 = ctx[7] - 1 > 0 && create_if_block_32(ctx);
      button = new Button_1({
        props: {
          variant: "raised",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button.$on("click", click_handler_5);
      let if_block2 = show_if && create_if_block_23(ctx);
      let if_block3 = ctx[0].body.length > ctx[9] * ctx[7] && create_if_block_13(ctx);
      const block = {
        c: function create2() {
          if (if_block0)
            if_block0.c();
          t0 = space();
          if (if_block1)
            if_block1.c();
          t1 = space();
          create_component(button.$$.fragment);
          t2 = space();
          if (if_block2)
            if_block2.c();
          t3 = space();
          if (if_block3)
            if_block3.c();
          if_block3_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(button, target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block2)
            if_block2.m(target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block3)
            if_block3.m(target, anchor);
          insert_dev(target, if_block3_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[7] > 1) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_42(ctx2);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }
          if (ctx2[7] - 1 > 0) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_32(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t1.parentNode, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          const button_changes = {};
          if (dirty[0] & 128 | dirty[1] & 16384) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
          if (dirty[0] & 641)
            show_if = ctx2[7] + 1 <= Math.floor(ctx2[0].body.length / ctx2[9]) + 1;
          if (show_if) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & 641) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_23(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t3.parentNode, t3);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (ctx2[0].body.length > ctx2[9] * ctx2[7]) {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & 641) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_13(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(button.$$.fragment, local);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(button.$$.fragment, local);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t0);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(button, detaching);
          if (detaching)
            detach_dev(t2);
          if (if_block2)
            if_block2.d(detaching);
          if (detaching)
            detach_dev(t3);
          if (if_block3)
            if_block3.d(detaching);
          if (detaching)
            detach_dev(if_block3_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_25.name,
        type: "slot",
        source: '(470:8) <Group variant=\\"raised\\">',
        ctx
      });
      return block;
    }
    function create_pending_block(ctx) {
      let div;
      let span;
      let t1;
      const block = {
        c: function create2() {
          div = element("div");
          span = element("span");
          span.textContent = "autorenew";
          t1 = text(" Loading");
          attr_dev(span, "class", "material-icons animate-spin");
          add_location(span, file9, 288, 6, 7866);
          attr_dev(div, "class", "w-full flex flex-col justify-center items-center h-96");
          add_location(div, file9, 285, 5, 7780);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_pending_block.name,
        type: "pending",
        source: '(284:24)       <!-- on load -->      <div       class=\\"w-full flex flex-col justify-center items-center h-96\\"      >       <span class=\\"material-icons animate-spin\\">        autorenew       </span> Loading      </div>     {:then returnVal}',
        ctx
      });
      return block;
    }
    function create_default_slot_110(ctx) {
      let div;
      let input;
      let t2;
      let promise2;
      let current;
      let mounted;
      let dispose;
      let info = {
        ctx,
        current: null,
        token: null,
        hasCatch: true,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        value: 34,
        error: 44,
        blocks: [, , ,]
      };
      handle_promise(promise2 = ctx[6], info);
      const block = {
        c: function create2() {
          div = element("div");
          input = element("input");
          t2 = space();
          info.block.c();
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "Suche...");
          attr_dev(input, "class", "p-2 rounded-md w-full");
          add_location(input, file9, 276, 4, 7570);
          attr_dev(div, "class", "flex flex-col gap-4 w-full");
          add_location(div, file9, 275, 3, 7525);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input);
          set_input_value(input, ctx[1]);
          append_dev(div, t2);
          info.block.m(div, info.anchor = null);
          info.mount = () => div;
          info.anchor = null;
          current = true;
          if (!mounted) {
            dispose = listen_dev(input, "input", ctx[19]);
            mounted = true;
          }
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & 2 && input.value !== ctx[1]) {
            set_input_value(input, ctx[1]);
          }
          info.ctx = ctx;
          if (dirty[0] & 64 && promise2 !== (promise2 = ctx[6]) && handle_promise(promise2, info))
            ;
          else {
            update_await_block_branch(info, ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(info.block);
          current = true;
        },
        o: function outro(local) {
          for (let i2 = 0; i2 < 3; i2 += 1) {
            const block2 = info.blocks[i2];
            transition_out(block2);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          info.block.d();
          info.token = null;
          info = null;
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_110.name,
        type: "slot",
        source: "(275:2) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot8(ctx) {
      let title;
      let t2;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_24]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_110]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t2 = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty[1] & 16384) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty[0] & 1023 | dirty[1] & 16384) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot8.name,
        type: "slot",
        source: "(273:1) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let section_1;
      let paper;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot8]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section_1 = element("section");
          create_component(paper.$$.fragment);
          attr_dev(section_1, "class", "flex flex-col gap-4 md:w-10/12 w-full mx-auto");
          add_location(section_1, file9, 271, 0, 7352);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section_1, anchor);
          mount_component(paper, section_1, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const paper_changes = {};
          if (dirty[0] & 1023 | dirty[1] & 16384) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section_1);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var click_handler_5 = () => {
    };
    function instance8($$self, $$props, $$invalidate) {
      let pageLength;
      let sort;
      let $userSettings;
      let $user;
      let $redirect;
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(15, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(16, $user = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(33, $redirect = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Pages", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      let data = {body: [], head: []};
      let orderMenu;
      let searchInputText;
      let tableWhitelist = ["id", "product"];
      let labels = [
        {key: "id", text: "ID"},
        {key: "product", text: "Produkt"},
        {
          key: "tomorrow_order_range",
          text: "Vorschlag Morgen"
        },
        {
          key: "tomorrow_order_qty",
          text: "Bestellung Morgen"
        },
        {
          key: "day_after_order_range",
          text: "Vorschlag \xDCbermorgen"
        },
        {
          key: "day_after_order_qty",
          text: "Bestellung \xDCbermorgen"
        },
        {
          key: "next7_order_range",
          text: "Vorschlag Woche"
        },
        {
          key: "next7_order_qty",
          text: "Bestellung Woche"
        }
      ];
      let dataTypes = [
        {
          key: "day_after_order_qty",
          type: "number"
        },
        {
          key: "tomorrow_order_qty",
          type: "number"
        },
        {key: "next7_order_qty", type: "number"}
      ];
      let dataPromise = new Promise(() => {
      });
      let sortBy = {col: "id", ascending: true};
      let currentPage = 1;
      let section;
      async function order(option, data2) {
        let orderUrl = `${backendURL}/api/order`;
        let resType;
        let filename = `Foodsight_Bestellung.${option}`;
        if (option === "xlsx") {
          resType = "arraybuffer";
        } else if (option === "csv") {
          resType = "text";
        }
        let orderOption;
        if ($userSettings?.tomorrow) {
          orderOption = "tomorrow";
        } else if ($userSettings?.day_after_tomorrow) {
          orderOption = "day_after_tomorrow";
        } else if ($userSettings?.next_seven_days) {
          orderOption = "next_seven_days";
        }
        axios({
          url: orderUrl,
          method: "POST",
          responseType: resType,
          data: {option, order_option: orderOption, data: data2}
        }).then((response) => {
          const url2 = window.URL.createObjectURL(new Blob([response.data]));
          const link = document.createElement("a");
          link.href = url2;
          link.setAttribute("download", filename);
          document.body.appendChild(link);
          link.click();
        });
      }
      function dataChanger(node, returnVal) {
        $$invalidate(0, data = returnVal);
      }
      function autoCache(node, data2) {
        return {
          update(data3) {
            if (!Object.keys($userSettings))
              return;
            let dataUrl;
            if ($user && Object.keys($user).length) {
              dataUrl = `${backendURL}/api/forecast/?store=${$userSettings.store}`;
            }
            localStorage.setItem(dataUrl, JSON.stringify({user: $user, data: data3}));
          }
        };
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console_12.warn(`<Pages> was created with unknown prop '${key}'`);
      });
      const func5 = (field, item) => item.key === field;
      const func_13 = (field, item) => item.key === field;
      function input_input_handler() {
        searchInputText = this.value;
        $$invalidate(1, searchInputText);
      }
      const func_2 = (col, item) => item.key === col;
      const click_handler = (col) => {
        $$invalidate(0, data.body = sort(data.body, col), data);
      };
      function textfield_value_binding(value, item, field) {
        if ($$self.$$.not_equal(item[field], value)) {
          item[field] = value;
          $$invalidate(0, data);
        }
      }
      function section_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          section = $$value;
          $$invalidate(8, section);
        });
      }
      const click_handler_1 = () => order("xlsx", data.body);
      const click_handler_2 = () => orderMenu.setOpen(true);
      const SMUI_action_handler = () => order("xlsx", data.body);
      const SMUI_action_handler_1 = () => order("csv", data.body);
      function menu_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          orderMenu = $$value;
          $$invalidate(5, orderMenu);
        });
      }
      const click_handler_3 = () => $$invalidate(7, currentPage--, currentPage);
      const click_handler_4 = () => $$invalidate(7, currentPage = currentPage - 1);
      const click_handler_6 = () => {
        $$invalidate(7, currentPage = currentPage + 1);
      };
      const click_handler_7 = () => {
        $$invalidate(7, currentPage++, currentPage);
      };
      $$self.$capture_state = () => ({
        axios,
        Paper,
        Title,
        Content,
        user,
        userSettings,
        backendURL,
        Menu,
        Button: Button_1,
        Group,
        GroupItem,
        Label: CommonLabel,
        Icon: CommonIcon,
        List,
        Item,
        Text,
        search,
        blur,
        fade,
        Textfield,
        redirect,
        onMount,
        data,
        orderMenu,
        searchInputText,
        tableWhitelist,
        labels,
        dataTypes,
        dataPromise,
        sortBy,
        currentPage,
        section,
        order,
        dataChanger,
        autoCache,
        sort,
        pageLength,
        $userSettings,
        $user,
        $redirect
      });
      $$self.$inject_state = ($$props2) => {
        if ("data" in $$props2)
          $$invalidate(0, data = $$props2.data);
        if ("orderMenu" in $$props2)
          $$invalidate(5, orderMenu = $$props2.orderMenu);
        if ("searchInputText" in $$props2)
          $$invalidate(1, searchInputText = $$props2.searchInputText);
        if ("tableWhitelist" in $$props2)
          $$invalidate(2, tableWhitelist = $$props2.tableWhitelist);
        if ("labels" in $$props2)
          $$invalidate(10, labels = $$props2.labels);
        if ("dataTypes" in $$props2)
          $$invalidate(11, dataTypes = $$props2.dataTypes);
        if ("dataPromise" in $$props2)
          $$invalidate(6, dataPromise = $$props2.dataPromise);
        if ("sortBy" in $$props2)
          $$invalidate(3, sortBy = $$props2.sortBy);
        if ("currentPage" in $$props2)
          $$invalidate(7, currentPage = $$props2.currentPage);
        if ("section" in $$props2)
          $$invalidate(8, section = $$props2.section);
        if ("sort" in $$props2)
          $$invalidate(4, sort = $$props2.sort);
        if ("pageLength" in $$props2)
          $$invalidate(9, pageLength = $$props2.pageLength);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 32768) {
          $$invalidate(9, pageLength = $userSettings?.rows_per_page || 10);
        }
        if ($$self.$$.dirty[0] & 98306) {
          $$invalidate(6, dataPromise = new Promise(async (res, rej) => {
            if (!$userSettings || !Object.keys($userSettings).length || !$userSettings.store) {
              rej("userSettings Not Defined");
              return;
            }
            let dataUrl;
            let keys = [];
            try {
              if ($user && Object.keys($user).length) {
                dataUrl = `${backendURL}/api/forecast/?store=${$userSettings.store}`;
              } else {
                dataUrl = `tableDataStore${$userSettings.store}.json`;
              }
              let result;
              if (localStorage.getItem(dataUrl) && JSON.stringify(JSON.parse(localStorage.getItem(dataUrl)).user) === JSON.stringify($user) && new Date(JSON.parse(localStorage.getItem(dataUrl)).data.timestamp).getUTCDate() === new Date().getUTCDate()) {
                let searchedData = search(JSON.parse(localStorage.getItem(dataUrl)).data.body, ["id", "product"], searchInputText);
                res({
                  body: searchedData,
                  head: JSON.parse(localStorage.getItem(dataUrl)).data.head,
                  timestamp: JSON.parse(localStorage.getItem(dataUrl)).data.timestamp
                });
              } else {
                result = await axios.get(dataUrl);
                result.data.forEach((val) => {
                  Object.keys(val).forEach((ob) => {
                    if (!keys.includes(ob)) {
                      keys.push(ob);
                    }
                  });
                });
                localStorage.setItem(dataUrl, JSON.stringify({
                  user: $user,
                  data: {
                    body: result.data,
                    head: keys,
                    timestamp: Date.now()
                  }
                }));
                let cachedStores = JSON.parse(localStorage.getItem("cachedStores")) || [];
                localStorage.setItem("cachedStores", JSON.stringify([...cachedStores, dataUrl]));
                let searchedData = search(result.data, ["id", "product"], searchInputText);
                res({
                  body: searchedData,
                  head: keys,
                  timestamp: Date.now()
                });
              }
            } catch (er) {
              console.log(er);
            }
          }));
        }
        if ($$self.$$.dirty[0] & 65536) {
          {
            let cachedStores = JSON.parse(localStorage.getItem("cachedStores")) || [];
            if (cachedStores.length) {
              cachedStores.forEach((key) => {
                let item = JSON.parse(localStorage.getItem(key));
                if (JSON.stringify(item?.user) != JSON.stringify($user)) {
                  localStorage.removeItem(key);
                  cachedStores = cachedStores.filter((item2) => {
                    return item2 != key;
                  });
                }
              });
              localStorage.setItem("cachedStores", JSON.stringify([...new Set(cachedStores)]));
            }
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.next_seven_days) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "next7_order_range", "next7_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["next7_order_range", "next7_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.day_after_tomorrow) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "day_after_order_range", "day_after_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["day_after_order_range", "day_after_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 32772) {
          if ($userSettings?.tomorrow) {
            $$invalidate(2, tableWhitelist = [...tableWhitelist, "tomorrow_order_range", "tomorrow_order_qty"]);
          } else {
            tableWhitelist.filter((item) => !["tomorrow_order_range", "tomorrow_order_qty"].includes(item));
          }
        }
        if ($$self.$$.dirty[0] & 8) {
          $$invalidate(4, sort = (data2, column) => {
            if (sortBy.col == column) {
              $$invalidate(3, sortBy.ascending = !sortBy.ascending, sortBy);
            } else {
              $$invalidate(3, sortBy.col = column, sortBy);
              $$invalidate(3, sortBy.ascending = true, sortBy);
            }
            let sortModifier = sortBy.ascending ? 1 : -1;
            let sort2 = (a2, b2) => a2[column] < b2[column] ? -1 * sortModifier : a2[column] > b2[column] ? 1 * sortModifier : 0;
            return data2.sort(sort2);
          });
        }
      };
      return [
        data,
        searchInputText,
        tableWhitelist,
        sortBy,
        sort,
        orderMenu,
        dataPromise,
        currentPage,
        section,
        pageLength,
        labels,
        dataTypes,
        order,
        dataChanger,
        autoCache,
        $userSettings,
        $user,
        func5,
        func_13,
        input_input_handler,
        func_2,
        click_handler,
        textfield_value_binding,
        section_1_binding,
        click_handler_1,
        click_handler_2,
        SMUI_action_handler,
        SMUI_action_handler_1,
        menu_binding,
        click_handler_3,
        click_handler_4,
        click_handler_6,
        click_handler_7
      ];
    }
    var Pages = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {}, add_css2, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Pages",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/settings.js
  var require_settings = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Settings
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    var file$52 = "node_modules/@smui/common/Hr.svelte";
    function create_fragment$73(ctx) {
      let hr;
      let useActions_action;
      let t;
      let current;
      let mounted;
      let dispose;
      let hr_levels = [ctx[3]];
      let hr_data = {};
      for (let i = 0; i < hr_levels.length; i += 1) {
        hr_data = assign(hr_data, hr_levels[i]);
      }
      const default_slot_template = ctx[6].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
      const block = {
        c: function create2() {
          hr = element("hr");
          t = space();
          if (default_slot)
            default_slot.c();
          set_attributes(hr, hr_data);
          add_location(hr, file$52, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, hr, anchor);
          ctx[7](hr);
          insert_dev(target, t, anchor);
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, hr, ctx[0])),
              action_destroyer(ctx[2].call(null, hr))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          set_attributes(hr, hr_data = get_spread_update(hr_levels, [dirty & 8 && ctx2[3]]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 32)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(hr);
          ctx[7](null);
          if (detaching)
            detach_dev(t);
          if (default_slot)
            default_slot.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$73.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$36($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Hr", slots, ["default"]);
      let {use: use2 = []} = $$props;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let element2 = null;
      function getElement() {
        return element2;
      }
      function hr_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(1, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("$$scope" in $$new_props)
          $$invalidate(5, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder,
        useActions,
        use: use2,
        forwardEvents,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("element" in $$props)
          $$invalidate(1, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        hr_binding
      ];
    }
    var Hr = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$36, create_fragment$73, safe_not_equal, {use: 0, getElement: 4});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Hr",
          options,
          id: create_fragment$73.name
        });
      }
      get use() {
        throw new Error("<Hr>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Hr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[4];
      }
      set getElement(value) {
        throw new Error("<Hr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function create_fragment$64(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
        {
          use: [ctx[9], ...ctx[0]]
        },
        {
          class: classMap4({
            [ctx[1]]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": ctx[2],
            "mdc-deprecated-list-divider--inset": ctx[3],
            "mdc-deprecated-list-divider--inset-leading": ctx[4],
            "mdc-deprecated-list-divider--inset-trailing": ctx[5],
            "mdc-deprecated-list-divider--inset-padding": ctx[6]
          })
        },
        {role: "separator"},
        ctx[10]
      ];
      var switch_value = ctx[7];
      function switch_props(ctx2) {
        let switch_instance_props = {};
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }
        return {
          props: switch_instance_props,
          $$inline: true
        };
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props());
        ctx[12](switch_instance);
      }
      const block = {
        c: function create2() {
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }
          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const switch_instance_changes = dirty & 1663 ? get_spread_update(switch_instance_spread_levels, [
            dirty & 513 && {
              use: [ctx2[9], ...ctx2[0]]
            },
            dirty & 126 && {
              class: classMap4({
                [ctx2[1]]: true,
                "mdc-deprecated-list-divider": true,
                "mdc-deprecated-list-divider--padded": ctx2[2],
                "mdc-deprecated-list-divider--inset": ctx2[3],
                "mdc-deprecated-list-divider--inset-leading": ctx2[4],
                "mdc-deprecated-list-divider--inset-trailing": ctx2[5],
                "mdc-deprecated-list-divider--inset-padding": ctx2[6]
              })
            },
            switch_instance_spread_levels[2],
            dirty & 1024 && get_spread_object(ctx2[10])
          ]) : {};
          if (switch_value !== (switch_value = ctx2[7])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              ctx2[12](switch_instance);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[12](null);
          if (detaching)
            detach_dev(switch_instance_anchor);
          if (switch_instance)
            destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$64.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "padded",
        "inset",
        "insetLeading",
        "insetTrailing",
        "insetPadding",
        "component",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Separator", slots, []);
      const forwardEvents = forwardEventsBuilder4(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {padded = false} = $$props;
      let {inset = false} = $$props;
      let {insetLeading = false} = $$props;
      let {insetTrailing = false} = $$props;
      let {insetPadding = false} = $$props;
      let element2;
      let nav = getContext("SMUI:list:item:nav");
      let context = getContext("SMUI:separator:context");
      let {component = nav || context !== "list" ? Hr : Li} = $$props;
      function getElement() {
        return element2.getElement();
      }
      function switch_instance_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(8, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("padded" in $$new_props)
          $$invalidate(2, padded = $$new_props.padded);
        if ("inset" in $$new_props)
          $$invalidate(3, inset = $$new_props.inset);
        if ("insetLeading" in $$new_props)
          $$invalidate(4, insetLeading = $$new_props.insetLeading);
        if ("insetTrailing" in $$new_props)
          $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
        if ("insetPadding" in $$new_props)
          $$invalidate(6, insetPadding = $$new_props.insetPadding);
        if ("component" in $$new_props)
          $$invalidate(7, component = $$new_props.component);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder4,
        classMap: classMap4,
        Li,
        Hr,
        forwardEvents,
        use: use2,
        className,
        padded,
        inset,
        insetLeading,
        insetTrailing,
        insetPadding,
        element: element2,
        nav,
        context,
        component,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("padded" in $$props)
          $$invalidate(2, padded = $$new_props.padded);
        if ("inset" in $$props)
          $$invalidate(3, inset = $$new_props.inset);
        if ("insetLeading" in $$props)
          $$invalidate(4, insetLeading = $$new_props.insetLeading);
        if ("insetTrailing" in $$props)
          $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
        if ("insetPadding" in $$props)
          $$invalidate(6, insetPadding = $$new_props.insetPadding);
        if ("element" in $$props)
          $$invalidate(8, element2 = $$new_props.element);
        if ("nav" in $$props)
          nav = $$new_props.nav;
        if ("context" in $$props)
          context = $$new_props.context;
        if ("component" in $$props)
          $$invalidate(7, component = $$new_props.component);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        padded,
        inset,
        insetLeading,
        insetTrailing,
        insetPadding,
        component,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        switch_instance_binding
      ];
    }
    var Separator = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$64, safe_not_equal, {
          use: 0,
          class: 1,
          padded: 2,
          inset: 3,
          insetLeading: 4,
          insetTrailing: 5,
          insetPadding: 6,
          component: 7,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Separator",
          options,
          id: create_fragment$64.name
        });
      }
      get use() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get padded() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set padded(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get inset() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set inset(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetLeading() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetLeading(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetTrailing() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetTrailing(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get insetPadding() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set insetPadding(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get component() {
        throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set component(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$3 = {
      DISABLED: "mdc-slider--disabled",
      DISCRETE: "mdc-slider--discrete",
      INPUT: "mdc-slider__input",
      RANGE: "mdc-slider--range",
      THUMB: "mdc-slider__thumb",
      THUMB_FOCUSED: "mdc-slider__thumb--focused",
      THUMB_KNOB: "mdc-slider__thumb-knob",
      THUMB_TOP: "mdc-slider__thumb--top",
      THUMB_WITH_INDICATOR: "mdc-slider__thumb--with-indicator",
      TICK_MARKS: "mdc-slider--tick-marks",
      TICK_MARKS_CONTAINER: "mdc-slider__tick-marks",
      TICK_MARK_ACTIVE: "mdc-slider__tick-mark--active",
      TICK_MARK_INACTIVE: "mdc-slider__tick-mark--inactive",
      TRACK: "mdc-slider__track",
      TRACK_ACTIVE: "mdc-slider__track--active_fill",
      VALUE_INDICATOR_TEXT: "mdc-slider__value-indicator-text"
    };
    var numbers$12 = {
      STEP_SIZE: 1,
      THUMB_UPDATE_MIN_PX: 5
    };
    var attributes = {
      ARIA_VALUETEXT: "aria-valuetext",
      INPUT_DISABLED: "disabled",
      INPUT_MIN: "min",
      INPUT_MAX: "max",
      INPUT_VALUE: "value",
      INPUT_STEP: "step"
    };
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var TickMark;
    (function(TickMark2) {
      TickMark2[TickMark2["ACTIVE"] = 0] = "ACTIVE";
      TickMark2[TickMark2["INACTIVE"] = 1] = "INACTIVE";
    })(TickMark || (TickMark = {}));
    var Thumb;
    (function(Thumb2) {
      Thumb2[Thumb2["START"] = 1] = "START";
      Thumb2[Thumb2["END"] = 2] = "END";
    })(Thumb || (Thumb = {}));
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var AnimationKeys;
    (function(AnimationKeys2) {
      AnimationKeys2["SLIDER_UPDATE"] = "slider_update";
    })(AnimationKeys || (AnimationKeys = {}));
    var HAS_WINDOW = typeof window !== "undefined";
    var MDCSliderFoundation = function(_super) {
      __extends(MDCSliderFoundation2, _super);
      function MDCSliderFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCSliderFoundation2.defaultAdapter), adapter)) || this;
        _this.initialStylesRemoved = false;
        _this.isDisabled = false;
        _this.isDiscrete = false;
        _this.step = numbers$12.STEP_SIZE;
        _this.hasTickMarks = false;
        _this.isRange = false;
        _this.thumb = null;
        _this.downEventClientX = null;
        _this.startThumbKnobWidth = 0;
        _this.endThumbKnobWidth = 0;
        _this.animFrame = new AnimationFrame();
        return _this;
      }
      Object.defineProperty(MDCSliderFoundation2, "defaultAdapter", {
        get: function() {
          return {
            hasClass: function() {
              return false;
            },
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            addThumbClass: function() {
              return void 0;
            },
            removeThumbClass: function() {
              return void 0;
            },
            getAttribute: function() {
              return null;
            },
            getInputValue: function() {
              return "";
            },
            setInputValue: function() {
              return void 0;
            },
            getInputAttribute: function() {
              return null;
            },
            setInputAttribute: function() {
              return null;
            },
            removeInputAttribute: function() {
              return null;
            },
            focusInput: function() {
              return void 0;
            },
            isInputFocused: function() {
              return false;
            },
            getThumbKnobWidth: function() {
              return 0;
            },
            getThumbBoundingClientRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            getBoundingClientRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            isRTL: function() {
              return false;
            },
            setThumbStyleProperty: function() {
              return void 0;
            },
            removeThumbStyleProperty: function() {
              return void 0;
            },
            setTrackActiveStyleProperty: function() {
              return void 0;
            },
            removeTrackActiveStyleProperty: function() {
              return void 0;
            },
            setValueIndicatorText: function() {
              return void 0;
            },
            getValueToAriaValueTextFn: function() {
              return null;
            },
            updateTickMarks: function() {
              return void 0;
            },
            setPointerCapture: function() {
              return void 0;
            },
            emitChangeEvent: function() {
              return void 0;
            },
            emitInputEvent: function() {
              return void 0;
            },
            emitDragStartEvent: function() {
              return void 0;
            },
            emitDragEndEvent: function() {
              return void 0;
            },
            registerEventHandler: function() {
              return void 0;
            },
            deregisterEventHandler: function() {
              return void 0;
            },
            registerThumbEventHandler: function() {
              return void 0;
            },
            deregisterThumbEventHandler: function() {
              return void 0;
            },
            registerInputEventHandler: function() {
              return void 0;
            },
            deregisterInputEventHandler: function() {
              return void 0;
            },
            registerBodyEventHandler: function() {
              return void 0;
            },
            deregisterBodyEventHandler: function() {
              return void 0;
            },
            registerWindowEventHandler: function() {
              return void 0;
            },
            deregisterWindowEventHandler: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSliderFoundation2.prototype.init = function() {
        var _this = this;
        this.isDisabled = this.adapter.hasClass(cssClasses$3.DISABLED);
        this.isDiscrete = this.adapter.hasClass(cssClasses$3.DISCRETE);
        this.hasTickMarks = this.adapter.hasClass(cssClasses$3.TICK_MARKS);
        this.isRange = this.adapter.hasClass(cssClasses$3.RANGE);
        var min = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MIN, this.isRange ? Thumb.START : Thumb.END), attributes.INPUT_MIN);
        var max = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MAX, Thumb.END), attributes.INPUT_MAX);
        var value = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.END), attributes.INPUT_VALUE);
        var valueStart = this.isRange ? this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.START), attributes.INPUT_VALUE) : min;
        var stepAttr = this.adapter.getInputAttribute(attributes.INPUT_STEP, Thumb.END);
        var step = stepAttr ? this.convertAttributeValueToNumber(stepAttr, attributes.INPUT_STEP) : this.step;
        this.validateProperties({min, max, value, valueStart, step});
        this.min = min;
        this.max = max;
        this.value = value;
        this.valueStart = valueStart;
        this.step = step;
        this.numDecimalPlaces = getNumDecimalPlaces(this.step);
        this.valueBeforeDownEvent = value;
        this.valueStartBeforeDownEvent = valueStart;
        this.mousedownOrTouchstartListener = this.handleMousedownOrTouchstart.bind(this);
        this.moveListener = this.handleMove.bind(this);
        this.pointerdownListener = this.handlePointerdown.bind(this);
        this.pointerupListener = this.handlePointerup.bind(this);
        this.thumbMouseenterListener = this.handleThumbMouseenter.bind(this);
        this.thumbMouseleaveListener = this.handleThumbMouseleave.bind(this);
        this.inputStartChangeListener = function() {
          _this.handleInputChange(Thumb.START);
        };
        this.inputEndChangeListener = function() {
          _this.handleInputChange(Thumb.END);
        };
        this.inputStartFocusListener = function() {
          _this.handleInputFocus(Thumb.START);
        };
        this.inputEndFocusListener = function() {
          _this.handleInputFocus(Thumb.END);
        };
        this.inputStartBlurListener = function() {
          _this.handleInputBlur(Thumb.START);
        };
        this.inputEndBlurListener = function() {
          _this.handleInputBlur(Thumb.END);
        };
        this.resizeListener = this.handleResize.bind(this);
        this.registerEventHandlers();
      };
      MDCSliderFoundation2.prototype.destroy = function() {
        this.deregisterEventHandlers();
      };
      MDCSliderFoundation2.prototype.getMin = function() {
        return this.min;
      };
      MDCSliderFoundation2.prototype.getMax = function() {
        return this.max;
      };
      MDCSliderFoundation2.prototype.getValue = function() {
        return this.value;
      };
      MDCSliderFoundation2.prototype.setValue = function(value) {
        if (this.isRange && value < this.valueStart) {
          throw new Error("end thumb value (" + value + ") must be >= start thumb " + ("value (" + this.valueStart + ")"));
        }
        this.updateValue(value, Thumb.END);
      };
      MDCSliderFoundation2.prototype.getValueStart = function() {
        if (!this.isRange) {
          throw new Error("`valueStart` is only applicable for range sliders.");
        }
        return this.valueStart;
      };
      MDCSliderFoundation2.prototype.setValueStart = function(valueStart) {
        if (!this.isRange) {
          throw new Error("`valueStart` is only applicable for range sliders.");
        }
        if (this.isRange && valueStart > this.value) {
          throw new Error("start thumb value (" + valueStart + ") must be <= end thumb " + ("value (" + this.value + ")"));
        }
        this.updateValue(valueStart, Thumb.START);
      };
      MDCSliderFoundation2.prototype.getStep = function() {
        return this.step;
      };
      MDCSliderFoundation2.prototype.getDisabled = function() {
        return this.isDisabled;
      };
      MDCSliderFoundation2.prototype.setDisabled = function(disabled) {
        this.isDisabled = disabled;
        if (disabled) {
          this.adapter.addClass(cssClasses$3.DISABLED);
          if (this.isRange) {
            this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.START);
          }
          this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.END);
        } else {
          this.adapter.removeClass(cssClasses$3.DISABLED);
          if (this.isRange) {
            this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.START);
          }
          this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.END);
        }
      };
      MDCSliderFoundation2.prototype.getIsRange = function() {
        return this.isRange;
      };
      MDCSliderFoundation2.prototype.layout = function(_a2) {
        var _b2 = _a2 === void 0 ? {} : _a2, skipUpdateUI = _b2.skipUpdateUI;
        this.rect = this.adapter.getBoundingClientRect();
        if (this.isRange) {
          this.startThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.START);
          this.endThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.END);
        }
        if (!skipUpdateUI) {
          this.updateUI();
        }
      };
      MDCSliderFoundation2.prototype.handleResize = function() {
        this.layout();
      };
      MDCSliderFoundation2.prototype.handleDown = function(event) {
        if (this.isDisabled)
          return;
        this.valueStartBeforeDownEvent = this.valueStart;
        this.valueBeforeDownEvent = this.value;
        var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
        this.downEventClientX = clientX;
        var value = this.mapClientXOnSliderScale(clientX);
        this.thumb = this.getThumbFromDownEvent(clientX, value);
        if (this.thumb === null)
          return;
        this.handleDragStart(event, value, this.thumb);
        this.updateValue(value, this.thumb, {emitInputEvent: true});
      };
      MDCSliderFoundation2.prototype.handleMove = function(event) {
        if (this.isDisabled)
          return;
        event.preventDefault();
        var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
        var dragAlreadyStarted = this.thumb != null;
        this.thumb = this.getThumbFromMoveEvent(clientX);
        if (this.thumb === null)
          return;
        var value = this.mapClientXOnSliderScale(clientX);
        if (!dragAlreadyStarted) {
          this.handleDragStart(event, value, this.thumb);
          this.adapter.emitDragStartEvent(value, this.thumb);
        }
        this.updateValue(value, this.thumb, {emitInputEvent: true});
      };
      MDCSliderFoundation2.prototype.handleUp = function() {
        if (this.isDisabled || this.thumb === null)
          return;
        var oldValue = this.thumb === Thumb.START ? this.valueStartBeforeDownEvent : this.valueBeforeDownEvent;
        var newValue = this.thumb === Thumb.START ? this.valueStart : this.value;
        if (oldValue !== newValue) {
          this.adapter.emitChangeEvent(newValue, this.thumb);
        }
        this.adapter.emitDragEndEvent(newValue, this.thumb);
        this.thumb = null;
      };
      MDCSliderFoundation2.prototype.handleThumbMouseenter = function() {
        if (!this.isDiscrete || !this.isRange)
          return;
        this.adapter.addThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, Thumb.START);
        this.adapter.addThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, Thumb.END);
      };
      MDCSliderFoundation2.prototype.handleThumbMouseleave = function() {
        if (!this.isDiscrete || !this.isRange)
          return;
        if (this.adapter.isInputFocused(Thumb.START) || this.adapter.isInputFocused(Thumb.END)) {
          return;
        }
        this.adapter.removeThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, Thumb.START);
        this.adapter.removeThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, Thumb.END);
      };
      MDCSliderFoundation2.prototype.handleMousedownOrTouchstart = function(event) {
        var _this = this;
        var moveEventType = event.type === "mousedown" ? "mousemove" : "touchmove";
        this.adapter.registerBodyEventHandler(moveEventType, this.moveListener);
        var upHandler = function() {
          _this.handleUp();
          _this.adapter.deregisterBodyEventHandler(moveEventType, _this.moveListener);
          _this.adapter.deregisterEventHandler("mouseup", upHandler);
          _this.adapter.deregisterEventHandler("touchend", upHandler);
        };
        this.adapter.registerBodyEventHandler("mouseup", upHandler);
        this.adapter.registerBodyEventHandler("touchend", upHandler);
        this.handleDown(event);
      };
      MDCSliderFoundation2.prototype.handlePointerdown = function(event) {
        this.adapter.setPointerCapture(event.pointerId);
        this.adapter.registerEventHandler("pointermove", this.moveListener);
        this.handleDown(event);
      };
      MDCSliderFoundation2.prototype.handleInputChange = function(thumb) {
        var value = Number(this.adapter.getInputValue(thumb));
        if (thumb === Thumb.START) {
          this.setValueStart(value);
        } else {
          this.setValue(value);
        }
        this.adapter.emitChangeEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
        this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
      };
      MDCSliderFoundation2.prototype.handleInputFocus = function(thumb) {
        this.adapter.addThumbClass(cssClasses$3.THUMB_FOCUSED, thumb);
        if (!this.isDiscrete)
          return;
        this.adapter.addThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, thumb);
        if (this.isRange) {
          var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
          this.adapter.addThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, otherThumb);
        }
      };
      MDCSliderFoundation2.prototype.handleInputBlur = function(thumb) {
        this.adapter.removeThumbClass(cssClasses$3.THUMB_FOCUSED, thumb);
        if (!this.isDiscrete)
          return;
        this.adapter.removeThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, thumb);
        if (this.isRange) {
          var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
          this.adapter.removeThumbClass(cssClasses$3.THUMB_WITH_INDICATOR, otherThumb);
        }
      };
      MDCSliderFoundation2.prototype.handleDragStart = function(event, value, thumb) {
        this.adapter.focusInput(thumb);
        event.preventDefault();
        this.adapter.emitDragStartEvent(value, thumb);
      };
      MDCSliderFoundation2.prototype.getThumbFromDownEvent = function(clientX, value) {
        if (!this.isRange)
          return Thumb.END;
        var thumbStartRect = this.adapter.getThumbBoundingClientRect(Thumb.START);
        var thumbEndRect = this.adapter.getThumbBoundingClientRect(Thumb.END);
        var inThumbStartBounds = clientX >= thumbStartRect.left && clientX <= thumbStartRect.right;
        var inThumbEndBounds = clientX >= thumbEndRect.left && clientX <= thumbEndRect.right;
        if (inThumbStartBounds && inThumbEndBounds) {
          return null;
        }
        if (inThumbStartBounds) {
          return Thumb.START;
        }
        if (inThumbEndBounds) {
          return Thumb.END;
        }
        if (value < this.valueStart) {
          return Thumb.START;
        }
        if (value > this.value) {
          return Thumb.END;
        }
        return value - this.valueStart <= this.value - value ? Thumb.START : Thumb.END;
      };
      MDCSliderFoundation2.prototype.getThumbFromMoveEvent = function(clientX) {
        if (this.thumb !== null)
          return this.thumb;
        if (this.downEventClientX === null) {
          throw new Error("`downEventClientX` is null after move event.");
        }
        var moveDistanceUnderThreshold = Math.abs(this.downEventClientX - clientX) < numbers$12.THUMB_UPDATE_MIN_PX;
        if (moveDistanceUnderThreshold)
          return this.thumb;
        var draggedThumbToLeft = clientX < this.downEventClientX;
        if (draggedThumbToLeft) {
          return this.adapter.isRTL() ? Thumb.END : Thumb.START;
        } else {
          return this.adapter.isRTL() ? Thumb.START : Thumb.END;
        }
      };
      MDCSliderFoundation2.prototype.updateUI = function(thumb) {
        this.updateThumbAndInputAttributes(thumb);
        this.updateThumbAndTrackUI(thumb);
        this.updateValueIndicatorUI(thumb);
        this.updateTickMarksUI();
      };
      MDCSliderFoundation2.prototype.updateThumbAndInputAttributes = function(thumb) {
        if (!thumb)
          return;
        var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
        var valueStr = String(value);
        this.adapter.setInputAttribute(attributes.INPUT_VALUE, valueStr, thumb);
        if (this.isRange && thumb === Thumb.START) {
          this.adapter.setInputAttribute(attributes.INPUT_MIN, valueStr, Thumb.END);
        } else if (this.isRange && thumb === Thumb.END) {
          this.adapter.setInputAttribute(attributes.INPUT_MAX, valueStr, Thumb.START);
        }
        if (this.adapter.getInputValue(thumb) !== valueStr) {
          this.adapter.setInputValue(valueStr, thumb);
        }
        var valueToAriaValueTextFn = this.adapter.getValueToAriaValueTextFn();
        if (valueToAriaValueTextFn) {
          this.adapter.setInputAttribute(attributes.ARIA_VALUETEXT, valueToAriaValueTextFn(value), thumb);
        }
      };
      MDCSliderFoundation2.prototype.updateValueIndicatorUI = function(thumb) {
        if (!this.isDiscrete)
          return;
        var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
        this.adapter.setValueIndicatorText(value, thumb === Thumb.START ? Thumb.START : Thumb.END);
        if (!thumb && this.isRange) {
          this.adapter.setValueIndicatorText(this.valueStart, Thumb.START);
        }
      };
      MDCSliderFoundation2.prototype.updateTickMarksUI = function() {
        if (!this.isDiscrete || !this.hasTickMarks)
          return;
        var numTickMarksInactiveStart = (this.valueStart - this.min) / this.step;
        var numTickMarksActive = (this.value - this.valueStart) / this.step + 1;
        var numTickMarksInactiveEnd = (this.max - this.value) / this.step;
        var tickMarksInactiveStart = Array.from({length: numTickMarksInactiveStart}).fill(TickMark.INACTIVE);
        var tickMarksActive = Array.from({length: numTickMarksActive}).fill(TickMark.ACTIVE);
        var tickMarksInactiveEnd = Array.from({length: numTickMarksInactiveEnd}).fill(TickMark.INACTIVE);
        this.adapter.updateTickMarks(tickMarksInactiveStart.concat(tickMarksActive).concat(tickMarksInactiveEnd));
      };
      MDCSliderFoundation2.prototype.mapClientXOnSliderScale = function(clientX) {
        var xPos = clientX - this.rect.left;
        var pctComplete = xPos / this.rect.width;
        if (this.adapter.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        var value = this.min + pctComplete * (this.max - this.min);
        if (value === this.max || value === this.min) {
          return value;
        }
        return Number(this.quantize(value).toFixed(this.numDecimalPlaces));
      };
      MDCSliderFoundation2.prototype.quantize = function(value) {
        var numSteps = Math.round((value - this.min) / this.step);
        return this.min + numSteps * this.step;
      };
      MDCSliderFoundation2.prototype.updateValue = function(value, thumb, _a2) {
        var _b2 = _a2 === void 0 ? {} : _a2, emitInputEvent = _b2.emitInputEvent;
        value = this.clampValue(value, thumb);
        if (this.isRange && thumb === Thumb.START) {
          if (this.valueStart === value)
            return;
          this.valueStart = value;
        } else {
          if (this.value === value)
            return;
          this.value = value;
        }
        this.updateUI(thumb);
        if (emitInputEvent) {
          this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
        }
      };
      MDCSliderFoundation2.prototype.clampValue = function(value, thumb) {
        value = Math.min(Math.max(value, this.min), this.max);
        var thumbStartMovedPastThumbEnd = this.isRange && thumb === Thumb.START && value > this.value;
        if (thumbStartMovedPastThumbEnd) {
          return this.value;
        }
        var thumbEndMovedPastThumbStart = this.isRange && thumb === Thumb.END && value < this.valueStart;
        if (thumbEndMovedPastThumbStart) {
          return this.valueStart;
        }
        return value;
      };
      MDCSliderFoundation2.prototype.updateThumbAndTrackUI = function(thumb) {
        var _this = this;
        var _a2 = this, max = _a2.max, min = _a2.min;
        var pctComplete = (this.value - this.valueStart) / (max - min);
        var rangePx = pctComplete * this.rect.width;
        var isRtl = this.adapter.isRTL();
        var transformProp = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
        if (this.isRange) {
          var thumbLeftPos_1 = this.adapter.isRTL() ? (max - this.value) / (max - min) * this.rect.width : (this.valueStart - min) / (max - min) * this.rect.width;
          var thumbRightPos_1 = thumbLeftPos_1 + rangePx;
          this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
            var trackAnimatesFromRight = !isRtl && thumb === Thumb.START || isRtl && thumb !== Thumb.START;
            if (trackAnimatesFromRight) {
              _this.adapter.setTrackActiveStyleProperty("transform-origin", "right");
              _this.adapter.setTrackActiveStyleProperty("left", "unset");
              _this.adapter.setTrackActiveStyleProperty("right", _this.rect.width - thumbRightPos_1 + "px");
            } else {
              _this.adapter.setTrackActiveStyleProperty("transform-origin", "left");
              _this.adapter.setTrackActiveStyleProperty("right", "unset");
              _this.adapter.setTrackActiveStyleProperty("left", thumbLeftPos_1 + "px");
            }
            _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
            var thumbStartPos = isRtl ? thumbRightPos_1 : thumbLeftPos_1;
            var thumbEndPos = _this.adapter.isRTL() ? thumbLeftPos_1 : thumbRightPos_1;
            if (thumb === Thumb.START || !thumb || !_this.initialStylesRemoved) {
              _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.START);
            }
            if (thumb === Thumb.END || !thumb || !_this.initialStylesRemoved) {
              _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbEndPos + "px)", Thumb.END);
            }
            _this.removeInitialStyles(isRtl);
            _this.updateOverlappingThumbsUI(thumbStartPos, thumbEndPos, thumb);
          });
        } else {
          this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
            var thumbStartPos = isRtl ? _this.rect.width - rangePx : rangePx;
            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.END);
            _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
            _this.removeInitialStyles(isRtl);
          });
        }
      };
      MDCSliderFoundation2.prototype.removeInitialStyles = function(isRtl) {
        if (this.initialStylesRemoved)
          return;
        var position = isRtl ? "right" : "left";
        this.adapter.removeThumbStyleProperty(position, Thumb.END);
        if (this.isRange) {
          this.adapter.removeThumbStyleProperty(position, Thumb.START);
        }
        this.initialStylesRemoved = true;
        this.resetTrackAndThumbAnimation();
      };
      MDCSliderFoundation2.prototype.resetTrackAndThumbAnimation = function() {
        var _this = this;
        if (!this.isDiscrete)
          return;
        var transitionProp = HAS_WINDOW ? getCorrectPropertyName(window, "transition") : "transition";
        var transitionDefault = "all 0s ease 0s";
        this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.END);
        if (this.isRange) {
          this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.START);
        }
        this.adapter.setTrackActiveStyleProperty(transitionProp, transitionDefault);
        requestAnimationFrame(function() {
          _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.END);
          _this.adapter.removeTrackActiveStyleProperty(transitionProp);
          if (_this.isRange) {
            _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.START);
          }
        });
      };
      MDCSliderFoundation2.prototype.updateOverlappingThumbsUI = function(thumbStartPos, thumbEndPos, thumb) {
        var thumbsOverlap = false;
        if (this.adapter.isRTL()) {
          var startThumbLeftEdge = thumbStartPos - this.startThumbKnobWidth / 2;
          var endThumbRightEdge = thumbEndPos + this.endThumbKnobWidth / 2;
          thumbsOverlap = endThumbRightEdge >= startThumbLeftEdge;
        } else {
          var startThumbRightEdge = thumbStartPos + this.startThumbKnobWidth / 2;
          var endThumbLeftEdge = thumbEndPos - this.endThumbKnobWidth / 2;
          thumbsOverlap = startThumbRightEdge >= endThumbLeftEdge;
        }
        if (thumbsOverlap) {
          this.adapter.addThumbClass(cssClasses$3.THUMB_TOP, thumb || Thumb.END);
          this.adapter.removeThumbClass(cssClasses$3.THUMB_TOP, thumb === Thumb.START ? Thumb.END : Thumb.START);
        } else {
          this.adapter.removeThumbClass(cssClasses$3.THUMB_TOP, Thumb.START);
          this.adapter.removeThumbClass(cssClasses$3.THUMB_TOP, Thumb.END);
        }
      };
      MDCSliderFoundation2.prototype.convertAttributeValueToNumber = function(attributeValue, attributeName) {
        if (attributeValue === null) {
          throw new Error("MDCSliderFoundation: `" + attributeName + "` must be non-null.");
        }
        var value = Number(attributeValue);
        if (isNaN(value)) {
          throw new Error("MDCSliderFoundation: `" + attributeName + "` value is " + ("`" + attributeValue + "`, but must be a number."));
        }
        return value;
      };
      MDCSliderFoundation2.prototype.validateProperties = function(_a2) {
        var min = _a2.min, max = _a2.max, value = _a2.value, valueStart = _a2.valueStart, step = _a2.step;
        if (min >= max) {
          throw new Error("MDCSliderFoundation: min must be strictly less than max. " + ("Current: [min: " + min + ", max: " + max + "]"));
        }
        if (step <= 0) {
          throw new Error("MDCSliderFoundation: step must be a positive number. " + ("Current step: " + this.step));
        }
        if (this.isRange) {
          if (value < min || value > max || valueStart < min || valueStart > max) {
            throw new Error("MDCSliderFoundation: values must be in [min, max] range. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
          }
          if (valueStart > value) {
            throw new Error("MDCSliderFoundation: start value must be <= end value. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
          }
          var numStepsValueStartFromMin = (valueStart - min) / step;
          var numStepsValueFromMin = (value - min) / step;
          if (numStepsValueStartFromMin % 1 !== 0 || numStepsValueFromMin % 1 !== 0) {
            throw new Error("MDCSliderFoundation: Slider values must be valid based on the " + ("step value. Current values: [start value: " + valueStart + ", ") + ("end value: " + value + "]"));
          }
        } else {
          if (value < min || value > max) {
            throw new Error("MDCSliderFoundation: value must be in [min, max] range. " + ("Current value: " + value));
          }
          var numStepsValueFromMin = (value - min) / step;
          if (numStepsValueFromMin % 1 !== 0) {
            throw new Error("MDCSliderFoundation: Slider value must be valid based on the " + ("step value. Current value: " + value));
          }
        }
      };
      MDCSliderFoundation2.prototype.registerEventHandlers = function() {
        this.adapter.registerWindowEventHandler("resize", this.resizeListener);
        if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
          this.adapter.registerEventHandler("pointerdown", this.pointerdownListener);
          this.adapter.registerEventHandler("pointerup", this.pointerupListener);
        } else {
          this.adapter.registerEventHandler("mousedown", this.mousedownOrTouchstartListener);
          this.adapter.registerEventHandler("touchstart", this.mousedownOrTouchstartListener);
        }
        if (this.isRange) {
          this.adapter.registerThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
          this.adapter.registerThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
          this.adapter.registerInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
          this.adapter.registerInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
          this.adapter.registerInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
        }
        this.adapter.registerThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
        this.adapter.registerThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.registerInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
        this.adapter.registerInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
        this.adapter.registerInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
      };
      MDCSliderFoundation2.prototype.deregisterEventHandlers = function() {
        this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
        if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
          this.adapter.deregisterEventHandler("pointerdown", this.pointerdownListener);
          this.adapter.deregisterEventHandler("pointerup", this.pointerupListener);
        } else {
          this.adapter.deregisterEventHandler("mousedown", this.mousedownOrTouchstartListener);
          this.adapter.deregisterEventHandler("touchstart", this.mousedownOrTouchstartListener);
        }
        if (this.isRange) {
          this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
          this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
          this.adapter.deregisterInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
          this.adapter.deregisterInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
          this.adapter.deregisterInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
        }
        this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
        this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.deregisterInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
        this.adapter.deregisterInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
        this.adapter.deregisterInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
      };
      MDCSliderFoundation2.prototype.handlePointerup = function() {
        this.handleUp();
        this.adapter.deregisterEventHandler("pointermove", this.moveListener);
      };
      MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS = HAS_WINDOW && Boolean(window.PointerEvent) && !isIOS();
      return MDCSliderFoundation2;
    }(MDCFoundation);
    function isIOS() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    function getNumDecimalPlaces(n) {
      var match = /(?:\.(\d+))?(?:[eE]([+\-]?\d+))?$/.exec(String(n));
      if (!match)
        return 0;
      var fraction = match[1] || "";
      var exponent = match[2] || 0;
      return Math.max(0, (fraction === "0" ? 0 : fraction.length) - Number(exponent));
    }
    var oldModifierRegex$22 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    var newModifierRegex$22 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder$22(component) {
      let $on;
      let events2 = [];
      const componentOn = component.$on;
      component.$on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let destructor = () => {
        };
        if ($on) {
          destructor = $on(eventType, callback);
        } else {
          events2.push([eventType, callback]);
        }
        const oldModifierMatch = eventType.match(oldModifierRegex$22);
        const newModifierMatch = eventType.match(newModifierRegex$22);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (oldModifierMatch && console) {
          console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
        }
        const componentDestructor = componentOn.call(component, eventType, callback);
        return (...args) => {
          destructor();
          return componentDestructor(...args);
        };
      };
      function forward(e) {
        bubble(component, e);
      }
      return (node) => {
        const destructors = [];
        const forwardDestructors = {};
        $on = (fullEventType, callback) => {
          let eventType = fullEventType;
          let handler = callback;
          let options = false;
          const oldModifierMatch = eventType.match(oldModifierRegex$22);
          const newModifierMatch = eventType.match(newModifierRegex$22);
          const modifierMatch = oldModifierMatch || newModifierMatch;
          if (modifierMatch) {
            const parts = eventType.split(oldModifierMatch ? ":" : "$");
            eventType = parts[0];
            options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
            if (options.nonpassive) {
              options.passive = false;
              delete options.nonpassive;
            }
            if (options.preventDefault) {
              handler = prevent_default(handler);
              delete options.preventDefault;
            }
            if (options.stopPropagation) {
              handler = stop_propagation(handler);
              delete options.stopPropagation;
            }
          }
          const off = listen(node, eventType, handler, options);
          const destructor = () => {
            off();
            const idx = destructors.indexOf(destructor);
            if (idx > -1) {
              destructors.splice(idx, 1);
            }
          };
          destructors.push(destructor);
          if (!eventType in forwardDestructors) {
            forwardDestructors[eventType] = listen(node, eventType, forward);
          }
          return destructor;
        };
        for (let i = 0; i < events2.length; i++) {
          $on(events2[i][0], events2[i][1]);
        }
        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
            for (let entry of Object.entries(forwardDestructors)) {
              entry[1]();
            }
          }
        };
      };
    }
    function classMap$22(classObj) {
      return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
    }
    function dispatch$22(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    function exclude$2(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf("$");
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }
      return newObj;
    }
    function prefixFilter$2(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }
      return newObj;
    }
    function useActions$22(node, actions) {
      let objects = [];
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray2 = Array.isArray(actions[i]);
          const action = isArray2 ? actions[i][0] : actions[i];
          if (isArray2 && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i = 0; i < actions2.length; i++) {
              if (objects[i] && "update" in objects[i]) {
                const isArray2 = Array.isArray(actions2[i]);
                if (isArray2 && actions2[i].length > 1) {
                  objects[i].update(actions2[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && "destroy" in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      };
    }
    var file$43 = "node_modules/@smui/slider/Slider.svelte";
    function get_each_context$12(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[84] = list[i];
      return child_ctx;
    }
    function create_else_block_1$1(ctx) {
      let input_1;
      let input_1_class_value;
      let mounted;
      let dispose;
      let input_1_levels = [
        {
          class: input_1_class_value = classMap$22({
            [ctx[12]]: true,
            "mdc-slider__input": true
          })
        },
        {type: "range"},
        {disabled: ctx[5]},
        {step: ctx[9]},
        {min: ctx[10]},
        {max: ctx[11]},
        ctx[32],
        ctx[23],
        prefixFilter$2(ctx[36], "input$")
      ];
      let input_1_data = {};
      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_1_data = assign(input_1_data, input_1_levels[i]);
      }
      const block = {
        c: function create2() {
          input_1 = element("input");
          set_attributes(input_1, input_1_data);
          add_location(input_1, file$43, 55, 4, 1211);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input_1, anchor);
          if (input_1.autofocus)
            input_1.focus();
          ctx[55](input_1);
          set_input_value(input_1, ctx[0]);
          if (!mounted) {
            dispose = [
              listen_dev(input_1, "change", ctx[56]),
              listen_dev(input_1, "input", ctx[56]),
              listen_dev(input_1, "blur", ctx[49], false, false, false),
              listen_dev(input_1, "focus", ctx[50], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
            dirty[0] & 4096 && input_1_class_value !== (input_1_class_value = classMap$22({
              [ctx2[12]]: true,
              "mdc-slider__input": true
            })) && {class: input_1_class_value},
            {type: "range"},
            dirty[0] & 32 && {disabled: ctx2[5]},
            dirty[0] & 512 && {step: ctx2[9]},
            dirty[0] & 1024 && {min: ctx2[10]},
            dirty[0] & 2048 && {max: ctx2[11]},
            ctx2[32],
            dirty[0] & 8388608 && ctx2[23],
            dirty[1] & 32 && prefixFilter$2(ctx2[36], "input$")
          ]));
          if (dirty[0] & 1) {
            set_input_value(input_1, ctx2[0]);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input_1);
          ctx[55](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$1.name,
        type: "else",
        source: "(55:2) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_5$1(ctx) {
      let input0;
      let input0_class_value;
      let t;
      let input1;
      let input1_class_value;
      let mounted;
      let dispose;
      let input0_levels = [
        {
          class: input0_class_value = classMap$22({
            [ctx[12]]: true,
            "mdc-slider__input": true
          })
        },
        {type: "range"},
        {disabled: ctx[5]},
        {step: ctx[9]},
        {min: ctx[10]},
        {max: ctx[2]},
        ctx[24],
        prefixFilter$2(ctx[36], "input$")
      ];
      let input0_data = {};
      for (let i = 0; i < input0_levels.length; i += 1) {
        input0_data = assign(input0_data, input0_levels[i]);
      }
      let input1_levels = [
        {
          class: input1_class_value = classMap$22({
            [ctx[12]]: true,
            "mdc-slider__input": true
          })
        },
        {type: "range"},
        {disabled: ctx[5]},
        {step: ctx[9]},
        {min: ctx[1]},
        {max: ctx[11]},
        ctx[32],
        ctx[23],
        prefixFilter$2(ctx[36], "input$")
      ];
      let input1_data = {};
      for (let i = 0; i < input1_levels.length; i += 1) {
        input1_data = assign(input1_data, input1_levels[i]);
      }
      const block = {
        c: function create2() {
          input0 = element("input");
          t = space();
          input1 = element("input");
          set_attributes(input0, input0_data);
          add_location(input0, file$43, 19, 4, 489);
          set_attributes(input1, input1_data);
          add_location(input1, file$43, 36, 4, 839);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input0, anchor);
          if (input0.autofocus)
            input0.focus();
          ctx[51](input0);
          set_input_value(input0, ctx[1]);
          insert_dev(target, t, anchor);
          insert_dev(target, input1, anchor);
          if (input1.autofocus)
            input1.focus();
          ctx[53](input1);
          set_input_value(input1, ctx[2]);
          if (!mounted) {
            dispose = [
              listen_dev(input0, "change", ctx[52]),
              listen_dev(input0, "input", ctx[52]),
              listen_dev(input0, "blur", ctx[47], false, false, false),
              listen_dev(input0, "focus", ctx[48], false, false, false),
              listen_dev(input1, "change", ctx[54]),
              listen_dev(input1, "input", ctx[54]),
              listen_dev(input1, "blur", ctx[45], false, false, false),
              listen_dev(input1, "focus", ctx[46], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input0, input0_data = get_spread_update(input0_levels, [
            dirty[0] & 4096 && input0_class_value !== (input0_class_value = classMap$22({
              [ctx2[12]]: true,
              "mdc-slider__input": true
            })) && {class: input0_class_value},
            {type: "range"},
            dirty[0] & 32 && {disabled: ctx2[5]},
            dirty[0] & 512 && {step: ctx2[9]},
            dirty[0] & 1024 && {min: ctx2[10]},
            dirty[0] & 4 && {max: ctx2[2]},
            dirty[0] & 16777216 && ctx2[24],
            dirty[1] & 32 && prefixFilter$2(ctx2[36], "input$")
          ]));
          if (dirty[0] & 2) {
            set_input_value(input0, ctx2[1]);
          }
          set_attributes(input1, input1_data = get_spread_update(input1_levels, [
            dirty[0] & 4096 && input1_class_value !== (input1_class_value = classMap$22({
              [ctx2[12]]: true,
              "mdc-slider__input": true
            })) && {class: input1_class_value},
            {type: "range"},
            dirty[0] & 32 && {disabled: ctx2[5]},
            dirty[0] & 512 && {step: ctx2[9]},
            dirty[0] & 2 && {min: ctx2[1]},
            dirty[0] & 2048 && {max: ctx2[11]},
            ctx2[32],
            dirty[0] & 8388608 && ctx2[23],
            dirty[1] & 32 && prefixFilter$2(ctx2[36], "input$")
          ]));
          if (dirty[0] & 4) {
            set_input_value(input1, ctx2[2]);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input0);
          ctx[51](null);
          if (detaching)
            detach_dev(t);
          if (detaching)
            detach_dev(input1);
          ctx[53](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$1.name,
        type: "if",
        source: "(19:2) {#if range}",
        ctx
      });
      return block;
    }
    function create_if_block_4$2(ctx) {
      let div;
      let each_value = ctx[30];
      validate_each_argument(each_value);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$12(get_each_context$12(ctx, each_value, i));
      }
      const block = {
        c: function create2() {
          div = element("div");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          attr_dev(div, "class", "mdc-slider__tick-marks");
          add_location(div, file$43, 86, 6, 1947);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1073741824) {
            each_value = ctx2[30];
            validate_each_argument(each_value);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$12(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$12(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, null);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$2.name,
        type: "if",
        source: "(86:4) {#if discrete && tickMarks && step > 0}",
        ctx
      });
      return block;
    }
    function create_each_block$12(ctx) {
      let div;
      let div_class_value;
      const block = {
        c: function create2() {
          div = element("div");
          attr_dev(div, "class", div_class_value = ctx[84] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive");
          add_location(div, file$43, 88, 10, 2039);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1073741824 && div_class_value !== (div_class_value = ctx2[84] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive")) {
            attr_dev(div, "class", div_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$12.name,
        type: "each",
        source: "(88:8) {#each currentTickMarks as tickMark}",
        ctx
      });
      return block;
    }
    function create_else_block$2(ctx) {
      let div1;
      let t;
      let div0;
      let div1_class_value;
      let div1_style_value;
      let Ripple_action;
      let mounted;
      let dispose;
      let if_block = ctx[7] && create_if_block_3$2(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          if (if_block)
            if_block.c();
          t = space();
          div0 = element("div");
          attr_dev(div0, "class", "mdc-slider__thumb-knob");
          add_location(div0, file$43, 184, 6, 5154);
          attr_dev(div1, "class", div1_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx[22]
          }));
          attr_dev(div1, "style", div1_style_value = Object.entries(ctx[26]).map(func_3).join(" "));
          add_location(div1, file$43, 157, 4, 4281);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          if (if_block)
            if_block.m(div1, null);
          append_dev(div1, t);
          append_dev(div1, div0);
          ctx[67](div0);
          ctx[68](div1);
          if (!mounted) {
            dispose = action_destroyer(Ripple_action = Ripple.call(null, div1, {
              unbounded: true,
              disabled: ctx[5],
              active: ctx[28],
              eventTarget: ctx[14],
              activeTarget: ctx[14],
              addClass: ctx[69],
              removeClass: ctx[70],
              addStyle: ctx[71]
            }));
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[7]) {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block_3$2(ctx2);
              if_block.c();
              if_block.m(div1, t);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty[0] & 4194304 && div1_class_value !== (div1_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx2[22]
          }))) {
            attr_dev(div1, "class", div1_class_value);
          }
          if (dirty[0] & 67108864 && div1_style_value !== (div1_style_value = Object.entries(ctx2[26]).map(func_3).join(" "))) {
            attr_dev(div1, "style", div1_style_value);
          }
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 268451872)
            Ripple_action.update.call(null, {
              unbounded: true,
              disabled: ctx2[5],
              active: ctx2[28],
              eventTarget: ctx2[14],
              activeTarget: ctx2[14],
              addClass: ctx2[69],
              removeClass: ctx2[70],
              addStyle: ctx2[71]
            });
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block)
            if_block.d();
          ctx[67](null);
          ctx[68](null);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(157:2) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$3(ctx) {
      let div1;
      let t0;
      let div0;
      let div1_class_value;
      let div1_style_value;
      let Ripple_action;
      let t1;
      let div3;
      let t2;
      let div2;
      let div3_class_value;
      let div3_style_value;
      let Ripple_action_1;
      let mounted;
      let dispose;
      let if_block0 = ctx[7] && create_if_block_2$2(ctx);
      let if_block1 = ctx[7] && create_if_block_1$2(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          div0 = element("div");
          t1 = space();
          div3 = element("div");
          if (if_block1)
            if_block1.c();
          t2 = space();
          div2 = element("div");
          attr_dev(div0, "class", "mdc-slider__thumb-knob");
          add_location(div0, file$43, 125, 6, 3210);
          attr_dev(div1, "class", div1_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx[21]
          }));
          attr_dev(div1, "style", div1_style_value = Object.entries(ctx[27]).map(func_13).join(" "));
          add_location(div1, file$43, 98, 4, 2270);
          attr_dev(div2, "class", "mdc-slider__thumb-knob");
          add_location(div2, file$43, 154, 6, 4195);
          attr_dev(div3, "class", div3_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx[22]
          }));
          attr_dev(div3, "style", div3_style_value = Object.entries(ctx[26]).map(func_2).join(" "));
          add_location(div3, file$43, 127, 4, 3291);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          if (if_block0)
            if_block0.m(div1, null);
          append_dev(div1, t0);
          append_dev(div1, div0);
          ctx[57](div0);
          ctx[58](div1);
          insert_dev(target, t1, anchor);
          insert_dev(target, div3, anchor);
          if (if_block1)
            if_block1.m(div3, null);
          append_dev(div3, t2);
          append_dev(div3, div2);
          ctx[62](div2);
          ctx[63](div3);
          if (!mounted) {
            dispose = [
              action_destroyer(Ripple_action = Ripple.call(null, div1, {
                unbounded: true,
                disabled: ctx[5],
                active: ctx[29],
                eventTarget: ctx[15],
                activeTarget: ctx[15],
                addClass: ctx[59],
                removeClass: ctx[60],
                addStyle: ctx[61]
              })),
              action_destroyer(Ripple_action_1 = Ripple.call(null, div3, {
                unbounded: true,
                disabled: ctx[5],
                active: ctx[28],
                eventTarget: ctx[14],
                activeTarget: ctx[14],
                addClass: ctx[64],
                removeClass: ctx[65],
                addStyle: ctx[66]
              }))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[7]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_2$2(ctx2);
              if_block0.c();
              if_block0.m(div1, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (dirty[0] & 2097152 && div1_class_value !== (div1_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx2[21]
          }))) {
            attr_dev(div1, "class", div1_class_value);
          }
          if (dirty[0] & 134217728 && div1_style_value !== (div1_style_value = Object.entries(ctx2[27]).map(func_13).join(" "))) {
            attr_dev(div1, "style", div1_style_value);
          }
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 536903712)
            Ripple_action.update.call(null, {
              unbounded: true,
              disabled: ctx2[5],
              active: ctx2[29],
              eventTarget: ctx2[15],
              activeTarget: ctx2[15],
              addClass: ctx2[59],
              removeClass: ctx2[60],
              addStyle: ctx2[61]
            });
          if (ctx2[7]) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block_1$2(ctx2);
              if_block1.c();
              if_block1.m(div3, t2);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (dirty[0] & 4194304 && div3_class_value !== (div3_class_value = classMap$22({
            "mdc-slider__thumb": true,
            ...ctx2[22]
          }))) {
            attr_dev(div3, "class", div3_class_value);
          }
          if (dirty[0] & 67108864 && div3_style_value !== (div3_style_value = Object.entries(ctx2[26]).map(func_2).join(" "))) {
            attr_dev(div3, "style", div3_style_value);
          }
          if (Ripple_action_1 && is_function(Ripple_action_1.update) && dirty[0] & 268451872)
            Ripple_action_1.update.call(null, {
              unbounded: true,
              disabled: ctx2[5],
              active: ctx2[28],
              eventTarget: ctx2[14],
              activeTarget: ctx2[14],
              addClass: ctx2[64],
              removeClass: ctx2[65],
              addStyle: ctx2[66]
            });
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block0)
            if_block0.d();
          ctx[57](null);
          ctx[58](null);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(div3);
          if (if_block1)
            if_block1.d();
          ctx[62](null);
          ctx[63](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(98:2) {#if range}",
        ctx
      });
      return block;
    }
    function create_if_block_3$2(ctx) {
      let div1;
      let div0;
      let span;
      let t;
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          span = element("span");
          t = text(ctx[0]);
          attr_dev(span, "class", "mdc-slider__value-indicator-text");
          add_location(span, file$43, 180, 12, 5042);
          attr_dev(div0, "class", "mdc-slider__value-indicator");
          add_location(div0, file$43, 179, 10, 4988);
          attr_dev(div1, "class", "mdc-slider__value-indicator-container");
          attr_dev(div1, "aria-hidden", "true");
          add_location(div1, file$43, 178, 8, 4907);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span);
          append_dev(span, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 1)
            set_data_dev(t, ctx2[0]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$2.name,
        type: "if",
        source: "(178:6) {#if discrete}",
        ctx
      });
      return block;
    }
    function create_if_block_2$2(ctx) {
      let div1;
      let div0;
      let span;
      let t;
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          span = element("span");
          t = text(ctx[1]);
          attr_dev(span, "class", "mdc-slider__value-indicator-text");
          add_location(span, file$43, 121, 12, 3098);
          attr_dev(div0, "class", "mdc-slider__value-indicator");
          add_location(div0, file$43, 120, 10, 3044);
          attr_dev(div1, "class", "mdc-slider__value-indicator-container");
          attr_dev(div1, "aria-hidden", "true");
          add_location(div1, file$43, 119, 8, 2963);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span);
          append_dev(span, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 2)
            set_data_dev(t, ctx2[1]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$2.name,
        type: "if",
        source: "(119:6) {#if discrete}",
        ctx
      });
      return block;
    }
    function create_if_block_1$2(ctx) {
      let div1;
      let div0;
      let span;
      let t;
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          span = element("span");
          t = text(ctx[2]);
          attr_dev(span, "class", "mdc-slider__value-indicator-text");
          add_location(span, file$43, 150, 12, 4085);
          attr_dev(div0, "class", "mdc-slider__value-indicator");
          add_location(div0, file$43, 149, 10, 4031);
          attr_dev(div1, "class", "mdc-slider__value-indicator-container");
          attr_dev(div1, "aria-hidden", "true");
          add_location(div1, file$43, 148, 8, 3950);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span);
          append_dev(span, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty[0] & 4)
            set_data_dev(t, ctx2[2]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$2.name,
        type: "if",
        source: "(148:6) {#if discrete}",
        ctx
      });
      return block;
    }
    function create_fragment$54(ctx) {
      let div4;
      let t0;
      let div3;
      let div0;
      let t1;
      let div2;
      let div1;
      let div1_style_value;
      let t2;
      let t3;
      let div4_class_value;
      let useActions_action;
      let mounted;
      let dispose;
      function select_block_type(ctx2, dirty) {
        if (ctx2[6])
          return create_if_block_5$1;
        return create_else_block_1$1;
      }
      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);
      let if_block1 = ctx[7] && ctx[8] && ctx[9] > 0 && create_if_block_4$2(ctx);
      function select_block_type_1(ctx2, dirty) {
        if (ctx2[6])
          return create_if_block$3;
        return create_else_block$2;
      }
      let current_block_type_1 = select_block_type_1(ctx);
      let if_block2 = current_block_type_1(ctx);
      let div4_levels = [
        {
          class: div4_class_value = Object.entries({
            [ctx[4]]: true,
            "mdc-slider": true,
            "mdc-slider--range": ctx[6],
            "mdc-slider--discrete": ctx[7],
            "mdc-slider--tick-marks": ctx[7] && ctx[8],
            "mdc-slider--disabled": ctx[5],
            ...ctx[20]
          }).filter(func_4).map(func_5).join(" ")
        },
        exclude$2(ctx[36], ["input$"])
      ];
      let div4_data = {};
      for (let i = 0; i < div4_levels.length; i += 1) {
        div4_data = assign(div4_data, div4_levels[i]);
      }
      const block = {
        c: function create2() {
          div4 = element("div");
          if_block0.c();
          t0 = space();
          div3 = element("div");
          div0 = element("div");
          t1 = space();
          div2 = element("div");
          div1 = element("div");
          t2 = space();
          if (if_block1)
            if_block1.c();
          t3 = space();
          if_block2.c();
          attr_dev(div0, "class", "mdc-slider__track--inactive");
          add_location(div0, file$43, 76, 4, 1604);
          attr_dev(div1, "class", "mdc-slider__track--active_fill");
          attr_dev(div1, "style", div1_style_value = Object.entries(ctx[25]).map(func$13).join(" "));
          add_location(div1, file$43, 78, 6, 1698);
          attr_dev(div2, "class", "mdc-slider__track--active");
          add_location(div2, file$43, 77, 4, 1652);
          attr_dev(div3, "class", "mdc-slider__track");
          add_location(div3, file$43, 75, 2, 1568);
          set_attributes(div4, div4_data);
          add_location(div4, file$43, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          if_block0.m(div4, null);
          append_dev(div4, t0);
          append_dev(div4, div3);
          append_dev(div3, div0);
          append_dev(div3, t1);
          append_dev(div3, div2);
          append_dev(div2, div1);
          append_dev(div3, t2);
          if (if_block1)
            if_block1.m(div3, null);
          append_dev(div4, t3);
          if_block2.m(div4, null);
          ctx[72](div4);
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions$22.call(null, div4, ctx[3])),
              action_destroyer(ctx[31].call(null, div4))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx2);
            if (if_block0) {
              if_block0.c();
              if_block0.m(div4, t0);
            }
          }
          if (dirty[0] & 33554432 && div1_style_value !== (div1_style_value = Object.entries(ctx2[25]).map(func$13).join(" "))) {
            attr_dev(div1, "style", div1_style_value);
          }
          if (ctx2[7] && ctx2[8] && ctx2[9] > 0) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block_4$2(ctx2);
              if_block1.c();
              if_block1.m(div3, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block2) {
            if_block2.p(ctx2, dirty);
          } else {
            if_block2.d(1);
            if_block2 = current_block_type_1(ctx2);
            if (if_block2) {
              if_block2.c();
              if_block2.m(div4, null);
            }
          }
          set_attributes(div4, div4_data = get_spread_update(div4_levels, [
            dirty[0] & 1049072 && div4_class_value !== (div4_class_value = Object.entries({
              [ctx2[4]]: true,
              "mdc-slider": true,
              "mdc-slider--range": ctx2[6],
              "mdc-slider--discrete": ctx2[7],
              "mdc-slider--tick-marks": ctx2[7] && ctx2[8],
              "mdc-slider--disabled": ctx2[5],
              ...ctx2[20]
            }).filter(func_4).map(func_5).join(" ")) && {class: div4_class_value},
            dirty[1] & 32 && exclude$2(ctx2[36], ["input$"])
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 8)
            useActions_action.update.call(null, ctx2[3]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div4);
          if_block0.d();
          if (if_block1)
            if_block1.d();
          if_block2.d();
          ctx[72](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$54.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func$13 = ([name, value]) => `${name}: ${value};`;
    var func_13 = ([name, value]) => `${name}: ${value};`;
    var func_2 = ([name, value]) => `${name}: ${value};`;
    var func_3 = ([name, value]) => `${name}: ${value};`;
    var func_4 = ([name, value]) => name !== "" && value;
    var func_5 = ([name]) => name;
    function instance_1$3($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "disabled",
        "range",
        "discrete",
        "tickMarks",
        "step",
        "min",
        "max",
        "value",
        "start",
        "end",
        "valueToAriaValueTextFn",
        "input$class",
        "layout",
        "getId",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Slider", slots, []);
      const forwardEvents = forwardEventsBuilder$22(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {disabled = false} = $$props;
      let {range = false} = $$props;
      let {discrete = false} = $$props;
      let {tickMarks = false} = $$props;
      let {step = 1} = $$props;
      let {min = 0} = $$props;
      let {max = 100} = $$props;
      let {value = null} = $$props;
      let {start = null} = $$props;
      let {end = null} = $$props;
      let {valueToAriaValueTextFn = (value2) => `${value2}`} = $$props;
      let {input$class = ""} = $$props;
      let element2;
      let instance9;
      let input;
      let inputStart;
      let thumbEl;
      let thumbStart;
      let thumbKnob;
      let thumbKnobStart;
      let internalClasses = {};
      let thumbStartClasses = {};
      let thumbClasses = {};
      let inputAttrs = {};
      let inputStartAttrs = {};
      let trackActiveStyles = {};
      let thumbStyles = {};
      let thumbStartStyles = {};
      let thumbRippleActive = false;
      let thumbStartRippleActive = false;
      let currentTickMarks;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      let addLayoutListener = getContext("SMUI:addLayoutListener");
      let removeLayoutListener;
      if (tickMarks && step > 0) {
        const absMax = max + Math.abs(min);
        if (range) {
          const absStart = start + Math.abs(min);
          currentTickMarks = [
            ...Array(absStart / step).map(() => TickMark.INACTIVE),
            ...Array(absMax / step - absStart / step - (absMax - absMax) / step + 1).map(() => TickMark.ACTIVE),
            ...Array((absMax - absMax) / step).map(() => TickMark.INACTIVE)
          ];
        } else {
          const absValue = value + Math.abs(min);
          currentTickMarks = [
            ...Array(absValue / step + 1).map(() => TickMark.ACTIVE),
            ...Array((absMax - absValue) / step).map(() => TickMark.INACTIVE)
          ];
        }
      }
      if (range) {
        const percent = (end - start) / (max - min);
        const percentStart = start / (max - min);
        const percentEnd = end / (max - min);
        trackActiveStyles.transform = `scaleX(${percent})`;
        thumbStyles.left = `calc(${percentEnd * 100}% -24px)`;
        thumbStartStyles.left = `calc(${percentStart * 100}% -24px)`;
      } else {
        const percent = value / (max - min);
        trackActiveStyles.transform = `scaleX(${percent})`;
        thumbStyles.left = `calc(${percent * 100}% -24px)`;
      }
      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }
      let previousValue = value;
      let previousStart = start;
      let previousEnd = end;
      onMount(() => {
        $$invalidate(41, instance9 = new MDCSliderFoundation({
          hasClass,
          addClass,
          removeClass,
          addThumbClass,
          removeThumbClass,
          getAttribute: (attribute) => getElement().getAttribute(attribute),
          getInputValue: (thumb) => range ? thumb === Thumb.START ? start : end : value,
          setInputValue: (val, thumb) => {
            if (range) {
              if (thumb === Thumb.START) {
                $$invalidate(1, start = Number(val));
                $$invalidate(43, previousStart = start);
              } else {
                $$invalidate(2, end = Number(val));
                $$invalidate(44, previousEnd = end);
              }
            } else {
              $$invalidate(0, value = Number(val));
              $$invalidate(42, previousValue = value);
            }
          },
          getInputAttribute: getInputAttr,
          setInputAttribute: addInputAttr,
          removeInputAttribute: removeInputAttr,
          focusInput: (thumb) => {
            if (range && thumb === Thumb.START) {
              inputStart.focus();
            } else {
              input.focus();
            }
          },
          isInputFocused: (thumb) => (range && thumb === Thumb.START ? inputStart : input) === document.activeElement,
          getThumbKnobWidth: (thumb) => (range && thumb === Thumb.START ? thumbKnobStart : thumbKnob).getBoundingClientRect().width,
          getThumbBoundingClientRect: (thumb) => (range && thumb === Thumb.START ? thumbStart : thumbEl).getBoundingClientRect(),
          getBoundingClientRect: () => getElement().getBoundingClientRect(),
          isRTL: () => getComputedStyle(getElement()).direction === "rtl",
          setThumbStyleProperty: addThumbStyle,
          removeThumbStyleProperty: removeThumbStyle,
          setTrackActiveStyleProperty: addTrackActiveStyle,
          removeTrackActiveStyleProperty: removeTrackActiveStyle,
          setValueIndicatorText: (_value, _thumb) => void 0,
          getValueToAriaValueTextFn: () => valueToAriaValueTextFn,
          updateTickMarks: (tickMarks2) => {
            $$invalidate(30, currentTickMarks = tickMarks2);
          },
          setPointerCapture: (pointerId) => {
            getElement().setPointerCapture(pointerId);
          },
          emitChangeEvent: (value2, thumb) => {
            dispatch$22(getElement(), "MDCSlider:change", {value: value2, thumb});
          },
          emitInputEvent: (value2, thumb) => {
            dispatch$22(getElement(), "MDCSlider:input", {value: value2, thumb});
          },
          emitDragStartEvent: (_2, thumb) => {
            if (range && thumb === Thumb.START) {
              $$invalidate(29, thumbStartRippleActive = true);
            } else {
              $$invalidate(28, thumbRippleActive = true);
            }
          },
          emitDragEndEvent: (_2, thumb) => {
            if (range && thumb === Thumb.START) {
              $$invalidate(29, thumbStartRippleActive = false);
            } else {
              $$invalidate(28, thumbRippleActive = false);
            }
          },
          registerEventHandler: (evtType, handler) => {
            getElement().addEventListener(evtType, handler);
          },
          deregisterEventHandler: (evtType, handler) => {
            getElement().removeEventListener(evtType, handler);
          },
          registerThumbEventHandler: (thumb, evtType, handler) => {
            (range && thumb === Thumb.START ? thumbStart : thumbEl).addEventListener(evtType, handler);
          },
          deregisterThumbEventHandler: (thumb, evtType, handler) => {
            (range && thumb === Thumb.START ? thumbStart : thumbEl).removeEventListener(evtType, handler);
          },
          registerInputEventHandler: (thumb, evtType, handler) => {
            (range && thumb === Thumb.START ? inputStart : input).addEventListener(evtType, handler);
          },
          deregisterInputEventHandler: (thumb, evtType, handler) => {
            (range && thumb === Thumb.START ? inputStart : input).removeEventListener(evtType, handler);
          },
          registerBodyEventHandler: (evtType, handler) => {
            document.body.addEventListener(evtType, handler);
          },
          deregisterBodyEventHandler: (evtType, handler) => {
            document.body.removeEventListener(evtType, handler);
          },
          registerWindowEventHandler: (evtType, handler) => {
            window.addEventListener(evtType, handler);
          },
          deregisterWindowEventHandler: (evtType, handler) => {
            window.removeEventListener(evtType, handler);
          }
        }));
        const accessor = {
          get element() {
            return getElement();
          },
          activateRipple() {
            if (!disabled) {
              $$invalidate(28, thumbRippleActive = true);
            }
          },
          deactivateRipple() {
            $$invalidate(28, thumbRippleActive = false);
          }
        };
        dispatch$22(element2, "SMUI:generic:input:mount", accessor);
        instance9.init();
        instance9.layout(true);
        return () => {
          dispatch$22(element2, "SMUI:generic:input:unmount", accessor);
          instance9.destroy();
        };
      });
      onDestroy(() => {
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(20, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(20, internalClasses[className2] = false, internalClasses);
        }
      }
      function addThumbClass(className2, thumb) {
        if (range && thumb === Thumb.START) {
          if (!thumbStartClasses[className2]) {
            $$invalidate(21, thumbStartClasses[className2] = true, thumbStartClasses);
          }
        } else {
          if (!thumbClasses[className2]) {
            $$invalidate(22, thumbClasses[className2] = true, thumbClasses);
          }
        }
      }
      function removeThumbClass(className2, thumb) {
        if (range && thumb === Thumb.START) {
          if (!(className2 in thumbStartClasses) || thumbStartClasses[className2]) {
            $$invalidate(21, thumbStartClasses[className2] = false, thumbStartClasses);
          }
        } else {
          if (!(className2 in thumbClasses) || thumbClasses[className2]) {
            $$invalidate(22, thumbClasses[className2] = false, thumbClasses);
          }
        }
      }
      function addThumbStyle(name, value2, thumb) {
        if (range && thumb === Thumb.START) {
          if (thumbStartStyles[name] != value2) {
            if (value2 === "" || value2 == null) {
              delete thumbStartStyles[name];
              $$invalidate(27, thumbStartStyles);
            } else {
              $$invalidate(27, thumbStartStyles[name] = value2, thumbStartStyles);
            }
          }
        } else {
          if (thumbStyles[name] != value2) {
            if (value2 === "" || value2 == null) {
              delete thumbStyles[name];
              $$invalidate(26, thumbStyles);
            } else {
              $$invalidate(26, thumbStyles[name] = value2, thumbStyles);
            }
          }
        }
      }
      function removeThumbStyle(name, thumb) {
        if (range && thumb === Thumb.START) {
          if (name in thumbStartStyles) {
            delete thumbStartStyles[name];
            $$invalidate(27, thumbStartStyles);
          }
        } else {
          if (name in thumbStyles) {
            delete thumbStyles[name];
            $$invalidate(26, thumbStyles);
          }
        }
      }
      function getInputAttr(name, thumb) {
        if (range && thumb === Thumb.START) {
          if (name === "value") {
            return `${start}`;
          }
          return name in inputStartAttrs ? inputStartAttrs[name] : inputStart.getAttribute(name);
        } else {
          if (name === "value") {
            return `${range ? end : value}`;
          }
          return name in inputAttrs ? inputAttrs[name] : input.getAttribute(name);
        }
      }
      function addInputAttr(name, value2, thumb) {
        if (range && thumb === Thumb.START) {
          if (inputStartAttrs[name] !== value2) {
            $$invalidate(24, inputStartAttrs[name] = value2, inputStartAttrs);
          }
        } else {
          if (inputAttrs[name] !== value2) {
            $$invalidate(23, inputAttrs[name] = value2, inputAttrs);
          }
        }
      }
      function removeInputAttr(name, thumb) {
        if (range && thumb === Thumb.START) {
          if (!(name in inputStartAttrs) || inputStartAttrs[name] != null) {
            $$invalidate(24, inputStartAttrs[name] = void 0, inputStartAttrs);
          }
        } else {
          if (!(name in inputAttrs) || inputAttrs[name] != null) {
            $$invalidate(23, inputAttrs[name] = void 0, inputAttrs);
          }
        }
      }
      function addTrackActiveStyle(name, value2) {
        if (trackActiveStyles[name] != value2) {
          if (value2 === "" || value2 == null) {
            delete trackActiveStyles[name];
            $$invalidate(25, trackActiveStyles);
          } else {
            $$invalidate(25, trackActiveStyles[name] = value2, trackActiveStyles);
          }
        }
      }
      function removeTrackActiveStyle(name) {
        if (name in trackActiveStyles) {
          delete trackActiveStyles[name];
          $$invalidate(25, trackActiveStyles);
        }
      }
      function layout() {
        return instance9.layout();
      }
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element2;
      }
      function blur_handler_1(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler_1(event) {
        bubble.call(this, $$self, event);
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function blur_handler_2(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler_2(event) {
        bubble.call(this, $$self, event);
      }
      function input0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          inputStart = $$value;
          $$invalidate(15, inputStart);
        });
      }
      function input0_change_input_handler() {
        start = to_number(this.value);
        $$invalidate(1, start);
      }
      function input1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          input = $$value;
          $$invalidate(14, input);
        });
      }
      function input1_change_input_handler() {
        end = to_number(this.value);
        $$invalidate(2, end);
      }
      function input_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          input = $$value;
          $$invalidate(14, input);
        });
      }
      function input_1_change_input_handler() {
        value = to_number(this.value);
        $$invalidate(0, value);
      }
      function div0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbKnobStart = $$value;
          $$invalidate(19, thumbKnobStart);
        });
      }
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbStart = $$value;
          $$invalidate(17, thumbStart);
        });
      }
      const Ripple_function = (className2) => addThumbClass(className2, Thumb.START);
      const Ripple_function_1 = (className2) => removeThumbClass(className2, Thumb.START);
      const Ripple_function_2 = (name, value2) => addThumbStyle(name, value2, Thumb.START);
      function div2_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbKnob = $$value;
          $$invalidate(18, thumbKnob);
        });
      }
      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbEl = $$value;
          $$invalidate(16, thumbEl);
        });
      }
      const Ripple_function_3 = (className2) => addThumbClass(className2, Thumb.END);
      const Ripple_function_4 = (className2) => removeThumbClass(className2, Thumb.END);
      const Ripple_function_5 = (name, value2) => addThumbStyle(name, value2, Thumb.END);
      function div0_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbKnob = $$value;
          $$invalidate(18, thumbKnob);
        });
      }
      function div1_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thumbEl = $$value;
          $$invalidate(16, thumbEl);
        });
      }
      const Ripple_function_6 = (className2) => addThumbClass(className2);
      const Ripple_function_7 = (className2) => removeThumbClass(className2);
      const Ripple_function_8 = (name, value2) => addThumbStyle(name, value2);
      function div4_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(13, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(36, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(3, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(4, className = $$new_props.class);
        if ("disabled" in $$new_props)
          $$invalidate(5, disabled = $$new_props.disabled);
        if ("range" in $$new_props)
          $$invalidate(6, range = $$new_props.range);
        if ("discrete" in $$new_props)
          $$invalidate(7, discrete = $$new_props.discrete);
        if ("tickMarks" in $$new_props)
          $$invalidate(8, tickMarks = $$new_props.tickMarks);
        if ("step" in $$new_props)
          $$invalidate(9, step = $$new_props.step);
        if ("min" in $$new_props)
          $$invalidate(10, min = $$new_props.min);
        if ("max" in $$new_props)
          $$invalidate(11, max = $$new_props.max);
        if ("value" in $$new_props)
          $$invalidate(0, value = $$new_props.value);
        if ("start" in $$new_props)
          $$invalidate(1, start = $$new_props.start);
        if ("end" in $$new_props)
          $$invalidate(2, end = $$new_props.end);
        if ("valueToAriaValueTextFn" in $$new_props)
          $$invalidate(37, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
        if ("input$class" in $$new_props)
          $$invalidate(12, input$class = $$new_props.input$class);
      };
      $$self.$capture_state = () => ({
        MDCSliderFoundation,
        Thumb,
        TickMark,
        onMount,
        onDestroy,
        getContext,
        tick,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder$22,
        classMap: classMap$22,
        exclude: exclude$2,
        prefixFilter: prefixFilter$2,
        useActions: useActions$22,
        dispatch: dispatch$22,
        Ripple,
        forwardEvents,
        use: use2,
        className,
        disabled,
        range,
        discrete,
        tickMarks,
        step,
        min,
        max,
        value,
        start,
        end,
        valueToAriaValueTextFn,
        input$class,
        element: element2,
        instance: instance9,
        input,
        inputStart,
        thumbEl,
        thumbStart,
        thumbKnob,
        thumbKnobStart,
        internalClasses,
        thumbStartClasses,
        thumbClasses,
        inputAttrs,
        inputStartAttrs,
        trackActiveStyles,
        thumbStyles,
        thumbStartStyles,
        thumbRippleActive,
        thumbStartRippleActive,
        currentTickMarks,
        inputProps,
        addLayoutListener,
        removeLayoutListener,
        previousValue,
        previousStart,
        previousEnd,
        hasClass,
        addClass,
        removeClass,
        addThumbClass,
        removeThumbClass,
        addThumbStyle,
        removeThumbStyle,
        getInputAttr,
        addInputAttr,
        removeInputAttr,
        addTrackActiveStyle,
        removeTrackActiveStyle,
        layout,
        getId,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(3, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(4, className = $$new_props.className);
        if ("disabled" in $$props)
          $$invalidate(5, disabled = $$new_props.disabled);
        if ("range" in $$props)
          $$invalidate(6, range = $$new_props.range);
        if ("discrete" in $$props)
          $$invalidate(7, discrete = $$new_props.discrete);
        if ("tickMarks" in $$props)
          $$invalidate(8, tickMarks = $$new_props.tickMarks);
        if ("step" in $$props)
          $$invalidate(9, step = $$new_props.step);
        if ("min" in $$props)
          $$invalidate(10, min = $$new_props.min);
        if ("max" in $$props)
          $$invalidate(11, max = $$new_props.max);
        if ("value" in $$props)
          $$invalidate(0, value = $$new_props.value);
        if ("start" in $$props)
          $$invalidate(1, start = $$new_props.start);
        if ("end" in $$props)
          $$invalidate(2, end = $$new_props.end);
        if ("valueToAriaValueTextFn" in $$props)
          $$invalidate(37, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
        if ("input$class" in $$props)
          $$invalidate(12, input$class = $$new_props.input$class);
        if ("element" in $$props)
          $$invalidate(13, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(41, instance9 = $$new_props.instance);
        if ("input" in $$props)
          $$invalidate(14, input = $$new_props.input);
        if ("inputStart" in $$props)
          $$invalidate(15, inputStart = $$new_props.inputStart);
        if ("thumbEl" in $$props)
          $$invalidate(16, thumbEl = $$new_props.thumbEl);
        if ("thumbStart" in $$props)
          $$invalidate(17, thumbStart = $$new_props.thumbStart);
        if ("thumbKnob" in $$props)
          $$invalidate(18, thumbKnob = $$new_props.thumbKnob);
        if ("thumbKnobStart" in $$props)
          $$invalidate(19, thumbKnobStart = $$new_props.thumbKnobStart);
        if ("internalClasses" in $$props)
          $$invalidate(20, internalClasses = $$new_props.internalClasses);
        if ("thumbStartClasses" in $$props)
          $$invalidate(21, thumbStartClasses = $$new_props.thumbStartClasses);
        if ("thumbClasses" in $$props)
          $$invalidate(22, thumbClasses = $$new_props.thumbClasses);
        if ("inputAttrs" in $$props)
          $$invalidate(23, inputAttrs = $$new_props.inputAttrs);
        if ("inputStartAttrs" in $$props)
          $$invalidate(24, inputStartAttrs = $$new_props.inputStartAttrs);
        if ("trackActiveStyles" in $$props)
          $$invalidate(25, trackActiveStyles = $$new_props.trackActiveStyles);
        if ("thumbStyles" in $$props)
          $$invalidate(26, thumbStyles = $$new_props.thumbStyles);
        if ("thumbStartStyles" in $$props)
          $$invalidate(27, thumbStartStyles = $$new_props.thumbStartStyles);
        if ("thumbRippleActive" in $$props)
          $$invalidate(28, thumbRippleActive = $$new_props.thumbRippleActive);
        if ("thumbStartRippleActive" in $$props)
          $$invalidate(29, thumbStartRippleActive = $$new_props.thumbStartRippleActive);
        if ("currentTickMarks" in $$props)
          $$invalidate(30, currentTickMarks = $$new_props.currentTickMarks);
        if ("inputProps" in $$props)
          $$invalidate(32, inputProps = $$new_props.inputProps);
        if ("addLayoutListener" in $$props)
          addLayoutListener = $$new_props.addLayoutListener;
        if ("removeLayoutListener" in $$props)
          removeLayoutListener = $$new_props.removeLayoutListener;
        if ("previousValue" in $$props)
          $$invalidate(42, previousValue = $$new_props.previousValue);
        if ("previousStart" in $$props)
          $$invalidate(43, previousStart = $$new_props.previousStart);
        if ("previousEnd" in $$props)
          $$invalidate(44, previousEnd = $$new_props.previousEnd);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 7 | $$self.$$.dirty[1] & 15360) {
          if (instance9) {
            if (previousValue !== value) {
              instance9.setValue(value);
            }
            if (previousStart !== start) {
              instance9.setValueStart(start);
            }
            if (previousEnd !== end) {
              instance9.setValue(end);
            }
            $$invalidate(42, previousValue = value);
            $$invalidate(43, previousStart = start);
            $$invalidate(44, previousEnd = end);
            instance9.layout();
          }
        }
      };
      return [
        value,
        start,
        end,
        use2,
        className,
        disabled,
        range,
        discrete,
        tickMarks,
        step,
        min,
        max,
        input$class,
        element2,
        input,
        inputStart,
        thumbEl,
        thumbStart,
        thumbKnob,
        thumbKnobStart,
        internalClasses,
        thumbStartClasses,
        thumbClasses,
        inputAttrs,
        inputStartAttrs,
        trackActiveStyles,
        thumbStyles,
        thumbStartStyles,
        thumbRippleActive,
        thumbStartRippleActive,
        currentTickMarks,
        forwardEvents,
        inputProps,
        addThumbClass,
        removeThumbClass,
        addThumbStyle,
        $$restProps,
        valueToAriaValueTextFn,
        layout,
        getId,
        getElement,
        instance9,
        previousValue,
        previousStart,
        previousEnd,
        blur_handler_1,
        focus_handler_1,
        blur_handler,
        focus_handler,
        blur_handler_2,
        focus_handler_2,
        input0_binding,
        input0_change_input_handler,
        input1_binding,
        input1_change_input_handler,
        input_1_binding,
        input_1_change_input_handler,
        div0_binding,
        div1_binding,
        Ripple_function,
        Ripple_function_1,
        Ripple_function_2,
        div2_binding,
        div3_binding,
        Ripple_function_3,
        Ripple_function_4,
        Ripple_function_5,
        div0_binding_1,
        div1_binding_1,
        Ripple_function_6,
        Ripple_function_7,
        Ripple_function_8,
        div4_binding
      ];
    }
    var Slider = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$3, create_fragment$54, safe_not_equal, {
          use: 3,
          class: 4,
          disabled: 5,
          range: 6,
          discrete: 7,
          tickMarks: 8,
          step: 9,
          min: 10,
          max: 11,
          value: 0,
          start: 1,
          end: 2,
          valueToAriaValueTextFn: 37,
          input$class: 12,
          layout: 38,
          getId: 39,
          getElement: 40
        }, null, [-1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Slider",
          options,
          id: create_fragment$54.name
        });
      }
      get use() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get range() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set range(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get discrete() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set discrete(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get tickMarks() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set tickMarks(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get step() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set step(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get min() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set min(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get max() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set max(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get start() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set start(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get end() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set end(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get valueToAriaValueTextFn() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set valueToAriaValueTextFn(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$class() {
        throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$class(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get layout() {
        return this.$$.ctx[38];
      }
      set layout(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getId() {
        return this.$$.ctx[39];
      }
      set getId(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[40];
      }
      set getElement(value) {
        throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$23 = {
      CHECKED: "mdc-switch--checked",
      DISABLED: "mdc-switch--disabled"
    };
    var strings$22 = {
      ARIA_CHECKED_ATTR: "aria-checked",
      NATIVE_CONTROL_SELECTOR: ".mdc-switch__native-control",
      RIPPLE_SURFACE_SELECTOR: ".mdc-switch__thumb-underlay"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSwitchFoundation = function(_super) {
      __extends(MDCSwitchFoundation2, _super);
      function MDCSwitchFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSwitchFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCSwitchFoundation2, "strings", {
        get: function() {
          return strings$22;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSwitchFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$23;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSwitchFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            setNativeControlChecked: function() {
              return void 0;
            },
            setNativeControlDisabled: function() {
              return void 0;
            },
            setNativeControlAttr: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSwitchFoundation2.prototype.setChecked = function(checked) {
        this.adapter.setNativeControlChecked(checked);
        this.updateAriaChecked_(checked);
        this.updateCheckedStyling_(checked);
      };
      MDCSwitchFoundation2.prototype.setDisabled = function(disabled) {
        this.adapter.setNativeControlDisabled(disabled);
        if (disabled) {
          this.adapter.addClass(cssClasses$23.DISABLED);
        } else {
          this.adapter.removeClass(cssClasses$23.DISABLED);
        }
      };
      MDCSwitchFoundation2.prototype.handleChange = function(evt) {
        var nativeControl = evt.target;
        this.updateAriaChecked_(nativeControl.checked);
        this.updateCheckedStyling_(nativeControl.checked);
      };
      MDCSwitchFoundation2.prototype.updateCheckedStyling_ = function(checked) {
        if (checked) {
          this.adapter.addClass(cssClasses$23.CHECKED);
        } else {
          this.adapter.removeClass(cssClasses$23.CHECKED);
        }
      };
      MDCSwitchFoundation2.prototype.updateAriaChecked_ = function(checked) {
        this.adapter.setNativeControlAttr(strings$22.ARIA_CHECKED_ATTR, "" + !!checked);
      };
      return MDCSwitchFoundation2;
    }(MDCFoundation);
    var oldModifierRegex$13 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    var newModifierRegex$13 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder$13(component) {
      let $on;
      let events2 = [];
      const componentOn = component.$on;
      component.$on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let destructor = () => {
        };
        if ($on) {
          destructor = $on(eventType, callback);
        } else {
          events2.push([eventType, callback]);
        }
        const oldModifierMatch = eventType.match(oldModifierRegex$13);
        const newModifierMatch = eventType.match(newModifierRegex$13);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (oldModifierMatch && console) {
          console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
        }
        const componentDestructor = componentOn.call(component, eventType, callback);
        return (...args) => {
          destructor();
          return componentDestructor(...args);
        };
      };
      function forward(e) {
        bubble(component, e);
      }
      return (node) => {
        const destructors = [];
        const forwardDestructors = {};
        $on = (fullEventType, callback) => {
          let eventType = fullEventType;
          let handler = callback;
          let options = false;
          const oldModifierMatch = eventType.match(oldModifierRegex$13);
          const newModifierMatch = eventType.match(newModifierRegex$13);
          const modifierMatch = oldModifierMatch || newModifierMatch;
          if (modifierMatch) {
            const parts = eventType.split(oldModifierMatch ? ":" : "$");
            eventType = parts[0];
            options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
            if (options.nonpassive) {
              options.passive = false;
              delete options.nonpassive;
            }
            if (options.preventDefault) {
              handler = prevent_default(handler);
              delete options.preventDefault;
            }
            if (options.stopPropagation) {
              handler = stop_propagation(handler);
              delete options.stopPropagation;
            }
          }
          const off = listen(node, eventType, handler, options);
          const destructor = () => {
            off();
            const idx = destructors.indexOf(destructor);
            if (idx > -1) {
              destructors.splice(idx, 1);
            }
          };
          destructors.push(destructor);
          if (!eventType in forwardDestructors) {
            forwardDestructors[eventType] = listen(node, eventType, forward);
          }
          return destructor;
        };
        for (let i = 0; i < events2.length; i++) {
          $on(events2[i][0], events2[i][1]);
        }
        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
            for (let entry of Object.entries(forwardDestructors)) {
              entry[1]();
            }
          }
        };
      };
    }
    function classMap$13(classObj) {
      return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
    }
    function dispatch$12(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    function exclude$1(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf("$");
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }
      return newObj;
    }
    function prefixFilter$1(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }
      return newObj;
    }
    function useActions$12(node, actions) {
      let objects = [];
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray2 = Array.isArray(actions[i]);
          const action = isArray2 ? actions[i][0] : actions[i];
          if (isArray2 && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i = 0; i < actions2.length; i++) {
              if (objects[i] && "update" in objects[i]) {
                const isArray2 = Array.isArray(actions2[i]);
                if (isArray2 && actions2[i].length > 1) {
                  objects[i].update(actions2[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && "destroy" in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      };
    }
    var file$33 = "node_modules/@smui/switch/Switch.svelte";
    function create_fragment$44(ctx) {
      let div3;
      let div0;
      let t0;
      let div2;
      let div1;
      let t1;
      let input;
      let input_class_value;
      let input_aria_checked_value;
      let input_value_value;
      let useActions_action;
      let div2_class_value;
      let Ripple_action;
      let div3_class_value;
      let useActions_action_1;
      let mounted;
      let dispose;
      let input_levels = [
        {
          class: input_class_value = classMap$13({
            [ctx[7]]: true,
            "mdc-switch__native-control": true
          })
        },
        {type: "checkbox"},
        {role: "switch"},
        ctx[17],
        {disabled: ctx[0]},
        {
          "aria-checked": input_aria_checked_value = ctx[8] ? "true" : "false"
        },
        {
          __value: input_value_value = ctx[5] === ctx[16] ? ctx[4] : ctx[5]
        },
        ctx[13],
        prefixFilter$1(ctx[20], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      let div3_levels = [
        {
          class: div3_class_value = classMap$13({
            [ctx[2]]: true,
            "mdc-switch": true,
            "mdc-switch--disabled": ctx[0],
            "mdc-switch--checked": ctx[8],
            "smui-switch--color-primary": ctx[3] === "primary",
            ...ctx[11]
          })
        },
        exclude$1(ctx[20], ["input$"])
      ];
      let div3_data = {};
      for (let i = 0; i < div3_levels.length; i += 1) {
        div3_data = assign(div3_data, div3_levels[i]);
      }
      const block = {
        c: function create2() {
          div3 = element("div");
          div0 = element("div");
          t0 = space();
          div2 = element("div");
          div1 = element("div");
          t1 = space();
          input = element("input");
          attr_dev(div0, "class", "mdc-switch__track");
          add_location(div0, file$33, 14, 2, 346);
          attr_dev(div1, "class", "mdc-switch__thumb");
          add_location(div1, file$33, 30, 4, 761);
          set_attributes(input, input_data);
          add_location(input, file$33, 31, 4, 799);
          attr_dev(div2, "class", div2_class_value = classMap$13({
            "mdc-switch__thumb-underlay": true,
            ...ctx[12]
          }));
          add_location(div2, file$33, 15, 2, 382);
          set_attributes(div3, div3_data);
          add_location(div3, file$33, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div3, t0);
          append_dev(div3, div2);
          append_dev(div2, div1);
          append_dev(div2, t1);
          append_dev(div2, input);
          if (input.autofocus)
            input.focus();
          ctx[31](input);
          input.checked = ctx[8];
          ctx[33](div3);
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions$12.call(null, input, ctx[6])),
              listen_dev(input, "change", ctx[32]),
              listen_dev(input, "blur", ctx[29], false, false, false),
              listen_dev(input, "focus", ctx[30], false, false, false),
              action_destroyer(Ripple_action = Ripple.call(null, div2, {
                unbounded: true,
                color: ctx[3],
                active: ctx[14],
                addClass: ctx[18],
                removeClass: ctx[19],
                eventTarget: ctx[10]
              })),
              action_destroyer(useActions_action_1 = useActions$12.call(null, div3, ctx[1])),
              action_destroyer(ctx[15].call(null, div3))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            dirty[0] & 128 && input_class_value !== (input_class_value = classMap$13({
              [ctx2[7]]: true,
              "mdc-switch__native-control": true
            })) && {class: input_class_value},
            {type: "checkbox"},
            {role: "switch"},
            ctx2[17],
            dirty[0] & 1 && {disabled: ctx2[0]},
            dirty[0] & 256 && input_aria_checked_value !== (input_aria_checked_value = ctx2[8] ? "true" : "false") && {"aria-checked": input_aria_checked_value},
            dirty[0] & 48 && input_value_value !== (input_value_value = ctx2[5] === ctx2[16] ? ctx2[4] : ctx2[5]) && {__value: input_value_value},
            dirty[0] & 8192 && ctx2[13],
            dirty[0] & 1048576 && prefixFilter$1(ctx2[20], "input$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 64)
            useActions_action.update.call(null, ctx2[6]);
          if (dirty[0] & 256) {
            input.checked = ctx2[8];
          }
          if (dirty[0] & 4096 && div2_class_value !== (div2_class_value = classMap$13({
            "mdc-switch__thumb-underlay": true,
            ...ctx2[12]
          }))) {
            attr_dev(div2, "class", div2_class_value);
          }
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 17416)
            Ripple_action.update.call(null, {
              unbounded: true,
              color: ctx2[3],
              active: ctx2[14],
              addClass: ctx2[18],
              removeClass: ctx2[19],
              eventTarget: ctx2[10]
            });
          set_attributes(div3, div3_data = get_spread_update(div3_levels, [
            dirty[0] & 2317 && div3_class_value !== (div3_class_value = classMap$13({
              [ctx2[2]]: true,
              "mdc-switch": true,
              "mdc-switch--disabled": ctx2[0],
              "mdc-switch--checked": ctx2[8],
              "smui-switch--color-primary": ctx2[3] === "primary",
              ...ctx2[11]
            })) && {class: div3_class_value},
            dirty[0] & 1048576 && exclude$1(ctx2[20], ["input$"])
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 2)
            useActions_action_1.update.call(null, ctx2[1]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div3);
          ctx[31](null);
          ctx[33](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$44.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance_1$23($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "disabled",
        "color",
        "group",
        "checked",
        "value",
        "valueKey",
        "input$use",
        "input$class",
        "getId",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Switch", slots, []);
      const forwardEvents = forwardEventsBuilder$13(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {disabled = false} = $$props;
      let {color = "secondary"} = $$props;
      let {group = uninitializedValue} = $$props;
      let {checked = uninitializedValue} = $$props;
      let {value = null} = $$props;
      let {valueKey = uninitializedValue} = $$props;
      let {input$use = []} = $$props;
      let {input$class = ""} = $$props;
      let element2;
      let instance9;
      let checkbox;
      let internalClasses = {};
      let thumbUnderlayClasses = {};
      let nativeControlAttrs = {};
      let rippleActive = false;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      let nativeChecked = group === uninitializedValue ? checked === uninitializedValue ? false : checked : group.indexOf(value) !== -1;
      let previousChecked = checked;
      let previousGroup = group === uninitializedValue ? [] : [...group];
      let previousNativeChecked = nativeChecked;
      onMount(() => {
        $$invalidate(25, instance9 = new MDCSwitchFoundation({
          addClass,
          removeClass,
          setNativeControlChecked: (checked2) => $$invalidate(8, nativeChecked = checked2),
          setNativeControlDisabled: (disabledValue) => $$invalidate(0, disabled = disabledValue),
          setNativeControlAttr: addNativeControlAttr
        }));
        const accessor = {
          get element() {
            return getElement();
          },
          get checked() {
            return nativeChecked;
          },
          set checked(checked2) {
            if (nativeChecked !== value) {
              $$invalidate(8, nativeChecked = value);
            }
          },
          activateRipple() {
            if (!disabled) {
              $$invalidate(14, rippleActive = true);
            }
          },
          deactivateRipple() {
            $$invalidate(14, rippleActive = false);
          }
        };
        dispatch$12(element2, "SMUI:generic:input:mount", accessor);
        instance9.init();
        return () => {
          dispatch$12(element2, "SMUI:generic:input:unmount", accessor);
          instance9.destroy();
        };
      });
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = false, internalClasses);
        }
      }
      function addThumbUnderlayClass(className2) {
        if (!thumbUnderlayClasses[className2]) {
          $$invalidate(12, thumbUnderlayClasses[className2] = true, thumbUnderlayClasses);
        }
      }
      function removeThumbUnderlayClass(className2) {
        if (!(className2 in thumbUnderlayClasses) || thumbUnderlayClasses[className2]) {
          $$invalidate(12, thumbUnderlayClasses[className2] = false, thumbUnderlayClasses);
        }
      }
      function addNativeControlAttr(name, value2) {
        if (nativeControlAttrs[name] !== value2) {
          $$invalidate(13, nativeControlAttrs[name] = value2, nativeControlAttrs);
        }
      }
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element2;
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          checkbox = $$value;
          $$invalidate(10, checkbox);
        });
      }
      function input_change_handler() {
        nativeChecked = this.checked;
        $$invalidate(8, nativeChecked), $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance9);
      }
      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(9, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("disabled" in $$new_props)
          $$invalidate(0, disabled = $$new_props.disabled);
        if ("color" in $$new_props)
          $$invalidate(3, color = $$new_props.color);
        if ("group" in $$new_props)
          $$invalidate(21, group = $$new_props.group);
        if ("checked" in $$new_props)
          $$invalidate(22, checked = $$new_props.checked);
        if ("value" in $$new_props)
          $$invalidate(4, value = $$new_props.value);
        if ("valueKey" in $$new_props)
          $$invalidate(5, valueKey = $$new_props.valueKey);
        if ("input$use" in $$new_props)
          $$invalidate(6, input$use = $$new_props.input$use);
        if ("input$class" in $$new_props)
          $$invalidate(7, input$class = $$new_props.input$class);
      };
      $$self.$capture_state = () => ({
        MDCSwitchFoundation,
        onMount,
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder$13,
        classMap: classMap$13,
        exclude: exclude$1,
        prefixFilter: prefixFilter$1,
        useActions: useActions$12,
        dispatch: dispatch$12,
        Ripple,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        disabled,
        color,
        group,
        checked,
        value,
        valueKey,
        input$use,
        input$class,
        element: element2,
        instance: instance9,
        checkbox,
        internalClasses,
        thumbUnderlayClasses,
        nativeControlAttrs,
        rippleActive,
        inputProps,
        nativeChecked,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        addClass,
        removeClass,
        addThumbUnderlayClass,
        removeThumbUnderlayClass,
        addNativeControlAttr,
        getId,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(16, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("disabled" in $$props)
          $$invalidate(0, disabled = $$new_props.disabled);
        if ("color" in $$props)
          $$invalidate(3, color = $$new_props.color);
        if ("group" in $$props)
          $$invalidate(21, group = $$new_props.group);
        if ("checked" in $$props)
          $$invalidate(22, checked = $$new_props.checked);
        if ("value" in $$props)
          $$invalidate(4, value = $$new_props.value);
        if ("valueKey" in $$props)
          $$invalidate(5, valueKey = $$new_props.valueKey);
        if ("input$use" in $$props)
          $$invalidate(6, input$use = $$new_props.input$use);
        if ("input$class" in $$props)
          $$invalidate(7, input$class = $$new_props.input$class);
        if ("element" in $$props)
          $$invalidate(9, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(25, instance9 = $$new_props.instance);
        if ("checkbox" in $$props)
          $$invalidate(10, checkbox = $$new_props.checkbox);
        if ("internalClasses" in $$props)
          $$invalidate(11, internalClasses = $$new_props.internalClasses);
        if ("thumbUnderlayClasses" in $$props)
          $$invalidate(12, thumbUnderlayClasses = $$new_props.thumbUnderlayClasses);
        if ("nativeControlAttrs" in $$props)
          $$invalidate(13, nativeControlAttrs = $$new_props.nativeControlAttrs);
        if ("rippleActive" in $$props)
          $$invalidate(14, rippleActive = $$new_props.rippleActive);
        if ("inputProps" in $$props)
          $$invalidate(17, inputProps = $$new_props.inputProps);
        if ("nativeChecked" in $$props)
          $$invalidate(8, nativeChecked = $$new_props.nativeChecked);
        if ("previousChecked" in $$props)
          $$invalidate(26, previousChecked = $$new_props.previousChecked);
        if ("previousGroup" in $$props)
          $$invalidate(27, previousGroup = $$new_props.previousGroup);
        if ("previousNativeChecked" in $$props)
          $$invalidate(28, previousNativeChecked = $$new_props.previousNativeChecked);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 509608208) {
          {
            let callHandleChange = false;
            if (group !== uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                const idx = group.indexOf(value);
                if (nativeChecked && idx === -1) {
                  group.push(value);
                  $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(8, nativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance9);
                } else if (!nativeChecked && idx !== -1) {
                  group.splice(idx, 1);
                  $$invalidate(21, group), $$invalidate(16, uninitializedValue), $$invalidate(28, previousNativeChecked), $$invalidate(8, nativeChecked), $$invalidate(4, value), $$invalidate(27, previousGroup), $$invalidate(22, checked), $$invalidate(26, previousChecked), $$invalidate(25, instance9);
                }
                callHandleChange = true;
              } else {
                const idxPrev = previousGroup.indexOf(value);
                const idx = group.indexOf(value);
                if (idxPrev > -1 && idx === -1) {
                  $$invalidate(8, nativeChecked = false);
                  callHandleChange = true;
                } else if (idx > -1 && idxPrev === -1) {
                  $$invalidate(8, nativeChecked = true);
                  callHandleChange = true;
                }
              }
            }
            if (checked === uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                callHandleChange = true;
              }
            } else if (checked !== nativeChecked) {
              if (checked === previousChecked) {
                $$invalidate(22, checked = nativeChecked);
              } else {
                $$invalidate(8, nativeChecked = checked);
              }
              callHandleChange = true;
            }
            $$invalidate(26, previousChecked = checked);
            $$invalidate(27, previousGroup = group === uninitializedValue ? [] : [...group]);
            $$invalidate(28, previousNativeChecked = nativeChecked);
            if (callHandleChange && instance9) {
              instance9.handleChange({target: {checked: nativeChecked}});
            }
          }
        }
      };
      return [
        disabled,
        use2,
        className,
        color,
        value,
        valueKey,
        input$use,
        input$class,
        nativeChecked,
        element2,
        checkbox,
        internalClasses,
        thumbUnderlayClasses,
        nativeControlAttrs,
        rippleActive,
        forwardEvents,
        uninitializedValue,
        inputProps,
        addThumbUnderlayClass,
        removeThumbUnderlayClass,
        $$restProps,
        group,
        checked,
        getId,
        getElement,
        instance9,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        blur_handler,
        focus_handler,
        input_binding,
        input_change_handler,
        div3_binding
      ];
    }
    var Switch = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$23, create_fragment$44, safe_not_equal, {
          use: 1,
          class: 2,
          disabled: 0,
          color: 3,
          group: 21,
          checked: 22,
          value: 4,
          valueKey: 5,
          input$use: 6,
          input$class: 7,
          getId: 23,
          getElement: 24
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Switch",
          options,
          id: create_fragment$44.name
        });
      }
      get use() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get group() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set group(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get checked() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set checked(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get valueKey() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set valueKey(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$use() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$use(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$class() {
        throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$class(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getId() {
        return this.$$.ctx[23];
      }
      set getId(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[24];
      }
      set getElement(value) {
        throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$13 = {
      ACTIVATED: "mdc-select--activated",
      DISABLED: "mdc-select--disabled",
      FOCUSED: "mdc-select--focused",
      INVALID: "mdc-select--invalid",
      MENU_INVALID: "mdc-select__menu--invalid",
      OUTLINED: "mdc-select--outlined",
      REQUIRED: "mdc-select--required",
      ROOT: "mdc-select",
      WITH_LEADING_ICON: "mdc-select--with-leading-icon"
    };
    var strings$12 = {
      ARIA_CONTROLS: "aria-controls",
      ARIA_DESCRIBEDBY: "aria-describedby",
      ARIA_SELECTED_ATTR: "aria-selected",
      CHANGE_EVENT: "MDCSelect:change",
      HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
      LABEL_SELECTOR: ".mdc-floating-label",
      LEADING_ICON_SELECTOR: ".mdc-select__icon",
      LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
      MENU_SELECTOR: ".mdc-select__menu",
      OUTLINE_SELECTOR: ".mdc-notched-outline",
      SELECTED_TEXT_SELECTOR: ".mdc-select__selected-text",
      SELECT_ANCHOR_SELECTOR: ".mdc-select__anchor",
      VALUE_ATTR: "data-value"
    };
    var numbers5 = {
      LABEL_SCALE: 0.75,
      UNSET_INDEX: -1,
      CLICK_DEBOUNCE_TIMEOUT_MS: 330
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectFoundation = function(_super) {
      __extends(MDCSelectFoundation2, _super);
      function MDCSelectFoundation2(adapter, foundationMap) {
        if (foundationMap === void 0) {
          foundationMap = {};
        }
        var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation2.defaultAdapter), adapter)) || this;
        _this.disabled = false;
        _this.isMenuOpen = false;
        _this.useDefaultValidation = true;
        _this.customValidity = true;
        _this.lastSelectedIndex = numbers5.UNSET_INDEX;
        _this.clickDebounceTimeout = 0;
        _this.recentlyClicked = false;
        _this.leadingIcon = foundationMap.leadingIcon;
        _this.helperText = foundationMap.helperText;
        return _this;
      }
      Object.defineProperty(MDCSelectFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$13;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "numbers", {
        get: function() {
          return numbers5;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            activateBottomLine: function() {
              return void 0;
            },
            deactivateBottomLine: function() {
              return void 0;
            },
            getSelectedIndex: function() {
              return -1;
            },
            setSelectedIndex: function() {
              return void 0;
            },
            hasLabel: function() {
              return false;
            },
            floatLabel: function() {
              return void 0;
            },
            getLabelWidth: function() {
              return 0;
            },
            setLabelRequired: function() {
              return void 0;
            },
            hasOutline: function() {
              return false;
            },
            notchOutline: function() {
              return void 0;
            },
            closeOutline: function() {
              return void 0;
            },
            setRippleCenter: function() {
              return void 0;
            },
            notifyChange: function() {
              return void 0;
            },
            setSelectedText: function() {
              return void 0;
            },
            isSelectAnchorFocused: function() {
              return false;
            },
            getSelectAnchorAttr: function() {
              return "";
            },
            setSelectAnchorAttr: function() {
              return void 0;
            },
            removeSelectAnchorAttr: function() {
              return void 0;
            },
            addMenuClass: function() {
              return void 0;
            },
            removeMenuClass: function() {
              return void 0;
            },
            openMenu: function() {
              return void 0;
            },
            closeMenu: function() {
              return void 0;
            },
            getAnchorElement: function() {
              return null;
            },
            setMenuAnchorElement: function() {
              return void 0;
            },
            setMenuAnchorCorner: function() {
              return void 0;
            },
            setMenuWrapFocus: function() {
              return void 0;
            },
            focusMenuItemAtIndex: function() {
              return void 0;
            },
            getMenuItemCount: function() {
              return 0;
            },
            getMenuItemValues: function() {
              return [];
            },
            getMenuItemTextAtIndex: function() {
              return "";
            },
            isTypeaheadInProgress: function() {
              return false;
            },
            typeaheadMatchItem: function() {
              return -1;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSelectFoundation2.prototype.getSelectedIndex = function() {
        return this.adapter.getSelectedIndex();
      };
      MDCSelectFoundation2.prototype.setSelectedIndex = function(index, closeMenu, skipNotify) {
        if (closeMenu === void 0) {
          closeMenu = false;
        }
        if (skipNotify === void 0) {
          skipNotify = false;
        }
        if (index >= this.adapter.getMenuItemCount()) {
          return;
        }
        if (index === numbers5.UNSET_INDEX) {
          this.adapter.setSelectedText("");
        } else {
          this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
        }
        this.adapter.setSelectedIndex(index);
        if (closeMenu) {
          this.adapter.closeMenu();
        }
        if (!skipNotify && this.lastSelectedIndex !== index) {
          this.handleChange();
        }
        this.lastSelectedIndex = index;
      };
      MDCSelectFoundation2.prototype.setValue = function(value, skipNotify) {
        if (skipNotify === void 0) {
          skipNotify = false;
        }
        var index = this.adapter.getMenuItemValues().indexOf(value);
        this.setSelectedIndex(index, false, skipNotify);
      };
      MDCSelectFoundation2.prototype.getValue = function() {
        var index = this.adapter.getSelectedIndex();
        var menuItemValues = this.adapter.getMenuItemValues();
        return index !== numbers5.UNSET_INDEX ? menuItemValues[index] : "";
      };
      MDCSelectFoundation2.prototype.getDisabled = function() {
        return this.disabled;
      };
      MDCSelectFoundation2.prototype.setDisabled = function(isDisabled) {
        this.disabled = isDisabled;
        if (this.disabled) {
          this.adapter.addClass(cssClasses$13.DISABLED);
          this.adapter.closeMenu();
        } else {
          this.adapter.removeClass(cssClasses$13.DISABLED);
        }
        if (this.leadingIcon) {
          this.leadingIcon.setDisabled(this.disabled);
        }
        if (this.disabled) {
          this.adapter.removeSelectAnchorAttr("tabindex");
        } else {
          this.adapter.setSelectAnchorAttr("tabindex", "0");
        }
        this.adapter.setSelectAnchorAttr("aria-disabled", this.disabled.toString());
      };
      MDCSelectFoundation2.prototype.openMenu = function() {
        this.adapter.addClass(cssClasses$13.ACTIVATED);
        this.adapter.openMenu();
        this.isMenuOpen = true;
        this.adapter.setSelectAnchorAttr("aria-expanded", "true");
      };
      MDCSelectFoundation2.prototype.setHelperTextContent = function(content) {
        if (this.helperText) {
          this.helperText.setContent(content);
        }
      };
      MDCSelectFoundation2.prototype.layout = function() {
        if (this.adapter.hasLabel()) {
          var optionHasValue = this.getValue().length > 0;
          var isFocused = this.adapter.hasClass(cssClasses$13.FOCUSED);
          var shouldFloatAndNotch = optionHasValue || isFocused;
          var isRequired = this.adapter.hasClass(cssClasses$13.REQUIRED);
          this.notchOutline(shouldFloatAndNotch);
          this.adapter.floatLabel(shouldFloatAndNotch);
          this.adapter.setLabelRequired(isRequired);
        }
      };
      MDCSelectFoundation2.prototype.layoutOptions = function() {
        var menuItemValues = this.adapter.getMenuItemValues();
        var selectedIndex = menuItemValues.indexOf(this.getValue());
        this.setSelectedIndex(selectedIndex, false, true);
      };
      MDCSelectFoundation2.prototype.handleMenuOpened = function() {
        if (this.adapter.getMenuItemValues().length === 0) {
          return;
        }
        var selectedIndex = this.getSelectedIndex();
        var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
        this.adapter.focusMenuItemAtIndex(focusItemIndex);
      };
      MDCSelectFoundation2.prototype.handleMenuClosing = function() {
        this.adapter.setSelectAnchorAttr("aria-expanded", "false");
      };
      MDCSelectFoundation2.prototype.handleMenuClosed = function() {
        this.adapter.removeClass(cssClasses$13.ACTIVATED);
        this.isMenuOpen = false;
        if (!this.adapter.isSelectAnchorFocused()) {
          this.blur();
        }
      };
      MDCSelectFoundation2.prototype.handleChange = function() {
        this.layout();
        this.adapter.notifyChange(this.getValue());
        var isRequired = this.adapter.hasClass(cssClasses$13.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
          this.setValid(this.isValid());
        }
      };
      MDCSelectFoundation2.prototype.handleMenuItemAction = function(index) {
        this.setSelectedIndex(index, true);
      };
      MDCSelectFoundation2.prototype.handleFocus = function() {
        this.adapter.addClass(cssClasses$13.FOCUSED);
        this.layout();
        this.adapter.activateBottomLine();
      };
      MDCSelectFoundation2.prototype.handleBlur = function() {
        if (this.isMenuOpen) {
          return;
        }
        this.blur();
      };
      MDCSelectFoundation2.prototype.handleClick = function(normalizedX) {
        if (this.disabled || this.recentlyClicked) {
          return;
        }
        this.setClickDebounceTimeout();
        if (this.isMenuOpen) {
          this.adapter.closeMenu();
          return;
        }
        this.adapter.setRippleCenter(normalizedX);
        this.openMenu();
      };
      MDCSelectFoundation2.prototype.handleKeydown = function(event) {
        if (this.isMenuOpen || !this.adapter.hasClass(cssClasses$13.FOCUSED)) {
          return;
        }
        var isEnter = normalizeKey(event) === KEY.ENTER;
        var isSpace = normalizeKey(event) === KEY.SPACEBAR;
        var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
        var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
        var isModifier = event.ctrlKey || event.metaKey;
        if (!isModifier && (!isSpace && event.key && event.key.length === 1 || isSpace && this.adapter.isTypeaheadInProgress())) {
          var key = isSpace ? " " : event.key;
          var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
          if (typeaheadNextIndex >= 0) {
            this.setSelectedIndex(typeaheadNextIndex);
          }
          event.preventDefault();
          return;
        }
        if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
          return;
        }
        if (arrowUp && this.getSelectedIndex() > 0) {
          this.setSelectedIndex(this.getSelectedIndex() - 1);
        } else if (arrowDown && this.getSelectedIndex() < this.adapter.getMenuItemCount() - 1) {
          this.setSelectedIndex(this.getSelectedIndex() + 1);
        }
        this.openMenu();
        event.preventDefault();
      };
      MDCSelectFoundation2.prototype.notchOutline = function(openNotch) {
        if (!this.adapter.hasOutline()) {
          return;
        }
        var isFocused = this.adapter.hasClass(cssClasses$13.FOCUSED);
        if (openNotch) {
          var labelScale = numbers5.LABEL_SCALE;
          var labelWidth = this.adapter.getLabelWidth() * labelScale;
          this.adapter.notchOutline(labelWidth);
        } else if (!isFocused) {
          this.adapter.closeOutline();
        }
      };
      MDCSelectFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
        if (this.leadingIcon) {
          this.leadingIcon.setAriaLabel(label);
        }
      };
      MDCSelectFoundation2.prototype.setLeadingIconContent = function(content) {
        if (this.leadingIcon) {
          this.leadingIcon.setContent(content);
        }
      };
      MDCSelectFoundation2.prototype.setUseDefaultValidation = function(useDefaultValidation) {
        this.useDefaultValidation = useDefaultValidation;
      };
      MDCSelectFoundation2.prototype.setValid = function(isValid) {
        if (!this.useDefaultValidation) {
          this.customValidity = isValid;
        }
        this.adapter.setSelectAnchorAttr("aria-invalid", (!isValid).toString());
        if (isValid) {
          this.adapter.removeClass(cssClasses$13.INVALID);
          this.adapter.removeMenuClass(cssClasses$13.MENU_INVALID);
        } else {
          this.adapter.addClass(cssClasses$13.INVALID);
          this.adapter.addMenuClass(cssClasses$13.MENU_INVALID);
        }
        this.syncHelperTextValidity(isValid);
      };
      MDCSelectFoundation2.prototype.isValid = function() {
        if (this.useDefaultValidation && this.adapter.hasClass(cssClasses$13.REQUIRED) && !this.adapter.hasClass(cssClasses$13.DISABLED)) {
          return this.getSelectedIndex() !== numbers5.UNSET_INDEX && (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
        }
        return this.customValidity;
      };
      MDCSelectFoundation2.prototype.setRequired = function(isRequired) {
        if (isRequired) {
          this.adapter.addClass(cssClasses$13.REQUIRED);
        } else {
          this.adapter.removeClass(cssClasses$13.REQUIRED);
        }
        this.adapter.setSelectAnchorAttr("aria-required", isRequired.toString());
        this.adapter.setLabelRequired(isRequired);
      };
      MDCSelectFoundation2.prototype.getRequired = function() {
        return this.adapter.getSelectAnchorAttr("aria-required") === "true";
      };
      MDCSelectFoundation2.prototype.init = function() {
        var anchorEl = this.adapter.getAnchorElement();
        if (anchorEl) {
          this.adapter.setMenuAnchorElement(anchorEl);
          this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
        }
        this.adapter.setMenuWrapFocus(false);
        this.setDisabled(this.adapter.hasClass(cssClasses$13.DISABLED));
        this.syncHelperTextValidity(!this.adapter.hasClass(cssClasses$13.INVALID));
        this.layout();
        this.layoutOptions();
      };
      MDCSelectFoundation2.prototype.blur = function() {
        this.adapter.removeClass(cssClasses$13.FOCUSED);
        this.layout();
        this.adapter.deactivateBottomLine();
        var isRequired = this.adapter.hasClass(cssClasses$13.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
          this.setValid(this.isValid());
        }
      };
      MDCSelectFoundation2.prototype.syncHelperTextValidity = function(isValid) {
        if (!this.helperText) {
          return;
        }
        this.helperText.setValidity(isValid);
        var helperTextVisible = this.helperText.isVisible();
        var helperTextId = this.helperText.getId();
        if (helperTextVisible && helperTextId) {
          this.adapter.setSelectAnchorAttr(strings$12.ARIA_DESCRIBEDBY, helperTextId);
        } else {
          this.adapter.removeSelectAnchorAttr(strings$12.ARIA_DESCRIBEDBY);
        }
      };
      MDCSelectFoundation2.prototype.setClickDebounceTimeout = function() {
        var _this = this;
        clearTimeout(this.clickDebounceTimeout);
        this.clickDebounceTimeout = setTimeout(function() {
          _this.recentlyClicked = false;
        }, numbers5.CLICK_DEBOUNCE_TIMEOUT_MS);
        this.recentlyClicked = true;
      };
      return MDCSelectFoundation2;
    }(MDCFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings6 = {
      ARIA_HIDDEN: "aria-hidden",
      ROLE: "role"
    };
    var cssClasses6 = {
      HELPER_TEXT_VALIDATION_MSG: "mdc-select-helper-text--validation-msg",
      HELPER_TEXT_VALIDATION_MSG_PERSISTENT: "mdc-select-helper-text--validation-msg-persistent"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCSelectHelperTextFoundation = function(_super) {
      __extends(MDCSelectHelperTextFoundation2, _super);
      function MDCSelectHelperTextFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCSelectHelperTextFoundation2, "cssClasses", {
        get: function() {
          return cssClasses6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectHelperTextFoundation2, "strings", {
        get: function() {
          return strings6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCSelectHelperTextFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            setAttr: function() {
              return void 0;
            },
            getAttr: function() {
              return null;
            },
            removeAttr: function() {
              return void 0;
            },
            setContent: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCSelectHelperTextFoundation2.prototype.getId = function() {
        return this.adapter.getAttr("id");
      };
      MDCSelectHelperTextFoundation2.prototype.isVisible = function() {
        return this.adapter.getAttr(strings6.ARIA_HIDDEN) !== "true";
      };
      MDCSelectHelperTextFoundation2.prototype.setContent = function(content) {
        this.adapter.setContent(content);
      };
      MDCSelectHelperTextFoundation2.prototype.setValidation = function(isValidation) {
        if (isValidation) {
          this.adapter.addClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter.removeClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG);
        }
      };
      MDCSelectHelperTextFoundation2.prototype.setValidationMsgPersistent = function(isPersistent) {
        if (isPersistent) {
          this.adapter.addClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        } else {
          this.adapter.removeClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        }
      };
      MDCSelectHelperTextFoundation2.prototype.setValidity = function(selectIsValid) {
        var isValidationMsg = this.adapter.hasClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG);
        if (!isValidationMsg) {
          return;
        }
        var isPersistentValidationMsg = this.adapter.hasClass(cssClasses6.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
        var msgShouldDisplay = !selectIsValid || isPersistentValidationMsg;
        if (msgShouldDisplay) {
          this.showToScreenReader();
          if (!selectIsValid) {
            this.adapter.setAttr(strings6.ROLE, "alert");
          } else {
            this.adapter.removeAttr(strings6.ROLE);
          }
          return;
        }
        this.adapter.removeAttr(strings6.ROLE);
        this.hide();
      };
      MDCSelectHelperTextFoundation2.prototype.showToScreenReader = function() {
        this.adapter.removeAttr(strings6.ARIA_HIDDEN);
      };
      MDCSelectHelperTextFoundation2.prototype.hide = function() {
        this.adapter.setAttr(strings6.ARIA_HIDDEN, "true");
      };
      return MDCSelectHelperTextFoundation2;
    }(MDCFoundation);
    var oldModifierRegex9 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    var newModifierRegex9 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder9(component) {
      let $on;
      let events2 = [];
      const componentOn = component.$on;
      component.$on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let destructor = () => {
        };
        if ($on) {
          destructor = $on(eventType, callback);
        } else {
          events2.push([eventType, callback]);
        }
        const oldModifierMatch = eventType.match(oldModifierRegex9);
        const newModifierMatch = eventType.match(newModifierRegex9);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (oldModifierMatch && console) {
          console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
        }
        const componentDestructor = componentOn.call(component, eventType, callback);
        return (...args) => {
          destructor();
          return componentDestructor(...args);
        };
      };
      function forward(e) {
        bubble(component, e);
      }
      return (node) => {
        const destructors = [];
        const forwardDestructors = {};
        $on = (fullEventType, callback) => {
          let eventType = fullEventType;
          let handler = callback;
          let options = false;
          const oldModifierMatch = eventType.match(oldModifierRegex9);
          const newModifierMatch = eventType.match(newModifierRegex9);
          const modifierMatch = oldModifierMatch || newModifierMatch;
          if (modifierMatch) {
            const parts = eventType.split(oldModifierMatch ? ":" : "$");
            eventType = parts[0];
            options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
            if (options.nonpassive) {
              options.passive = false;
              delete options.nonpassive;
            }
            if (options.preventDefault) {
              handler = prevent_default(handler);
              delete options.preventDefault;
            }
            if (options.stopPropagation) {
              handler = stop_propagation(handler);
              delete options.stopPropagation;
            }
          }
          const off = listen(node, eventType, handler, options);
          const destructor = () => {
            off();
            const idx = destructors.indexOf(destructor);
            if (idx > -1) {
              destructors.splice(idx, 1);
            }
          };
          destructors.push(destructor);
          if (!eventType in forwardDestructors) {
            forwardDestructors[eventType] = listen(node, eventType, forward);
          }
          return destructor;
        };
        for (let i = 0; i < events2.length; i++) {
          $on(events2[i][0], events2[i][1]);
        }
        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
            for (let entry of Object.entries(forwardDestructors)) {
              entry[1]();
            }
          }
        };
      };
    }
    function classMap9(classObj) {
      return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
    }
    function dispatch5(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    function exclude3(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf("$");
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }
      return newObj;
    }
    function prefixFilter3(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }
      return newObj;
    }
    function useActions8(node, actions) {
      let objects = [];
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray2 = Array.isArray(actions[i]);
          const action = isArray2 ? actions[i][0] : actions[i];
          if (isArray2 && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i = 0; i < actions2.length; i++) {
              if (objects[i] && "update" in objects[i]) {
                const isArray2 = Array.isArray(actions2[i]);
                if (isArray2 && actions2[i].length > 1) {
                  objects[i].update(actions2[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && "destroy" in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      };
    }
    function Anchor(node, {
      addClass = (className) => node.classList.add(className),
      removeClass = (className) => node.classList.remove(className)
    } = {}) {
      addClass("mdc-menu-surface--anchor");
      return {
        destroy() {
          removeClass("mdc-menu-surface--anchor");
        }
      };
    }
    var file$26 = "node_modules/@smui/select/helper-text/HelperText.svelte";
    function create_else_block$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[8]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 256)
            set_data_dev(t, ctx2[8]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(17:31) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$2(ctx) {
      let current;
      const default_slot_template = ctx[13].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 4096)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(17:2) {#if content == null}",
        ctx
      });
      return block;
    }
    function create_fragment$36(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let div_class_value;
      let div_aria_hidden_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$2, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[8] == null)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div_levels = [
        {
          class: div_class_value = classMap9({
            [ctx[1]]: true,
            "mdc-select-helper-text": true,
            "mdc-select-helper-text--validation-msg": ctx[4],
            "mdc-select-helper-text--validation-msg-persistent": ctx[3],
            ...ctx[6]
          })
        },
        {
          "aria-hidden": div_aria_hidden_value = ctx[3] ? null : "true"
        },
        {id: ctx[2]},
        ctx[7],
        ctx[10]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if_block.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          ctx[14](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, div, ctx[0])),
              action_destroyer(ctx[9].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 90 && div_class_value !== (div_class_value = classMap9({
              [ctx2[1]]: true,
              "mdc-select-helper-text": true,
              "mdc-select-helper-text--validation-msg": ctx2[4],
              "mdc-select-helper-text--validation-msg-persistent": ctx2[3],
              ...ctx2[6]
            }))) && {class: div_class_value},
            (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? null : "true")) && {"aria-hidden": div_aria_hidden_value},
            (!current || dirty & 4) && {id: ctx2[2]},
            dirty & 128 && ctx2[7],
            dirty & 1024 && ctx2[10]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if_blocks[current_block_type_index].d();
          ctx[14](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$36.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter$1 = 0;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("HelperText", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {id = "SMUI-select-helper-text-" + counter$1++} = $$props;
      let {persistent = false} = $$props;
      let {validationMsg = false} = $$props;
      let element2;
      let instance9;
      let internalClasses = {};
      let internalAttrs = {};
      let content = null;
      onMount(() => {
        instance9 = new MDCSelectHelperTextFoundation({
          addClass,
          removeClass,
          hasClass,
          getAttr,
          setAttr: addAttr,
          removeAttr,
          setContent: (value) => {
            $$invalidate(8, content = value);
          }
        });
        if (id.startsWith("SMUI-select-helper-text-")) {
          dispatch5(getElement(), "SMUI:select:helper-text:id", id);
        }
        dispatch5(getElement(), "SMUI:select:helper-text:mount", instance9);
        instance9.init();
        return () => {
          dispatch5(getElement(), "SMUI:select:helper-text:unmount", instance9);
          instance9.destroy();
        };
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = false, internalClasses);
        }
      }
      function getAttr(name) {
        return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
      }
      function addAttr(name, value) {
        if (internalAttrs[name] !== value) {
          $$invalidate(7, internalAttrs[name] = value, internalAttrs);
        }
      }
      function removeAttr(name) {
        if (!(name in internalAttrs) || internalAttrs[name] != null) {
          $$invalidate(7, internalAttrs[name] = void 0, internalAttrs);
        }
      }
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(5, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("id" in $$new_props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$new_props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$new_props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("$$scope" in $$new_props)
          $$invalidate(12, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter$1,
        MDCSelectHelperTextFoundation,
        onMount,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        classMap: classMap9,
        useActions: useActions8,
        dispatch: dispatch5,
        forwardEvents,
        use: use2,
        className,
        id,
        persistent,
        validationMsg,
        element: element2,
        instance: instance9,
        internalClasses,
        internalAttrs,
        content,
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("id" in $$props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("element" in $$props)
          $$invalidate(5, element2 = $$new_props.element);
        if ("instance" in $$props)
          instance9 = $$new_props.instance;
        if ("internalClasses" in $$props)
          $$invalidate(6, internalClasses = $$new_props.internalClasses);
        if ("internalAttrs" in $$props)
          $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
        if ("content" in $$props)
          $$invalidate(8, content = $$new_props.content);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        id,
        persistent,
        validationMsg,
        element2,
        internalClasses,
        internalAttrs,
        content,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var HelperText = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$36, safe_not_equal, {
          use: 0,
          class: 1,
          id: 2,
          persistent: 3,
          validationMsg: 4,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HelperText",
          options,
          id: create_fragment$36.name
        });
      }
      get use() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get validationMsg() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set validationMsg(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var file$18 = "node_modules/@smui/select/Select.svelte";
    var get_helperText_slot_changes = (dirty) => ({});
    var get_helperText_slot_context = (ctx) => ({});
    var get_leadingIcon_slot_changes2 = (dirty) => ({});
    var get_leadingIcon_slot_context2 = (ctx) => ({});
    var get_label_slot_changes_12 = (dirty) => ({});
    var get_label_slot_context_12 = (ctx) => ({});
    var get_label_slot_changes3 = (dirty) => ({});
    var get_label_slot_context3 = (ctx) => ({});
    function create_if_block_62(ctx) {
      let input;
      let input_levels = [
        {type: "hidden"},
        {required: ctx[10]},
        {disabled: ctx[6]},
        {value: ctx[0]},
        prefixFilter3(ctx[53], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      const block = {
        c: function create2() {
          input = element("input");
          set_attributes(input, input_data);
          add_location(input, file$18, 52, 4, 1508);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);
          if (input.autofocus)
            input.focus();
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            {type: "hidden"},
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[0] & 64 && {disabled: ctx2[6]},
            dirty[0] & 1 && {value: ctx2[0]},
            dirty[1] & 4194304 && prefixFilter3(ctx2[53], "input$")
          ]));
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(input);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_62.name,
        type: "if",
        source: "(52:2) {#if hiddenInput}",
        ctx
      });
      return block;
    }
    function create_if_block_52(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          attr_dev(span, "class", "mdc-select__ripple");
          add_location(span, file$18, 86, 6, 2430);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_52.name,
        type: "if",
        source: "(86:4) {#if variant === 'filled'}",
        ctx
      });
      return block;
    }
    function create_if_block_4$1(ctx) {
      let floatinglabel;
      let current;
      const floatinglabel_spread_levels = [
        {id: ctx[11] + "-smui-label"},
        {
          floatAbove: ctx[43] !== ""
        },
        {required: ctx[10]},
        prefixFilter3(ctx[53], "label$")
      ];
      let floatinglabel_props = {
        $$slots: {default: [create_default_slot_5$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
        floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
      }
      floatinglabel = new FloatingLabel({
        props: floatinglabel_props,
        $$inline: true
      });
      ctx[64](floatinglabel);
      const block = {
        c: function create2() {
          create_component(floatinglabel.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(floatinglabel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 4198400 ? get_spread_update(floatinglabel_spread_levels, [
            dirty[0] & 2048 && {id: ctx2[11] + "-smui-label"},
            dirty[1] & 4096 && {
              floatAbove: ctx2[43] !== ""
            },
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter3(ctx2[53], "label$"))
          ]) : {};
          if (dirty[0] & 512 | dirty[2] & 33554432) {
            floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
          }
          floatinglabel.$set(floatinglabel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(floatinglabel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(floatinglabel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[64](null);
          destroy_component(floatinglabel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$1.name,
        type: "if",
        source: "(89:4) {#if variant !== 'outlined' && !noLabel && (label != null || $$slots.label)}",
        ctx
      });
      return block;
    }
    function create_default_slot_5$1(ctx) {
      let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
      let t;
      let current;
      const label_slot_template = ctx[61].label;
      const label_slot = create_slot(label_slot_template, ctx, ctx[87], get_label_slot_context3);
      const block = {
        c: function create2() {
          t = text(t_value);
          if (label_slot)
            label_slot.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          if (label_slot) {
            label_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
            set_data_dev(t, t_value);
          if (label_slot) {
            if (label_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(label_slot, label_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(label_slot_template, ctx2[87], dirty, get_label_slot_changes3), get_label_slot_context3);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
          if (label_slot)
            label_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: "(90:6) <FloatingLabel         bind:this={floatingLabel}         id={inputId + '-smui-label'}         floatAbove={$selectedTextStore !== ''}         {required}         {...prefixFilter($$restProps, 'label$')}         >",
        ctx
      });
      return block;
    }
    function create_if_block_2$1(ctx) {
      let notchedoutline;
      let current;
      const notchedoutline_spread_levels = [
        {
          noLabel: ctx[8] || ctx[9] == null && !ctx[52].label
        },
        prefixFilter3(ctx[53], "outline$")
      ];
      let notchedoutline_props = {
        $$slots: {default: [create_default_slot_3$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
        notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
      }
      notchedoutline = new NotchedOutline({
        props: notchedoutline_props,
        $$inline: true
      });
      ctx[66](notchedoutline);
      const block = {
        c: function create2() {
          create_component(notchedoutline.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(notchedoutline, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const notchedoutline_changes = dirty[0] & 768 | dirty[1] & 6291456 ? get_spread_update(notchedoutline_spread_levels, [
            dirty[0] & 768 | dirty[1] & 2097152 && {
              noLabel: ctx2[8] || ctx2[9] == null && !ctx2[52].label
            },
            dirty[1] & 4194304 && get_spread_object(prefixFilter3(ctx2[53], "outline$"))
          ]) : {};
          if (dirty[0] & 3840 | dirty[1] & 6296064 | dirty[2] & 33554432) {
            notchedoutline_changes.$$scope = {dirty, ctx: ctx2};
          }
          notchedoutline.$set(notchedoutline_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(notchedoutline.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(notchedoutline.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[66](null);
          destroy_component(notchedoutline, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$1.name,
        type: "if",
        source: "(99:4) {#if variant === 'outlined'}",
        ctx
      });
      return block;
    }
    function create_if_block_3$1(ctx) {
      let floatinglabel;
      let current;
      const floatinglabel_spread_levels = [
        {id: ctx[11] + "-smui-label"},
        {
          floatAbove: ctx[43] !== ""
        },
        {required: ctx[10]},
        prefixFilter3(ctx[53], "label$")
      ];
      let floatinglabel_props = {
        $$slots: {default: [create_default_slot_4$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
        floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
      }
      floatinglabel = new FloatingLabel({
        props: floatinglabel_props,
        $$inline: true
      });
      ctx[65](floatinglabel);
      const block = {
        c: function create2() {
          create_component(floatinglabel.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(floatinglabel, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 4198400 ? get_spread_update(floatinglabel_spread_levels, [
            dirty[0] & 2048 && {id: ctx2[11] + "-smui-label"},
            dirty[1] & 4096 && {
              floatAbove: ctx2[43] !== ""
            },
            dirty[0] & 1024 && {required: ctx2[10]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter3(ctx2[53], "label$"))
          ]) : {};
          if (dirty[0] & 512 | dirty[2] & 33554432) {
            floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
          }
          floatinglabel.$set(floatinglabel_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(floatinglabel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(floatinglabel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[65](null);
          destroy_component(floatinglabel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$1.name,
        type: "if",
        source: "(105:8) {#if !noLabel && (label != null || $$slots.label)}",
        ctx
      });
      return block;
    }
    function create_default_slot_4$1(ctx) {
      let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
      let t;
      let current;
      const label_slot_template = ctx[61].label;
      const label_slot = create_slot(label_slot_template, ctx, ctx[87], get_label_slot_context_12);
      const block = {
        c: function create2() {
          t = text(t_value);
          if (label_slot)
            label_slot.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          if (label_slot) {
            label_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
            set_data_dev(t, t_value);
          if (label_slot) {
            if (label_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(label_slot, label_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(label_slot_template, ctx2[87], dirty, get_label_slot_changes_12), get_label_slot_context_12);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
          if (label_slot)
            label_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: "(106:10) <FloatingLabel             bind:this={floatingLabel}             id={inputId + '-smui-label'}             floatAbove={$selectedTextStore !== ''}             {required}             {...prefixFilter($$restProps, 'label$')}             >",
        ctx
      });
      return block;
    }
    function create_default_slot_3$1(ctx) {
      let if_block_anchor;
      let current;
      let if_block = !ctx[8] && (ctx[9] != null || ctx[52].label) && create_if_block_3$1(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (!ctx2[8] && (ctx2[9] != null || ctx2[52].label)) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty[0] & 768 | dirty[1] & 2097152) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_3$1(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(100:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
        ctx
      });
      return block;
    }
    function create_if_block_1$1(ctx) {
      let lineripple;
      let current;
      const lineripple_spread_levels = [prefixFilter3(ctx[53], "ripple$")];
      let lineripple_props = {};
      for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
        lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
      }
      lineripple = new LineRipple({props: lineripple_props, $$inline: true});
      ctx[68](lineripple);
      const block = {
        c: function create2() {
          create_component(lineripple.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(lineripple, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const lineripple_changes = dirty[1] & 4194304 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter3(ctx2[53], "ripple$"))]) : {};
          lineripple.$set(lineripple_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(lineripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(lineripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[68](null);
          destroy_component(lineripple, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(169:4) {#if variant !== 'outlined' && ripple}",
        ctx
      });
      return block;
    }
    function create_default_slot_2$1(ctx) {
      let current;
      const default_slot_template = ctx[61].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[87], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(default_slot_template, ctx2[87], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: `(195:4) <List       role=\\"listbox\\"       {wrapFocus}       bind:selectedIndex       on:SMUI:list:mount={(event) => (list = event.detail)}       {...prefixFilter($$restProps, 'list$')}>`,
        ctx
      });
      return block;
    }
    function create_default_slot_1$1(ctx) {
      let list_1;
      let updating_selectedIndex;
      let current;
      const list_1_spread_levels = [
        {role: "listbox"},
        {wrapFocus: ctx[36]},
        prefixFilter3(ctx[53], "list$")
      ];
      function list_1_selectedIndex_binding(value) {
        ctx[74](value);
      }
      let list_1_props = {
        $$slots: {default: [create_default_slot_2$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < list_1_spread_levels.length; i += 1) {
        list_1_props = assign(list_1_props, list_1_spread_levels[i]);
      }
      if (ctx[24] !== void 0) {
        list_1_props.selectedIndex = ctx[24];
      }
      list_1 = new List({props: list_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(list_1, "selectedIndex", list_1_selectedIndex_binding));
      list_1.$on("SMUI:list:mount", ctx[75]);
      const block = {
        c: function create2() {
          create_component(list_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_1_changes = dirty[1] & 4194336 ? get_spread_update(list_1_spread_levels, [
            list_1_spread_levels[0],
            dirty[1] & 32 && {wrapFocus: ctx2[36]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter3(ctx2[53], "list$"))
          ]) : {};
          if (dirty[2] & 33554432) {
            list_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_selectedIndex && dirty[0] & 16777216) {
            updating_selectedIndex = true;
            list_1_changes.selectedIndex = ctx2[24];
            add_flush_callback(() => updating_selectedIndex = false);
          }
          list_1.$set(list_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(177:2) <Menu     class={classMap({       [menu$class]: true,       'mdc-select__menu': true,       ...menuClasses,     })}     fullWidth     anchor={false}     {anchorElement}     {anchorCorner}     bind:open={menuOpen}     on:MDCMenu:selected={(event) =>       instance && instance.handleMenuItemAction(event.detail.index)}     on:MDCMenuSurface:closing={() => instance && instance.handleMenuClosing()}     on:MDCMenuSurface:closed={() => instance && instance.handleMenuClosed()}     on:MDCMenuSurface:opened={() => instance && instance.handleMenuOpened()}     {...prefixFilter($$restProps, 'menu$')}   >",
        ctx
      });
      return block;
    }
    function create_if_block$13(ctx) {
      let helpertext;
      let current;
      const helpertext_spread_levels = [prefixFilter3(ctx[53], "helperText$")];
      let helpertext_props = {
        $$slots: {default: [create_default_slot$23]},
        $$scope: {ctx}
      };
      for (let i = 0; i < helpertext_spread_levels.length; i += 1) {
        helpertext_props = assign(helpertext_props, helpertext_spread_levels[i]);
      }
      helpertext = new HelperText({props: helpertext_props, $$inline: true});
      helpertext.$on("SMUI:select:helper-text:id", ctx[84]);
      helpertext.$on("SMUI:select:helper-text:mount", ctx[85]);
      helpertext.$on("SMUI:select:helper-text:unmount", ctx[86]);
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = dirty[1] & 4194304 ? get_spread_update(helpertext_spread_levels, [get_spread_object(prefixFilter3(ctx2[53], "helperText$"))]) : {};
          if (dirty[2] & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$13.name,
        type: "if",
        source: "(204:0) {#if $$slots.helperText}",
        ctx
      });
      return block;
    }
    function create_default_slot$23(ctx) {
      let current;
      const helperText_slot_template = ctx[61].helperText;
      const helperText_slot = create_slot(helperText_slot_template, ctx, ctx[87], get_helperText_slot_context);
      const block = {
        c: function create2() {
          if (helperText_slot)
            helperText_slot.c();
        },
        m: function mount(target, anchor) {
          if (helperText_slot) {
            helperText_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (helperText_slot) {
            if (helperText_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(helperText_slot, helperText_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(helperText_slot_template, ctx2[87], dirty, get_helperText_slot_changes), get_helperText_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helperText_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helperText_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (helperText_slot)
            helperText_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$23.name,
        type: "slot",
        source: "(205:2) <HelperText     on:SMUI:select:helper-text:id={(event) => (helperId = event.detail)}     on:SMUI:select:helper-text:mount={(event) => (helperText = event.detail)}     on:SMUI:select:helper-text:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     {...prefixFilter($$restProps, 'helperText$')}     >",
        ctx
      });
      return block;
    }
    function create_fragment$28(ctx) {
      let div1;
      let t0;
      let div0;
      let t1;
      let t2;
      let t3;
      let t4;
      let span1;
      let span0;
      let t5;
      let span0_id_value;
      let span0_class_value;
      let span0_aria_labelledby_value;
      let useActions_action;
      let span1_class_value;
      let useActions_action_1;
      let t6;
      let span2;
      let svg;
      let polygon0;
      let polygon1;
      let span2_class_value;
      let useActions_action_2;
      let t7;
      let div0_class_value;
      let div0_aria_required_value;
      let div0_aria_disabled_value;
      let useActions_action_3;
      let t8;
      let menu;
      let updating_open;
      let div1_class_value;
      let div1_style_value;
      let Ripple_action;
      let useActions_action_4;
      let t9;
      let if_block5_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block0 = ctx[12] && create_if_block_62(ctx);
      let if_block1 = ctx[7] === "filled" && create_if_block_52(ctx);
      let if_block2 = ctx[7] !== "outlined" && !ctx[8] && (ctx[9] != null || ctx[52].label) && create_if_block_4$1(ctx);
      let if_block3 = ctx[7] === "outlined" && create_if_block_2$1(ctx);
      const leadingIcon_slot_template = ctx[61].leadingIcon;
      const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[87], get_leadingIcon_slot_context2);
      let span0_levels = [
        {
          id: span0_id_value = ctx[11] + "-smui-selected-text"
        },
        {
          class: span0_class_value = classMap9({
            [ctx[18]]: true,
            "mdc-select__selected-text": true
          })
        },
        {role: "button"},
        {"aria-haspopup": "listbox"},
        {
          "aria-labelledby": span0_aria_labelledby_value = ctx[11] + "-smui-label"
        },
        prefixFilter3(ctx[53], "selectedText$")
      ];
      let span0_data = {};
      for (let i = 0; i < span0_levels.length; i += 1) {
        span0_data = assign(span0_data, span0_levels[i]);
      }
      let span1_levels = [
        {
          class: span1_class_value = classMap9({
            [ctx[16]]: true,
            "mdc-select__selected-text-container": true
          })
        },
        prefixFilter3(ctx[53], "selectedTextContainer$")
      ];
      let span1_data = {};
      for (let i = 0; i < span1_levels.length; i += 1) {
        span1_data = assign(span1_data, span1_levels[i]);
      }
      let span2_levels = [
        {
          class: span2_class_value = classMap9({
            [ctx[20]]: true,
            "mdc-select__dropdown-icon": true
          })
        },
        prefixFilter3(ctx[53], "dropdownIcon$")
      ];
      let span2_data = {};
      for (let i = 0; i < span2_levels.length; i += 1) {
        span2_data = assign(span2_data, span2_levels[i]);
      }
      let if_block4 = ctx[7] !== "outlined" && ctx[5] && create_if_block_1$1(ctx);
      let div0_levels = [
        {
          class: div0_class_value = classMap9({
            [ctx[14]]: true,
            "mdc-select__anchor": true
          })
        },
        {
          "aria-required": div0_aria_required_value = ctx[10] ? "true" : null
        },
        {
          "aria-disabled": div0_aria_disabled_value = ctx[6] ? "true" : null
        },
        {"aria-controls": ctx[31]},
        {"aria-describedby": ctx[31]},
        ctx[29],
        prefixFilter3(ctx[53], "anchor$")
      ];
      let div0_data = {};
      for (let i = 0; i < div0_levels.length; i += 1) {
        div0_data = assign(div0_data, div0_levels[i]);
      }
      const menu_spread_levels = [
        {
          class: classMap9({
            [ctx[21]]: true,
            "mdc-select__menu": true,
            ...ctx[33]
          })
        },
        {fullWidth: true},
        {anchor: false},
        {anchorElement: ctx[34]},
        {anchorCorner: ctx[35]},
        prefixFilter3(ctx[53], "menu$")
      ];
      function menu_open_binding(value) {
        ctx[76](value);
      }
      let menu_props = {
        $$slots: {default: [create_default_slot_1$1]},
        $$scope: {ctx}
      };
      for (let i = 0; i < menu_spread_levels.length; i += 1) {
        menu_props = assign(menu_props, menu_spread_levels[i]);
      }
      if (ctx[32] !== void 0) {
        menu_props.open = ctx[32];
      }
      menu = new Menu({props: menu_props, $$inline: true});
      binding_callbacks.push(() => bind3(menu, "open", menu_open_binding));
      menu.$on("MDCMenu:selected", ctx[77]);
      menu.$on("MDCMenuSurface:closing", ctx[78]);
      menu.$on("MDCMenuSurface:closed", ctx[79]);
      menu.$on("MDCMenuSurface:opened", ctx[80]);
      let div1_levels = [
        {
          class: div1_class_value = classMap9({
            [ctx[3]]: true,
            "mdc-select": true,
            "mdc-select--required": ctx[10],
            "mdc-select--disabled": ctx[6],
            "mdc-select--filled": ctx[7] === "filled",
            "mdc-select--outlined": ctx[7] === "outlined",
            "smui-select--standard": ctx[7] === "standard",
            "mdc-select--with-leading-icon": ctx[22] === ctx[45] ? ctx[52].leadingIcon : ctx[22],
            "mdc-select--no-label": ctx[8] || ctx[9] == null && !ctx[52].label,
            "mdc-select--invalid": ctx[1] !== ctx[45] && ctx[1],
            "mdc-select--activated": ctx[32],
            "mdc-data-table__pagination-rows-per-page-select": ctx[46] === "data-table:pagination",
            ...ctx[26]
          })
        },
        {
          style: div1_style_value = Object.entries(ctx[27]).map(func5).concat([ctx[4]]).join(" ")
        },
        exclude3(ctx[53], [
          "input$",
          "anchor$",
          "label$",
          "outline$",
          "selectedTextContainer$",
          "selectedText$",
          "dropdownIcon$",
          "ripple$",
          "menu$",
          "list$",
          "helperText$"
        ])
      ];
      let div1_data = {};
      for (let i = 0; i < div1_levels.length; i += 1) {
        div1_data = assign(div1_data, div1_levels[i]);
      }
      let if_block5 = ctx[52].helperText && create_if_block$13(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          div0 = element("div");
          if (if_block1)
            if_block1.c();
          t1 = space();
          if (if_block2)
            if_block2.c();
          t2 = space();
          if (if_block3)
            if_block3.c();
          t3 = space();
          if (leadingIcon_slot)
            leadingIcon_slot.c();
          t4 = space();
          span1 = element("span");
          span0 = element("span");
          t5 = text(ctx[43]);
          t6 = space();
          span2 = element("span");
          svg = svg_element("svg");
          polygon0 = svg_element("polygon");
          polygon1 = svg_element("polygon");
          t7 = space();
          if (if_block4)
            if_block4.c();
          t8 = space();
          create_component(menu.$$.fragment);
          t9 = space();
          if (if_block5)
            if_block5.c();
          if_block5_anchor = empty();
          set_attributes(span0, span0_data);
          add_location(span0, file$18, 125, 6, 3794);
          set_attributes(span1, span1_data);
          add_location(span1, file$18, 117, 4, 3532);
          attr_dev(polygon0, "class", "mdc-select__dropdown-icon-inactive");
          attr_dev(polygon0, "stroke", "none");
          attr_dev(polygon0, "fill-rule", "evenodd");
          attr_dev(polygon0, "points", "7 10 12 15 17 10");
          add_location(polygon0, file$18, 154, 8, 4616);
          attr_dev(polygon1, "class", "mdc-select__dropdown-icon-active");
          attr_dev(polygon1, "stroke", "none");
          attr_dev(polygon1, "fill-rule", "evenodd");
          attr_dev(polygon1, "points", "7 15 12 10 17 15");
          add_location(polygon1, file$18, 160, 8, 4787);
          attr_dev(svg, "class", "mdc-select__dropdown-icon-graphic");
          attr_dev(svg, "viewBox", "7 10 10 5");
          attr_dev(svg, "focusable", "false");
          add_location(svg, file$18, 149, 6, 4491);
          set_attributes(span2, span2_data);
          add_location(span2, file$18, 141, 4, 4266);
          set_attributes(div0, div0_data);
          add_location(div0, file$18, 60, 2, 1647);
          set_attributes(div1, div1_data);
          add_location(div1, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          if (if_block0)
            if_block0.m(div1, null);
          append_dev(div1, t0);
          append_dev(div1, div0);
          if (if_block1)
            if_block1.m(div0, null);
          append_dev(div0, t1);
          if (if_block2)
            if_block2.m(div0, null);
          append_dev(div0, t2);
          if (if_block3)
            if_block3.m(div0, null);
          append_dev(div0, t3);
          if (leadingIcon_slot) {
            leadingIcon_slot.m(div0, null);
          }
          append_dev(div0, t4);
          append_dev(div0, span1);
          append_dev(span1, span0);
          append_dev(span0, t5);
          ctx[67](span0);
          append_dev(div0, t6);
          append_dev(div0, span2);
          append_dev(span2, svg);
          append_dev(svg, polygon0);
          append_dev(svg, polygon1);
          append_dev(div0, t7);
          if (if_block4)
            if_block4.m(div0, null);
          ctx[69](div0);
          append_dev(div1, t8);
          mount_component(menu, div1, null);
          ctx[81](div1);
          insert_dev(target, t9, anchor);
          if (if_block5)
            if_block5.m(target, anchor);
          insert_dev(target, if_block5_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, span0, ctx[17])),
              action_destroyer(useActions_action_1 = useActions8.call(null, span1, ctx[15])),
              action_destroyer(useActions_action_2 = useActions8.call(null, span2, ctx[19])),
              action_destroyer(useActions_action_3 = useActions8.call(null, div0, ctx[13])),
              listen_dev(div0, "focus", ctx[70], false, false, false),
              listen_dev(div0, "blur", ctx[71], false, false, false),
              listen_dev(div0, "click", ctx[72], false, false, false),
              listen_dev(div0, "keydown", ctx[73], false, false, false),
              listen_dev(div0, "focus", ctx[62], false, false, false),
              listen_dev(div0, "blur", ctx[63], false, false, false),
              action_destroyer(Ripple_action = Ripple.call(null, div1, {
                ripple: ctx[7] === "filled",
                unbounded: false,
                addClass: ctx[49],
                removeClass: ctx[50],
                addStyle: ctx[51]
              })),
              action_destroyer(Anchor.call(null, div1, {
                addClass: ctx[49],
                removeClass: ctx[50]
              })),
              action_destroyer(useActions_action_4 = useActions8.call(null, div1, ctx[2])),
              action_destroyer(ctx[44].call(null, div1)),
              listen_dev(div1, "SMUI:select:leading-icon:mount", ctx[82], false, false, false),
              listen_dev(div1, "SMUI:select:leading-icon:unmount", ctx[83], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (ctx2[12]) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_62(ctx2);
              if_block0.c();
              if_block0.m(div1, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (ctx2[7] === "filled") {
            if (if_block1)
              ;
            else {
              if_block1 = create_if_block_52(ctx2);
              if_block1.c();
              if_block1.m(div0, t1);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (ctx2[7] !== "outlined" && !ctx2[8] && (ctx2[9] != null || ctx2[52].label)) {
            if (if_block2) {
              if_block2.p(ctx2, dirty);
              if (dirty[0] & 896 | dirty[1] & 2097152) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_4$1(ctx2);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div0, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          if (ctx2[7] === "outlined") {
            if (if_block3) {
              if_block3.p(ctx2, dirty);
              if (dirty[0] & 128) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_2$1(ctx2);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div0, t3);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if (leadingIcon_slot) {
            if (leadingIcon_slot.p && (!current || dirty[2] & 33554432)) {
              update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[87], !current ? get_all_dirty_from_scope(ctx2[87]) : get_slot_changes(leadingIcon_slot_template, ctx2[87], dirty, get_leadingIcon_slot_changes2), get_leadingIcon_slot_context2);
            }
          }
          if (!current || dirty[1] & 4096)
            set_data_dev(t5, ctx2[43]);
          set_attributes(span0, span0_data = get_spread_update(span0_levels, [
            (!current || dirty[0] & 2048 && span0_id_value !== (span0_id_value = ctx2[11] + "-smui-selected-text")) && {id: span0_id_value},
            (!current || dirty[0] & 262144 && span0_class_value !== (span0_class_value = classMap9({
              [ctx2[18]]: true,
              "mdc-select__selected-text": true
            }))) && {class: span0_class_value},
            {role: "button"},
            {"aria-haspopup": "listbox"},
            (!current || dirty[0] & 2048 && span0_aria_labelledby_value !== (span0_aria_labelledby_value = ctx2[11] + "-smui-label")) && {
              "aria-labelledby": span0_aria_labelledby_value
            },
            dirty[1] & 4194304 && prefixFilter3(ctx2[53], "selectedText$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 131072)
            useActions_action.update.call(null, ctx2[17]);
          set_attributes(span1, span1_data = get_spread_update(span1_levels, [
            (!current || dirty[0] & 65536 && span1_class_value !== (span1_class_value = classMap9({
              [ctx2[16]]: true,
              "mdc-select__selected-text-container": true
            }))) && {class: span1_class_value},
            dirty[1] & 4194304 && prefixFilter3(ctx2[53], "selectedTextContainer$")
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 32768)
            useActions_action_1.update.call(null, ctx2[15]);
          set_attributes(span2, span2_data = get_spread_update(span2_levels, [
            (!current || dirty[0] & 1048576 && span2_class_value !== (span2_class_value = classMap9({
              [ctx2[20]]: true,
              "mdc-select__dropdown-icon": true
            }))) && {class: span2_class_value},
            dirty[1] & 4194304 && prefixFilter3(ctx2[53], "dropdownIcon$")
          ]));
          if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & 524288)
            useActions_action_2.update.call(null, ctx2[19]);
          if (ctx2[7] !== "outlined" && ctx2[5]) {
            if (if_block4) {
              if_block4.p(ctx2, dirty);
              if (dirty[0] & 160) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_1$1(ctx2);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div0, null);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
          set_attributes(div0, div0_data = get_spread_update(div0_levels, [
            (!current || dirty[0] & 16384 && div0_class_value !== (div0_class_value = classMap9({
              [ctx2[14]]: true,
              "mdc-select__anchor": true
            }))) && {class: div0_class_value},
            (!current || dirty[0] & 1024 && div0_aria_required_value !== (div0_aria_required_value = ctx2[10] ? "true" : null)) && {
              "aria-required": div0_aria_required_value
            },
            (!current || dirty[0] & 64 && div0_aria_disabled_value !== (div0_aria_disabled_value = ctx2[6] ? "true" : null)) && {
              "aria-disabled": div0_aria_disabled_value
            },
            (!current || dirty[1] & 1) && {"aria-controls": ctx2[31]},
            (!current || dirty[1] & 1) && {"aria-describedby": ctx2[31]},
            dirty[0] & 536870912 && ctx2[29],
            dirty[1] & 4194304 && prefixFilter3(ctx2[53], "anchor$")
          ]));
          if (useActions_action_3 && is_function(useActions_action_3.update) && dirty[0] & 8192)
            useActions_action_3.update.call(null, ctx2[13]);
          const menu_changes = dirty[0] & 2097152 | dirty[1] & 4194332 ? get_spread_update(menu_spread_levels, [
            dirty[0] & 2097152 | dirty[1] & 4 && {
              class: classMap9({
                [ctx2[21]]: true,
                "mdc-select__menu": true,
                ...ctx2[33]
              })
            },
            menu_spread_levels[1],
            menu_spread_levels[2],
            dirty[1] & 8 && {anchorElement: ctx2[34]},
            dirty[1] & 16 && {anchorCorner: ctx2[35]},
            dirty[1] & 4194304 && get_spread_object(prefixFilter3(ctx2[53], "menu$"))
          ]) : {};
          if (dirty[0] & 16777216 | dirty[1] & 4194400 | dirty[2] & 33554432) {
            menu_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_open && dirty[1] & 2) {
            updating_open = true;
            menu_changes.open = ctx2[32];
            add_flush_callback(() => updating_open = false);
          }
          menu.$set(menu_changes);
          set_attributes(div1, div1_data = get_spread_update(div1_levels, [
            (!current || dirty[0] & 71305162 | dirty[1] & 2097154 && div1_class_value !== (div1_class_value = classMap9({
              [ctx2[3]]: true,
              "mdc-select": true,
              "mdc-select--required": ctx2[10],
              "mdc-select--disabled": ctx2[6],
              "mdc-select--filled": ctx2[7] === "filled",
              "mdc-select--outlined": ctx2[7] === "outlined",
              "smui-select--standard": ctx2[7] === "standard",
              "mdc-select--with-leading-icon": ctx2[22] === ctx2[45] ? ctx2[52].leadingIcon : ctx2[22],
              "mdc-select--no-label": ctx2[8] || ctx2[9] == null && !ctx2[52].label,
              "mdc-select--invalid": ctx2[1] !== ctx2[45] && ctx2[1],
              "mdc-select--activated": ctx2[32],
              "mdc-data-table__pagination-rows-per-page-select": ctx2[46] === "data-table:pagination",
              ...ctx2[26]
            }))) && {class: div1_class_value},
            (!current || dirty[0] & 134217744 && div1_style_value !== (div1_style_value = Object.entries(ctx2[27]).map(func5).concat([ctx2[4]]).join(" "))) && {style: div1_style_value},
            dirty[1] & 4194304 && exclude3(ctx2[53], [
              "input$",
              "anchor$",
              "label$",
              "outline$",
              "selectedTextContainer$",
              "selectedText$",
              "dropdownIcon$",
              "ripple$",
              "menu$",
              "list$",
              "helperText$"
            ])
          ]));
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 128)
            Ripple_action.update.call(null, {
              ripple: ctx2[7] === "filled",
              unbounded: false,
              addClass: ctx2[49],
              removeClass: ctx2[50],
              addStyle: ctx2[51]
            });
          if (useActions_action_4 && is_function(useActions_action_4.update) && dirty[0] & 4)
            useActions_action_4.update.call(null, ctx2[2]);
          if (ctx2[52].helperText) {
            if (if_block5) {
              if_block5.p(ctx2, dirty);
              if (dirty[1] & 2097152) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block$13(ctx2);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(leadingIcon_slot, local);
          transition_in(if_block4);
          transition_in(menu.$$.fragment, local);
          transition_in(if_block5);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(leadingIcon_slot, local);
          transition_out(if_block4);
          transition_out(menu.$$.fragment, local);
          transition_out(if_block5);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block0)
            if_block0.d();
          if (if_block1)
            if_block1.d();
          if (if_block2)
            if_block2.d();
          if (if_block3)
            if_block3.d();
          if (leadingIcon_slot)
            leadingIcon_slot.d(detaching);
          ctx[67](null);
          if (if_block4)
            if_block4.d();
          ctx[69](null);
          destroy_component(menu);
          ctx[81](null);
          if (detaching)
            detach_dev(t9);
          if (if_block5)
            if_block5.d(detaching);
          if (detaching)
            detach_dev(if_block5_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    function getNormalizedXCoordinate(evt) {
      const targetClientRect = evt.target.getBoundingClientRect();
      const xCoordinate = isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
      return xCoordinate - targetClientRect.left;
    }
    function isTouchEvent(evt) {
      return !!evt.touches;
    }
    var func5 = ([name, value]) => `${name}: ${value};`;
    function instance_15($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "ripple",
        "disabled",
        "variant",
        "noLabel",
        "label",
        "value",
        "key",
        "dirty",
        "invalid",
        "updateInvalid",
        "required",
        "inputId",
        "hiddenInput",
        "anchor$use",
        "anchor$class",
        "selectedTextContainer$use",
        "selectedTextContainer$class",
        "selectedText$use",
        "selectedText$class",
        "dropdownIcon$use",
        "dropdownIcon$class",
        "menu$class",
        "withLeadingIcon",
        "focus",
        "layout",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $selectedTextStore;
      let $valueStore;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Select", slots, ["label", "leadingIcon", "default", "helperText"]);
      const $$slots = compute_slots(slots);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      const uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {ripple = true} = $$props;
      let {disabled = false} = $$props;
      let {variant = "standard"} = $$props;
      let {noLabel = false} = $$props;
      let {label = null} = $$props;
      let {value = ""} = $$props;
      let {key = (item) => item} = $$props;
      let {dirty = false} = $$props;
      let {invalid = uninitializedValue} = $$props;
      let {updateInvalid = invalid === uninitializedValue} = $$props;
      let {required = false} = $$props;
      let {inputId = "SMUI-select-" + counter3++} = $$props;
      let {hiddenInput = false} = $$props;
      let {anchor$use = []} = $$props;
      let {anchor$class = ""} = $$props;
      let {selectedTextContainer$use = []} = $$props;
      let {selectedTextContainer$class = ""} = $$props;
      let {selectedText$use = []} = $$props;
      let {selectedText$class = ""} = $$props;
      let {dropdownIcon$use = []} = $$props;
      let {dropdownIcon$class = ""} = $$props;
      let {menu$class = ""} = $$props;
      let {withLeadingIcon = uninitializedValue} = $$props;
      let element2;
      let instance9;
      let internalClasses = {};
      let internalStyles = {};
      let selectAnchor;
      let selectAnchorAttrs = {};
      let selectText;
      let selectedIndex = -1;
      let helperId;
      let addLayoutListener = getContext("SMUI:addLayoutListener");
      let removeLayoutListener;
      let menuOpen = false;
      let menuClasses = {};
      let anchorElement;
      let anchorCorner;
      let wrapFocus = false;
      let list;
      let context = getContext("SMUI:select:context");
      let leadingIcon;
      let helperText;
      let floatingLabel;
      let lineRipple;
      let notchedOutline;
      setContext("SMUI:list:role", "");
      setContext("SMUI:list:nav", false);
      const selectedTextStore = writable("");
      validate_store(selectedTextStore, "selectedTextStore");
      component_subscribe($$self, selectedTextStore, (value2) => $$invalidate(43, $selectedTextStore = value2));
      setContext("SMUI:select:selectedText", selectedTextStore);
      const valueStore = writable(value);
      validate_store(valueStore, "valueStore");
      component_subscribe($$self, valueStore, (value2) => $$invalidate(89, $valueStore = value2));
      setContext("SMUI:select:value", valueStore);
      let previousSelectedIndex = selectedIndex;
      if (addLayoutListener) {
        removeLayoutListener = addLayoutListener(layout);
      }
      onMount(() => {
        $$invalidate(23, instance9 = new MDCSelectFoundation({
          getMenuItemAttr: (menuItem, attr2) => menuItem.getAttribute(attr2),
          setSelectedText: (text2) => {
            set_store_value(selectedTextStore, $selectedTextStore = text2, $selectedTextStore);
          },
          isSelectAnchorFocused: () => document.activeElement === selectAnchor,
          getSelectAnchorAttr,
          setSelectAnchorAttr: addSelectAnchorAttr,
          removeSelectAnchorAttr,
          addMenuClass,
          removeMenuClass,
          openMenu: () => {
            $$invalidate(32, menuOpen = true);
          },
          closeMenu: () => {
            $$invalidate(32, menuOpen = false);
          },
          getAnchorElement: () => selectAnchor,
          setMenuAnchorElement: (value2) => {
            $$invalidate(34, anchorElement = value2);
          },
          setMenuAnchorCorner: (value2) => {
            $$invalidate(35, anchorCorner = value2);
          },
          setMenuWrapFocus: (value2) => {
            $$invalidate(36, wrapFocus = value2);
          },
          getSelectedIndex: () => selectedIndex,
          setSelectedIndex: (index) => {
            $$invalidate(60, previousSelectedIndex = index);
            $$invalidate(24, selectedIndex = index);
            $$invalidate(0, value = getMenuItemValues()[selectedIndex]);
          },
          focusMenuItemAtIndex: (index) => {
            list.focusItemAtIndex(index);
          },
          getMenuItemCount: () => list.items.length,
          getMenuItemValues: () => getMenuItemValues().map(key),
          getMenuItemTextAtIndex: (index) => list.getPrimaryTextAtIndex(index),
          isTypeaheadInProgress: () => list.typeaheadInProgress,
          typeaheadMatchItem: (nextChar, startingIndex) => list.typeaheadMatchItem(nextChar, startingIndex),
          addClass,
          removeClass,
          hasClass,
          setRippleCenter: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
          activateBottomLine: () => lineRipple && lineRipple.activate(),
          deactivateBottomLine: () => lineRipple && lineRipple.deactivate(),
          notifyChange: (_selectedValue) => {
            $$invalidate(54, dirty = true);
            if (updateInvalid) {
              $$invalidate(1, invalid = !instance9.isValid());
            }
            dispatch5(getElement(), "MDCSelect:change", {value, index: selectedIndex});
          },
          hasOutline: () => !!notchedOutline,
          notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth),
          closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
          hasLabel: () => !!floatingLabel,
          floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
          getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
          setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired)
        }, {
          get helperText() {
            return helperText;
          },
          get leadingIcon() {
            return leadingIcon;
          }
        }));
        $$invalidate(24, selectedIndex = getMenuItemValues().indexOf(value));
        instance9.init();
        return () => {
          instance9.destroy();
        };
      });
      onDestroy(() => {
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(26, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(26, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name, value2) {
        if (internalStyles[name] != value2) {
          if (value2 === "" || value2 == null) {
            delete internalStyles[name];
            $$invalidate(27, internalStyles);
          } else {
            $$invalidate(27, internalStyles[name] = value2, internalStyles);
          }
        }
      }
      function addMenuClass(className2) {
        if (!menuClasses[className2]) {
          $$invalidate(33, menuClasses[className2] = true, menuClasses);
        }
      }
      function removeMenuClass(className2) {
        if (!(className2 in menuClasses) || menuClasses[className2]) {
          $$invalidate(33, menuClasses[className2] = false, menuClasses);
        }
      }
      function getSelectAnchorAttr(name) {
        return name in selectAnchorAttrs ? selectAnchorAttrs[name] : getElement().getAttribute(name);
      }
      function addSelectAnchorAttr(name, value2) {
        if (selectAnchorAttrs[name] !== value2) {
          $$invalidate(29, selectAnchorAttrs[name] = value2, selectAnchorAttrs);
        }
      }
      function removeSelectAnchorAttr(name) {
        if (!(name in selectAnchorAttrs) || selectAnchorAttrs[name] != null) {
          $$invalidate(29, selectAnchorAttrs[name] = void 0, selectAnchorAttrs);
        }
      }
      function getMenuItemValues() {
        return list.getOrderedList().map((accessor) => accessor.getValue());
      }
      function focus() {
        selectAnchor.focus();
      }
      function layout() {
        instance9.layout();
      }
      function getElement() {
        return element2;
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function floatinglabel_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          floatingLabel = $$value;
          $$invalidate(40, floatingLabel);
        });
      }
      function floatinglabel_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          floatingLabel = $$value;
          $$invalidate(40, floatingLabel);
        });
      }
      function notchedoutline_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          notchedOutline = $$value;
          $$invalidate(42, notchedOutline);
        });
      }
      function span0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          selectText = $$value;
          $$invalidate(30, selectText);
        });
      }
      function lineripple_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          lineRipple = $$value;
          $$invalidate(41, lineRipple);
        });
      }
      function div0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          selectAnchor = $$value;
          $$invalidate(28, selectAnchor);
        });
      }
      const focus_handler_1 = () => instance9 && instance9.handleFocus();
      const blur_handler_1 = () => instance9 && instance9.handleBlur();
      const click_handler = (event) => {
        selectAnchor.focus();
        if (instance9) {
          instance9.handleClick(getNormalizedXCoordinate(event));
        }
      };
      const keydown_handler = (event) => instance9 && instance9.handleKeydown(event);
      function list_1_selectedIndex_binding(value2) {
        selectedIndex = value2;
        $$invalidate(24, selectedIndex);
      }
      const SMUI_list_mount_handler = (event) => $$invalidate(37, list = event.detail);
      function menu_open_binding(value2) {
        menuOpen = value2;
        $$invalidate(32, menuOpen);
      }
      const MDCMenu_selected_handler = (event) => instance9 && instance9.handleMenuItemAction(event.detail.index);
      const MDCMenuSurface_closing_handler = () => instance9 && instance9.handleMenuClosing();
      const MDCMenuSurface_closed_handler = () => instance9 && instance9.handleMenuClosed();
      const MDCMenuSurface_opened_handler = () => instance9 && instance9.handleMenuOpened();
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(25, element2);
        });
      }
      const SMUI_select_leading_icon_mount_handler = (event) => $$invalidate(38, leadingIcon = event.detail);
      const SMUI_select_leading_icon_unmount_handler = () => $$invalidate(38, leadingIcon = void 0);
      const SMUI_select_helper_text_id_handler = (event) => $$invalidate(31, helperId = event.detail);
      const SMUI_select_helper_text_mount_handler = (event) => $$invalidate(39, helperText = event.detail);
      const SMUI_select_helper_text_unmount_handler = () => {
        $$invalidate(31, helperId = void 0);
        $$invalidate(39, helperText = void 0);
      };
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(3, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(4, style = $$new_props.style);
        if ("ripple" in $$new_props)
          $$invalidate(5, ripple = $$new_props.ripple);
        if ("disabled" in $$new_props)
          $$invalidate(6, disabled = $$new_props.disabled);
        if ("variant" in $$new_props)
          $$invalidate(7, variant = $$new_props.variant);
        if ("noLabel" in $$new_props)
          $$invalidate(8, noLabel = $$new_props.noLabel);
        if ("label" in $$new_props)
          $$invalidate(9, label = $$new_props.label);
        if ("value" in $$new_props)
          $$invalidate(0, value = $$new_props.value);
        if ("key" in $$new_props)
          $$invalidate(55, key = $$new_props.key);
        if ("dirty" in $$new_props)
          $$invalidate(54, dirty = $$new_props.dirty);
        if ("invalid" in $$new_props)
          $$invalidate(1, invalid = $$new_props.invalid);
        if ("updateInvalid" in $$new_props)
          $$invalidate(56, updateInvalid = $$new_props.updateInvalid);
        if ("required" in $$new_props)
          $$invalidate(10, required = $$new_props.required);
        if ("inputId" in $$new_props)
          $$invalidate(11, inputId = $$new_props.inputId);
        if ("hiddenInput" in $$new_props)
          $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
        if ("anchor$use" in $$new_props)
          $$invalidate(13, anchor$use = $$new_props.anchor$use);
        if ("anchor$class" in $$new_props)
          $$invalidate(14, anchor$class = $$new_props.anchor$class);
        if ("selectedTextContainer$use" in $$new_props)
          $$invalidate(15, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
        if ("selectedTextContainer$class" in $$new_props)
          $$invalidate(16, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
        if ("selectedText$use" in $$new_props)
          $$invalidate(17, selectedText$use = $$new_props.selectedText$use);
        if ("selectedText$class" in $$new_props)
          $$invalidate(18, selectedText$class = $$new_props.selectedText$class);
        if ("dropdownIcon$use" in $$new_props)
          $$invalidate(19, dropdownIcon$use = $$new_props.dropdownIcon$use);
        if ("dropdownIcon$class" in $$new_props)
          $$invalidate(20, dropdownIcon$class = $$new_props.dropdownIcon$class);
        if ("menu$class" in $$new_props)
          $$invalidate(21, menu$class = $$new_props.menu$class);
        if ("withLeadingIcon" in $$new_props)
          $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
        if ("$$scope" in $$new_props)
          $$invalidate(87, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCSelectFoundation,
        onMount,
        onDestroy,
        getContext,
        setContext,
        writable,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        classMap: classMap9,
        exclude: exclude3,
        prefixFilter: prefixFilter3,
        useActions: useActions8,
        dispatch: dispatch5,
        Ripple,
        Anchor,
        Menu,
        List,
        FloatingLabel,
        LineRipple,
        NotchedOutline,
        HelperText,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        ripple,
        disabled,
        variant,
        noLabel,
        label,
        value,
        key,
        dirty,
        invalid,
        updateInvalid,
        required,
        inputId,
        hiddenInput,
        anchor$use,
        anchor$class,
        selectedTextContainer$use,
        selectedTextContainer$class,
        selectedText$use,
        selectedText$class,
        dropdownIcon$use,
        dropdownIcon$class,
        menu$class,
        withLeadingIcon,
        element: element2,
        instance: instance9,
        internalClasses,
        internalStyles,
        selectAnchor,
        selectAnchorAttrs,
        selectText,
        selectedIndex,
        helperId,
        addLayoutListener,
        removeLayoutListener,
        menuOpen,
        menuClasses,
        anchorElement,
        anchorCorner,
        wrapFocus,
        list,
        context,
        leadingIcon,
        helperText,
        floatingLabel,
        lineRipple,
        notchedOutline,
        selectedTextStore,
        valueStore,
        previousSelectedIndex,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        addMenuClass,
        removeMenuClass,
        getSelectAnchorAttr,
        addSelectAnchorAttr,
        removeSelectAnchorAttr,
        getMenuItemValues,
        getNormalizedXCoordinate,
        isTouchEvent,
        focus,
        layout,
        getElement,
        $selectedTextStore,
        $valueStore
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(3, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(4, style = $$new_props.style);
        if ("ripple" in $$props)
          $$invalidate(5, ripple = $$new_props.ripple);
        if ("disabled" in $$props)
          $$invalidate(6, disabled = $$new_props.disabled);
        if ("variant" in $$props)
          $$invalidate(7, variant = $$new_props.variant);
        if ("noLabel" in $$props)
          $$invalidate(8, noLabel = $$new_props.noLabel);
        if ("label" in $$props)
          $$invalidate(9, label = $$new_props.label);
        if ("value" in $$props)
          $$invalidate(0, value = $$new_props.value);
        if ("key" in $$props)
          $$invalidate(55, key = $$new_props.key);
        if ("dirty" in $$props)
          $$invalidate(54, dirty = $$new_props.dirty);
        if ("invalid" in $$props)
          $$invalidate(1, invalid = $$new_props.invalid);
        if ("updateInvalid" in $$props)
          $$invalidate(56, updateInvalid = $$new_props.updateInvalid);
        if ("required" in $$props)
          $$invalidate(10, required = $$new_props.required);
        if ("inputId" in $$props)
          $$invalidate(11, inputId = $$new_props.inputId);
        if ("hiddenInput" in $$props)
          $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
        if ("anchor$use" in $$props)
          $$invalidate(13, anchor$use = $$new_props.anchor$use);
        if ("anchor$class" in $$props)
          $$invalidate(14, anchor$class = $$new_props.anchor$class);
        if ("selectedTextContainer$use" in $$props)
          $$invalidate(15, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
        if ("selectedTextContainer$class" in $$props)
          $$invalidate(16, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
        if ("selectedText$use" in $$props)
          $$invalidate(17, selectedText$use = $$new_props.selectedText$use);
        if ("selectedText$class" in $$props)
          $$invalidate(18, selectedText$class = $$new_props.selectedText$class);
        if ("dropdownIcon$use" in $$props)
          $$invalidate(19, dropdownIcon$use = $$new_props.dropdownIcon$use);
        if ("dropdownIcon$class" in $$props)
          $$invalidate(20, dropdownIcon$class = $$new_props.dropdownIcon$class);
        if ("menu$class" in $$props)
          $$invalidate(21, menu$class = $$new_props.menu$class);
        if ("withLeadingIcon" in $$props)
          $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
        if ("element" in $$props)
          $$invalidate(25, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(23, instance9 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(26, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(27, internalStyles = $$new_props.internalStyles);
        if ("selectAnchor" in $$props)
          $$invalidate(28, selectAnchor = $$new_props.selectAnchor);
        if ("selectAnchorAttrs" in $$props)
          $$invalidate(29, selectAnchorAttrs = $$new_props.selectAnchorAttrs);
        if ("selectText" in $$props)
          $$invalidate(30, selectText = $$new_props.selectText);
        if ("selectedIndex" in $$props)
          $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
        if ("helperId" in $$props)
          $$invalidate(31, helperId = $$new_props.helperId);
        if ("addLayoutListener" in $$props)
          addLayoutListener = $$new_props.addLayoutListener;
        if ("removeLayoutListener" in $$props)
          removeLayoutListener = $$new_props.removeLayoutListener;
        if ("menuOpen" in $$props)
          $$invalidate(32, menuOpen = $$new_props.menuOpen);
        if ("menuClasses" in $$props)
          $$invalidate(33, menuClasses = $$new_props.menuClasses);
        if ("anchorElement" in $$props)
          $$invalidate(34, anchorElement = $$new_props.anchorElement);
        if ("anchorCorner" in $$props)
          $$invalidate(35, anchorCorner = $$new_props.anchorCorner);
        if ("wrapFocus" in $$props)
          $$invalidate(36, wrapFocus = $$new_props.wrapFocus);
        if ("list" in $$props)
          $$invalidate(37, list = $$new_props.list);
        if ("context" in $$props)
          $$invalidate(46, context = $$new_props.context);
        if ("leadingIcon" in $$props)
          $$invalidate(38, leadingIcon = $$new_props.leadingIcon);
        if ("helperText" in $$props)
          $$invalidate(39, helperText = $$new_props.helperText);
        if ("floatingLabel" in $$props)
          $$invalidate(40, floatingLabel = $$new_props.floatingLabel);
        if ("lineRipple" in $$props)
          $$invalidate(41, lineRipple = $$new_props.lineRipple);
        if ("notchedOutline" in $$props)
          $$invalidate(42, notchedOutline = $$new_props.notchedOutline);
        if ("previousSelectedIndex" in $$props)
          $$invalidate(60, previousSelectedIndex = $$new_props.previousSelectedIndex);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 25165825 | $$self.$$.dirty[1] & 536870912) {
          if (previousSelectedIndex !== selectedIndex) {
            $$invalidate(60, previousSelectedIndex = selectedIndex);
            if (instance9) {
              instance9.setSelectedIndex(selectedIndex, false, true);
            } else {
              const values = getMenuItemValues();
              if (value !== values[selectedIndex]) {
                $$invalidate(0, value = values[selectedIndex]);
              }
            }
          }
        }
        if ($$self.$$.dirty[0] & 1) {
          set_store_value(valueStore, $valueStore = value, $valueStore);
        }
        if ($$self.$$.dirty[0] & 8388609 | $$self.$$.dirty[1] & 16777216) {
          if (instance9 && instance9.getValue() !== key(value)) {
            instance9.setValue(key(value));
          }
        }
        if ($$self.$$.dirty[0] & 8388672) {
          if (instance9 && instance9.getDisabled() !== disabled) {
            instance9.setDisabled(disabled);
          }
        }
        if ($$self.$$.dirty[0] & 8388610 | $$self.$$.dirty[1] & 41943040) {
          if (instance9 && dirty && instance9.isValid() !== !invalid) {
            if (updateInvalid) {
              $$invalidate(1, invalid = !instance9.isValid());
            } else {
              instance9.setValid(!invalid);
            }
          }
        }
        if ($$self.$$.dirty[0] & 8389632) {
          if (instance9 && instance9.getRequired() !== required) {
            instance9.setRequired(required);
          }
        }
      };
      return [
        value,
        invalid,
        use2,
        className,
        style,
        ripple,
        disabled,
        variant,
        noLabel,
        label,
        required,
        inputId,
        hiddenInput,
        anchor$use,
        anchor$class,
        selectedTextContainer$use,
        selectedTextContainer$class,
        selectedText$use,
        selectedText$class,
        dropdownIcon$use,
        dropdownIcon$class,
        menu$class,
        withLeadingIcon,
        instance9,
        selectedIndex,
        element2,
        internalClasses,
        internalStyles,
        selectAnchor,
        selectAnchorAttrs,
        selectText,
        helperId,
        menuOpen,
        menuClasses,
        anchorElement,
        anchorCorner,
        wrapFocus,
        list,
        leadingIcon,
        helperText,
        floatingLabel,
        lineRipple,
        notchedOutline,
        $selectedTextStore,
        forwardEvents,
        uninitializedValue,
        context,
        selectedTextStore,
        valueStore,
        addClass,
        removeClass,
        addStyle,
        $$slots,
        $$restProps,
        dirty,
        key,
        updateInvalid,
        focus,
        layout,
        getElement,
        previousSelectedIndex,
        slots,
        focus_handler,
        blur_handler,
        floatinglabel_binding,
        floatinglabel_binding_1,
        notchedoutline_binding,
        span0_binding,
        lineripple_binding,
        div0_binding,
        focus_handler_1,
        blur_handler_1,
        click_handler,
        keydown_handler,
        list_1_selectedIndex_binding,
        SMUI_list_mount_handler,
        menu_open_binding,
        MDCMenu_selected_handler,
        MDCMenuSurface_closing_handler,
        MDCMenuSurface_closed_handler,
        MDCMenuSurface_opened_handler,
        div1_binding,
        SMUI_select_leading_icon_mount_handler,
        SMUI_select_leading_icon_unmount_handler,
        SMUI_select_helper_text_id_handler,
        SMUI_select_helper_text_mount_handler,
        SMUI_select_helper_text_unmount_handler,
        $$scope
      ];
    }
    var Select = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_15, create_fragment$28, safe_not_equal, {
          use: 2,
          class: 3,
          style: 4,
          ripple: 5,
          disabled: 6,
          variant: 7,
          noLabel: 8,
          label: 9,
          value: 0,
          key: 55,
          dirty: 54,
          invalid: 1,
          updateInvalid: 56,
          required: 10,
          inputId: 11,
          hiddenInput: 12,
          anchor$use: 13,
          anchor$class: 14,
          selectedTextContainer$use: 15,
          selectedTextContainer$class: 16,
          selectedText$use: 17,
          selectedText$class: 18,
          dropdownIcon$use: 19,
          dropdownIcon$class: 20,
          menu$class: 21,
          withLeadingIcon: 22,
          focus: 57,
          layout: 58,
          getElement: 59
        }, null, [-1, -1, -1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Select",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ripple() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ripple(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get noLabel() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set noLabel(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get label() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set label(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get key() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set key(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dirty() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dirty(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get invalid() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set invalid(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get updateInvalid() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set updateInvalid(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get required() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set required(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get inputId() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set inputId(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get hiddenInput() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set hiddenInput(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get anchor$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set anchor$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get anchor$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set anchor$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedTextContainer$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedTextContainer$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedTextContainer$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedTextContainer$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedText$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedText$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get selectedText$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set selectedText$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dropdownIcon$use() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dropdownIcon$use(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dropdownIcon$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dropdownIcon$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get menu$class() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set menu$class(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get withLeadingIcon() {
        throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set withLeadingIcon(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get focus() {
        return this.$$.ctx[57];
      }
      set focus(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get layout() {
        return this.$$.ctx[58];
      }
      set layout(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[59];
      }
      set getElement(value) {
        throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function create_default_slot$14(ctx) {
      let current;
      const default_slot_template = ctx[11].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 8192)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$14.name,
        type: "slot",
        source: "(1:0) <Item   bind:this={element}   use={[forwardEvents, ...use]}   data-value={value}   {value}   {selected}   {...$$restProps}>",
        ctx
      });
      return block;
    }
    function create_fragment$18(ctx) {
      let item;
      let current;
      const item_spread_levels = [
        {
          use: [ctx[4], ...ctx[0]]
        },
        {"data-value": ctx[1]},
        {value: ctx[1]},
        {selected: ctx[3]},
        ctx[7]
      ];
      let item_props = {
        $$slots: {default: [create_default_slot$14]},
        $$scope: {ctx}
      };
      for (let i = 0; i < item_spread_levels.length; i += 1) {
        item_props = assign(item_props, item_spread_levels[i]);
      }
      item = new Item({props: item_props, $$inline: true});
      ctx[12](item);
      const block = {
        c: function create2() {
          create_component(item.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(item, target, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const item_changes = dirty & 155 ? get_spread_update(item_spread_levels, [
            dirty & 17 && {
              use: [ctx2[4], ...ctx2[0]]
            },
            dirty & 2 && {"data-value": ctx2[1]},
            dirty & 2 && {value: ctx2[1]},
            dirty & 8 && {selected: ctx2[3]},
            dirty & 128 && get_spread_object(ctx2[7])
          ]) : {};
          if (dirty & 8192) {
            item_changes.$$scope = {dirty, ctx: ctx2};
          }
          item.$set(item_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(item.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(item.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[12](null);
          destroy_component(item, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      let selected;
      const omit_props_names = ["use", "class", "value", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $selectedText;
      let $selectedValue;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Option", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      let {use: use2 = []} = $$props;
      const className = "";
      let {value = ""} = $$props;
      let element2;
      const selectedText = getContext("SMUI:select:selectedText");
      validate_store(selectedText, "selectedText");
      component_subscribe($$self, selectedText, (value2) => $$invalidate(14, $selectedText = value2));
      const selectedValue = getContext("SMUI:select:value");
      validate_store(selectedValue, "selectedValue");
      component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
      setContext("SMUI:list:item:role", "option");
      onMount(setSelectedText);
      onDestroy(setSelectedText);
      function setSelectedText() {
        if (selected && element2) {
          set_store_value(selectedText, $selectedText = element2.getPrimaryText(), $selectedText);
        }
      }
      function getElement() {
        return element2.getElement();
      }
      function item_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("value" in $$new_props)
          $$invalidate(1, value = $$new_props.value);
        if ("$$scope" in $$new_props)
          $$invalidate(13, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        onMount,
        onDestroy,
        getContext,
        setContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        Item,
        forwardEvents,
        use: use2,
        className,
        value,
        element: element2,
        selectedText,
        selectedValue,
        setSelectedText,
        getElement,
        selected,
        $selectedText,
        $selectedValue
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("value" in $$props)
          $$invalidate(1, value = $$new_props.value);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("selected" in $$props)
          $$invalidate(3, selected = $$new_props.selected);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1026) {
          $$invalidate(3, selected = value != null && value !== "" && $selectedValue === value);
        }
      };
      return [
        use2,
        value,
        element2,
        selected,
        forwardEvents,
        selectedText,
        selectedValue,
        $$restProps,
        className,
        getElement,
        $selectedValue,
        slots,
        item_binding,
        $$scope
      ];
    }
    var Option = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {
          use: 0,
          class: 8,
          value: 1,
          getElement: 9
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Option",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        return this.$$.ctx[8];
      }
      set class(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[9];
      }
      set getElement(value) {
        throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_12, console: console_12} = globals;
    var file9 = "src/pages/settings.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-19l48d9", '.file.svelte-19l48d9.svelte-19l48d9{opacity:0;width:0.1px;height:0.1px;position:absolute}input.svelte-19l48d9:hover+label.svelte-19l48d9,input.svelte-19l48d9:focus+label.svelte-19l48d9{transform:scale(1.015);filter:brightness(104%)}.file-input.svelte-19l48d9 label.svelte-19l48d9{display:block;position:relative;width:fit-content;background:"var(--mdc-theme-callout)";box-shadow:0 2px 4px rgba(0, 0, 0, 0.4);display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform .2s ease-out}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dGluZ3Muc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNDLEtBQUEsOEJBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxDQUFVLENBQ1YsS0FBQSxDQUFBLEtBQVksQ0FDWixNQUFBLENBQUEsS0FBYSxDQUNiLFFBQUEsQ0FBQSxRQUFrQixBQUNuQixDQUFBLEFBQ0Esb0JBQUEsTUFBQSxDQUFBLG9CQUFBLGlEQUVDLFNBQUEsQ0FBQSxNQUFBLEtBQUEsQ0FBdUIsQ0FDdkIsTUFBQSxDQUFBLFdBQUEsSUFBQSxDQUF3QixBQUN6QixDQUFBLEFBQ0EsMEJBQUEsQ0FBQSxLQUFBLGVBQUEsQ0FBQSxBQUNDLE9BQUEsQ0FBQSxLQUFjLENBQ2QsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEtBQUEsQ0FBQSxXQUFrQixDQUNsQixVQUFBLENBQUEsMEJBQXNDLENBQ3RDLFVBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBd0MsQ0FDeEMsT0FBQSxDQUFBLElBQWEsQ0FDYixXQUFBLENBQUEsTUFBbUIsQ0FDbkIsZUFBQSxDQUFBLE1BQXVCLENBQ3ZCLE1BQUEsQ0FBQSxPQUFlLENBQ2YsVUFBQSxDQUFBLFNBQUEsQ0FBQSxHQUFBLENBQUEsUUFBa0MsQUFDbkMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJzcmMvcGFnZXMvc3JjL3BhZ2VzL3NldHRpbmdzLnN2ZWx0ZSJdfQ== */');
    }
    function get_each_context2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[14] = list[i];
      return child_ctx;
    }
    function create_if_block6(ctx) {
      let section;
      let paper;
      let section_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot8]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          section = element("section");
          create_component(paper.$$.fragment);
          attr_dev(section, "class", "flex flex-col gap-4 md:w-10/12 w-full mx-auto ");
          add_location(section, file9, 103, 0, 2495);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          mount_component(paper, section, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const paper_changes = {};
          if (dirty & 131075) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!section_intro) {
            add_render_callback(() => {
              section_intro = create_in_transition(section, fade, {});
              section_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block6.name,
        type: "if",
        source: "(103:0) {#if Object.keys($userSettings).length > 0}",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Einstellungen";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file9, 105, 9, 2600);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: "(106:2) <Title>",
        ctx
      });
      return block;
    }
    function create_if_block_23(ctx) {
      let div1;
      let h2;
      let t1;
      let div0;
      let p;
      let t2_value = ctx[1]?.register_plugin_name + "";
      let t2;
      let t3;
      let br0;
      let t4;
      let t5;
      let br1;
      let if_block = ctx[1]?.register_plugin === "plugins.manual.manual" && create_if_block_32(ctx);
      const block = {
        c: function create2() {
          div1 = element("div");
          h2 = element("h2");
          h2.textContent = "Kassensystem";
          t1 = space();
          div0 = element("div");
          p = element("p");
          t2 = text(t2_value);
          t3 = space();
          br0 = element("br");
          t4 = space();
          if (if_block)
            if_block.c();
          t5 = space();
          br1 = element("br");
          add_location(h2, file9, 114, 6, 2905);
          add_location(p, file9, 116, 7, 2946);
          add_location(br0, file9, 117, 7, 2998);
          add_location(br1, file9, 138, 7, 3745);
          add_location(div0, file9, 115, 6, 2933);
          attr_dev(div1, "class", "flex justify-between");
          add_location(div1, file9, 113, 5, 2864);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, h2);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div0, p);
          append_dev(p, t2);
          append_dev(div0, t3);
          append_dev(div0, br0);
          append_dev(div0, t4);
          if (if_block)
            if_block.m(div0, null);
          append_dev(div0, t5);
          append_dev(div0, br1);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 2 && t2_value !== (t2_value = ctx2[1]?.register_plugin_name + ""))
            set_data_dev(t2, t2_value);
          if (ctx2[1]?.register_plugin === "plugins.manual.manual") {
            if (if_block) {
              if_block.p(ctx2, dirty);
            } else {
              if_block = create_if_block_32(ctx2);
              if_block.c();
              if_block.m(div0, t5);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (if_block)
            if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_23.name,
        type: "if",
        source: "(113:4) {#if $userSettings?.register_plugin_name}",
        ctx
      });
      return block;
    }
    function create_if_block_32(ctx) {
      let div;
      let input;
      let t0;
      let label;
      let t2;
      let if_block_anchor;
      let mounted;
      let dispose;
      function select_block_type(ctx2, dirty) {
        if (ctx2[0] && ctx2[0][0])
          return create_if_block_42;
        return create_else_block_12;
      }
      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          div = element("div");
          input = element("input");
          t0 = space();
          label = element("label");
          label.textContent = "DATEI HOCHLADEN";
          t2 = space();
          if_block.c();
          if_block_anchor = empty();
          attr_dev(input, "type", "file");
          attr_dev(input, "id", "file");
          attr_dev(input, "class", "file svelte-19l48d9");
          attr_dev(input, "accept", ".xls,.xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel");
          add_location(input, file9, 120, 9, 3117);
          attr_dev(label, "for", "file");
          set_style(label, "background", "var(--mdc-theme-callout)");
          attr_dev(label, "class", "px-4 py-2 m-0 text-white text-sm font-medium tracking-widest rounded-sm svelte-19l48d9");
          add_location(label, file9, 127, 9, 3357);
          attr_dev(div, "class", "file-input svelte-19l48d9");
          add_location(div, file9, 119, 8, 3083);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input);
          append_dev(div, t0);
          append_dev(div, label);
          insert_dev(target, t2, anchor);
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          if (!mounted) {
            dispose = listen_dev(input, "change", ctx[3]);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t2);
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_32.name,
        type: "if",
        source: '(119:7) {#if $userSettings?.register_plugin===\\"plugins.manual.manual\\"}',
        ctx
      });
      return block;
    }
    function create_else_block_12(ctx) {
      let p;
      const block = {
        c: function create2() {
          p = element("p");
          p.textContent = "(.xlsx, .xls)";
          set_style(p, "text-align", "center");
          add_location(p, file9, 135, 9, 3662);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_12.name,
        type: "else",
        source: "(135:8) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_42(ctx) {
      let p;
      let t_value = ctx[0][0].name + "";
      let t;
      const block = {
        c: function create2() {
          p = element("p");
          t = text(t_value);
          add_location(p, file9, 133, 9, 3614);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1 && t_value !== (t_value = ctx2[0][0].name + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_42.name,
        type: "if",
        source: "(133:8) {#if files && files[0]}",
        ctx
      });
      return block;
    }
    function create_else_block3(ctx) {
      let option;
      let current;
      option = new Option({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(option.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(option, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const option_changes = {};
          if (dirty & 131072) {
            option_changes.$$scope = {dirty, ctx: ctx2};
          }
          option.$set(option_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(option.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(option.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(option, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block3.name,
        type: "else",
        source: "(158:8) {:else}",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Problem Loading");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(159:9) <Option>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t_value = ctx[14].store_name + "";
      let t;
      const block = {
        c: function create2() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 2 && t_value !== (t_value = ctx2[14].store_name + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: "(153:9) <Option           value={s.store}           on:SMUI:action={() => changeStore(s)}           >",
        ctx
      });
      return block;
    }
    function create_each_block2(ctx) {
      let option;
      let current;
      function SMUI_action_handler() {
        return ctx[4](ctx[14]);
      }
      option = new Option({
        props: {
          value: ctx[14].store,
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      option.$on("SMUI:action", SMUI_action_handler);
      const block = {
        c: function create2() {
          create_component(option.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(option, target, anchor);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          const option_changes = {};
          if (dirty & 2)
            option_changes.value = ctx[14].store;
          if (dirty & 131074) {
            option_changes.$$scope = {dirty, ctx};
          }
          option.$set(option_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(option.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(option.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(option, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block2.name,
        type: "each",
        source: "(152:8) {#each $userSettings.stores as s}",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let each_1_anchor;
      let current;
      let each_value = ctx[1].stores;
      validate_each_argument(each_value);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
      }
      const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      let each_1_else = null;
      if (!each_value.length) {
        each_1_else = create_else_block3(ctx);
      }
      const block = {
        c: function create2() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty();
          if (each_1_else) {
            each_1_else.c();
          }
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }
          insert_dev(target, each_1_anchor, anchor);
          if (each_1_else) {
            each_1_else.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 6) {
            each_value = ctx2[1].stores;
            validate_each_argument(each_value);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context2(ctx2, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block2(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx2, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block3(ctx2);
              each_1_else.c();
              transition_in(each_1_else, 1);
              each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
            } else if (each_1_else) {
              group_outros();
              transition_out(each_1_else, 1, 1, () => {
                each_1_else = null;
              });
              check_outros();
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching)
            detach_dev(each_1_anchor);
          if (each_1_else)
            each_1_else.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: '(148:7) <Select         bind:value={$userSettings.store}         style=\\"max-width:150px;\\"        >',
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding(value) {
        ctx[6](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].tomorrow !== void 0) {
        switch_1_props.checked = ctx[1].tomorrow;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].tomorrow;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: "(181:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot_2(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "Morgen";
          attr_dev(span, "slot", "label");
          add_location(span, file9, 185, 7, 4824);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot_2.name,
        type: "slot",
        source: "(186:7) ",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding_1(value) {
        ctx[7](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].day_after_tomorrow !== void 0) {
        switch_1_props.checked = ctx[1].day_after_tomorrow;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding_1));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].day_after_tomorrow;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(190:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot_1(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "\xDCbermorgen";
          attr_dev(span, "slot", "label");
          add_location(span, file9, 194, 7, 5029);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot_1.name,
        type: "slot",
        source: "(195:7) ",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let switch_1;
      let updating_checked;
      let current;
      function switch_1_checked_binding_2(value) {
        ctx[8](value);
      }
      let switch_1_props = {color: "primary"};
      if (ctx[1].next_seven_days !== void 0) {
        switch_1_props.checked = ctx[1].next_seven_days;
      }
      switch_1 = new Switch({props: switch_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(switch_1, "checked", switch_1_checked_binding_2));
      const block = {
        c: function create2() {
          create_component(switch_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(switch_1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_1_changes = {};
          if (!updating_checked && dirty & 2) {
            updating_checked = true;
            switch_1_changes.checked = ctx2[1].next_seven_days;
            add_flush_callback(() => updating_checked = false);
          }
          switch_1.$set(switch_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(switch_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(switch_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(switch_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(199:6) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "N\xE4chste 7 Tage";
          attr_dev(span, "slot", "label");
          add_location(span, file9, 203, 7, 5235);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot.name,
        type: "slot",
        source: "(204:7) ",
        ctx
      });
      return block;
    }
    function create_if_block_13(ctx) {
      let br;
      let t0;
      let div2;
      let div0;
      let h2;
      let t2;
      let p;
      let t3_value = ctx[1].rows_per_page + "";
      let t3;
      let t4;
      let div1;
      let slider;
      let updating_value;
      let current;
      function slider_value_binding(value) {
        ctx[9](value);
      }
      let slider_props = {
        min: 10,
        max: 100,
        step: 10,
        discrete: true,
        "input$aria-label": "Discrete slider"
      };
      if (ctx[1].rows_per_page !== void 0) {
        slider_props.value = ctx[1].rows_per_page;
      }
      slider = new Slider({props: slider_props, $$inline: true});
      binding_callbacks.push(() => bind3(slider, "value", slider_value_binding));
      const block = {
        c: function create2() {
          br = element("br");
          t0 = space();
          div2 = element("div");
          div0 = element("div");
          h2 = element("h2");
          h2.textContent = "Zeilen pro Seite";
          t2 = space();
          p = element("p");
          t3 = text(t3_value);
          t4 = space();
          div1 = element("div");
          create_component(slider.$$.fragment);
          add_location(br, file9, 208, 6, 5353);
          add_location(h2, file9, 211, 8, 5444);
          add_location(p, file9, 212, 8, 5478);
          attr_dev(div0, "class", "flex justify-between");
          add_location(div0, file9, 210, 7, 5401);
          attr_dev(div1, "class", "w-full");
          add_location(div1, file9, 215, 7, 5537);
          attr_dev(div2, "class", "flex flex-col");
          add_location(div2, file9, 209, 6, 5366);
        },
        m: function mount(target, anchor) {
          insert_dev(target, br, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div0, h2);
          append_dev(div0, t2);
          append_dev(div0, p);
          append_dev(p, t3);
          append_dev(div2, t4);
          append_dev(div2, div1);
          mount_component(slider, div1, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1].rows_per_page + ""))
            set_data_dev(t3, t3_value);
          const slider_changes = {};
          if (!updating_value && dirty & 2) {
            updating_value = true;
            slider_changes.value = ctx2[1].rows_per_page;
            add_flush_callback(() => updating_value = false);
          }
          slider.$set(slider_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(slider.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(slider.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(br);
          if (detaching)
            detach_dev(t0);
          if (detaching)
            detach_dev(div2);
          destroy_component(slider);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(208:5) {#if $userSettings.rows_per_page}",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let div0;
      let h20;
      let t1;
      let p0;
      let t2_value = (ctx[1]?.username || "DEMO") + "";
      let t2;
      let t3;
      let t4;
      let separator0;
      let br0;
      let t5;
      let div1;
      let h21;
      let t7;
      let p1;
      let select;
      let updating_value;
      let t8;
      let div2;
      let h22;
      let t10;
      let p2;
      let t11_value = ctx[1]?.country + "";
      let t11;
      let t12;
      let div3;
      let h23;
      let t14;
      let p3;
      let t15_value = ctx[1]?.state + "";
      let t15;
      let t16;
      let div4;
      let h24;
      let t18;
      let p4;
      let t19_value = ctx[1]?.city + "";
      let t19;
      let t20;
      let separator1;
      let br1;
      let t21;
      let h25;
      let t23;
      let div5;
      let formfield0;
      let t24;
      let div6;
      let formfield1;
      let t25;
      let div7;
      let formfield2;
      let t26;
      let if_block1_anchor;
      let current;
      let if_block0 = ctx[1]?.register_plugin_name && create_if_block_23(ctx);
      separator0 = new Separator({$$inline: true});
      function select_value_binding(value) {
        ctx[5](value);
      }
      let select_props = {
        style: "max-width:150px;",
        $$slots: {default: [create_default_slot_62]},
        $$scope: {ctx}
      };
      if (ctx[1].store !== void 0) {
        select_props.value = ctx[1].store;
      }
      select = new Select({props: select_props, $$inline: true});
      binding_callbacks.push(() => bind3(select, "value", select_value_binding));
      separator1 = new Separator({$$inline: true});
      formfield0 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot_2],
            default: [create_default_slot_52]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      formfield1 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot_1],
            default: [create_default_slot_42]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      formfield2 = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot],
            default: [create_default_slot_32]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      let if_block1 = ctx[1].rows_per_page && create_if_block_13(ctx);
      const block = {
        c: function create2() {
          div0 = element("div");
          h20 = element("h2");
          h20.textContent = "angemeldete/r Benutzer*In";
          t1 = space();
          p0 = element("p");
          t2 = text(t2_value);
          t3 = space();
          if (if_block0)
            if_block0.c();
          t4 = space();
          create_component(separator0.$$.fragment);
          br0 = element("br");
          t5 = space();
          div1 = element("div");
          h21 = element("h2");
          h21.textContent = "Standort";
          t7 = space();
          p1 = element("p");
          create_component(select.$$.fragment);
          t8 = space();
          div2 = element("div");
          h22 = element("h2");
          h22.textContent = "Land";
          t10 = space();
          p2 = element("p");
          t11 = text(t11_value);
          t12 = space();
          div3 = element("div");
          h23 = element("h2");
          h23.textContent = "Bundesland";
          t14 = space();
          p3 = element("p");
          t15 = text(t15_value);
          t16 = space();
          div4 = element("div");
          h24 = element("h2");
          h24.textContent = "Stadt";
          t18 = space();
          p4 = element("p");
          t19 = text(t19_value);
          t20 = space();
          create_component(separator1.$$.fragment);
          br1 = element("br");
          t21 = space();
          h25 = element("h2");
          h25.textContent = "Vorhersage und Planung";
          t23 = space();
          div5 = element("div");
          create_component(formfield0.$$.fragment);
          t24 = space();
          div6 = element("div");
          create_component(formfield1.$$.fragment);
          t25 = space();
          div7 = element("div");
          create_component(formfield2.$$.fragment);
          t26 = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          add_location(h20, file9, 109, 5, 2719);
          add_location(p0, file9, 110, 5, 2759);
          attr_dev(div0, "class", "flex justify-between");
          add_location(div0, file9, 108, 4, 2679);
          add_location(br0, file9, 142, 17, 3804);
          add_location(h21, file9, 145, 6, 3858);
          add_location(p1, file9, 146, 6, 3882);
          attr_dev(div1, "class", "flex justify-between");
          add_location(div1, file9, 144, 5, 3817);
          add_location(h22, file9, 164, 6, 4322);
          add_location(p2, file9, 165, 6, 4342);
          attr_dev(div2, "class", "flex justify-between");
          add_location(div2, file9, 163, 5, 4281);
          add_location(h23, file9, 168, 6, 4432);
          add_location(p3, file9, 169, 6, 4458);
          attr_dev(div3, "class", "flex justify-between");
          add_location(div3, file9, 167, 5, 4391);
          add_location(h24, file9, 172, 6, 4546);
          add_location(p4, file9, 173, 6, 4567);
          attr_dev(div4, "class", "flex justify-between");
          add_location(div4, file9, 171, 5, 4505);
          add_location(br1, file9, 176, 18, 4627);
          attr_dev(h25, "class", "text-xl my-6");
          add_location(h25, file9, 178, 5, 4640);
          add_location(div5, file9, 179, 5, 4698);
          add_location(div6, file9, 188, 5, 4893);
          add_location(div7, file9, 197, 5, 5102);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, h20);
          append_dev(div0, t1);
          append_dev(div0, p0);
          append_dev(p0, t2);
          insert_dev(target, t3, anchor);
          if (if_block0)
            if_block0.m(target, anchor);
          insert_dev(target, t4, anchor);
          mount_component(separator0, target, anchor);
          insert_dev(target, br0, anchor);
          insert_dev(target, t5, anchor);
          insert_dev(target, div1, anchor);
          append_dev(div1, h21);
          append_dev(div1, t7);
          append_dev(div1, p1);
          mount_component(select, p1, null);
          insert_dev(target, t8, anchor);
          insert_dev(target, div2, anchor);
          append_dev(div2, h22);
          append_dev(div2, t10);
          append_dev(div2, p2);
          append_dev(p2, t11);
          insert_dev(target, t12, anchor);
          insert_dev(target, div3, anchor);
          append_dev(div3, h23);
          append_dev(div3, t14);
          append_dev(div3, p3);
          append_dev(p3, t15);
          insert_dev(target, t16, anchor);
          insert_dev(target, div4, anchor);
          append_dev(div4, h24);
          append_dev(div4, t18);
          append_dev(div4, p4);
          append_dev(p4, t19);
          insert_dev(target, t20, anchor);
          mount_component(separator1, target, anchor);
          insert_dev(target, br1, anchor);
          insert_dev(target, t21, anchor);
          insert_dev(target, h25, anchor);
          insert_dev(target, t23, anchor);
          insert_dev(target, div5, anchor);
          mount_component(formfield0, div5, null);
          insert_dev(target, t24, anchor);
          insert_dev(target, div6, anchor);
          mount_component(formfield1, div6, null);
          insert_dev(target, t25, anchor);
          insert_dev(target, div7, anchor);
          mount_component(formfield2, div7, null);
          insert_dev(target, t26, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t2_value !== (t2_value = (ctx2[1]?.username || "DEMO") + ""))
            set_data_dev(t2, t2_value);
          if (ctx2[1]?.register_plugin_name) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_23(ctx2);
              if_block0.c();
              if_block0.m(t4.parentNode, t4);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          const select_changes = {};
          if (dirty & 131074) {
            select_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value && dirty & 2) {
            updating_value = true;
            select_changes.value = ctx2[1].store;
            add_flush_callback(() => updating_value = false);
          }
          select.$set(select_changes);
          if ((!current || dirty & 2) && t11_value !== (t11_value = ctx2[1]?.country + ""))
            set_data_dev(t11, t11_value);
          if ((!current || dirty & 2) && t15_value !== (t15_value = ctx2[1]?.state + ""))
            set_data_dev(t15, t15_value);
          if ((!current || dirty & 2) && t19_value !== (t19_value = ctx2[1]?.city + ""))
            set_data_dev(t19, t19_value);
          const formfield0_changes = {};
          if (dirty & 131074) {
            formfield0_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield0.$set(formfield0_changes);
          const formfield1_changes = {};
          if (dirty & 131074) {
            formfield1_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield1.$set(formfield1_changes);
          const formfield2_changes = {};
          if (dirty & 131074) {
            formfield2_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield2.$set(formfield2_changes);
          if (ctx2[1].rows_per_page) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
              if (dirty & 2) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_13(ctx2);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(separator0.$$.fragment, local);
          transition_in(select.$$.fragment, local);
          transition_in(separator1.$$.fragment, local);
          transition_in(formfield0.$$.fragment, local);
          transition_in(formfield1.$$.fragment, local);
          transition_in(formfield2.$$.fragment, local);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(separator0.$$.fragment, local);
          transition_out(select.$$.fragment, local);
          transition_out(separator1.$$.fragment, local);
          transition_out(formfield0.$$.fragment, local);
          transition_out(formfield1.$$.fragment, local);
          transition_out(formfield2.$$.fragment, local);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div0);
          if (detaching)
            detach_dev(t3);
          if (if_block0)
            if_block0.d(detaching);
          if (detaching)
            detach_dev(t4);
          destroy_component(separator0, detaching);
          if (detaching)
            detach_dev(br0);
          if (detaching)
            detach_dev(t5);
          if (detaching)
            detach_dev(div1);
          destroy_component(select);
          if (detaching)
            detach_dev(t8);
          if (detaching)
            detach_dev(div2);
          if (detaching)
            detach_dev(t12);
          if (detaching)
            detach_dev(div3);
          if (detaching)
            detach_dev(t16);
          if (detaching)
            detach_dev(div4);
          if (detaching)
            detach_dev(t20);
          destroy_component(separator1, detaching);
          if (detaching)
            detach_dev(br1);
          if (detaching)
            detach_dev(t21);
          if (detaching)
            detach_dev(h25);
          if (detaching)
            detach_dev(t23);
          if (detaching)
            detach_dev(div5);
          destroy_component(formfield0);
          if (detaching)
            detach_dev(t24);
          if (detaching)
            detach_dev(div6);
          destroy_component(formfield1);
          if (detaching)
            detach_dev(t25);
          if (detaching)
            detach_dev(div7);
          destroy_component(formfield2);
          if (detaching)
            detach_dev(t26);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: "(108:3) <List>",
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let list;
      let current;
      list = new List({
        props: {
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(list.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(list, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const list_changes = {};
          if (dirty & 131075) {
            list_changes.$$scope = {dirty, ctx: ctx2};
          }
          list.$set(list_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(list.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(list.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(list, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(107:2) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot8(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 131072) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 131075) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot8.name,
        type: "slot",
        source: "(105:1) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let show_if = Object.keys(ctx[1]).length > 0;
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block6(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 2)
            show_if = Object.keys(ctx2[1]).length > 0;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block6(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance8($$self, $$props, $$invalidate) {
      let $notification;
      let $userSettings;
      let $redirect;
      let $user;
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(10, $notification = $$value));
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(1, $userSettings = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(11, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(12, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Settings", slots, []);
      onMount(() => {
        if (!($user && Object.keys($user).length)) {
          $redirect("/signup");
        }
      });
      function changeStore(storeObject) {
        set_store_value(userSettings, $userSettings.state = storeObject.state, $userSettings);
        set_store_value(userSettings, $userSettings.city = storeObject.city, $userSettings);
        set_store_value(userSettings, $userSettings.store_name = storeObject.store_name, $userSettings);
      }
      let files;
      function testFileUploaded(newValue) {
        if (files && files[0]) {
          console.log(newValue[0].name);
          let ext = files[0].name.split(".").pop();
          switch (ext) {
            case "xls":
            case "xlsx":
              console.log("Allowed");
              let formData = new FormData();
              formData.append("file", files[0]);
              axios.post("/api/sales_upload", formData, {
                headers: {"Content-Type": "multipart/form-data"}
              }).then((response) => {
                console.log(response.data);
              }).catch(function() {
                console.log("FAILURE!!");
              });
              break;
            default:
              console.log("Not allowed");
              $$invalidate(0, files = null);
              set_store_value(notification, $notification = {
                text: "Es k\xF6nnen nur Excel-Dateien hochgeladen werden.",
                bg: "var(--mdc-theme-callout);",
                color: "var(--mdc-theme-on-primary);"
              }, $notification);
              setTimeout(() => {
                set_store_value(notification, $notification = void 0, $notification);
              }, 5e3);
          }
        }
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console_12.warn(`<Settings> was created with unknown prop '${key}'`);
      });
      function input_change_handler() {
        files = this.files;
        $$invalidate(0, files);
      }
      const SMUI_action_handler = (s) => changeStore(s);
      function select_value_binding(value) {
        if ($$self.$$.not_equal($userSettings.store, value)) {
          $userSettings.store = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding(value) {
        if ($$self.$$.not_equal($userSettings.tomorrow, value)) {
          $userSettings.tomorrow = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding_1(value) {
        if ($$self.$$.not_equal($userSettings.day_after_tomorrow, value)) {
          $userSettings.day_after_tomorrow = value;
          userSettings.set($userSettings);
        }
      }
      function switch_1_checked_binding_2(value) {
        if ($$self.$$.not_equal($userSettings.next_seven_days, value)) {
          $userSettings.next_seven_days = value;
          userSettings.set($userSettings);
        }
      }
      function slider_value_binding(value) {
        if ($$self.$$.not_equal($userSettings.rows_per_page, value)) {
          $userSettings.rows_per_page = value;
          userSettings.set($userSettings);
        }
      }
      $$self.$capture_state = () => ({
        user,
        userSettings,
        notification,
        Slider,
        Switch,
        FormField,
        Paper,
        Title,
        Content,
        Select,
        Option,
        List,
        Item,
        Separator,
        Subheader,
        axios,
        fade,
        redirect,
        onMount,
        changeStore,
        files,
        testFileUploaded,
        $notification,
        $userSettings,
        $redirect,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("files" in $$props2)
          $$invalidate(0, files = $$props2.files);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          {
            testFileUploaded(files);
          }
        }
      };
      return [
        files,
        $userSettings,
        changeStore,
        input_change_handler,
        SMUI_action_handler,
        select_value_binding,
        switch_1_checked_binding,
        switch_1_checked_binding_1,
        switch_1_checked_binding_2,
        slider_value_binding
      ];
    }
    var Settings = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Settings",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/signup.js
  var require_signup = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Signup
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$13 = {
      HELPER_TEXT_PERSISTENT: "mdc-text-field-helper-text--persistent",
      HELPER_TEXT_VALIDATION_MSG: "mdc-text-field-helper-text--validation-msg",
      ROOT: "mdc-text-field-helper-text"
    };
    var strings$12 = {
      ARIA_HIDDEN: "aria-hidden",
      ROLE: "role",
      ROOT_SELECTOR: "." + cssClasses$13.ROOT
    };
    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTextFieldHelperTextFoundation = function(_super) {
      __extends(MDCTextFieldHelperTextFoundation2, _super);
      function MDCTextFieldHelperTextFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$13;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTextFieldHelperTextFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            getAttr: function() {
              return null;
            },
            setAttr: function() {
              return void 0;
            },
            removeAttr: function() {
              return void 0;
            },
            setContent: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTextFieldHelperTextFoundation2.prototype.getId = function() {
        return this.adapter.getAttr("id");
      };
      MDCTextFieldHelperTextFoundation2.prototype.isVisible = function() {
        return this.adapter.getAttr(strings$12.ARIA_HIDDEN) !== "true";
      };
      MDCTextFieldHelperTextFoundation2.prototype.setContent = function(content) {
        this.adapter.setContent(content);
      };
      MDCTextFieldHelperTextFoundation2.prototype.isPersistent = function() {
        return this.adapter.hasClass(cssClasses$13.HELPER_TEXT_PERSISTENT);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setPersistent = function(isPersistent) {
        if (isPersistent) {
          this.adapter.addClass(cssClasses$13.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter.removeClass(cssClasses$13.HELPER_TEXT_PERSISTENT);
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.isValidation = function() {
        return this.adapter.hasClass(cssClasses$13.HELPER_TEXT_VALIDATION_MSG);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setValidation = function(isValidation) {
        if (isValidation) {
          this.adapter.addClass(cssClasses$13.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter.removeClass(cssClasses$13.HELPER_TEXT_VALIDATION_MSG);
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.showToScreenReader = function() {
        this.adapter.removeAttr(strings$12.ARIA_HIDDEN);
      };
      MDCTextFieldHelperTextFoundation2.prototype.setValidity = function(inputIsValid) {
        var helperTextIsPersistent = this.adapter.hasClass(cssClasses$13.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter.hasClass(cssClasses$13.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
        if (validationMsgNeedsDisplay) {
          this.showToScreenReader();
          this.adapter.setAttr(strings$12.ROLE, "alert");
        } else {
          this.adapter.removeAttr(strings$12.ROLE);
        }
        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      };
      MDCTextFieldHelperTextFoundation2.prototype.hide_ = function() {
        this.adapter.setAttr(strings$12.ARIA_HIDDEN, "true");
      };
      return MDCTextFieldHelperTextFoundation2;
    }(MDCFoundation);
    function dispatch$12(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    var file$26 = "node_modules/@smui/textfield/helper-text/HelperText.svelte";
    function create_else_block3(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[8]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 256)
            set_data_dev(t, ctx2[8]);
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block3.name,
        type: "else",
        source: "(17:31) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block6(ctx) {
      let current;
      const default_slot_template = ctx[13].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 4096)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block6.name,
        type: "if",
        source: "(17:2) {#if content == null}",
        ctx
      });
      return block;
    }
    function create_fragment$28(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let div_class_value;
      let div_aria_hidden_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block6, create_else_block3];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[8] == null)
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let div_levels = [
        {
          class: div_class_value = classMap7({
            [ctx[1]]: true,
            "mdc-text-field-helper-text": true,
            "mdc-text-field-helper-text--persistent": ctx[3],
            "mdc-text-field-helper-text--validation-msg": ctx[4],
            ...ctx[6]
          })
        },
        {
          "aria-hidden": div_aria_hidden_value = ctx[3] ? null : "true"
        },
        {id: ctx[2]},
        ctx[7],
        ctx[10]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if_block.c();
          set_attributes(div, div_data);
          add_location(div, file$26, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          ctx[14](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions6.call(null, div, ctx[0])),
              action_destroyer(ctx[9].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 90 && div_class_value !== (div_class_value = classMap7({
              [ctx2[1]]: true,
              "mdc-text-field-helper-text": true,
              "mdc-text-field-helper-text--persistent": ctx2[3],
              "mdc-text-field-helper-text--validation-msg": ctx2[4],
              ...ctx2[6]
            }))) && {class: div_class_value},
            (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? null : "true")) && {"aria-hidden": div_aria_hidden_value},
            (!current || dirty & 4) && {id: ctx2[2]},
            dirty & 128 && ctx2[7],
            dirty & 1024 && ctx2[10]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if_blocks[current_block_type_index].d();
          ctx[14](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("HelperText", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder7(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {id = "SMUI-textfield-helper-text-" + counter3++} = $$props;
      let {persistent = false} = $$props;
      let {validationMsg = false} = $$props;
      let element2;
      let instance9;
      let internalClasses = {};
      let internalAttrs = {};
      let content = null;
      onMount(() => {
        instance9 = new MDCTextFieldHelperTextFoundation({
          addClass,
          removeClass,
          hasClass,
          getAttr,
          setAttr: addAttr,
          removeAttr,
          setContent: (value) => {
            $$invalidate(8, content = value);
          }
        });
        if (id.startsWith("SMUI-textfield-helper-text-")) {
          dispatch$12(getElement(), "SMUI:textfield:helper-text:id", id);
        }
        dispatch$12(getElement(), "SMUI:textfield:helper-text:mount", instance9);
        instance9.init();
        return () => {
          dispatch$12(getElement(), "SMUI:textfield:helper-text:unmount", instance9);
          instance9.destroy();
        };
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(6, internalClasses[className2] = false, internalClasses);
        }
      }
      function getAttr(name) {
        return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
      }
      function addAttr(name, value) {
        if (internalAttrs[name] !== value) {
          $$invalidate(7, internalAttrs[name] = value, internalAttrs);
        }
      }
      function removeAttr(name) {
        if (!(name in internalAttrs) || internalAttrs[name] != null) {
          $$invalidate(7, internalAttrs[name] = void 0, internalAttrs);
        }
      }
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(5, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("id" in $$new_props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$new_props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$new_props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("$$scope" in $$new_props)
          $$invalidate(12, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCTextFieldHelperTextFoundation,
        onMount,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder7,
        classMap: classMap7,
        useActions: useActions6,
        dispatch: dispatch$12,
        forwardEvents,
        use: use2,
        className,
        id,
        persistent,
        validationMsg,
        element: element2,
        instance: instance9,
        internalClasses,
        internalAttrs,
        content,
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("id" in $$props)
          $$invalidate(2, id = $$new_props.id);
        if ("persistent" in $$props)
          $$invalidate(3, persistent = $$new_props.persistent);
        if ("validationMsg" in $$props)
          $$invalidate(4, validationMsg = $$new_props.validationMsg);
        if ("element" in $$props)
          $$invalidate(5, element2 = $$new_props.element);
        if ("instance" in $$props)
          instance9 = $$new_props.instance;
        if ("internalClasses" in $$props)
          $$invalidate(6, internalClasses = $$new_props.internalClasses);
        if ("internalAttrs" in $$props)
          $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
        if ("content" in $$props)
          $$invalidate(8, content = $$new_props.content);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        id,
        persistent,
        validationMsg,
        element2,
        internalClasses,
        internalAttrs,
        content,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        div_binding
      ];
    }
    var HelperText = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$28, safe_not_equal, {
          use: 0,
          class: 1,
          id: 2,
          persistent: 3,
          validationMsg: 4,
          getElement: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HelperText",
          options,
          id: create_fragment$28.name
        });
      }
      get use() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get validationMsg() {
        throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set validationMsg(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[11];
      }
      set getElement(value) {
        throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses6 = {
      ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
      ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
      ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
      ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
      ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
      ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
      BACKGROUND: "mdc-checkbox__background",
      CHECKED: "mdc-checkbox--checked",
      CHECKMARK: "mdc-checkbox__checkmark",
      CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
      DISABLED: "mdc-checkbox--disabled",
      INDETERMINATE: "mdc-checkbox--indeterminate",
      MIXEDMARK: "mdc-checkbox__mixedmark",
      NATIVE_CONTROL: "mdc-checkbox__native-control",
      ROOT: "mdc-checkbox",
      SELECTED: "mdc-checkbox--selected",
      UPGRADED: "mdc-checkbox--upgraded"
    };
    var strings6 = {
      ARIA_CHECKED_ATTR: "aria-checked",
      ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
      DATA_INDETERMINATE_ATTR: "data-indeterminate",
      NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
      TRANSITION_STATE_CHECKED: "checked",
      TRANSITION_STATE_INDETERMINATE: "indeterminate",
      TRANSITION_STATE_INIT: "init",
      TRANSITION_STATE_UNCHECKED: "unchecked"
    };
    var numbers5 = {
      ANIM_END_LATCH_MS: 250
    };
    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCCheckboxFoundation = function(_super) {
      __extends(MDCCheckboxFoundation2, _super);
      function MDCCheckboxFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation2.defaultAdapter), adapter)) || this;
        _this.currentCheckState_ = strings6.TRANSITION_STATE_INIT;
        _this.currentAnimationClass_ = "";
        _this.animEndLatchTimer_ = 0;
        _this.enableAnimationEndHandler_ = false;
        return _this;
      }
      Object.defineProperty(MDCCheckboxFoundation2, "cssClasses", {
        get: function() {
          return cssClasses6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "strings", {
        get: function() {
          return strings6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "numbers", {
        get: function() {
          return numbers5;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCCheckboxFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            forceLayout: function() {
              return void 0;
            },
            hasNativeControl: function() {
              return false;
            },
            isAttachedToDOM: function() {
              return false;
            },
            isChecked: function() {
              return false;
            },
            isIndeterminate: function() {
              return false;
            },
            removeClass: function() {
              return void 0;
            },
            removeNativeControlAttr: function() {
              return void 0;
            },
            setNativeControlAttr: function() {
              return void 0;
            },
            setNativeControlDisabled: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCCheckboxFoundation2.prototype.init = function() {
        this.currentCheckState_ = this.determineCheckState_();
        this.updateAriaChecked_();
        this.adapter.addClass(cssClasses6.UPGRADED);
      };
      MDCCheckboxFoundation2.prototype.destroy = function() {
        clearTimeout(this.animEndLatchTimer_);
      };
      MDCCheckboxFoundation2.prototype.setDisabled = function(disabled) {
        this.adapter.setNativeControlDisabled(disabled);
        if (disabled) {
          this.adapter.addClass(cssClasses6.DISABLED);
        } else {
          this.adapter.removeClass(cssClasses6.DISABLED);
        }
      };
      MDCCheckboxFoundation2.prototype.handleAnimationEnd = function() {
        var _this = this;
        if (!this.enableAnimationEndHandler_) {
          return;
        }
        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function() {
          _this.adapter.removeClass(_this.currentAnimationClass_);
          _this.enableAnimationEndHandler_ = false;
        }, numbers5.ANIM_END_LATCH_MS);
      };
      MDCCheckboxFoundation2.prototype.handleChange = function() {
        this.transitionCheckState_();
      };
      MDCCheckboxFoundation2.prototype.transitionCheckState_ = function() {
        if (!this.adapter.hasNativeControl()) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_();
        if (oldState === newState) {
          return;
        }
        this.updateAriaChecked_();
        var TRANSITION_STATE_UNCHECKED = strings6.TRANSITION_STATE_UNCHECKED;
        var SELECTED = cssClasses6.SELECTED;
        if (newState === TRANSITION_STATE_UNCHECKED) {
          this.adapter.removeClass(SELECTED);
        } else {
          this.adapter.addClass(SELECTED);
        }
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter.forceLayout();
          this.adapter.removeClass(this.currentAnimationClass_);
        }
        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;
        if (this.adapter.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter.addClass(this.currentAnimationClass_);
          this.enableAnimationEndHandler_ = true;
        }
      };
      MDCCheckboxFoundation2.prototype.determineCheckState_ = function() {
        var TRANSITION_STATE_INDETERMINATE = strings6.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings6.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings6.TRANSITION_STATE_UNCHECKED;
        if (this.adapter.isIndeterminate()) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return this.adapter.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      };
      MDCCheckboxFoundation2.prototype.getTransitionAnimationClass_ = function(oldState, newState) {
        var TRANSITION_STATE_INIT = strings6.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings6.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings6.TRANSITION_STATE_UNCHECKED;
        var _a2 = MDCCheckboxFoundation2.cssClasses, ANIM_UNCHECKED_CHECKED = _a2.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a2.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a2.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a2.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a2.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a2.ANIM_INDETERMINATE_UNCHECKED;
        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return "";
            }
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      };
      MDCCheckboxFoundation2.prototype.updateAriaChecked_ = function() {
        if (this.adapter.isIndeterminate()) {
          this.adapter.setNativeControlAttr(strings6.ARIA_CHECKED_ATTR, strings6.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter.removeNativeControlAttr(strings6.ARIA_CHECKED_ATTR);
        }
      };
      return MDCCheckboxFoundation2;
    }(MDCFoundation);
    var oldModifierRegex9 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    var newModifierRegex9 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder9(component) {
      let $on;
      let events2 = [];
      const componentOn = component.$on;
      component.$on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let destructor = () => {
        };
        if ($on) {
          destructor = $on(eventType, callback);
        } else {
          events2.push([eventType, callback]);
        }
        const oldModifierMatch = eventType.match(oldModifierRegex9);
        const newModifierMatch = eventType.match(newModifierRegex9);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (oldModifierMatch && console) {
          console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
        }
        const componentDestructor = componentOn.call(component, eventType, callback);
        return (...args) => {
          destructor();
          return componentDestructor(...args);
        };
      };
      function forward(e) {
        bubble(component, e);
      }
      return (node) => {
        const destructors = [];
        const forwardDestructors = {};
        $on = (fullEventType, callback) => {
          let eventType = fullEventType;
          let handler = callback;
          let options = false;
          const oldModifierMatch = eventType.match(oldModifierRegex9);
          const newModifierMatch = eventType.match(newModifierRegex9);
          const modifierMatch = oldModifierMatch || newModifierMatch;
          if (modifierMatch) {
            const parts = eventType.split(oldModifierMatch ? ":" : "$");
            eventType = parts[0];
            options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
            if (options.nonpassive) {
              options.passive = false;
              delete options.nonpassive;
            }
            if (options.preventDefault) {
              handler = prevent_default(handler);
              delete options.preventDefault;
            }
            if (options.stopPropagation) {
              handler = stop_propagation(handler);
              delete options.stopPropagation;
            }
          }
          const off = listen(node, eventType, handler, options);
          const destructor = () => {
            off();
            const idx = destructors.indexOf(destructor);
            if (idx > -1) {
              destructors.splice(idx, 1);
            }
          };
          destructors.push(destructor);
          if (!eventType in forwardDestructors) {
            forwardDestructors[eventType] = listen(node, eventType, forward);
          }
          return destructor;
        };
        for (let i = 0; i < events2.length; i++) {
          $on(events2[i][0], events2[i][1]);
        }
        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
            for (let entry of Object.entries(forwardDestructors)) {
              entry[1]();
            }
          }
        };
      };
    }
    function classMap9(classObj) {
      return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
    }
    function dispatch5(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    function exclude3(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf("$");
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }
      return newObj;
    }
    function prefixFilter3(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }
      return newObj;
    }
    function useActions8(node, actions) {
      let objects = [];
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray2 = Array.isArray(actions[i]);
          const action = isArray2 ? actions[i][0] : actions[i];
          if (isArray2 && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i = 0; i < actions2.length; i++) {
              if (objects[i] && "update" in objects[i]) {
                const isArray2 = Array.isArray(actions2[i]);
                if (isArray2 && actions2[i].length > 1) {
                  objects[i].update(actions2[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && "destroy" in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      };
    }
    var file$18 = "node_modules/@smui/checkbox/Checkbox.svelte";
    function create_fragment$18(ctx) {
      let div3;
      let input;
      let input_class_value;
      let input_value_value;
      let input_data_indeterminate_value;
      let useActions_action;
      let t0;
      let div1;
      let svg;
      let path;
      let t1;
      let div0;
      let t2;
      let div2;
      let div3_class_value;
      let div3_style_value;
      let useActions_action_1;
      let Ripple_action;
      let mounted;
      let dispose;
      let input_levels = [
        {
          class: input_class_value = classMap9({
            [ctx[9]]: true,
            "mdc-checkbox__native-control": true
          })
        },
        {type: "checkbox"},
        ctx[20],
        {disabled: ctx[1]},
        {
          __value: input_value_value = ctx[7] === ctx[19] ? ctx[6] : ctx[7]
        },
        {
          "data-indeterminate": input_data_indeterminate_value = ctx[0] !== ctx[19] && ctx[0] ? "true" : null
        },
        ctx[16],
        prefixFilter3(ctx[26], "input$")
      ];
      let input_data = {};
      for (let i = 0; i < input_levels.length; i += 1) {
        input_data = assign(input_data, input_levels[i]);
      }
      let div3_levels = [
        {
          class: div3_class_value = classMap9({
            [ctx[3]]: true,
            "mdc-checkbox": true,
            "mdc-checkbox--disabled": ctx[1],
            "mdc-checkbox--touch": ctx[5],
            "mdc-data-table__header-row-checkbox": ctx[21] === "data-table" && ctx[22],
            "mdc-data-table__row-checkbox": ctx[21] === "data-table" && !ctx[22],
            ...ctx[14]
          })
        },
        {
          style: div3_style_value = Object.entries(ctx[15]).map(func5).concat([ctx[4]]).join(" ")
        },
        exclude3(ctx[26], ["input$"])
      ];
      let div3_data = {};
      for (let i = 0; i < div3_levels.length; i += 1) {
        div3_data = assign(div3_data, div3_levels[i]);
      }
      const block = {
        c: function create2() {
          div3 = element("div");
          input = element("input");
          t0 = space();
          div1 = element("div");
          svg = svg_element("svg");
          path = svg_element("path");
          t1 = space();
          div0 = element("div");
          t2 = space();
          div2 = element("div");
          set_attributes(input, input_data);
          add_location(input, file$18, 30, 2, 804);
          attr_dev(path, "class", "mdc-checkbox__checkmark-path");
          attr_dev(path, "fill", "none");
          attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
          add_location(path, file$18, 52, 6, 1438);
          attr_dev(svg, "class", "mdc-checkbox__checkmark");
          attr_dev(svg, "viewBox", "0 0 24 24");
          add_location(svg, file$18, 51, 4, 1374);
          attr_dev(div0, "class", "mdc-checkbox__mixedmark");
          add_location(div0, file$18, 58, 4, 1578);
          attr_dev(div1, "class", "mdc-checkbox__background");
          add_location(div1, file$18, 50, 2, 1331);
          attr_dev(div2, "class", "mdc-checkbox__ripple");
          add_location(div2, file$18, 60, 2, 1629);
          set_attributes(div3, div3_data);
          add_location(div3, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, input);
          if (input.autofocus)
            input.focus();
          ctx[36](input);
          input.checked = ctx[12];
          append_dev(div3, t0);
          append_dev(div3, div1);
          append_dev(div1, svg);
          append_dev(svg, path);
          append_dev(div1, t1);
          append_dev(div1, div0);
          append_dev(div3, t2);
          append_dev(div3, div2);
          ctx[38](div3);
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, input, ctx[8])),
              listen_dev(input, "change", ctx[37]),
              listen_dev(input, "blur", ctx[34], false, false, false),
              listen_dev(input, "focus", ctx[35], false, false, false),
              action_destroyer(useActions_action_1 = useActions8.call(null, div3, ctx[2])),
              action_destroyer(ctx[18].call(null, div3)),
              action_destroyer(Ripple_action = Ripple.call(null, div3, {
                unbounded: true,
                addClass: ctx[23],
                removeClass: ctx[24],
                addStyle: ctx[25],
                active: ctx[17],
                eventTarget: ctx[11]
              })),
              listen_dev(div3, "animationend", ctx[39], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          set_attributes(input, input_data = get_spread_update(input_levels, [
            dirty[0] & 512 && input_class_value !== (input_class_value = classMap9({
              [ctx2[9]]: true,
              "mdc-checkbox__native-control": true
            })) && {class: input_class_value},
            {type: "checkbox"},
            ctx2[20],
            dirty[0] & 2 && {disabled: ctx2[1]},
            dirty[0] & 192 && input_value_value !== (input_value_value = ctx2[7] === ctx2[19] ? ctx2[6] : ctx2[7]) && {__value: input_value_value},
            dirty[0] & 1 && input_data_indeterminate_value !== (input_data_indeterminate_value = ctx2[0] !== ctx2[19] && ctx2[0] ? "true" : null) && {
              "data-indeterminate": input_data_indeterminate_value
            },
            dirty[0] & 65536 && ctx2[16],
            dirty[0] & 67108864 && prefixFilter3(ctx2[26], "input$")
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
            useActions_action.update.call(null, ctx2[8]);
          if (dirty[0] & 4096) {
            input.checked = ctx2[12];
          }
          set_attributes(div3, div3_data = get_spread_update(div3_levels, [
            dirty[0] & 16426 && div3_class_value !== (div3_class_value = classMap9({
              [ctx2[3]]: true,
              "mdc-checkbox": true,
              "mdc-checkbox--disabled": ctx2[1],
              "mdc-checkbox--touch": ctx2[5],
              "mdc-data-table__header-row-checkbox": ctx2[21] === "data-table" && ctx2[22],
              "mdc-data-table__row-checkbox": ctx2[21] === "data-table" && !ctx2[22],
              ...ctx2[14]
            })) && {class: div3_class_value},
            dirty[0] & 32784 && div3_style_value !== (div3_style_value = Object.entries(ctx2[15]).map(func5).concat([ctx2[4]]).join(" ")) && {style: div3_style_value},
            dirty[0] & 67108864 && exclude3(ctx2[26], ["input$"])
          ]));
          if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 4)
            useActions_action_1.update.call(null, ctx2[2]);
          if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 133120)
            Ripple_action.update.call(null, {
              unbounded: true,
              addClass: ctx2[23],
              removeClass: ctx2[24],
              addStyle: ctx2[25],
              active: ctx2[17],
              eventTarget: ctx2[11]
            });
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div3);
          ctx[36](null);
          ctx[38](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func5 = ([name, value]) => `${name}: ${value};`;
    function instance_15($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "disabled",
        "touch",
        "indeterminate",
        "group",
        "checked",
        "value",
        "valueKey",
        "input$use",
        "input$class",
        "getId",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Checkbox", slots, []);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {disabled = false} = $$props;
      let {touch = false} = $$props;
      let {indeterminate = uninitializedValue} = $$props;
      let {group = uninitializedValue} = $$props;
      let {checked = uninitializedValue} = $$props;
      let {value = null} = $$props;
      let {valueKey = uninitializedValue} = $$props;
      let {input$use = []} = $$props;
      let {input$class = ""} = $$props;
      let element2;
      let instance9;
      let checkbox;
      let internalClasses = {};
      let internalStyles = {};
      let nativeControlAttrs = {};
      let rippleActive = false;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      let nativeChecked = group === uninitializedValue ? checked === uninitializedValue ? false : checked : group.indexOf(value) !== -1;
      let context = getContext("SMUI:checkbox:context");
      let dataTableHeader = getContext("SMUI:data-table:row:header");
      let previousChecked = checked;
      let previousGroup = group === uninitializedValue ? [] : [...group];
      let previousNativeChecked = nativeChecked;
      onMount(() => {
        $$invalidate(10, instance9 = new MDCCheckboxFoundation({
          addClass,
          forceLayout: () => element2.offsetWidth,
          hasNativeControl: () => true,
          isAttachedToDOM: () => Boolean(element2.parentNode),
          isChecked: () => nativeChecked,
          isIndeterminate: () => indeterminate === uninitializedValue ? false : indeterminate,
          removeClass,
          removeNativeControlAttr,
          setNativeControlAttr: addNativeControlAttr,
          setNativeControlDisabled: (value2) => $$invalidate(1, disabled = value2)
        }));
        const accessor = {
          _smui_checkbox_accessor: true,
          get element() {
            return getElement();
          },
          get checked() {
            return nativeChecked;
          },
          set checked(value2) {
            if (nativeChecked !== value2) {
              $$invalidate(12, nativeChecked = value2);
            }
          },
          get indeterminate() {
            return indeterminate === uninitializedValue ? false : indeterminate;
          },
          set indeterminate(value2) {
            $$invalidate(0, indeterminate = value2);
          },
          activateRipple() {
            if (!disabled) {
              $$invalidate(17, rippleActive = true);
            }
          },
          deactivateRipple() {
            $$invalidate(17, rippleActive = false);
          }
        };
        dispatch5(element2, "SMUI:generic:input:mount", accessor);
        dispatch5(element2, "SMUI:checkbox:mount", accessor);
        instance9.init();
        return () => {
          dispatch5(element2, "SMUI:generic:input:unmount", accessor);
          dispatch5(element2, "SMUI:checkbox:unmount", accessor);
          instance9.destroy();
        };
      });
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(14, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(14, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name, value2) {
        if (internalStyles[name] != value2) {
          if (value2 === "" || value2 == null) {
            delete internalStyles[name];
            $$invalidate(15, internalStyles);
          } else {
            $$invalidate(15, internalStyles[name] = value2, internalStyles);
          }
        }
      }
      function addNativeControlAttr(name, value2) {
        if (nativeControlAttrs[name] !== value2) {
          $$invalidate(16, nativeControlAttrs[name] = value2, nativeControlAttrs);
        }
      }
      function removeNativeControlAttr(name) {
        if (!(name in nativeControlAttrs) || nativeControlAttrs[name] != null) {
          $$invalidate(16, nativeControlAttrs[name] = void 0, nativeControlAttrs);
        }
      }
      function getId() {
        return inputProps && inputProps.id;
      }
      function getElement() {
        return element2;
      }
      function blur_handler(event) {
        bubble.call(this, $$self, event);
      }
      function focus_handler(event) {
        bubble.call(this, $$self, event);
      }
      function input_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          checkbox = $$value;
          $$invalidate(11, checkbox), $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(10, instance9);
        });
      }
      function input_change_handler() {
        nativeChecked = this.checked;
        $$invalidate(12, nativeChecked), $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance9);
      }
      function div3_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(13, element2);
        });
      }
      const animationend_handler = () => instance9 && instance9.handleAnimationEnd();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(3, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(4, style = $$new_props.style);
        if ("disabled" in $$new_props)
          $$invalidate(1, disabled = $$new_props.disabled);
        if ("touch" in $$new_props)
          $$invalidate(5, touch = $$new_props.touch);
        if ("indeterminate" in $$new_props)
          $$invalidate(0, indeterminate = $$new_props.indeterminate);
        if ("group" in $$new_props)
          $$invalidate(27, group = $$new_props.group);
        if ("checked" in $$new_props)
          $$invalidate(28, checked = $$new_props.checked);
        if ("value" in $$new_props)
          $$invalidate(6, value = $$new_props.value);
        if ("valueKey" in $$new_props)
          $$invalidate(7, valueKey = $$new_props.valueKey);
        if ("input$use" in $$new_props)
          $$invalidate(8, input$use = $$new_props.input$use);
        if ("input$class" in $$new_props)
          $$invalidate(9, input$class = $$new_props.input$class);
      };
      $$self.$capture_state = () => ({
        MDCCheckboxFoundation,
        onMount,
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        classMap: classMap9,
        exclude: exclude3,
        prefixFilter: prefixFilter3,
        useActions: useActions8,
        dispatch: dispatch5,
        Ripple,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        disabled,
        touch,
        indeterminate,
        group,
        checked,
        value,
        valueKey,
        input$use,
        input$class,
        element: element2,
        instance: instance9,
        checkbox,
        internalClasses,
        internalStyles,
        nativeControlAttrs,
        rippleActive,
        inputProps,
        nativeChecked,
        context,
        dataTableHeader,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        addClass,
        removeClass,
        addStyle,
        addNativeControlAttr,
        removeNativeControlAttr,
        getId,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(19, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(2, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(3, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(4, style = $$new_props.style);
        if ("disabled" in $$props)
          $$invalidate(1, disabled = $$new_props.disabled);
        if ("touch" in $$props)
          $$invalidate(5, touch = $$new_props.touch);
        if ("indeterminate" in $$props)
          $$invalidate(0, indeterminate = $$new_props.indeterminate);
        if ("group" in $$props)
          $$invalidate(27, group = $$new_props.group);
        if ("checked" in $$props)
          $$invalidate(28, checked = $$new_props.checked);
        if ("value" in $$props)
          $$invalidate(6, value = $$new_props.value);
        if ("valueKey" in $$props)
          $$invalidate(7, valueKey = $$new_props.valueKey);
        if ("input$use" in $$props)
          $$invalidate(8, input$use = $$new_props.input$use);
        if ("input$class" in $$props)
          $$invalidate(9, input$class = $$new_props.input$class);
        if ("element" in $$props)
          $$invalidate(13, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(10, instance9 = $$new_props.instance);
        if ("checkbox" in $$props)
          $$invalidate(11, checkbox = $$new_props.checkbox);
        if ("internalClasses" in $$props)
          $$invalidate(14, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(15, internalStyles = $$new_props.internalStyles);
        if ("nativeControlAttrs" in $$props)
          $$invalidate(16, nativeControlAttrs = $$new_props.nativeControlAttrs);
        if ("rippleActive" in $$props)
          $$invalidate(17, rippleActive = $$new_props.rippleActive);
        if ("inputProps" in $$props)
          $$invalidate(20, inputProps = $$new_props.inputProps);
        if ("nativeChecked" in $$props)
          $$invalidate(12, nativeChecked = $$new_props.nativeChecked);
        if ("context" in $$props)
          $$invalidate(21, context = $$new_props.context);
        if ("dataTableHeader" in $$props)
          $$invalidate(22, dataTableHeader = $$new_props.dataTableHeader);
        if ("previousChecked" in $$props)
          $$invalidate(31, previousChecked = $$new_props.previousChecked);
        if ("previousGroup" in $$props)
          $$invalidate(32, previousGroup = $$new_props.previousGroup);
        if ("previousNativeChecked" in $$props)
          $$invalidate(33, previousNativeChecked = $$new_props.previousNativeChecked);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 402660417 | $$self.$$.dirty[1] & 7) {
          {
            let callHandleChange = false;
            if (group !== uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                const idx = group.indexOf(value);
                if (nativeChecked && idx === -1) {
                  group.push(value);
                  $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance9);
                } else if (!nativeChecked && idx !== -1) {
                  group.splice(idx, 1);
                  $$invalidate(27, group), $$invalidate(19, uninitializedValue), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(11, checkbox), $$invalidate(0, indeterminate), $$invalidate(10, instance9);
                }
                callHandleChange = true;
              } else {
                const idxPrev = previousGroup.indexOf(value);
                const idx = group.indexOf(value);
                if (idxPrev > -1 && idx === -1) {
                  $$invalidate(12, nativeChecked = false);
                  callHandleChange = true;
                } else if (idx > -1 && idxPrev === -1) {
                  $$invalidate(12, nativeChecked = true);
                  callHandleChange = true;
                }
              }
            }
            if (checked === uninitializedValue) {
              if (previousNativeChecked !== nativeChecked) {
                callHandleChange = true;
              }
            } else if (checked !== nativeChecked) {
              if (checked === previousChecked) {
                $$invalidate(28, checked = nativeChecked);
              } else {
                $$invalidate(12, nativeChecked = checked);
              }
              callHandleChange = true;
            }
            if (checkbox) {
              if (indeterminate === uninitializedValue) {
                if (checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = false, checkbox);
                  callHandleChange = true;
                }
              } else {
                if (!indeterminate && checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = false, checkbox);
                  callHandleChange = true;
                } else if (indeterminate && !checkbox.indeterminate) {
                  $$invalidate(11, checkbox.indeterminate = true, checkbox);
                  callHandleChange = true;
                }
              }
            }
            $$invalidate(31, previousChecked = checked);
            $$invalidate(32, previousGroup = group === uninitializedValue ? [] : [...group]);
            $$invalidate(33, previousNativeChecked = nativeChecked);
            if (callHandleChange && instance9) {
              instance9.handleChange();
            }
          }
        }
      };
      return [
        indeterminate,
        disabled,
        use2,
        className,
        style,
        touch,
        value,
        valueKey,
        input$use,
        input$class,
        instance9,
        checkbox,
        nativeChecked,
        element2,
        internalClasses,
        internalStyles,
        nativeControlAttrs,
        rippleActive,
        forwardEvents,
        uninitializedValue,
        inputProps,
        context,
        dataTableHeader,
        addClass,
        removeClass,
        addStyle,
        $$restProps,
        group,
        checked,
        getId,
        getElement,
        previousChecked,
        previousGroup,
        previousNativeChecked,
        blur_handler,
        focus_handler,
        input_binding,
        input_change_handler,
        div3_binding,
        animationend_handler
      ];
    }
    var Checkbox = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_15, create_fragment$18, safe_not_equal, {
          use: 2,
          class: 3,
          style: 4,
          disabled: 1,
          touch: 5,
          indeterminate: 0,
          group: 27,
          checked: 28,
          value: 6,
          valueKey: 7,
          input$use: 8,
          input$class: 9,
          getId: 29,
          getElement: 30
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Checkbox",
          options,
          id: create_fragment$18.name
        });
      }
      get use() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get disabled() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set disabled(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get touch() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set touch(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get indeterminate() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set indeterminate(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get group() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set group(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get checked() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set checked(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get value() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set value(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get valueKey() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set valueKey(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$use() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$use(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get input$class() {
        throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set input$class(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getId() {
        return this.$$.ctx[29];
      }
      set getId(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[30];
      }
      set getElement(value) {
        throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_12} = globals;
    var file9 = "src/pages/signup.svelte";
    function create_default_slot_122(ctx) {
      let h1;
      const block = {
        c: function create2() {
          h1 = element("h1");
          h1.textContent = "Registrieren";
          attr_dev(h1, "class", "text-2xl my-6");
          add_location(h1, file9, 84, 8, 2054);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: "(85:1) <Title>",
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Wie d\xFCrfen wir Sie ansprechen?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: '(89:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_5(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_5.name,
        type: "slot",
        source: "(89:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("G\xFCltige E-Mail-Adresse");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: '(94:4) <HelperText slot=\\"helper\\">',
        ctx
      });
      return block;
    }
    function create_helper_slot_4(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_4.name,
        type: "slot",
        source: "(94:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Ben\xF6tigt z.B. wenn Sie ihr Passwort nicht mehr wissen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: '(97:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_3(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_3.name,
        type: "slot",
        source: "(97:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text(ctx[7]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 128)
            set_data_dev(t, ctx2[7]);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: '(109:4) <Icon      class=\\"material-icons\\"      slot=\\"trailingIcon\\"      on:click={() => togglePwd()}>',
        ctx
      });
      return block;
    }
    function create_trailingIcon_slot(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          class: "material-icons",
          slot: "trailingIcon",
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      icon.$on("click", ctx[15]);
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const icon_changes = {};
          if (dirty & 33554560) {
            icon_changes.$$scope = {dirty, ctx: ctx2};
          }
          icon.$set(icon_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_trailingIcon_slot.name,
        type: "slot",
        source: "(109:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Mind.12 Zeichen, Buchstaben, Zahlen, Sonderzeichen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(114:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_2(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_2.name,
        type: "slot",
        source: "(114:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Wo befindet sich Ihr (erstes) Gesch\xE4ft?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: '(119:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot_1(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot_1.name,
        type: "slot",
        source: "(119:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Welches Kassensystem verwenden Sie?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: '(124:4) <HelperText slot=\\"helper\\"      >',
        ctx
      });
      return block;
    }
    function create_helper_slot(ctx) {
      let helpertext;
      let current;
      helpertext = new HelperText({
        props: {
          slot: "helper",
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(helpertext.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(helpertext, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const helpertext_changes = {};
          if (dirty & 33554432) {
            helpertext_changes.$$scope = {dirty, ctx: ctx2};
          }
          helpertext.$set(helpertext_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(helpertext.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(helpertext.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(helpertext, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_helper_slot.name,
        type: "slot",
        source: "(124:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let checkbox;
      let updating_checked;
      let current;
      function checkbox_checked_binding(value) {
        ctx[19](value);
      }
      let checkbox_props = {input$required: true};
      if (ctx[6] !== void 0) {
        checkbox_props.checked = ctx[6];
      }
      checkbox = new Checkbox({props: checkbox_props, $$inline: true});
      binding_callbacks.push(() => bind3(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create2() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const checkbox_changes = {};
          if (!updating_checked && dirty & 64) {
            updating_checked = true;
            checkbox_changes.checked = ctx2[6];
            add_flush_callback(() => updating_checked = false);
          }
          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: "(128:3) <FormField>",
        ctx
      });
      return block;
    }
    function create_label_slot(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "Ich stimme zu, dass foodsight mich per E-Mail und Telefon\n					zwecks Onboarding kontaktiert.";
          attr_dev(span, "slot", "label");
          add_location(span, file9, 129, 4, 3486);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_label_slot.name,
        type: "slot",
        source: "(130:4) ",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Absenden");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(141:4) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 33554432) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: `(136:3) <Button     variant=\\"raised\\"     style=\\"background: {'var(--mdc-theme-callout)'}\\"     type=\\"submit\\"    >`,
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let form;
      let textfield0;
      let updating_value;
      let t0;
      let textfield1;
      let updating_value_1;
      let t1;
      let textfield2;
      let updating_value_2;
      let t2;
      let textfield3;
      let updating_value_3;
      let t3;
      let textfield4;
      let updating_value_4;
      let t4;
      let textfield5;
      let updating_value_5;
      let t5;
      let formfield;
      let t6;
      let br;
      let t7;
      let button;
      let current;
      let mounted;
      let dispose;
      function textfield0_value_binding(value) {
        ctx[12](value);
      }
      let textfield0_props = {
        label: "Name",
        type: "name",
        $$slots: {helper: [create_helper_slot_5]},
        $$scope: {ctx}
      };
      if (ctx[0] !== void 0) {
        textfield0_props.value = ctx[0];
      }
      textfield0 = new Textfield({props: textfield0_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield0, "value", textfield0_value_binding));
      function textfield1_value_binding(value) {
        ctx[13](value);
      }
      let textfield1_props = {
        label: "E-Mail",
        type: "email",
        required: true,
        $$slots: {helper: [create_helper_slot_4]},
        $$scope: {ctx}
      };
      if (ctx[1] !== void 0) {
        textfield1_props.value = ctx[1];
      }
      textfield1 = new Textfield({props: textfield1_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield1, "value", textfield1_value_binding));
      function textfield2_value_binding(value) {
        ctx[14](value);
      }
      let textfield2_props = {
        label: "Telefon",
        type: "phone",
        required: true,
        $$slots: {helper: [create_helper_slot_3]},
        $$scope: {ctx}
      };
      if (ctx[2] !== void 0) {
        textfield2_props.value = ctx[2];
      }
      textfield2 = new Textfield({props: textfield2_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield2, "value", textfield2_value_binding));
      function textfield3_value_binding(value) {
        ctx[16](value);
      }
      let textfield3_props = {
        label: "Passwort",
        type: ctx[8],
        required: true,
        input$pattern: ctx[11],
        style: "width:200px",
        $$slots: {
          helper: [create_helper_slot_2],
          trailingIcon: [create_trailingIcon_slot]
        },
        $$scope: {ctx}
      };
      if (ctx[3] !== void 0) {
        textfield3_props.value = ctx[3];
      }
      textfield3 = new Textfield({props: textfield3_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield3, "value", textfield3_value_binding));
      function textfield4_value_binding(value) {
        ctx[17](value);
      }
      let textfield4_props = {
        label: "Standort",
        type: "text",
        $$slots: {helper: [create_helper_slot_1]},
        $$scope: {ctx}
      };
      if (ctx[4] !== void 0) {
        textfield4_props.value = ctx[4];
      }
      textfield4 = new Textfield({props: textfield4_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield4, "value", textfield4_value_binding));
      function textfield5_value_binding(value) {
        ctx[18](value);
      }
      let textfield5_props = {
        label: "Kassensystem",
        type: "text",
        $$slots: {helper: [create_helper_slot]},
        $$scope: {ctx}
      };
      if (ctx[5] !== void 0) {
        textfield5_props.value = ctx[5];
      }
      textfield5 = new Textfield({props: textfield5_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield5, "value", textfield5_value_binding));
      formfield = new FormField({
        props: {
          $$slots: {
            label: [create_label_slot],
            default: [create_default_slot_42]
          },
          $$scope: {ctx}
        },
        $$inline: true
      });
      button = new Button_1({
        props: {
          variant: "raised",
          style: "background: var(--mdc-theme-callout)",
          type: "submit",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          form = element("form");
          create_component(textfield0.$$.fragment);
          t0 = space();
          create_component(textfield1.$$.fragment);
          t1 = space();
          create_component(textfield2.$$.fragment);
          t2 = space();
          create_component(textfield3.$$.fragment);
          t3 = space();
          create_component(textfield4.$$.fragment);
          t4 = space();
          create_component(textfield5.$$.fragment);
          t5 = space();
          create_component(formfield.$$.fragment);
          t6 = space();
          br = element("br");
          t7 = space();
          create_component(button.$$.fragment);
          add_location(br, file9, 134, 3, 3636);
          add_location(form, file9, 86, 2, 2119);
        },
        m: function mount(target, anchor) {
          insert_dev(target, form, anchor);
          mount_component(textfield0, form, null);
          append_dev(form, t0);
          mount_component(textfield1, form, null);
          append_dev(form, t1);
          mount_component(textfield2, form, null);
          append_dev(form, t2);
          mount_component(textfield3, form, null);
          append_dev(form, t3);
          mount_component(textfield4, form, null);
          append_dev(form, t4);
          mount_component(textfield5, form, null);
          append_dev(form, t5);
          mount_component(formfield, form, null);
          append_dev(form, t6);
          append_dev(form, br);
          append_dev(form, t7);
          mount_component(button, form, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(ctx[9]), false, true, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          const textfield0_changes = {};
          if (dirty & 33554432) {
            textfield0_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value && dirty & 1) {
            updating_value = true;
            textfield0_changes.value = ctx2[0];
            add_flush_callback(() => updating_value = false);
          }
          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};
          if (dirty & 33554432) {
            textfield1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_1 && dirty & 2) {
            updating_value_1 = true;
            textfield1_changes.value = ctx2[1];
            add_flush_callback(() => updating_value_1 = false);
          }
          textfield1.$set(textfield1_changes);
          const textfield2_changes = {};
          if (dirty & 33554432) {
            textfield2_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_2 && dirty & 4) {
            updating_value_2 = true;
            textfield2_changes.value = ctx2[2];
            add_flush_callback(() => updating_value_2 = false);
          }
          textfield2.$set(textfield2_changes);
          const textfield3_changes = {};
          if (dirty & 256)
            textfield3_changes.type = ctx2[8];
          if (dirty & 33554560) {
            textfield3_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_3 && dirty & 8) {
            updating_value_3 = true;
            textfield3_changes.value = ctx2[3];
            add_flush_callback(() => updating_value_3 = false);
          }
          textfield3.$set(textfield3_changes);
          const textfield4_changes = {};
          if (dirty & 33554432) {
            textfield4_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_4 && dirty & 16) {
            updating_value_4 = true;
            textfield4_changes.value = ctx2[4];
            add_flush_callback(() => updating_value_4 = false);
          }
          textfield4.$set(textfield4_changes);
          const textfield5_changes = {};
          if (dirty & 33554432) {
            textfield5_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_value_5 && dirty & 32) {
            updating_value_5 = true;
            textfield5_changes.value = ctx2[5];
            add_flush_callback(() => updating_value_5 = false);
          }
          textfield5.$set(textfield5_changes);
          const formfield_changes = {};
          if (dirty & 33554496) {
            formfield_changes.$$scope = {dirty, ctx: ctx2};
          }
          formfield.$set(formfield_changes);
          const button_changes = {};
          if (dirty & 33554432) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(textfield2.$$.fragment, local);
          transition_in(textfield3.$$.fragment, local);
          transition_in(textfield4.$$.fragment, local);
          transition_in(textfield5.$$.fragment, local);
          transition_in(formfield.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(textfield2.$$.fragment, local);
          transition_out(textfield3.$$.fragment, local);
          transition_out(textfield4.$$.fragment, local);
          transition_out(textfield5.$$.fragment, local);
          transition_out(formfield.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(form);
          destroy_component(textfield0);
          destroy_component(textfield1);
          destroy_component(textfield2);
          destroy_component(textfield3);
          destroy_component(textfield4);
          destroy_component(textfield5);
          destroy_component(formfield);
          destroy_component(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(86:1) <Content>",
        ctx
      });
      return block;
    }
    function create_default_slot8(ctx) {
      let title;
      let t;
      let content;
      let current;
      title = new Title({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      content = new Content({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(content.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(content, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 33554432) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const content_changes = {};
          if (dirty & 33554943) {
            content_changes.$$scope = {dirty, ctx: ctx2};
          }
          content.$set(content_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(content.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(content.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(content, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot8.name,
        type: "slot",
        source: "(84:0) <Paper elevation={1}>",
        ctx
      });
      return block;
    }
    function create_fragment10(ctx) {
      let div;
      let paper;
      let div_intro;
      let current;
      paper = new Paper({
        props: {
          elevation: 1,
          $$slots: {default: [create_default_slot8]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          create_component(paper.$$.fragment);
          add_location(div, file9, 82, 0, 2010);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(paper, div, null);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          const paper_changes = {};
          if (dirty & 33554943) {
            paper_changes.$$scope = {dirty, ctx: ctx2};
          }
          paper.$set(paper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(paper.$$.fragment, local);
          if (!div_intro) {
            add_render_callback(() => {
              div_intro = create_in_transition(div, fade, {});
              div_intro.start();
            });
          }
          current = true;
        },
        o: function outro(local) {
          transition_out(paper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(paper);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance8($$self, $$props, $$invalidate) {
      let $modal;
      let $notification;
      let $goto;
      let $redirect;
      let $user;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(20, $modal = $$value));
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(21, $notification = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(22, $goto = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(23, $redirect = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(24, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Signup", slots, []);
      onMount(() => {
        if ($user && Object.keys($user).length) {
          $redirect("/");
        }
      });
      let name = "";
      let email = "";
      let phone = "";
      let password = "";
      let location2 = "";
      let register = "";
      let agree = null;
      async function sendSignup() {
        let payload = {
          name,
          email,
          phone,
          password,
          location: location2,
          register_type: register,
          agree
        };
        axios.post(`${backendURL}/api/signup`, payload).then((response) => {
          set_store_value(notification, $notification = {
            text: "Danke! Ihre Registrierung ist eingegangen. Wir melden uns in K\xFCrze bei Ihnen.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
            set_store_value(modal, $modal = {}, $modal);
            $goto("/");
          }, 5e3);
        }, () => {
          set_store_value(notification, $notification = {
            text: "Leider ist etwas schiefgegangen. Bitte kontaktieren Sie uns unter support@ml4all.com",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
            set_store_value(modal, $modal = {}, $modal);
          }, 5e3);
        });
      }
      let pwdIcon = "visibility";
      let pwdType = "password";
      function togglePwd() {
        if (pwdIcon === "visibility") {
          $$invalidate(7, pwdIcon = "visibility_off");
          $$invalidate(8, pwdType = "text");
        } else {
          $$invalidate(7, pwdIcon = "visibility");
          $$invalidate(8, pwdType = "password");
        }
      }
      let pattern = ".{12,}";
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Signup> was created with unknown prop '${key}'`);
      });
      function textfield0_value_binding(value) {
        name = value;
        $$invalidate(0, name);
      }
      function textfield1_value_binding(value) {
        email = value;
        $$invalidate(1, email);
      }
      function textfield2_value_binding(value) {
        phone = value;
        $$invalidate(2, phone);
      }
      const click_handler = () => togglePwd();
      function textfield3_value_binding(value) {
        password = value;
        $$invalidate(3, password);
      }
      function textfield4_value_binding(value) {
        location2 = value;
        $$invalidate(4, location2);
      }
      function textfield5_value_binding(value) {
        register = value;
        $$invalidate(5, register);
      }
      function checkbox_checked_binding(value) {
        agree = value;
        $$invalidate(6, agree);
      }
      $$self.$capture_state = () => ({
        Paper,
        Title,
        Content,
        Button: Button_1,
        Label: CommonLabel,
        Icon: CommonIcon,
        Textfield,
        HelperText,
        FormField,
        Checkbox,
        user,
        backendURL,
        modal,
        notification,
        axios,
        goto,
        redirect,
        fade,
        onMount,
        name,
        email,
        phone,
        password,
        location: location2,
        register,
        agree,
        sendSignup,
        pwdIcon,
        pwdType,
        togglePwd,
        pattern,
        $modal,
        $notification,
        $goto,
        $redirect,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("name" in $$props2)
          $$invalidate(0, name = $$props2.name);
        if ("email" in $$props2)
          $$invalidate(1, email = $$props2.email);
        if ("phone" in $$props2)
          $$invalidate(2, phone = $$props2.phone);
        if ("password" in $$props2)
          $$invalidate(3, password = $$props2.password);
        if ("location" in $$props2)
          $$invalidate(4, location2 = $$props2.location);
        if ("register" in $$props2)
          $$invalidate(5, register = $$props2.register);
        if ("agree" in $$props2)
          $$invalidate(6, agree = $$props2.agree);
        if ("pwdIcon" in $$props2)
          $$invalidate(7, pwdIcon = $$props2.pwdIcon);
        if ("pwdType" in $$props2)
          $$invalidate(8, pwdType = $$props2.pwdType);
        if ("pattern" in $$props2)
          $$invalidate(11, pattern = $$props2.pattern);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        name,
        email,
        phone,
        password,
        location2,
        register,
        agree,
        pwdIcon,
        pwdType,
        sendSignup,
        togglePwd,
        pattern,
        textfield0_value_binding,
        textfield1_value_binding,
        textfield2_value_binding,
        click_handler,
        textfield3_value_binding,
        textfield4_value_binding,
        textfield5_value_binding,
        checkbox_checked_binding
      ];
    }
    var Signup = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Signup",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/_layout.js
  var require_layout = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Layout
    });
    (function(l, r) {
      if (!l || l.getElementById("livereloadscript"))
        return;
      r = l.createElement("script");
      r.async = 1;
      r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
      r.id = "livereloadscript";
      l.getElementsByTagName("head")[0].appendChild(r);
    })(self.document);
    function dispatch$12(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    var file$d = "node_modules/@smui/list/Label.svelte";
    function create_fragment$f(ctx) {
      let label;
      let label_class_value;
      let label_for_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
      let label_levels = [
        {
          class: label_class_value = classMap4({
            [ctx[1]]: true,
            "mdc-deprecated-list-item__text": true
          })
        },
        {
          for: label_for_value = ctx[4] ? ctx[4].id : null
        },
        ctx[5]
      ];
      let label_data = {};
      for (let i = 0; i < label_levels.length; i += 1) {
        label_data = assign(label_data, label_levels[i]);
      }
      const block = {
        c: function create2() {
          label = element("label");
          if (default_slot)
            default_slot.c();
          set_attributes(label, label_data);
          add_location(label, file$d, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, label, anchor);
          if (default_slot) {
            default_slot.m(label, null);
          }
          ctx[9](label);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions4.call(null, label, ctx[0])),
              action_destroyer(ctx[3].call(null, label))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 128)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null), null);
            }
          }
          set_attributes(label, label_data = get_spread_update(label_levels, [
            (!current || dirty & 2 && label_class_value !== (label_class_value = classMap4({
              [ctx2[1]]: true,
              "mdc-deprecated-list-item__text": true
            }))) && {class: label_class_value},
            {for: label_for_value},
            dirty & 32 && ctx2[5]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(label);
          if (default_slot)
            default_slot.d(detaching);
          ctx[9](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$c($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Label", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder4(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let element2;
      let inputProps = getContext("SMUI:generic:input:props") || {};
      function getElement() {
        return element2;
      }
      function label_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("$$scope" in $$new_props)
          $$invalidate(7, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder4,
        classMap: classMap4,
        useActions: useActions4,
        forwardEvents,
        use: use2,
        className,
        element: element2,
        inputProps,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
        if ("inputProps" in $$props)
          $$invalidate(4, inputProps = $$new_props.inputProps);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        element2,
        forwardEvents,
        inputProps,
        $$restProps,
        getElement,
        $$scope,
        slots,
        label_binding
      ];
    }
    var Label = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$c, create_fragment$f, safe_not_equal, {use: 0, class: 1, getElement: 6});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Label",
          options,
          id: create_fragment$f.name
        });
      }
      get use() {
        throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[6];
      }
      set getElement(value) {
        throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$4} = globals;
    var file$c = "src/components/components/Notification.svelte";
    function create_if_block$6(ctx) {
      let div;
      let t_value = ctx[0].text + "";
      let t;
      let div_style_value;
      let div_intro;
      let div_outro;
      let current;
      const block = {
        c: function create2() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "fixed right-8 bottom-20 bg-green-500 rounded px-8 py-4");
          attr_dev(div, "style", div_style_value = `background: ${ctx[0].bg}; color: ${ctx[0].color}`);
          add_location(div, file$c, 7, 1, 206);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty & 1) && t_value !== (t_value = ctx[0].text + ""))
            set_data_dev(t, t_value);
          if (!current || dirty & 1 && div_style_value !== (div_style_value = `background: ${ctx[0].bg}; color: ${ctx[0].color}`)) {
            attr_dev(div, "style", div_style_value);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          add_render_callback(() => {
            if (div_outro)
              div_outro.end(1);
            div_intro = create_in_transition(div, fly, {
              duration: 300,
              x: 0,
              y: 500,
              opacity: 0.5,
              easing: quintOut
            });
            div_intro.start();
          });
          current = true;
        },
        o: function outro(local) {
          if (div_intro)
            div_intro.invalidate();
          div_outro = create_out_transition(div, fly, {
            delay: 250,
            duration: 300,
            x: 500,
            y: 0,
            opacity: 0.5,
            easing: quintOut
          });
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching && div_outro)
            div_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(7:0) {#if $notification && Object.keys($notification).length}",
        ctx
      });
      return block;
    }
    function create_fragment$e(ctx) {
      let show_if = ctx[0] && Object.keys(ctx[0]).length;
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block$6(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 1)
            show_if = ctx2[0] && Object.keys(ctx2[0]).length;
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$b($$self, $$props, $$invalidate) {
      let $notification;
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(0, $notification = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Notification", slots, []);
      const writable_props = [];
      Object_1$4.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Notification> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({
        notification,
        fly,
        quintOut,
        $notification
      });
      return [$notification];
    }
    var Notification = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$b, create_fragment$e, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Notification",
          options,
          id: create_fragment$e.name
        });
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$13 = {
      ICON_BUTTON_ON: "mdc-icon-button--on",
      ROOT: "mdc-icon-button"
    };
    var strings$22 = {
      ARIA_LABEL: "aria-label",
      ARIA_PRESSED: "aria-pressed",
      DATA_ARIA_LABEL_OFF: "data-aria-label-off",
      DATA_ARIA_LABEL_ON: "data-aria-label-on",
      CHANGE_EVENT: "MDCIconButtonToggle:change"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCIconButtonToggleFoundation = function(_super) {
      __extends(MDCIconButtonToggleFoundation2, _super);
      function MDCIconButtonToggleFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation2.defaultAdapter), adapter)) || this;
        _this.hasToggledAriaLabel = false;
        return _this;
      }
      Object.defineProperty(MDCIconButtonToggleFoundation2, "cssClasses", {
        get: function() {
          return cssClasses$13;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCIconButtonToggleFoundation2, "strings", {
        get: function() {
          return strings$22;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCIconButtonToggleFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            notifyChange: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            getAttr: function() {
              return null;
            },
            setAttr: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCIconButtonToggleFoundation2.prototype.init = function() {
        var ariaLabelOn = this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_ON);
        var ariaLabelOff = this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_OFF);
        if (ariaLabelOn && ariaLabelOff) {
          if (this.adapter.getAttr(strings$22.ARIA_PRESSED) !== null) {
            throw new Error("MDCIconButtonToggleFoundation: Button should not set `aria-pressed` if it has a toggled aria label.");
          }
          this.hasToggledAriaLabel = true;
        } else {
          this.adapter.setAttr(strings$22.ARIA_PRESSED, String(this.isOn()));
        }
      };
      MDCIconButtonToggleFoundation2.prototype.handleClick = function() {
        this.toggle();
        this.adapter.notifyChange({isOn: this.isOn()});
      };
      MDCIconButtonToggleFoundation2.prototype.isOn = function() {
        return this.adapter.hasClass(cssClasses$13.ICON_BUTTON_ON);
      };
      MDCIconButtonToggleFoundation2.prototype.toggle = function(isOn) {
        if (isOn === void 0) {
          isOn = !this.isOn();
        }
        if (isOn) {
          this.adapter.addClass(cssClasses$13.ICON_BUTTON_ON);
        } else {
          this.adapter.removeClass(cssClasses$13.ICON_BUTTON_ON);
        }
        if (this.hasToggledAriaLabel) {
          var ariaLabel = isOn ? this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(strings$22.DATA_ARIA_LABEL_OFF);
          this.adapter.setAttr(strings$22.ARIA_LABEL, ariaLabel || "");
        } else {
          this.adapter.setAttr(strings$22.ARIA_PRESSED, "" + isOn);
        }
      };
      return MDCIconButtonToggleFoundation2;
    }(MDCFoundation);
    function create_default_slot$4(ctx) {
      let current;
      const default_slot_template = ctx[28].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[32], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[1] & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[32], !current ? get_all_dirty_from_scope(ctx2[32]) : get_slot_changes(default_slot_template, ctx2[32], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: true,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-icon-button': true,     'mdc-icon-button--on': pressed !== uninitializedValue && pressed,     'mdc-card__action': context === 'card:action',     'mdc-card__action--icon': context === 'card:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__dismiss': context === 'snackbar:actions',     'mdc-data-table__pagination-button': context === 'data-table:pagination',     'mdc-data-table__sort-icon-button':       context === 'data-table:sortable-header-cell',     'mdc-dialog__close': context === 'dialog:header' && action === 'close',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   aria-pressed={pressed !== uninitializedValue     ? pressed       ? 'true'       : 'false'     : null}   aria-label={pressed ? ariaLabelOn : ariaLabelOff}   data-aria-label-on={ariaLabelOn}   data-aria-label-off={ariaLabelOff}   aria-describedby={ariaDescribedby}   on:click={() => instance && instance.handleClick()}   on:click={() =>     context === 'top-app-bar:navigation' &&     dispatch(element, 'SMUI:top-app-bar:icon-button:nav')}   {href}   {...actionProp}   {...internalAttrs}   {...$$restProps}>",
        ctx
      });
      return block;
    }
    function create_fragment$d(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
        {
          use: [
            [
              Ripple,
              {
                ripple: ctx[4],
                unbounded: true,
                color: ctx[5],
                disabled: !!ctx[24].disabled,
                addClass: ctx[21],
                removeClass: ctx[22],
                addStyle: ctx[23]
              }
            ],
            ctx[17],
            ...ctx[1]
          ]
        },
        {
          class: classMap({
            [ctx[2]]: true,
            "mdc-icon-button": true,
            "mdc-icon-button--on": ctx[0] !== ctx[18] && ctx[0],
            "mdc-card__action": ctx[19] === "card:action",
            "mdc-card__action--icon": ctx[19] === "card:action",
            "mdc-top-app-bar__navigation-icon": ctx[19] === "top-app-bar:navigation",
            "mdc-top-app-bar__action-item": ctx[19] === "top-app-bar:action",
            "mdc-snackbar__dismiss": ctx[19] === "snackbar:actions",
            "mdc-data-table__pagination-button": ctx[19] === "data-table:pagination",
            "mdc-data-table__sort-icon-button": ctx[19] === "data-table:sortable-header-cell",
            "mdc-dialog__close": ctx[19] === "dialog:header" && ctx[9] === "close",
            ...ctx[13]
          })
        },
        {
          style: Object.entries(ctx[14]).map(func$22).concat([ctx[3]]).join(" ")
        },
        {
          "aria-pressed": ctx[0] !== ctx[18] ? ctx[0] ? "true" : "false" : null
        },
        {
          "aria-label": ctx[0] ? ctx[6] : ctx[7]
        },
        {
          "data-aria-label-on": ctx[6]
        },
        {
          "data-aria-label-off": ctx[7]
        },
        {
          "aria-describedby": ctx[20]
        },
        {href: ctx[8]},
        ctx[16],
        ctx[15],
        ctx[24]
      ];
      var switch_value = ctx[10];
      function switch_props(ctx2) {
        let switch_instance_props = {
          $$slots: {default: [create_default_slot$4]},
          $$scope: {ctx: ctx2}
        };
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
        }
        return {
          props: switch_instance_props,
          $$inline: true
        };
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        ctx[29](switch_instance);
        switch_instance.$on("click", ctx[30]);
        switch_instance.$on("click", ctx[31]);
      }
      const block = {
        c: function create2() {
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }
          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const switch_instance_changes = dirty[0] & 33547263 ? get_spread_update(switch_instance_spread_levels, [
            dirty[0] & 31588402 && {
              use: [
                [
                  Ripple,
                  {
                    ripple: ctx2[4],
                    unbounded: true,
                    color: ctx2[5],
                    disabled: !!ctx2[24].disabled,
                    addClass: ctx2[21],
                    removeClass: ctx2[22],
                    addStyle: ctx2[23]
                  }
                ],
                ctx2[17],
                ...ctx2[1]
              ]
            },
            dirty[0] & 795141 && {
              class: classMap({
                [ctx2[2]]: true,
                "mdc-icon-button": true,
                "mdc-icon-button--on": ctx2[0] !== ctx2[18] && ctx2[0],
                "mdc-card__action": ctx2[19] === "card:action",
                "mdc-card__action--icon": ctx2[19] === "card:action",
                "mdc-top-app-bar__navigation-icon": ctx2[19] === "top-app-bar:navigation",
                "mdc-top-app-bar__action-item": ctx2[19] === "top-app-bar:action",
                "mdc-snackbar__dismiss": ctx2[19] === "snackbar:actions",
                "mdc-data-table__pagination-button": ctx2[19] === "data-table:pagination",
                "mdc-data-table__sort-icon-button": ctx2[19] === "data-table:sortable-header-cell",
                "mdc-dialog__close": ctx2[19] === "dialog:header" && ctx2[9] === "close",
                ...ctx2[13]
              })
            },
            dirty[0] & 16392 && {
              style: Object.entries(ctx2[14]).map(func$22).concat([ctx2[3]]).join(" ")
            },
            dirty[0] & 262145 && {
              "aria-pressed": ctx2[0] !== ctx2[18] ? ctx2[0] ? "true" : "false" : null
            },
            dirty[0] & 193 && {
              "aria-label": ctx2[0] ? ctx2[6] : ctx2[7]
            },
            dirty[0] & 64 && {
              "data-aria-label-on": ctx2[6]
            },
            dirty[0] & 128 && {
              "data-aria-label-off": ctx2[7]
            },
            dirty[0] & 1048576 && {
              "aria-describedby": ctx2[20]
            },
            dirty[0] & 256 && {href: ctx2[8]},
            dirty[0] & 65536 && get_spread_object(ctx2[16]),
            dirty[0] & 32768 && get_spread_object(ctx2[15]),
            dirty[0] & 16777216 && get_spread_object(ctx2[24])
          ]) : {};
          if (dirty[1] & 2) {
            switch_instance_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (switch_value !== (switch_value = ctx2[10])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx2));
              ctx2[29](switch_instance);
              switch_instance.$on("click", ctx2[30]);
              switch_instance.$on("click", ctx2[31]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          ctx[29](null);
          if (detaching)
            detach_dev(switch_instance_anchor);
          if (switch_instance)
            destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func$22 = ([name, value]) => `${name}: ${value};`;
    function instance_1$23($$self, $$props, $$invalidate) {
      let actionProp;
      const omit_props_names = [
        "use",
        "class",
        "style",
        "ripple",
        "color",
        "toggle",
        "pressed",
        "ariaLabelOn",
        "ariaLabelOff",
        "href",
        "action",
        "component",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("IconButton", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {ripple = true} = $$props;
      let {color = null} = $$props;
      let {toggle = false} = $$props;
      let {pressed = uninitializedValue} = $$props;
      let {ariaLabelOn = null} = $$props;
      let {ariaLabelOff = null} = $$props;
      let {href = null} = $$props;
      let {action = null} = $$props;
      let element2;
      let instance9;
      let internalClasses = {};
      let internalStyles = {};
      let internalAttrs = {};
      let context = getContext("SMUI:icon-button:context");
      let ariaDescribedby = getContext("SMUI:icon-button:aria-describedby");
      let {component = href == null ? Button : A} = $$props;
      setContext("SMUI:icon:context", "icon-button");
      let oldToggle = null;
      onDestroy(() => {
        instance9 && instance9.destroy();
      });
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(13, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(13, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name, value) {
        if (internalStyles[name] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name];
            $$invalidate(14, internalStyles);
          } else {
            $$invalidate(14, internalStyles[name] = value, internalStyles);
          }
        }
      }
      function getAttr(name) {
        return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
      }
      function addAttr(name, value) {
        if (internalAttrs[name] !== value) {
          $$invalidate(15, internalAttrs[name] = value, internalAttrs);
        }
      }
      function handleChange(evtData) {
        $$invalidate(0, pressed = evtData.isOn);
      }
      function getElement() {
        return element2.getElement();
      }
      function switch_instance_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(11, element2);
        });
      }
      const click_handler = () => instance9 && instance9.handleClick();
      const click_handler_1 = () => context === "top-app-bar:navigation" && dispatch$12(element2, "SMUI:top-app-bar:icon-button:nav");
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(3, style = $$new_props.style);
        if ("ripple" in $$new_props)
          $$invalidate(4, ripple = $$new_props.ripple);
        if ("color" in $$new_props)
          $$invalidate(5, color = $$new_props.color);
        if ("toggle" in $$new_props)
          $$invalidate(25, toggle = $$new_props.toggle);
        if ("pressed" in $$new_props)
          $$invalidate(0, pressed = $$new_props.pressed);
        if ("ariaLabelOn" in $$new_props)
          $$invalidate(6, ariaLabelOn = $$new_props.ariaLabelOn);
        if ("ariaLabelOff" in $$new_props)
          $$invalidate(7, ariaLabelOff = $$new_props.ariaLabelOff);
        if ("href" in $$new_props)
          $$invalidate(8, href = $$new_props.href);
        if ("action" in $$new_props)
          $$invalidate(9, action = $$new_props.action);
        if ("component" in $$new_props)
          $$invalidate(10, component = $$new_props.component);
        if ("$$scope" in $$new_props)
          $$invalidate(32, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        MDCIconButtonToggleFoundation,
        onDestroy,
        getContext,
        setContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        dispatch: dispatch$12,
        Ripple,
        A,
        Button,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        ripple,
        color,
        toggle,
        pressed,
        ariaLabelOn,
        ariaLabelOff,
        href,
        action,
        element: element2,
        instance: instance9,
        internalClasses,
        internalStyles,
        internalAttrs,
        context,
        ariaDescribedby,
        component,
        oldToggle,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        getAttr,
        addAttr,
        handleChange,
        getElement,
        actionProp
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          $$invalidate(18, uninitializedValue = $$new_props.uninitializedValue);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(3, style = $$new_props.style);
        if ("ripple" in $$props)
          $$invalidate(4, ripple = $$new_props.ripple);
        if ("color" in $$props)
          $$invalidate(5, color = $$new_props.color);
        if ("toggle" in $$props)
          $$invalidate(25, toggle = $$new_props.toggle);
        if ("pressed" in $$props)
          $$invalidate(0, pressed = $$new_props.pressed);
        if ("ariaLabelOn" in $$props)
          $$invalidate(6, ariaLabelOn = $$new_props.ariaLabelOn);
        if ("ariaLabelOff" in $$props)
          $$invalidate(7, ariaLabelOff = $$new_props.ariaLabelOff);
        if ("href" in $$props)
          $$invalidate(8, href = $$new_props.href);
        if ("action" in $$props)
          $$invalidate(9, action = $$new_props.action);
        if ("element" in $$props)
          $$invalidate(11, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(12, instance9 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(13, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(14, internalStyles = $$new_props.internalStyles);
        if ("internalAttrs" in $$props)
          $$invalidate(15, internalAttrs = $$new_props.internalAttrs);
        if ("context" in $$props)
          $$invalidate(19, context = $$new_props.context);
        if ("ariaDescribedby" in $$props)
          $$invalidate(20, ariaDescribedby = $$new_props.ariaDescribedby);
        if ("component" in $$props)
          $$invalidate(10, component = $$new_props.component);
        if ("oldToggle" in $$props)
          $$invalidate(27, oldToggle = $$new_props.oldToggle);
        if ("actionProp" in $$props)
          $$invalidate(16, actionProp = $$new_props.actionProp);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 512) {
          $$invalidate(16, actionProp = (() => {
            if (context === "data-table:pagination") {
              switch (action) {
                case "first-page":
                  return {"data-first-page": "true"};
                case "prev-page":
                  return {"data-prev-page": "true"};
                case "next-page":
                  return {"data-next-page": "true"};
                case "last-page":
                  return {"data-last-page": "true"};
                default:
                  return {"data-action": "true"};
              }
            } else if (context === "dialog:header") {
              return {"data-mdc-dialog-action": action};
            } else {
              return {action};
            }
          })());
        }
        if ($$self.$$.dirty[0] & 167778304) {
          if (element2 && getElement() && toggle !== oldToggle) {
            if (toggle && !instance9) {
              $$invalidate(12, instance9 = new MDCIconButtonToggleFoundation({
                addClass,
                hasClass,
                notifyChange: (evtData) => {
                  handleChange(evtData);
                  dispatch$12(getElement(), "MDCIconButtonToggle:change", evtData);
                },
                removeClass,
                getAttr,
                setAttr: addAttr
              }));
              instance9.init();
            } else if (!toggle && instance9) {
              instance9.destroy();
              $$invalidate(12, instance9 = null);
              $$invalidate(13, internalClasses = {});
              $$invalidate(15, internalAttrs = {});
            }
            $$invalidate(27, oldToggle = toggle);
          }
        }
        if ($$self.$$.dirty[0] & 4097) {
          if (instance9 && instance9.isOn() !== pressed) {
            instance9.toggle(pressed);
          }
        }
      };
      return [
        pressed,
        use2,
        className,
        style,
        ripple,
        color,
        ariaLabelOn,
        ariaLabelOff,
        href,
        action,
        component,
        element2,
        instance9,
        internalClasses,
        internalStyles,
        internalAttrs,
        actionProp,
        forwardEvents,
        uninitializedValue,
        context,
        ariaDescribedby,
        addClass,
        removeClass,
        addStyle,
        $$restProps,
        toggle,
        getElement,
        oldToggle,
        slots,
        switch_instance_binding,
        click_handler,
        click_handler_1,
        $$scope
      ];
    }
    var IconButton = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$23, create_fragment$d, safe_not_equal, {
          use: 1,
          class: 2,
          style: 3,
          ripple: 4,
          color: 5,
          toggle: 25,
          pressed: 0,
          ariaLabelOn: 6,
          ariaLabelOff: 7,
          href: 8,
          action: 9,
          component: 10,
          getElement: 26
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "IconButton",
          options,
          id: create_fragment$d.name
        });
      }
      get use() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ripple() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ripple(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get toggle() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set toggle(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get pressed() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set pressed(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ariaLabelOn() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ariaLabelOn(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get ariaLabelOff() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set ariaLabelOff(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get href() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set href(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get action() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set action(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get component() {
        throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set component(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[26];
      }
      set getElement(value) {
        throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$3} = globals;
    var file$b = "src/components/Modal/main.svelte";
    function create_if_block$5(ctx) {
      let div1;
      let div0;
      let div0_transition;
      let t0;
      let main1;
      let header;
      let h1;
      let t1_value = ctx[0]?.title + "";
      let t1;
      let t2;
      let iconbutton;
      let t3;
      let main0;
      let switch_instance;
      let main1_transition;
      let current;
      let mounted;
      let dispose;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot$32]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[3]);
      var switch_value = ctx[0]?.component;
      function switch_props(ctx2) {
        return {$$inline: true};
      }
      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          t0 = space();
          main1 = element("main");
          header = element("header");
          h1 = element("h1");
          t1 = text(t1_value);
          t2 = space();
          create_component(iconbutton.$$.fragment);
          t3 = space();
          main0 = element("main");
          if (switch_instance)
            create_component(switch_instance.$$.fragment);
          attr_dev(div0, "class", "bg-black bg-opacity-75 w-screen h-screen z-10 absolute top-0 left-0 bottom-0 right-0 ");
          add_location(div0, file$b, 10, 2, 365);
          attr_dev(h1, "class", "text-2xl");
          add_location(h1, file$b, 22, 4, 722);
          attr_dev(header, "class", "p-2 flex justify-between items-center");
          add_location(header, file$b, 21, 3, 663);
          attr_dev(main0, "class", "p-2");
          add_location(main0, file$b, 31, 3, 904);
          attr_dev(main1, "class", "bg-white rounded md:w-6/12 z-20 flex flex-col divide-y divide-gray-600");
          add_location(main1, file$b, 17, 2, 537);
          attr_dev(div1, "class", "fixed top-0 bottom-0 left-0 right-0 overflow-hidden flex justify-center items-center z-40 h-screen w-screen");
          add_location(div1, file$b, 7, 1, 237);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div1, t0);
          append_dev(div1, main1);
          append_dev(main1, header);
          append_dev(header, h1);
          append_dev(h1, t1);
          append_dev(header, t2);
          mount_component(iconbutton, header, null);
          append_dev(main1, t3);
          append_dev(main1, main0);
          if (switch_instance) {
            mount_component(switch_instance, main0, null);
          }
          current = true;
          if (!mounted) {
            dispose = listen_dev(div0, "click", ctx[2], false, false, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0]?.title + ""))
            set_data_dev(t1, t1_value);
          const iconbutton_changes = {};
          if (dirty & 16) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          if (switch_value !== (switch_value = ctx2[0]?.component)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, main0, null);
            } else {
              switch_instance = null;
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          add_render_callback(() => {
            if (!div0_transition)
              div0_transition = create_bidirectional_transition(div0, fade, {}, true);
            div0_transition.run(1);
          });
          transition_in(iconbutton.$$.fragment, local);
          if (switch_instance)
            transition_in(switch_instance.$$.fragment, local);
          add_render_callback(() => {
            if (!main1_transition)
              main1_transition = create_bidirectional_transition(main1, fly, {x: 500}, true);
            main1_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div0_transition)
            div0_transition = create_bidirectional_transition(div0, fade, {}, false);
          div0_transition.run(0);
          transition_out(iconbutton.$$.fragment, local);
          if (switch_instance)
            transition_out(switch_instance.$$.fragment, local);
          if (!main1_transition)
            main1_transition = create_bidirectional_transition(main1, fly, {x: 500}, false);
          main1_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (detaching && div0_transition)
            div0_transition.end();
          destroy_component(iconbutton);
          if (switch_instance)
            destroy_component(switch_instance);
          if (detaching && main1_transition)
            main1_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(7:0) {#if $modal && Object.keys($modal).length != 0 && !$screenShotMode}",
        ctx
      });
      return block;
    }
    function create_default_slot$32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("close");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$32.name,
        type: "slot",
        source: '(24:4) <IconButton      class=\\"material-icons\\"      on:click={() => {       $modal = {};      }}      >',
        ctx
      });
      return block;
    }
    function create_fragment$c(ctx) {
      let show_if = ctx[0] && Object.keys(ctx[0]).length != 0 && !ctx[1];
      let if_block_anchor;
      let current;
      let if_block = show_if && create_if_block$5(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (dirty & 3)
            show_if = ctx2[0] && Object.keys(ctx2[0]).length != 0 && !ctx2[1];
          if (show_if) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 3) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$5(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$a($$self, $$props, $$invalidate) {
      let $modal;
      let $screenShotMode;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(0, $modal = $$value));
      validate_store(screenShotMode, "screenShotMode");
      component_subscribe($$self, screenShotMode, ($$value) => $$invalidate(1, $screenShotMode = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Main", slots, []);
      const writable_props = [];
      Object_1$3.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Main> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        set_store_value(modal, $modal = {}, $modal);
      };
      const click_handler_1 = () => {
        set_store_value(modal, $modal = {}, $modal);
      };
      $$self.$capture_state = () => ({
        fly,
        fade,
        IconButton,
        modal,
        screenShotMode,
        $modal,
        $screenShotMode
      });
      return [$modal, $screenShotMode, click_handler, click_handler_1];
    }
    var Main$1 = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$a, create_fragment$c, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Main",
          options,
          id: create_fragment$c.name
        });
      }
    };
    var html2canvas$1 = {exports: {}};
    /*!
     * html2canvas 1.3.2 <https://html2canvas.hertzen.com>
     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */
    (function(module2, exports2) {
      (function(global2, factory) {
        module2.exports = factory();
      })(commonjsGlobal, function() {
        /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.
        
            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.
        
            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        function __extends2(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign2 = function() {
          __assign2 = Object.assign || function __assign3(t) {
            for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s = arguments[i2];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign2.apply(this, arguments);
        };
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _2 = {label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: []}, f2, y, t, g;
          return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_2)
              try {
                if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _2.label++;
                    return {value: op[1], done: false};
                  case 5:
                    _2.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _2.ops.pop();
                    _2.trys.pop();
                    continue;
                  default:
                    if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _2 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _2.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _2.label < t[1]) {
                      _2.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _2.label < t[2]) {
                      _2.label = t[2];
                      _2.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _2.ops.pop();
                    _2.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _2);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f2 = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return {value: op[0] ? op[1] : void 0, done: true};
          }
        }
        function __spreadArray(to, from, pack2) {
          if (pack2 || arguments.length === 2)
            for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
              if (ar || !(i2 in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
              }
            }
          return to.concat(ar || from);
        }
        var Bounds = function() {
          function Bounds2(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
          }
          Bounds2.prototype.add = function(x, y, w, h) {
            return new Bounds2(this.left + x, this.top + y, this.width + w, this.height + h);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = domRectList[0];
            return domRect ? new Bounds2(domRect.x + context.windowBounds.left, domRect.y + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }();
        var parseBounds = function(context, node) {
          return Bounds.fromClientRect(context, node.getBoundingClientRect());
        };
        var parseDocumentSize = function(document2) {
          var body = document2.body;
          var documentElement = document2.documentElement;
          if (!body || !documentElement) {
            throw new Error("Unable to get document size");
          }
          var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
          var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
          return new Bounds(0, 0, width, height);
        };
        var toCodePoints$1 = function(str) {
          var codePoints = [];
          var i2 = 0;
          var length = str.length;
          while (i2 < length) {
            var value = str.charCodeAt(i2++);
            if (value >= 55296 && value <= 56319 && i2 < length) {
              var extra = str.charCodeAt(i2++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i2--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint$1 = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index = -1;
          var result = "";
          while (++index < length) {
            var codePoint = codePoints[index];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
          lookup$2[chars$2.charCodeAt(i$2)] = i$2;
        }
        var decode$1 = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup$2[base642.charCodeAt(i2)];
            encoded2 = lookup$2[base642.charCodeAt(i2 + 1)];
            encoded3 = lookup$2[base642.charCodeAt(i2 + 2)];
            encoded4 = lookup$2[base642.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 2) {
            bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var polyUint32Array$1 = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 4) {
            bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2$1 = 5;
        var UTRIE2_SHIFT_1$1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT$1 = 2;
        var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
        var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
        var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
        var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
        var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
        var slice16$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32$1 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64$1 = function(base642) {
          var buffer = decode$1(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
        };
        var Trie$1 = function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }();
        var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
        var LETTER_NUMBER_MODIFIER = 50;
        var BK = 1;
        var CR$1 = 2;
        var LF$1 = 3;
        var CM = 4;
        var NL = 5;
        var WJ = 7;
        var ZW = 8;
        var GL = 9;
        var SP = 10;
        var ZWJ$1 = 11;
        var B2 = 12;
        var BA = 13;
        var BB = 14;
        var HY = 15;
        var CB = 16;
        var CL = 17;
        var CP = 18;
        var EX = 19;
        var IN = 20;
        var NS = 21;
        var OP = 22;
        var QU = 23;
        var IS = 24;
        var NU = 25;
        var PO = 26;
        var PR = 27;
        var SY = 28;
        var AI = 29;
        var AL = 30;
        var CJ = 31;
        var EB = 32;
        var EM = 33;
        var H2 = 34;
        var H32 = 35;
        var HL = 36;
        var ID = 37;
        var JL = 38;
        var JV = 39;
        var JT = 40;
        var RI$1 = 41;
        var SA = 42;
        var XX = 43;
        var ea_OP = [9001, 65288];
        var BREAK_MANDATORY = "!";
        var BREAK_NOT_ALLOWED$1 = "\xD7";
        var BREAK_ALLOWED$1 = "\xF7";
        var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
        var ALPHABETICS = [AL, HL];
        var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
        var SPACE$1 = [SP, ZW];
        var PREFIX_POSTFIX = [PR, PO];
        var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
        var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H32];
        var HYPHEN = [HY, BA];
        var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
          if (lineBreak2 === void 0) {
            lineBreak2 = "strict";
          }
          var types = [];
          var indices = [];
          var categories = [];
          codePoints.forEach(function(codePoint, index) {
            var classType = UnicodeTrie$1.get(codePoint);
            if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
            } else {
              categories.push(false);
            }
            if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
              if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
                indices.push(index);
                return types.push(CB);
              }
            }
            if (classType === CM || classType === ZWJ$1) {
              if (index === 0) {
                indices.push(index);
                return types.push(AL);
              }
              var prev = types[index - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                indices.push(indices[index - 1]);
                return types.push(prev);
              }
              indices.push(index);
              return types.push(AL);
            }
            indices.push(index);
            if (classType === CJ) {
              return types.push(lineBreak2 === "strict" ? NS : ID);
            }
            if (classType === SA) {
              return types.push(AL);
            }
            if (classType === AI) {
              return types.push(AL);
            }
            if (classType === XX) {
              if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
                return types.push(ID);
              } else {
                return types.push(AL);
              }
            }
            types.push(classType);
          });
          return [indices, types, categories];
        };
        var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
          var current = classTypes[currentIndex];
          if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
            var i2 = currentIndex;
            while (i2 <= classTypes.length) {
              i2++;
              var next = classTypes[i2];
              if (next === b) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (current === SP) {
            var i2 = currentIndex;
            while (i2 > 0) {
              i2--;
              var prev = classTypes[i2];
              if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
                var n = currentIndex;
                while (n <= classTypes.length) {
                  n++;
                  var next = classTypes[n];
                  if (next === b) {
                    return true;
                  }
                  if (next !== SP) {
                    break;
                  }
                }
              }
              if (prev !== SP) {
                break;
              }
            }
          }
          return false;
        };
        var previousNonSpaceClassType = function(currentIndex, classTypes) {
          var i2 = currentIndex;
          while (i2 >= 0) {
            var type = classTypes[i2];
            if (type === SP) {
              i2--;
            } else {
              return type;
            }
          }
          return 0;
        };
        var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
          if (indicies[index] === 0) {
            return BREAK_NOT_ALLOWED$1;
          }
          var currentIndex = index - 1;
          if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
            return BREAK_NOT_ALLOWED$1;
          }
          var beforeIndex = currentIndex - 1;
          var afterIndex = currentIndex + 1;
          var current = classTypes[currentIndex];
          var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
          var next = classTypes[afterIndex];
          if (current === CR$1 && next === LF$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
            return BREAK_MANDATORY;
          }
          if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (SPACE$1.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
            return BREAK_ALLOWED$1;
          }
          if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === WJ || next === WJ) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SP) {
            return BREAK_ALLOWED$1;
          }
          if (current === QU || next === QU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === CB || current === CB) {
            return BREAK_ALLOWED$1;
          }
          if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (before === HL && HYPHEN.indexOf(current) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === SY && next === HL) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (next === IN) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
            var prevIndex = currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if ([PR, PO].indexOf(next) !== -1) {
            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
            while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                return BREAK_NOT_ALLOWED$1;
              } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
              } else {
                break;
              }
            }
          }
          if (JL === current && [JL, JV, H2, H32].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H32].indexOf(current) !== -1 && next === JT) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
            return BREAK_NOT_ALLOWED$1;
          }
          if (current === RI$1 && next === RI$1) {
            var i2 = indicies[currentIndex];
            var count = 1;
            while (i2 > 0) {
              i2--;
              if (classTypes[i2] === RI$1) {
                count++;
              } else {
                break;
              }
            }
            if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
            }
          }
          if (current === EB && next === EM) {
            return BREAK_NOT_ALLOWED$1;
          }
          return BREAK_ALLOWED$1;
        };
        var cssFormattedClasses = function(codePoints, options) {
          if (!options) {
            options = {lineBreak: "normal", wordBreak: "normal"};
          }
          var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
          if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
            classTypes = classTypes.map(function(type) {
              return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
            });
          }
          var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
            return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
          }) : void 0;
          return [indicies, classTypes, forbiddenBreakpoints];
        };
        var Break = function() {
          function Break2(codePoints, lineBreak2, start, end) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start;
            this.end = end;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }();
        var LineBreaker = function(str, options) {
          var codePoints = toCodePoints$1(str);
          var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
          var length = codePoints.length;
          var lastEnd = 0;
          var nextIndex = 0;
          return {
            next: function() {
              if (nextIndex >= length) {
                return {done: true, value: null};
              }
              var lineBreak2 = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
              }
              if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
                lastEnd = nextIndex;
                return {value, done: false};
              }
              return {done: true, value: null};
            }
          };
        };
        var FLAG_UNRESTRICTED = 1 << 0;
        var FLAG_ID = 1 << 1;
        var FLAG_INTEGER = 1 << 2;
        var FLAG_NUMBER = 1 << 3;
        var LINE_FEED = 10;
        var SOLIDUS = 47;
        var REVERSE_SOLIDUS = 92;
        var CHARACTER_TABULATION = 9;
        var SPACE = 32;
        var QUOTATION_MARK = 34;
        var EQUALS_SIGN = 61;
        var NUMBER_SIGN = 35;
        var DOLLAR_SIGN = 36;
        var PERCENTAGE_SIGN = 37;
        var APOSTROPHE = 39;
        var LEFT_PARENTHESIS = 40;
        var RIGHT_PARENTHESIS = 41;
        var LOW_LINE = 95;
        var HYPHEN_MINUS = 45;
        var EXCLAMATION_MARK = 33;
        var LESS_THAN_SIGN = 60;
        var GREATER_THAN_SIGN = 62;
        var COMMERCIAL_AT = 64;
        var LEFT_SQUARE_BRACKET = 91;
        var RIGHT_SQUARE_BRACKET = 93;
        var CIRCUMFLEX_ACCENT = 61;
        var LEFT_CURLY_BRACKET = 123;
        var QUESTION_MARK = 63;
        var RIGHT_CURLY_BRACKET = 125;
        var VERTICAL_LINE = 124;
        var TILDE = 126;
        var CONTROL = 128;
        var REPLACEMENT_CHARACTER = 65533;
        var ASTERISK = 42;
        var PLUS_SIGN = 43;
        var COMMA = 44;
        var COLON = 58;
        var SEMICOLON = 59;
        var FULL_STOP = 46;
        var NULL = 0;
        var BACKSPACE = 8;
        var LINE_TABULATION = 11;
        var SHIFT_OUT = 14;
        var INFORMATION_SEPARATOR_ONE = 31;
        var DELETE = 127;
        var EOF = -1;
        var ZERO = 48;
        var a = 97;
        var e = 101;
        var f = 102;
        var u = 117;
        var z = 122;
        var A2 = 65;
        var E = 69;
        var F = 70;
        var U = 85;
        var Z = 90;
        var isDigit = function(codePoint) {
          return codePoint >= ZERO && codePoint <= 57;
        };
        var isSurrogateCodePoint = function(codePoint) {
          return codePoint >= 55296 && codePoint <= 57343;
        };
        var isHex = function(codePoint) {
          return isDigit(codePoint) || codePoint >= A2 && codePoint <= F || codePoint >= a && codePoint <= f;
        };
        var isLowerCaseLetter = function(codePoint) {
          return codePoint >= a && codePoint <= z;
        };
        var isUpperCaseLetter = function(codePoint) {
          return codePoint >= A2 && codePoint <= Z;
        };
        var isLetter = function(codePoint) {
          return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
        };
        var isNonASCIICodePoint = function(codePoint) {
          return codePoint >= CONTROL;
        };
        var isWhiteSpace = function(codePoint) {
          return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
        };
        var isNameStartCodePoint = function(codePoint) {
          return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
        };
        var isNameCodePoint = function(codePoint) {
          return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
        };
        var isNonPrintableCodePoint = function(codePoint) {
          return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
        };
        var isValidEscape = function(c1, c2) {
          if (c1 !== REVERSE_SOLIDUS) {
            return false;
          }
          return c2 !== LINE_FEED;
        };
        var isIdentifierStart = function(c1, c2, c3) {
          if (c1 === HYPHEN_MINUS) {
            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
          } else if (isNameStartCodePoint(c1)) {
            return true;
          } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
            return true;
          }
          return false;
        };
        var isNumberStart = function(c1, c2, c3) {
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
            if (isDigit(c2)) {
              return true;
            }
            return c2 === FULL_STOP && isDigit(c3);
          }
          if (c1 === FULL_STOP) {
            return isDigit(c2);
          }
          return isDigit(c1);
        };
        var stringToNumber = function(codePoints) {
          var c = 0;
          var sign = 1;
          if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
              sign = -1;
            }
            c++;
          }
          var integers = [];
          while (isDigit(codePoints[c])) {
            integers.push(codePoints[c++]);
          }
          var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
          if (codePoints[c] === FULL_STOP) {
            c++;
          }
          var fraction = [];
          while (isDigit(codePoints[c])) {
            fraction.push(codePoints[c++]);
          }
          var fracd = fraction.length;
          var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
          if (codePoints[c] === E || codePoints[c] === e) {
            c++;
          }
          var expsign = 1;
          if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
              expsign = -1;
            }
            c++;
          }
          var exponent = [];
          while (isDigit(codePoints[c])) {
            exponent.push(codePoints[c++]);
          }
          var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
          return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
        };
        var LEFT_PARENTHESIS_TOKEN = {
          type: 2
        };
        var RIGHT_PARENTHESIS_TOKEN = {
          type: 3
        };
        var COMMA_TOKEN = {type: 4};
        var SUFFIX_MATCH_TOKEN = {type: 13};
        var PREFIX_MATCH_TOKEN = {type: 8};
        var COLUMN_TOKEN = {type: 21};
        var DASH_MATCH_TOKEN = {type: 9};
        var INCLUDE_MATCH_TOKEN = {type: 10};
        var LEFT_CURLY_BRACKET_TOKEN = {
          type: 11
        };
        var RIGHT_CURLY_BRACKET_TOKEN = {
          type: 12
        };
        var SUBSTRING_MATCH_TOKEN = {type: 14};
        var BAD_URL_TOKEN = {type: 23};
        var BAD_STRING_TOKEN = {type: 1};
        var CDO_TOKEN = {type: 25};
        var CDC_TOKEN = {type: 24};
        var COLON_TOKEN = {type: 26};
        var SEMICOLON_TOKEN = {type: 27};
        var LEFT_SQUARE_BRACKET_TOKEN = {
          type: 28
        };
        var RIGHT_SQUARE_BRACKET_TOKEN = {
          type: 29
        };
        var WHITESPACE_TOKEN = {type: 31};
        var EOF_TOKEN = {type: 32};
        var Tokenizer = function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c2 = this.peekCodePoint(1);
                var c3 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                  var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return {type: 5, value, flags};
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e2 = this.peekCodePoint(0);
                var e3 = this.peekCodePoint(1);
                if (isNumberStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e2, e3)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c = this.consumeCodePoint();
                    if (c === ASTERISK) {
                      c = this.consumeCodePoint();
                      if (c === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a2 = this.peekCodePoint(1);
                var a3 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a2, a3)) {
                  var value = this.consumeName();
                  return {type: 7, value};
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u:
              case U:
                var u1 = this.peekCodePoint(0);
                var u2 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return {type: 6, value: fromCodePoint$1(codePoint)};
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F : digit;
              })), 16);
              return {type: 30, start: start_1, end};
            }
            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return {type: 30, start, end};
            } else {
              return {type: 30, start, end: start};
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return {type: 19, value};
            }
            return {type: 20, value};
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return {type: 22, value: ""};
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return {type: 22, value: stringToken.value};
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return {type: 22, value: fromCodePoint$1.apply(void 0, value)};
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return {type: 22, value: fromCodePoint$1.apply(void 0, value)};
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 6e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i2 = 0;
            do {
              var codePoint = this._value[i2];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i2);
                return {type: 0, value};
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i2);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next = this._value[i2 + 1];
                if (next !== EOF && next !== void 0) {
                  if (next === LINE_FEED) {
                    value += this.consumeStringSlice(i2);
                    i2 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next)) {
                    value += this.consumeStringSlice(i2);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i2 = -1;
                  }
                }
              }
              i2++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return {type: 15, number, flags, unit};
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return {type: 16, number, flags};
            }
            return {type: 17, number, flags};
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }();
        var Parser = function() {
          function Parser2(tokens) {
            this._tokens = tokens;
          }
          Parser2.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser2(tokenizer.read());
          };
          Parser2.parseValue = function(value) {
            return Parser2.create(value).parseComponentValue();
          };
          Parser2.parseValues = function(value) {
            return Parser2.create(value).parseComponentValues();
          };
          Parser2.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser2.prototype.parseComponentValues = function() {
            var values = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values;
              }
              values.push(value);
              values.push();
            }
          };
          Parser2.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser2.prototype.consumeSimpleBlock = function(type) {
            var block = {type, values: []};
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser2.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser2.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser2.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser2;
        }();
        var isDimensionToken = function(token) {
          return token.type === 15;
        };
        var isNumberToken = function(token) {
          return token.type === 17;
        };
        var isIdentToken = function(token) {
          return token.type === 20;
        };
        var isStringToken = function(token) {
          return token.type === 0;
        };
        var isIdentWithValue = function(token, value) {
          return isIdentToken(token) && token.value === value;
        };
        var nonWhiteSpace = function(token) {
          return token.type !== 31;
        };
        var nonFunctionArgSeparator = function(token) {
          return token.type !== 31 && token.type !== 4;
        };
        var parseFunctionArgs = function(tokens) {
          var args = [];
          var arg = [];
          tokens.forEach(function(token) {
            if (token.type === 4) {
              if (arg.length === 0) {
                throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
            }
            if (token.type !== 31) {
              arg.push(token);
            }
          });
          if (arg.length) {
            args.push(arg);
          }
          return args;
        };
        var isEndingTokenFor = function(token, type) {
          if (type === 11 && token.type === 12) {
            return true;
          }
          if (type === 28 && token.type === 29) {
            return true;
          }
          return type === 2 && token.type === 3;
        };
        var isLength = function(token) {
          return token.type === 17 || token.type === 15;
        };
        var isLengthPercentage = function(token) {
          return token.type === 16 || isLength(token);
        };
        var parseLengthPercentageTuple = function(tokens) {
          return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
        };
        var ZERO_LENGTH = {
          type: 17,
          number: 0,
          flags: FLAG_INTEGER
        };
        var FIFTY_PERCENT = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var HUNDRED_PERCENT = {
          type: 16,
          number: 100,
          flags: FLAG_INTEGER
        };
        var getAbsoluteValueForTuple = function(tuple, width, height) {
          var x = tuple[0], y = tuple[1];
          return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== "undefined" ? y : x, height)];
        };
        var getAbsoluteValue = function(token, parent2) {
          if (token.type === 16) {
            return token.number / 100 * parent2;
          }
          if (isDimensionToken(token)) {
            switch (token.unit) {
              case "rem":
              case "em":
                return 16 * token.number;
              case "px":
              default:
                return token.number;
            }
          }
          return token.number;
        };
        var DEG = "deg";
        var GRAD = "grad";
        var RAD = "rad";
        var TURN = "turn";
        var angle = {
          name: "angle",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit) {
                case DEG:
                  return Math.PI * value.number / 180;
                case GRAD:
                  return Math.PI / 200 * value.number;
                case RAD:
                  return value.number;
                case TURN:
                  return Math.PI * 2 * value.number;
              }
            }
            throw new Error("Unsupported angle type");
          }
        };
        var isAngle = function(value) {
          if (value.type === 15) {
            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
            }
          }
          return false;
        };
        var parseNamedSide = function(tokens) {
          var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
            return ident.value;
          }).join(" ");
          switch (sideOrCorner) {
            case "to bottom right":
            case "to right bottom":
            case "left top":
            case "top left":
              return [ZERO_LENGTH, ZERO_LENGTH];
            case "to top":
            case "bottom":
              return deg(0);
            case "to bottom left":
            case "to left bottom":
            case "right top":
            case "top right":
              return [ZERO_LENGTH, HUNDRED_PERCENT];
            case "to right":
            case "left":
              return deg(90);
            case "to top left":
            case "to left top":
            case "right bottom":
            case "bottom right":
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
            case "to bottom":
            case "top":
              return deg(180);
            case "to top right":
            case "to right top":
            case "left bottom":
            case "bottom left":
              return [HUNDRED_PERCENT, ZERO_LENGTH];
            case "to left":
            case "right":
              return deg(270);
          }
          return 0;
        };
        var deg = function(deg2) {
          return Math.PI * deg2 / 180;
        };
        var color$1 = {
          name: "color",
          parse: function(context, value) {
            if (value.type === 18) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
              }
              return colorFunction(context, value.values);
            }
            if (value.type === 5) {
              if (value.value.length === 3) {
                var r = value.value.substring(0, 1);
                var g = value.value.substring(1, 2);
                var b = value.value.substring(2, 3);
                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
              }
              if (value.value.length === 4) {
                var r = value.value.substring(0, 1);
                var g = value.value.substring(1, 2);
                var b = value.value.substring(2, 3);
                var a2 = value.value.substring(3, 4);
                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
              }
              if (value.value.length === 6) {
                var r = value.value.substring(0, 2);
                var g = value.value.substring(2, 4);
                var b = value.value.substring(4, 6);
                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
              }
              if (value.value.length === 8) {
                var r = value.value.substring(0, 2);
                var g = value.value.substring(2, 4);
                var b = value.value.substring(4, 6);
                var a2 = value.value.substring(6, 8);
                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
              }
            }
            if (value.type === 20) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== "undefined") {
                return namedColor;
              }
            }
            return COLORS.TRANSPARENT;
          }
        };
        var isTransparent = function(color2) {
          return (255 & color2) === 0;
        };
        var asString = function(color2) {
          var alpha = 255 & color2;
          var blue = 255 & color2 >> 8;
          var green = 255 & color2 >> 16;
          var red = 255 & color2 >> 24;
          return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
        };
        var pack = function(r, g, b, a2) {
          return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
        };
        var getTokenColorValue = function(token, i2) {
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 16) {
            var max = i2 === 3 ? 1 : 255;
            return i2 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
          }
          return 0;
        };
        var rgb = function(_context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          if (tokens.length === 3) {
            var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
            return pack(r, g, b, 1);
          }
          if (tokens.length === 4) {
            var _b2 = tokens.map(getTokenColorValue), r = _b2[0], g = _b2[1], b = _b2[2], a2 = _b2[3];
            return pack(r, g, b, a2);
          }
          return 0;
        };
        function hue2rgb(t1, t2, hue) {
          if (hue < 0) {
            hue += 1;
          }
          if (hue >= 1) {
            hue -= 1;
          }
          if (hue < 1 / 6) {
            return (t2 - t1) * hue * 6 + t1;
          } else if (hue < 1 / 2) {
            return t2;
          } else if (hue < 2 / 3) {
            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
          } else {
            return t1;
          }
        }
        var hsl = function(context, args) {
          var tokens = args.filter(nonFunctionArgSeparator);
          var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
          var h = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
          var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
          var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
          var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
          if (s === 0) {
            return pack(l * 255, l * 255, l * 255, 1);
          }
          var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var t1 = l * 2 - t2;
          var r = hue2rgb(t1, t2, h + 1 / 3);
          var g = hue2rgb(t1, t2, h);
          var b = hue2rgb(t1, t2, h - 1 / 3);
          return pack(r * 255, g * 255, b * 255, a2);
        };
        var SUPPORTED_COLOR_FUNCTIONS = {
          hsl,
          hsla: hsl,
          rgb,
          rgba: rgb
        };
        var parseColor = function(context, value) {
          return color$1.parse(context, Parser.create(value).parseComponentValue());
        };
        var COLORS = {
          ALICEBLUE: 4042850303,
          ANTIQUEWHITE: 4209760255,
          AQUA: 16777215,
          AQUAMARINE: 2147472639,
          AZURE: 4043309055,
          BEIGE: 4126530815,
          BISQUE: 4293182719,
          BLACK: 255,
          BLANCHEDALMOND: 4293643775,
          BLUE: 65535,
          BLUEVIOLET: 2318131967,
          BROWN: 2771004159,
          BURLYWOOD: 3736635391,
          CADETBLUE: 1604231423,
          CHARTREUSE: 2147418367,
          CHOCOLATE: 3530104575,
          CORAL: 4286533887,
          CORNFLOWERBLUE: 1687547391,
          CORNSILK: 4294499583,
          CRIMSON: 3692313855,
          CYAN: 16777215,
          DARKBLUE: 35839,
          DARKCYAN: 9145343,
          DARKGOLDENROD: 3095837695,
          DARKGRAY: 2846468607,
          DARKGREEN: 6553855,
          DARKGREY: 2846468607,
          DARKKHAKI: 3182914559,
          DARKMAGENTA: 2332068863,
          DARKOLIVEGREEN: 1433087999,
          DARKORANGE: 4287365375,
          DARKORCHID: 2570243327,
          DARKRED: 2332033279,
          DARKSALMON: 3918953215,
          DARKSEAGREEN: 2411499519,
          DARKSLATEBLUE: 1211993087,
          DARKSLATEGRAY: 793726975,
          DARKSLATEGREY: 793726975,
          DARKTURQUOISE: 13554175,
          DARKVIOLET: 2483082239,
          DEEPPINK: 4279538687,
          DEEPSKYBLUE: 12582911,
          DIMGRAY: 1768516095,
          DIMGREY: 1768516095,
          DODGERBLUE: 512819199,
          FIREBRICK: 2988581631,
          FLORALWHITE: 4294635775,
          FORESTGREEN: 579543807,
          FUCHSIA: 4278255615,
          GAINSBORO: 3705462015,
          GHOSTWHITE: 4177068031,
          GOLD: 4292280575,
          GOLDENROD: 3668254975,
          GRAY: 2155905279,
          GREEN: 8388863,
          GREENYELLOW: 2919182335,
          GREY: 2155905279,
          HONEYDEW: 4043305215,
          HOTPINK: 4285117695,
          INDIANRED: 3445382399,
          INDIGO: 1258324735,
          IVORY: 4294963455,
          KHAKI: 4041641215,
          LAVENDER: 3873897215,
          LAVENDERBLUSH: 4293981695,
          LAWNGREEN: 2096890111,
          LEMONCHIFFON: 4294626815,
          LIGHTBLUE: 2916673279,
          LIGHTCORAL: 4034953471,
          LIGHTCYAN: 3774873599,
          LIGHTGOLDENRODYELLOW: 4210742015,
          LIGHTGRAY: 3553874943,
          LIGHTGREEN: 2431553791,
          LIGHTGREY: 3553874943,
          LIGHTPINK: 4290167295,
          LIGHTSALMON: 4288707327,
          LIGHTSEAGREEN: 548580095,
          LIGHTSKYBLUE: 2278488831,
          LIGHTSLATEGRAY: 2005441023,
          LIGHTSLATEGREY: 2005441023,
          LIGHTSTEELBLUE: 2965692159,
          LIGHTYELLOW: 4294959359,
          LIME: 16711935,
          LIMEGREEN: 852308735,
          LINEN: 4210091775,
          MAGENTA: 4278255615,
          MAROON: 2147483903,
          MEDIUMAQUAMARINE: 1724754687,
          MEDIUMBLUE: 52735,
          MEDIUMORCHID: 3126187007,
          MEDIUMPURPLE: 2473647103,
          MEDIUMSEAGREEN: 1018393087,
          MEDIUMSLATEBLUE: 2070474495,
          MEDIUMSPRINGGREEN: 16423679,
          MEDIUMTURQUOISE: 1221709055,
          MEDIUMVIOLETRED: 3340076543,
          MIDNIGHTBLUE: 421097727,
          MINTCREAM: 4127193855,
          MISTYROSE: 4293190143,
          MOCCASIN: 4293178879,
          NAVAJOWHITE: 4292783615,
          NAVY: 33023,
          OLDLACE: 4260751103,
          OLIVE: 2155872511,
          OLIVEDRAB: 1804477439,
          ORANGE: 4289003775,
          ORANGERED: 4282712319,
          ORCHID: 3664828159,
          PALEGOLDENROD: 4008225535,
          PALEGREEN: 2566625535,
          PALETURQUOISE: 2951671551,
          PALEVIOLETRED: 3681588223,
          PAPAYAWHIP: 4293907967,
          PEACHPUFF: 4292524543,
          PERU: 3448061951,
          PINK: 4290825215,
          PLUM: 3718307327,
          POWDERBLUE: 2967529215,
          PURPLE: 2147516671,
          REBECCAPURPLE: 1714657791,
          RED: 4278190335,
          ROSYBROWN: 3163525119,
          ROYALBLUE: 1097458175,
          SADDLEBROWN: 2336560127,
          SALMON: 4202722047,
          SANDYBROWN: 4104413439,
          SEAGREEN: 780883967,
          SEASHELL: 4294307583,
          SIENNA: 2689740287,
          SILVER: 3233857791,
          SKYBLUE: 2278484991,
          SLATEBLUE: 1784335871,
          SLATEGRAY: 1887473919,
          SLATEGREY: 1887473919,
          SNOW: 4294638335,
          SPRINGGREEN: 16744447,
          STEELBLUE: 1182971135,
          TAN: 3535047935,
          TEAL: 8421631,
          THISTLE: 3636451583,
          TOMATO: 4284696575,
          TRANSPARENT: 0,
          TURQUOISE: 1088475391,
          VIOLET: 4001558271,
          WHEAT: 4125012991,
          WHITE: 4294967295,
          WHITESMOKE: 4126537215,
          YELLOW: 4294902015,
          YELLOWGREEN: 2597139199
        };
        var BACKGROUND_CLIP;
        (function(BACKGROUND_CLIP2) {
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["BORDER_BOX"] = 0] = "BORDER_BOX";
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["PADDING_BOX"] = 1] = "PADDING_BOX";
          BACKGROUND_CLIP2[BACKGROUND_CLIP2["CONTENT_BOX"] = 2] = "CONTENT_BOX";
        })(BACKGROUND_CLIP || (BACKGROUND_CLIP = {}));
        var backgroundClip = {
          name: "background-clip",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return BACKGROUND_CLIP.PADDING_BOX;
                  case "content-box":
                    return BACKGROUND_CLIP.CONTENT_BOX;
                }
              }
              return BACKGROUND_CLIP.BORDER_BOX;
            });
          }
        };
        var backgroundColor = {
          name: "background-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var parseColorStop = function(context, args) {
          var color2 = color$1.parse(context, args[0]);
          var stop = args[1];
          return stop && isLengthPercentage(stop) ? {color: color2, stop} : {color: color2, stop: null};
        };
        var processColorStops = function(stops, lineLength) {
          var first = stops[0];
          var last = stops[stops.length - 1];
          if (first.stop === null) {
            first.stop = ZERO_LENGTH;
          }
          if (last.stop === null) {
            last.stop = HUNDRED_PERCENT;
          }
          var processStops = [];
          var previous = 0;
          for (var i2 = 0; i2 < stops.length; i2++) {
            var stop_1 = stops[i2].stop;
            if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                processStops.push(absoluteValue);
              } else {
                processStops.push(previous);
              }
              previous = absoluteValue;
            } else {
              processStops.push(null);
            }
          }
          var gapBegin = null;
          for (var i2 = 0; i2 < processStops.length; i2++) {
            var stop_2 = processStops[i2];
            if (stop_2 === null) {
              if (gapBegin === null) {
                gapBegin = i2;
              }
            } else if (gapBegin !== null) {
              var gapLength = i2 - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g = 1; g <= gapLength; g++) {
                processStops[gapBegin + g - 1] = gapValue * g;
              }
              gapBegin = null;
            }
          }
          return stops.map(function(_a2, i3) {
            var color2 = _a2.color;
            return {color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0)};
          });
        };
        var getAngleFromCorner = function(corner, width, height) {
          var centerX = width / 2;
          var centerY = height / 2;
          var x = getAbsoluteValue(corner[0], width) - centerX;
          var y = centerY - getAbsoluteValue(corner[1], height);
          return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
        };
        var calculateGradientDirection = function(angle2, width, height) {
          var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
          var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          var halfLineLength = lineLength / 2;
          var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
          var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
          return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
        };
        var distance = function(a2, b) {
          return Math.sqrt(a2 * a2 + b * b);
        };
        var findCorner = function(width, height, x, y, closest2) {
          var corners = [
            [0, 0],
            [0, height],
            [width, 0],
            [width, height]
          ];
          return corners.reduce(function(stat, corner) {
            var cx = corner[0], cy = corner[1];
            var d = distance(x - cx, y - cy);
            if (closest2 ? d < stat.optimumDistance : d > stat.optimumDistance) {
              return {
                optimumCorner: corner,
                optimumDistance: d
              };
            }
            return stat;
          }, {
            optimumDistance: closest2 ? Infinity : -Infinity,
            optimumCorner: null
          }).optimumCorner;
        };
        var calculateRadius = function(gradient, x, y, width, height) {
          var rx = 0;
          var ry = 0;
          switch (gradient.size) {
            case CSSRadialExtent.CLOSEST_SIDE:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                rx = Math.min(Math.abs(x), Math.abs(x - width));
                ry = Math.min(Math.abs(y), Math.abs(y - height));
              }
              break;
            case CSSRadialExtent.CLOSEST_CORNER:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                var _a2 = findCorner(width, height, x, y, true), cx = _a2[0], cy = _a2[1];
                rx = distance(cx - x, (cy - y) / c);
                ry = c * rx;
              }
              break;
            case CSSRadialExtent.FARTHEST_SIDE:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                rx = Math.max(Math.abs(x), Math.abs(x - width));
                ry = Math.max(Math.abs(y), Math.abs(y - height));
              }
              break;
            case CSSRadialExtent.FARTHEST_CORNER:
              if (gradient.shape === CSSRadialShape.CIRCLE) {
                rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              } else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                var _b2 = findCorner(width, height, x, y, false), cx = _b2[0], cy = _b2[1];
                rx = distance(cx - x, (cy - y) / c);
                ry = c * rx;
              }
              break;
          }
          if (Array.isArray(gradient.size)) {
            rx = getAbsoluteValue(gradient.size[0], width);
            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
          }
          return [rx, ry];
        };
        var linearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            if (i2 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && firstToken.value === "to") {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = angle.parse(context, firstToken);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {angle: angle$1, stops, type: CSSImageType.LINEAR_GRADIENT};
        };
        var prefixLinearGradient = function(context, tokens) {
          var angle$1 = deg(180);
          var stops = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            if (i2 === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
                angle$1 = parseNamedSide(arg);
                return;
              } else if (isAngle(firstToken)) {
                angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
                return;
              }
            }
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          });
          return {
            angle: angle$1,
            stops,
            type: CSSImageType.LINEAR_GRADIENT
          };
        };
        var webkitGradient = function(context, tokens) {
          var angle2 = deg(180);
          var stops = [];
          var type = CSSImageType.LINEAR_GRADIENT;
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var firstToken = arg[0];
            if (i2 === 0) {
              if (isIdentToken(firstToken) && firstToken.value === "linear") {
                type = CSSImageType.LINEAR_GRADIENT;
                return;
              } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
                type = CSSImageType.RADIAL_GRADIENT;
                return;
              }
            }
            if (firstToken.type === 18) {
              if (firstToken.name === "from") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({stop: ZERO_LENGTH, color: color2});
              } else if (firstToken.name === "to") {
                var color2 = color$1.parse(context, firstToken.values[0]);
                stops.push({stop: HUNDRED_PERCENT, color: color2});
              } else if (firstToken.name === "color-stop") {
                var values = firstToken.values.filter(nonFunctionArgSeparator);
                if (values.length === 2) {
                  var color2 = color$1.parse(context, values[1]);
                  var stop_1 = values[0];
                  if (isNumberToken(stop_1)) {
                    stops.push({
                      stop: {type: 16, number: stop_1.number * 100, flags: stop_1.flags},
                      color: color2
                    });
                  }
                }
              }
            }
          });
          return type === CSSImageType.LINEAR_GRADIENT ? {
            angle: (angle2 + deg(180)) % deg(360),
            stops,
            type
          } : {size, shape, stops, position: position2, type};
        };
        var CLOSEST_SIDE = "closest-side";
        var FARTHEST_SIDE = "farthest-side";
        var CLOSEST_CORNER = "closest-corner";
        var FARTHEST_CORNER = "farthest-corner";
        var CIRCLE = "circle";
        var ELLIPSE = "ellipse";
        var COVER = "cover";
        var CONTAIN = "contain";
        var radialGradient = function(context, tokens) {
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var isColorStop = true;
            if (i2 === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function(acc, token) {
                if (isAtPosition_1) {
                  if (isIdentToken(token)) {
                    switch (token.value) {
                      case "center":
                        position2.push(FIFTY_PERCENT);
                        return acc;
                      case "top":
                      case "left":
                        position2.push(ZERO_LENGTH);
                        return acc;
                      case "right":
                      case "bottom":
                        position2.push(HUNDRED_PERCENT);
                        return acc;
                    }
                  } else if (isLengthPercentage(token) || isLength(token)) {
                    position2.push(token);
                  }
                } else if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = CSSRadialShape.CIRCLE;
                      return false;
                    case ELLIPSE:
                      shape = CSSRadialShape.ELLIPSE;
                      return false;
                    case "at":
                      isAtPosition_1 = true;
                      return false;
                    case CLOSEST_SIDE:
                      size = CSSRadialExtent.CLOSEST_SIDE;
                      return false;
                    case COVER:
                    case FARTHEST_SIDE:
                      size = CSSRadialExtent.FARTHEST_SIDE;
                      return false;
                    case CONTAIN:
                    case CLOSEST_CORNER:
                      size = CSSRadialExtent.CLOSEST_CORNER;
                      return false;
                    case FARTHEST_CORNER:
                      size = CSSRadialExtent.FARTHEST_CORNER;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {size, shape, stops, position: position2, type: CSSImageType.RADIAL_GRADIENT};
        };
        var prefixRadialGradient = function(context, tokens) {
          var shape = CSSRadialShape.CIRCLE;
          var size = CSSRadialExtent.FARTHEST_CORNER;
          var stops = [];
          var position2 = [];
          parseFunctionArgs(tokens).forEach(function(arg, i2) {
            var isColorStop = true;
            if (i2 === 0) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return false;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return false;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return false;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            } else if (i2 === 1) {
              isColorStop = arg.reduce(function(acc, token) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case CIRCLE:
                      shape = CSSRadialShape.CIRCLE;
                      return false;
                    case ELLIPSE:
                      shape = CSSRadialShape.ELLIPSE;
                      return false;
                    case CONTAIN:
                    case CLOSEST_SIDE:
                      size = CSSRadialExtent.CLOSEST_SIDE;
                      return false;
                    case FARTHEST_SIDE:
                      size = CSSRadialExtent.FARTHEST_SIDE;
                      return false;
                    case CLOSEST_CORNER:
                      size = CSSRadialExtent.CLOSEST_CORNER;
                      return false;
                    case COVER:
                    case FARTHEST_CORNER:
                      size = CSSRadialExtent.FARTHEST_CORNER;
                      return false;
                  }
                } else if (isLength(token) || isLengthPercentage(token)) {
                  if (!Array.isArray(size)) {
                    size = [];
                  }
                  size.push(token);
                  return false;
                }
                return acc;
              }, isColorStop);
            }
            if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
            }
          });
          return {size, shape, stops, position: position2, type: CSSImageType.RADIAL_GRADIENT};
        };
        var CSSImageType;
        (function(CSSImageType2) {
          CSSImageType2[CSSImageType2["URL"] = 0] = "URL";
          CSSImageType2[CSSImageType2["LINEAR_GRADIENT"] = 1] = "LINEAR_GRADIENT";
          CSSImageType2[CSSImageType2["RADIAL_GRADIENT"] = 2] = "RADIAL_GRADIENT";
        })(CSSImageType || (CSSImageType = {}));
        var isLinearGradient = function(background) {
          return background.type === CSSImageType.LINEAR_GRADIENT;
        };
        var isRadialGradient = function(background) {
          return background.type === CSSImageType.RADIAL_GRADIENT;
        };
        var CSSRadialShape;
        (function(CSSRadialShape2) {
          CSSRadialShape2[CSSRadialShape2["CIRCLE"] = 0] = "CIRCLE";
          CSSRadialShape2[CSSRadialShape2["ELLIPSE"] = 1] = "ELLIPSE";
        })(CSSRadialShape || (CSSRadialShape = {}));
        var CSSRadialExtent;
        (function(CSSRadialExtent2) {
          CSSRadialExtent2[CSSRadialExtent2["CLOSEST_SIDE"] = 0] = "CLOSEST_SIDE";
          CSSRadialExtent2[CSSRadialExtent2["FARTHEST_SIDE"] = 1] = "FARTHEST_SIDE";
          CSSRadialExtent2[CSSRadialExtent2["CLOSEST_CORNER"] = 2] = "CLOSEST_CORNER";
          CSSRadialExtent2[CSSRadialExtent2["FARTHEST_CORNER"] = 3] = "FARTHEST_CORNER";
        })(CSSRadialExtent || (CSSRadialExtent = {}));
        var image = {
          name: "image",
          parse: function(context, value) {
            if (value.type === 22) {
              var image_1 = {url: value.value, type: CSSImageType.URL};
              context.cache.addImage(value.value);
              return image_1;
            }
            if (value.type === 18) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
              }
              return imageFunction(context, value.values);
            }
            throw new Error("Unsupported image type " + value.type);
          }
        };
        function isSupportedImage(value) {
          return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
        }
        var SUPPORTED_IMAGE_FUNCTIONS = {
          "linear-gradient": linearGradient,
          "-moz-linear-gradient": prefixLinearGradient,
          "-ms-linear-gradient": prefixLinearGradient,
          "-o-linear-gradient": prefixLinearGradient,
          "-webkit-linear-gradient": prefixLinearGradient,
          "radial-gradient": radialGradient,
          "-moz-radial-gradient": prefixRadialGradient,
          "-ms-radial-gradient": prefixRadialGradient,
          "-o-radial-gradient": prefixRadialGradient,
          "-webkit-radial-gradient": prefixRadialGradient,
          "-webkit-gradient": webkitGradient
        };
        var backgroundImage = {
          name: "background-image",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens.filter(function(value) {
              return nonFunctionArgSeparator(value) && isSupportedImage(value);
            }).map(function(value) {
              return image.parse(context, value);
            });
          }
        };
        var backgroundOrigin = {
          name: "background-origin",
          initialValue: "border-box",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.map(function(token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "padding-box":
                    return 1;
                  case "content-box":
                    return 2;
                }
              }
              return 0;
            });
          }
        };
        var backgroundPosition = {
          name: "background-position",
          initialValue: "0% 0%",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isLengthPercentage);
            }).map(parseLengthPercentageTuple);
          }
        };
        var BACKGROUND_REPEAT;
        (function(BACKGROUND_REPEAT2) {
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT"] = 0] = "REPEAT";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["NO_REPEAT"] = 1] = "NO_REPEAT";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT_X"] = 2] = "REPEAT_X";
          BACKGROUND_REPEAT2[BACKGROUND_REPEAT2["REPEAT_Y"] = 3] = "REPEAT_Y";
        })(BACKGROUND_REPEAT || (BACKGROUND_REPEAT = {}));
        var backgroundRepeat = {
          name: "background-repeat",
          initialValue: "repeat",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isIdentToken).map(function(token) {
                return token.value;
              }).join(" ");
            }).map(parseBackgroundRepeat);
          }
        };
        var parseBackgroundRepeat = function(value) {
          switch (value) {
            case "no-repeat":
              return BACKGROUND_REPEAT.NO_REPEAT;
            case "repeat-x":
            case "repeat no-repeat":
              return BACKGROUND_REPEAT.REPEAT_X;
            case "repeat-y":
            case "no-repeat repeat":
              return BACKGROUND_REPEAT.REPEAT_Y;
            case "repeat":
            default:
              return BACKGROUND_REPEAT.REPEAT;
          }
        };
        var BACKGROUND_SIZE;
        (function(BACKGROUND_SIZE2) {
          BACKGROUND_SIZE2["AUTO"] = "auto";
          BACKGROUND_SIZE2["CONTAIN"] = "contain";
          BACKGROUND_SIZE2["COVER"] = "cover";
        })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
        var backgroundSize = {
          name: "background-size",
          initialValue: "0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseFunctionArgs(tokens).map(function(values) {
              return values.filter(isBackgroundSizeInfoToken);
            });
          }
        };
        var isBackgroundSizeInfoToken = function(value) {
          return isIdentToken(value) || isLengthPercentage(value);
        };
        var borderColorForSide = function(side) {
          return {
            name: "border-" + side + "-color",
            initialValue: "transparent",
            prefix: false,
            type: 3,
            format: "color"
          };
        };
        var borderTopColor = borderColorForSide("top");
        var borderRightColor = borderColorForSide("right");
        var borderBottomColor = borderColorForSide("bottom");
        var borderLeftColor = borderColorForSide("left");
        var borderRadiusForSide = function(side) {
          return {
            name: "border-radius-" + side,
            initialValue: "0 0",
            prefix: false,
            type: 1,
            parse: function(_context, tokens) {
              return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
            }
          };
        };
        var borderTopLeftRadius = borderRadiusForSide("top-left");
        var borderTopRightRadius = borderRadiusForSide("top-right");
        var borderBottomRightRadius = borderRadiusForSide("bottom-right");
        var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
        var BORDER_STYLE;
        (function(BORDER_STYLE2) {
          BORDER_STYLE2[BORDER_STYLE2["NONE"] = 0] = "NONE";
          BORDER_STYLE2[BORDER_STYLE2["SOLID"] = 1] = "SOLID";
          BORDER_STYLE2[BORDER_STYLE2["DASHED"] = 2] = "DASHED";
          BORDER_STYLE2[BORDER_STYLE2["DOTTED"] = 3] = "DOTTED";
          BORDER_STYLE2[BORDER_STYLE2["DOUBLE"] = 4] = "DOUBLE";
        })(BORDER_STYLE || (BORDER_STYLE = {}));
        var borderStyleForSide = function(side) {
          return {
            name: "border-" + side + "-style",
            initialValue: "solid",
            prefix: false,
            type: 2,
            parse: function(_context, style) {
              switch (style) {
                case "none":
                  return BORDER_STYLE.NONE;
                case "dashed":
                  return BORDER_STYLE.DASHED;
                case "dotted":
                  return BORDER_STYLE.DOTTED;
                case "double":
                  return BORDER_STYLE.DOUBLE;
              }
              return BORDER_STYLE.SOLID;
            }
          };
        };
        var borderTopStyle = borderStyleForSide("top");
        var borderRightStyle = borderStyleForSide("right");
        var borderBottomStyle = borderStyleForSide("bottom");
        var borderLeftStyle = borderStyleForSide("left");
        var borderWidthForSide = function(side) {
          return {
            name: "border-" + side + "-width",
            initialValue: "0",
            type: 0,
            prefix: false,
            parse: function(_context, token) {
              if (isDimensionToken(token)) {
                return token.number;
              }
              return 0;
            }
          };
        };
        var borderTopWidth = borderWidthForSide("top");
        var borderRightWidth = borderWidthForSide("right");
        var borderBottomWidth = borderWidthForSide("bottom");
        var borderLeftWidth = borderWidthForSide("left");
        var color = {
          name: "color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var direction = {
          name: "direction",
          initialValue: "ltr",
          prefix: false,
          type: 2,
          parse: function(_context, direction2) {
            switch (direction2) {
              case "rtl":
                return 1;
              case "ltr":
              default:
                return 0;
            }
          }
        };
        var display = {
          name: "display",
          initialValue: "inline-block",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).reduce(function(bit, token) {
              return bit | parseDisplayValue(token.value);
            }, 0);
          }
        };
        var parseDisplayValue = function(display2) {
          switch (display2) {
            case "block":
            case "-webkit-box":
              return 2;
            case "inline":
              return 4;
            case "run-in":
              return 8;
            case "flow":
              return 16;
            case "flow-root":
              return 32;
            case "table":
              return 64;
            case "flex":
            case "-webkit-flex":
              return 128;
            case "grid":
            case "-ms-grid":
              return 256;
            case "ruby":
              return 512;
            case "subgrid":
              return 1024;
            case "list-item":
              return 2048;
            case "table-row-group":
              return 4096;
            case "table-header-group":
              return 8192;
            case "table-footer-group":
              return 16384;
            case "table-row":
              return 32768;
            case "table-cell":
              return 65536;
            case "table-column-group":
              return 131072;
            case "table-column":
              return 262144;
            case "table-caption":
              return 524288;
            case "ruby-base":
              return 1048576;
            case "ruby-text":
              return 2097152;
            case "ruby-base-container":
              return 4194304;
            case "ruby-text-container":
              return 8388608;
            case "contents":
              return 16777216;
            case "inline-block":
              return 33554432;
            case "inline-list-item":
              return 67108864;
            case "inline-table":
              return 134217728;
            case "inline-flex":
              return 268435456;
            case "inline-grid":
              return 536870912;
          }
          return 0;
        };
        var FLOAT;
        (function(FLOAT2) {
          FLOAT2[FLOAT2["NONE"] = 0] = "NONE";
          FLOAT2[FLOAT2["LEFT"] = 1] = "LEFT";
          FLOAT2[FLOAT2["RIGHT"] = 2] = "RIGHT";
          FLOAT2[FLOAT2["INLINE_START"] = 3] = "INLINE_START";
          FLOAT2[FLOAT2["INLINE_END"] = 4] = "INLINE_END";
        })(FLOAT || (FLOAT = {}));
        var float = {
          name: "float",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, float2) {
            switch (float2) {
              case "left":
                return FLOAT.LEFT;
              case "right":
                return FLOAT.RIGHT;
              case "inline-start":
                return FLOAT.INLINE_START;
              case "inline-end":
                return FLOAT.INLINE_END;
            }
            return FLOAT.NONE;
          }
        };
        var letterSpacing = {
          name: "letter-spacing",
          initialValue: "0",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "normal") {
              return 0;
            }
            if (token.type === 17) {
              return token.number;
            }
            if (token.type === 15) {
              return token.number;
            }
            return 0;
          }
        };
        var LINE_BREAK;
        (function(LINE_BREAK2) {
          LINE_BREAK2["NORMAL"] = "normal";
          LINE_BREAK2["STRICT"] = "strict";
        })(LINE_BREAK || (LINE_BREAK = {}));
        var lineBreak = {
          name: "line-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, lineBreak2) {
            switch (lineBreak2) {
              case "strict":
                return LINE_BREAK.STRICT;
              case "normal":
              default:
                return LINE_BREAK.NORMAL;
            }
          }
        };
        var lineHeight = {
          name: "line-height",
          initialValue: "normal",
          prefix: false,
          type: 4
        };
        var computeLineHeight = function(token, fontSize2) {
          if (isIdentToken(token) && token.value === "normal") {
            return 1.2 * fontSize2;
          } else if (token.type === 17) {
            return fontSize2 * token.number;
          } else if (isLengthPercentage(token)) {
            return getAbsoluteValue(token, fontSize2);
          }
          return fontSize2;
        };
        var listStyleImage = {
          name: "list-style-image",
          initialValue: "none",
          type: 0,
          prefix: false,
          parse: function(context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            return image.parse(context, token);
          }
        };
        var LIST_STYLE_POSITION;
        (function(LIST_STYLE_POSITION2) {
          LIST_STYLE_POSITION2[LIST_STYLE_POSITION2["INSIDE"] = 0] = "INSIDE";
          LIST_STYLE_POSITION2[LIST_STYLE_POSITION2["OUTSIDE"] = 1] = "OUTSIDE";
        })(LIST_STYLE_POSITION || (LIST_STYLE_POSITION = {}));
        var listStylePosition = {
          name: "list-style-position",
          initialValue: "outside",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "inside":
                return LIST_STYLE_POSITION.INSIDE;
              case "outside":
              default:
                return LIST_STYLE_POSITION.OUTSIDE;
            }
          }
        };
        var LIST_STYLE_TYPE;
        (function(LIST_STYLE_TYPE2) {
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["NONE"] = -1] = "NONE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISC"] = 0] = "DISC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CIRCLE"] = 1] = "CIRCLE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SQUARE"] = 2] = "SQUARE";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DECIMAL"] = 3] = "DECIMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_DECIMAL"] = 4] = "CJK_DECIMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DECIMAL_LEADING_ZERO"] = 5] = "DECIMAL_LEADING_ZERO";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ROMAN"] = 6] = "LOWER_ROMAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ROMAN"] = 7] = "UPPER_ROMAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_GREEK"] = 8] = "LOWER_GREEK";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ALPHA"] = 9] = "LOWER_ALPHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ALPHA"] = 10] = "UPPER_ALPHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ARABIC_INDIC"] = 11] = "ARABIC_INDIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ARMENIAN"] = 12] = "ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["BENGALI"] = 13] = "BENGALI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CAMBODIAN"] = 14] = "CAMBODIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_EARTHLY_BRANCH"] = 15] = "CJK_EARTHLY_BRANCH";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_HEAVENLY_STEM"] = 16] = "CJK_HEAVENLY_STEM";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["CJK_IDEOGRAPHIC"] = 17] = "CJK_IDEOGRAPHIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DEVANAGARI"] = 18] = "DEVANAGARI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ETHIOPIC_NUMERIC"] = 19] = "ETHIOPIC_NUMERIC";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GEORGIAN"] = 20] = "GEORGIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GUJARATI"] = 21] = "GUJARATI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["GURMUKHI"] = 22] = "GURMUKHI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HEBREW"] = 22] = "HEBREW";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HIRAGANA"] = 23] = "HIRAGANA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["HIRAGANA_IROHA"] = 24] = "HIRAGANA_IROHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["JAPANESE_FORMAL"] = 25] = "JAPANESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["JAPANESE_INFORMAL"] = 26] = "JAPANESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KANNADA"] = 27] = "KANNADA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KATAKANA"] = 28] = "KATAKANA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KATAKANA_IROHA"] = 29] = "KATAKANA_IROHA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KHMER"] = 30] = "KHMER";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANGUL_FORMAL"] = 31] = "KOREAN_HANGUL_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANJA_FORMAL"] = 32] = "KOREAN_HANJA_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["KOREAN_HANJA_INFORMAL"] = 33] = "KOREAN_HANJA_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LAO"] = 34] = "LAO";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["LOWER_ARMENIAN"] = 35] = "LOWER_ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MALAYALAM"] = 36] = "MALAYALAM";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MONGOLIAN"] = 37] = "MONGOLIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["MYANMAR"] = 38] = "MYANMAR";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["ORIYA"] = 39] = "ORIYA";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["PERSIAN"] = 40] = "PERSIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SIMP_CHINESE_FORMAL"] = 41] = "SIMP_CHINESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["SIMP_CHINESE_INFORMAL"] = 42] = "SIMP_CHINESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TAMIL"] = 43] = "TAMIL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TELUGU"] = 44] = "TELUGU";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["THAI"] = 45] = "THAI";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TIBETAN"] = 46] = "TIBETAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TRAD_CHINESE_FORMAL"] = 47] = "TRAD_CHINESE_FORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["TRAD_CHINESE_INFORMAL"] = 48] = "TRAD_CHINESE_INFORMAL";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["UPPER_ARMENIAN"] = 49] = "UPPER_ARMENIAN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISCLOSURE_OPEN"] = 50] = "DISCLOSURE_OPEN";
          LIST_STYLE_TYPE2[LIST_STYLE_TYPE2["DISCLOSURE_CLOSED"] = 51] = "DISCLOSURE_CLOSED";
        })(LIST_STYLE_TYPE || (LIST_STYLE_TYPE = {}));
        var listStyleType = {
          name: "list-style-type",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, type) {
            switch (type) {
              case "disc":
                return LIST_STYLE_TYPE.DISC;
              case "circle":
                return LIST_STYLE_TYPE.CIRCLE;
              case "square":
                return LIST_STYLE_TYPE.SQUARE;
              case "decimal":
                return LIST_STYLE_TYPE.DECIMAL;
              case "cjk-decimal":
                return LIST_STYLE_TYPE.CJK_DECIMAL;
              case "decimal-leading-zero":
                return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
              case "lower-roman":
                return LIST_STYLE_TYPE.LOWER_ROMAN;
              case "upper-roman":
                return LIST_STYLE_TYPE.UPPER_ROMAN;
              case "lower-greek":
                return LIST_STYLE_TYPE.LOWER_GREEK;
              case "lower-alpha":
                return LIST_STYLE_TYPE.LOWER_ALPHA;
              case "upper-alpha":
                return LIST_STYLE_TYPE.UPPER_ALPHA;
              case "arabic-indic":
                return LIST_STYLE_TYPE.ARABIC_INDIC;
              case "armenian":
                return LIST_STYLE_TYPE.ARMENIAN;
              case "bengali":
                return LIST_STYLE_TYPE.BENGALI;
              case "cambodian":
                return LIST_STYLE_TYPE.CAMBODIAN;
              case "cjk-earthly-branch":
                return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
              case "cjk-heavenly-stem":
                return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
              case "cjk-ideographic":
                return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
              case "devanagari":
                return LIST_STYLE_TYPE.DEVANAGARI;
              case "ethiopic-numeric":
                return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
              case "georgian":
                return LIST_STYLE_TYPE.GEORGIAN;
              case "gujarati":
                return LIST_STYLE_TYPE.GUJARATI;
              case "gurmukhi":
                return LIST_STYLE_TYPE.GURMUKHI;
              case "hebrew":
                return LIST_STYLE_TYPE.HEBREW;
              case "hiragana":
                return LIST_STYLE_TYPE.HIRAGANA;
              case "hiragana-iroha":
                return LIST_STYLE_TYPE.HIRAGANA_IROHA;
              case "japanese-formal":
                return LIST_STYLE_TYPE.JAPANESE_FORMAL;
              case "japanese-informal":
                return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
              case "kannada":
                return LIST_STYLE_TYPE.KANNADA;
              case "katakana":
                return LIST_STYLE_TYPE.KATAKANA;
              case "katakana-iroha":
                return LIST_STYLE_TYPE.KATAKANA_IROHA;
              case "khmer":
                return LIST_STYLE_TYPE.KHMER;
              case "korean-hangul-formal":
                return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
              case "korean-hanja-formal":
                return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
              case "korean-hanja-informal":
                return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
              case "lao":
                return LIST_STYLE_TYPE.LAO;
              case "lower-armenian":
                return LIST_STYLE_TYPE.LOWER_ARMENIAN;
              case "malayalam":
                return LIST_STYLE_TYPE.MALAYALAM;
              case "mongolian":
                return LIST_STYLE_TYPE.MONGOLIAN;
              case "myanmar":
                return LIST_STYLE_TYPE.MYANMAR;
              case "oriya":
                return LIST_STYLE_TYPE.ORIYA;
              case "persian":
                return LIST_STYLE_TYPE.PERSIAN;
              case "simp-chinese-formal":
                return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
              case "simp-chinese-informal":
                return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
              case "tamil":
                return LIST_STYLE_TYPE.TAMIL;
              case "telugu":
                return LIST_STYLE_TYPE.TELUGU;
              case "thai":
                return LIST_STYLE_TYPE.THAI;
              case "tibetan":
                return LIST_STYLE_TYPE.TIBETAN;
              case "trad-chinese-formal":
                return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
              case "trad-chinese-informal":
                return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
              case "upper-armenian":
                return LIST_STYLE_TYPE.UPPER_ARMENIAN;
              case "disclosure-open":
                return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
              case "disclosure-closed":
                return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
              case "none":
              default:
                return LIST_STYLE_TYPE.NONE;
            }
          }
        };
        var marginForSide = function(side) {
          return {
            name: "margin-" + side,
            initialValue: "0",
            prefix: false,
            type: 4
          };
        };
        var marginTop = marginForSide("top");
        var marginRight = marginForSide("right");
        var marginBottom = marginForSide("bottom");
        var marginLeft = marginForSide("left");
        var OVERFLOW;
        (function(OVERFLOW2) {
          OVERFLOW2[OVERFLOW2["VISIBLE"] = 0] = "VISIBLE";
          OVERFLOW2[OVERFLOW2["HIDDEN"] = 1] = "HIDDEN";
          OVERFLOW2[OVERFLOW2["SCROLL"] = 2] = "SCROLL";
          OVERFLOW2[OVERFLOW2["CLIP"] = 3] = "CLIP";
          OVERFLOW2[OVERFLOW2["AUTO"] = 4] = "AUTO";
        })(OVERFLOW || (OVERFLOW = {}));
        var overflow = {
          name: "overflow",
          initialValue: "visible",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(overflow2) {
              switch (overflow2.value) {
                case "hidden":
                  return OVERFLOW.HIDDEN;
                case "scroll":
                  return OVERFLOW.SCROLL;
                case "clip":
                  return OVERFLOW.CLIP;
                case "auto":
                  return OVERFLOW.AUTO;
                case "visible":
                default:
                  return OVERFLOW.VISIBLE;
              }
            });
          }
        };
        var overflowWrap = {
          name: "overflow-wrap",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "break-word":
                return "break-word";
              case "normal":
              default:
                return "normal";
            }
          }
        };
        var paddingForSide = function(side) {
          return {
            name: "padding-" + side,
            initialValue: "0",
            prefix: false,
            type: 3,
            format: "length-percentage"
          };
        };
        var paddingTop = paddingForSide("top");
        var paddingRight = paddingForSide("right");
        var paddingBottom = paddingForSide("bottom");
        var paddingLeft = paddingForSide("left");
        var TEXT_ALIGN;
        (function(TEXT_ALIGN2) {
          TEXT_ALIGN2[TEXT_ALIGN2["LEFT"] = 0] = "LEFT";
          TEXT_ALIGN2[TEXT_ALIGN2["CENTER"] = 1] = "CENTER";
          TEXT_ALIGN2[TEXT_ALIGN2["RIGHT"] = 2] = "RIGHT";
        })(TEXT_ALIGN || (TEXT_ALIGN = {}));
        var textAlign = {
          name: "text-align",
          initialValue: "left",
          prefix: false,
          type: 2,
          parse: function(_context, textAlign2) {
            switch (textAlign2) {
              case "right":
                return TEXT_ALIGN.RIGHT;
              case "center":
              case "justify":
                return TEXT_ALIGN.CENTER;
              case "left":
              default:
                return TEXT_ALIGN.LEFT;
            }
          }
        };
        var POSITION;
        (function(POSITION2) {
          POSITION2[POSITION2["STATIC"] = 0] = "STATIC";
          POSITION2[POSITION2["RELATIVE"] = 1] = "RELATIVE";
          POSITION2[POSITION2["ABSOLUTE"] = 2] = "ABSOLUTE";
          POSITION2[POSITION2["FIXED"] = 3] = "FIXED";
          POSITION2[POSITION2["STICKY"] = 4] = "STICKY";
        })(POSITION || (POSITION = {}));
        var position = {
          name: "position",
          initialValue: "static",
          prefix: false,
          type: 2,
          parse: function(_context, position2) {
            switch (position2) {
              case "relative":
                return POSITION.RELATIVE;
              case "absolute":
                return POSITION.ABSOLUTE;
              case "fixed":
                return POSITION.FIXED;
              case "sticky":
                return POSITION.STICKY;
            }
            return POSITION.STATIC;
          }
        };
        var textShadow = {
          name: "text-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: COLORS.TRANSPARENT,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH
              };
              var c = 0;
              for (var i2 = 0; i2 < values.length; i2++) {
                var token = values[i2];
                if (isLength(token)) {
                  if (c === 0) {
                    shadow.offsetX = token;
                  } else if (c === 1) {
                    shadow.offsetY = token;
                  } else {
                    shadow.blur = token;
                  }
                  c++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var TEXT_TRANSFORM;
        (function(TEXT_TRANSFORM2) {
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["NONE"] = 0] = "NONE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["LOWERCASE"] = 1] = "LOWERCASE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["UPPERCASE"] = 2] = "UPPERCASE";
          TEXT_TRANSFORM2[TEXT_TRANSFORM2["CAPITALIZE"] = 3] = "CAPITALIZE";
        })(TEXT_TRANSFORM || (TEXT_TRANSFORM = {}));
        var textTransform = {
          name: "text-transform",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, textTransform2) {
            switch (textTransform2) {
              case "uppercase":
                return TEXT_TRANSFORM.UPPERCASE;
              case "lowercase":
                return TEXT_TRANSFORM.LOWERCASE;
              case "capitalize":
                return TEXT_TRANSFORM.CAPITALIZE;
            }
            return TEXT_TRANSFORM.NONE;
          }
        };
        var transform$1 = {
          name: "transform",
          initialValue: "none",
          prefix: true,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20 && token.value === "none") {
              return null;
            }
            if (token.type === 18) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === "undefined") {
                throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
              }
              return transformFunction(token.values);
            }
            return null;
          }
        };
        var matrix = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          return values.length === 6 ? values : null;
        };
        var matrix3d = function(args) {
          var values = args.filter(function(arg) {
            return arg.type === 17;
          }).map(function(arg) {
            return arg.number;
          });
          var a1 = values[0], b1 = values[1];
          values[2];
          values[3];
          var a2 = values[4], b2 = values[5];
          values[6];
          values[7];
          values[8];
          values[9];
          values[10];
          values[11];
          var a4 = values[12], b4 = values[13];
          values[14];
          values[15];
          return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
        };
        var SUPPORTED_TRANSFORM_FUNCTIONS = {
          matrix,
          matrix3d
        };
        var DEFAULT_VALUE = {
          type: 16,
          number: 50,
          flags: FLAG_INTEGER
        };
        var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
        var transformOrigin = {
          name: "transform-origin",
          initialValue: "50% 50%",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            var origins = tokens.filter(isLengthPercentage);
            if (origins.length !== 2) {
              return DEFAULT;
            }
            return [origins[0], origins[1]];
          }
        };
        var VISIBILITY;
        (function(VISIBILITY2) {
          VISIBILITY2[VISIBILITY2["VISIBLE"] = 0] = "VISIBLE";
          VISIBILITY2[VISIBILITY2["HIDDEN"] = 1] = "HIDDEN";
          VISIBILITY2[VISIBILITY2["COLLAPSE"] = 2] = "COLLAPSE";
        })(VISIBILITY || (VISIBILITY = {}));
        var visibility = {
          name: "visible",
          initialValue: "none",
          prefix: false,
          type: 2,
          parse: function(_context, visibility2) {
            switch (visibility2) {
              case "hidden":
                return VISIBILITY.HIDDEN;
              case "collapse":
                return VISIBILITY.COLLAPSE;
              case "visible":
              default:
                return VISIBILITY.VISIBLE;
            }
          }
        };
        var WORD_BREAK;
        (function(WORD_BREAK2) {
          WORD_BREAK2["NORMAL"] = "normal";
          WORD_BREAK2["BREAK_ALL"] = "break-all";
          WORD_BREAK2["KEEP_ALL"] = "keep-all";
        })(WORD_BREAK || (WORD_BREAK = {}));
        var wordBreak = {
          name: "word-break",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, wordBreak2) {
            switch (wordBreak2) {
              case "break-all":
                return WORD_BREAK.BREAK_ALL;
              case "keep-all":
                return WORD_BREAK.KEEP_ALL;
              case "normal":
              default:
                return WORD_BREAK.NORMAL;
            }
          }
        };
        var zIndex = {
          name: "z-index",
          initialValue: "auto",
          prefix: false,
          type: 0,
          parse: function(_context, token) {
            if (token.type === 20) {
              return {auto: true, order: 0};
            }
            if (isNumberToken(token)) {
              return {auto: false, order: token.number};
            }
            throw new Error("Invalid z-index number parsed");
          }
        };
        var time = {
          name: "time",
          parse: function(_context, value) {
            if (value.type === 15) {
              switch (value.unit.toLowerCase()) {
                case "s":
                  return 1e3 * value.number;
                case "ms":
                  return value.number;
              }
            }
            throw new Error("Unsupported time type");
          }
        };
        var opacity = {
          name: "opacity",
          initialValue: "1",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            return 1;
          }
        };
        var textDecorationColor = {
          name: "text-decoration-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
        var textDecorationLine = {
          name: "text-decoration-line",
          initialValue: "none",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              switch (token.value) {
                case "underline":
                  return 1;
                case "overline":
                  return 2;
                case "line-through":
                  return 3;
                case "none":
                  return 4;
              }
              return 0;
            }).filter(function(line) {
              return line !== 0;
            });
          }
        };
        var fontFamily = {
          name: "font-family",
          initialValue: "",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var accumulator = [];
            var results = [];
            tokens.forEach(function(token) {
              switch (token.type) {
                case 20:
                case 0:
                  accumulator.push(token.value);
                  break;
                case 17:
                  accumulator.push(token.number.toString());
                  break;
                case 4:
                  results.push(accumulator.join(" "));
                  accumulator.length = 0;
                  break;
              }
            });
            if (accumulator.length) {
              results.push(accumulator.join(" "));
            }
            return results.map(function(result) {
              return result.indexOf(" ") === -1 ? result : "'" + result + "'";
            });
          }
        };
        var fontSize = {
          name: "font-size",
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length"
        };
        var fontWeight = {
          name: "font-weight",
          initialValue: "normal",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isNumberToken(token)) {
              return token.number;
            }
            if (isIdentToken(token)) {
              switch (token.value) {
                case "bold":
                  return 700;
                case "normal":
                default:
                  return 400;
              }
            }
            return 400;
          }
        };
        var fontVariant = {
          name: "font-variant",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            return tokens.filter(isIdentToken).map(function(token) {
              return token.value;
            });
          }
        };
        var FONT_STYLE;
        (function(FONT_STYLE2) {
          FONT_STYLE2["NORMAL"] = "normal";
          FONT_STYLE2["ITALIC"] = "italic";
          FONT_STYLE2["OBLIQUE"] = "oblique";
        })(FONT_STYLE || (FONT_STYLE = {}));
        var fontStyle = {
          name: "font-style",
          initialValue: "normal",
          prefix: false,
          type: 2,
          parse: function(_context, overflow2) {
            switch (overflow2) {
              case "oblique":
                return FONT_STYLE.OBLIQUE;
              case "italic":
                return FONT_STYLE.ITALIC;
              case "normal":
              default:
                return FONT_STYLE.NORMAL;
            }
          }
        };
        var contains = function(bit, value) {
          return (bit & value) !== 0;
        };
        var content = {
          name: "content",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return [];
            }
            return tokens;
          }
        };
        var counterIncrement = {
          name: "counter-increment",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var increments = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i2 = 0; i2 < filtered.length; i2++) {
              var counter4 = filtered[i2];
              var next = filtered[i2 + 1];
              if (counter4.type === 20) {
                var increment = next && isNumberToken(next) ? next.number : 1;
                increments.push({counter: counter4.value, increment});
              }
            }
            return increments;
          }
        };
        var counterReset = {
          name: "counter-reset",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return [];
            }
            var resets = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i2 = 0; i2 < filtered.length; i2++) {
              var counter4 = filtered[i2];
              var next = filtered[i2 + 1];
              if (isIdentToken(counter4) && counter4.value !== "none") {
                var reset = next && isNumberToken(next) ? next.number : 0;
                resets.push({counter: counter4.value, reset});
              }
            }
            return resets;
          }
        };
        var duration = {
          name: "duration",
          initialValue: "0s",
          prefix: false,
          type: 1,
          parse: function(context, tokens) {
            return tokens.filter(isDimensionToken).map(function(token) {
              return time.parse(context, token);
            });
          }
        };
        var quotes = {
          name: "quotes",
          initialValue: "none",
          prefix: true,
          type: 1,
          parse: function(_context, tokens) {
            if (tokens.length === 0) {
              return null;
            }
            var first = tokens[0];
            if (first.type === 20 && first.value === "none") {
              return null;
            }
            var quotes2 = [];
            var filtered = tokens.filter(isStringToken);
            if (filtered.length % 2 !== 0) {
              return null;
            }
            for (var i2 = 0; i2 < filtered.length; i2 += 2) {
              var open_1 = filtered[i2].value;
              var close_1 = filtered[i2 + 1].value;
              quotes2.push({open: open_1, close: close_1});
            }
            return quotes2;
          }
        };
        var getQuote = function(quotes2, depth, open) {
          if (!quotes2) {
            return "";
          }
          var quote = quotes2[Math.min(depth, quotes2.length - 1)];
          if (!quote) {
            return "";
          }
          return open ? quote.open : quote.close;
        };
        var boxShadow = {
          name: "box-shadow",
          initialValue: "none",
          type: 1,
          prefix: false,
          parse: function(context, tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
              return [];
            }
            return parseFunctionArgs(tokens).map(function(values) {
              var shadow = {
                color: 255,
                offsetX: ZERO_LENGTH,
                offsetY: ZERO_LENGTH,
                blur: ZERO_LENGTH,
                spread: ZERO_LENGTH,
                inset: false
              };
              var c = 0;
              for (var i2 = 0; i2 < values.length; i2++) {
                var token = values[i2];
                if (isIdentWithValue(token, "inset")) {
                  shadow.inset = true;
                } else if (isLength(token)) {
                  if (c === 0) {
                    shadow.offsetX = token;
                  } else if (c === 1) {
                    shadow.offsetY = token;
                  } else if (c === 2) {
                    shadow.blur = token;
                  } else {
                    shadow.spread = token;
                  }
                  c++;
                } else {
                  shadow.color = color$1.parse(context, token);
                }
              }
              return shadow;
            });
          }
        };
        var PAINT_ORDER_LAYER;
        (function(PAINT_ORDER_LAYER2) {
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["FILL"] = 0] = "FILL";
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["STROKE"] = 1] = "STROKE";
          PAINT_ORDER_LAYER2[PAINT_ORDER_LAYER2["MARKERS"] = 2] = "MARKERS";
        })(PAINT_ORDER_LAYER || (PAINT_ORDER_LAYER = {}));
        var paintOrder = {
          name: "paint-order",
          initialValue: "normal",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            var DEFAULT_VALUE2 = [PAINT_ORDER_LAYER.FILL, PAINT_ORDER_LAYER.STROKE, PAINT_ORDER_LAYER.MARKERS];
            var layers = [];
            tokens.filter(isIdentToken).forEach(function(token) {
              switch (token.value) {
                case "stroke":
                  layers.push(PAINT_ORDER_LAYER.STROKE);
                  break;
                case "fill":
                  layers.push(PAINT_ORDER_LAYER.FILL);
                  break;
                case "markers":
                  layers.push(PAINT_ORDER_LAYER.MARKERS);
                  break;
              }
            });
            DEFAULT_VALUE2.forEach(function(value) {
              if (layers.indexOf(value) === -1) {
                layers.push(value);
              }
            });
            return layers;
          }
        };
        var webkitTextStrokeColor = {
          name: "-webkit-text-stroke-color",
          initialValue: "currentcolor",
          prefix: false,
          type: 3,
          format: "color"
        };
        var webkitTextStrokeWidth = {
          name: "-webkit-text-stroke-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
        var CSSParsedDeclaration = function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a2, _b2;
            this.animationDuration = parse(context, duration, declaration.animationDuration);
            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
            this.color = parse(context, color, declaration.color);
            this.direction = parse(context, direction, declaration.direction);
            this.display = parse(context, display, declaration.display);
            this.float = parse(context, float, declaration.cssFloat);
            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse(context, fontSize, declaration.fontSize);
            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse(context, marginTop, declaration.marginTop);
            this.marginRight = parse(context, marginRight, declaration.marginRight);
            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
            this.opacity = parse(context, opacity, declaration.opacity);
            var overflowTuple = parse(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
            this.position = parse(context, position, declaration.position);
            this.textAlign = parse(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
            this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
            this.textShadow = parse(context, textShadow, declaration.textShadow);
            this.textTransform = parse(context, textTransform, declaration.textTransform);
            this.transform = parse(context, transform$1, declaration.transform);
            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== POSITION.STATIC;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== FLOAT.NONE;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
          };
          return CSSParsedDeclaration2;
        }();
        var CSSParsedPseudoDeclaration = function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse(context, content, declaration.content);
            this.quotes = parse(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }();
        var CSSParsedCounterDeclaration = function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }();
        var parse = function(context, descriptor, style) {
          var tokenizer = new Tokenizer();
          var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
          tokenizer.write(value);
          var parser = new Parser(tokenizer.read());
          switch (descriptor.type) {
            case 2:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
            case 0:
              return descriptor.parse(context, parser.parseComponentValue());
            case 1:
              return descriptor.parse(context, parser.parseComponentValues());
            case 4:
              return parser.parseComponentValue();
            case 3:
              switch (descriptor.format) {
                case "angle":
                  return angle.parse(context, parser.parseComponentValue());
                case "color":
                  return color$1.parse(context, parser.parseComponentValue());
                case "image":
                  return image.parse(context, parser.parseComponentValue());
                case "length":
                  var length_1 = parser.parseComponentValue();
                  return isLength(length_1) ? length_1 : ZERO_LENGTH;
                case "length-percentage":
                  var value_1 = parser.parseComponentValue();
                  return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                case "time":
                  return time.parse(context, parser.parseComponentValue());
              }
              break;
          }
        };
        var elementDebuggerAttribute = "data-html2canvas-debug";
        var getElementDebugType = function(element2) {
          var attribute = element2.getAttribute(elementDebuggerAttribute);
          switch (attribute) {
            case "all":
              return 1;
            case "clone":
              return 2;
            case "parse":
              return 3;
            case "render":
              return 4;
            default:
              return 0;
          }
        };
        var isDebugging = function(element2, type) {
          var elementType = getElementDebugType(element2);
          return elementType === 1 || type === elementType;
        };
        var ElementContainer = function() {
          function ElementContainer2(context, element2) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(element2, 3)) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element2, null));
            if (isHTMLElementNode(element2)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element2.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element2.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element2);
            if (isDebugging(element2, 4)) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }();
        var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
        var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
          lookup$1[chars$1.charCodeAt(i$1)] = i$1;
        }
        var decode = function(base642) {
          var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base642[base642.length - 1] === "=") {
            bufferLength--;
            if (base642[base642.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
          var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup$1[base642.charCodeAt(i2)];
            encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
            encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
            encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        };
        var polyUint16Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 2) {
            bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var polyUint32Array = function(buffer) {
          var length = buffer.length;
          var bytes = [];
          for (var i2 = 0; i2 < length; i2 += 4) {
            bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
          }
          return bytes;
        };
        var UTRIE2_SHIFT_2 = 5;
        var UTRIE2_SHIFT_1 = 6 + 5;
        var UTRIE2_INDEX_SHIFT = 2;
        var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
        var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
        var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
        var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
        var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
        var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
        var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
        var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
        var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
        var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
        var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
        var slice16 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint16Array(Array.prototype.slice.call(view, start, end));
        };
        var slice32 = function(view, start, end) {
          if (view.slice) {
            return view.slice(start, end);
          }
          return new Uint32Array(Array.prototype.slice.call(view, start, end));
        };
        var createTrieFromBase64 = function(base642, _byteLength) {
          var buffer = decode(base642);
          var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
          var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
          var headerLength = 24;
          var index = slice16(view16, headerLength / 2, view32[4] / 2);
          var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
          return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
        };
        var Trie = function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }();
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        var Prepend = 1;
        var CR = 2;
        var LF = 3;
        var Control = 4;
        var Extend = 5;
        var SpacingMark = 7;
        var L = 8;
        var V = 9;
        var T = 10;
        var LV = 11;
        var LVT = 12;
        var ZWJ = 13;
        var Extended_Pictographic = 14;
        var RI = 15;
        var toCodePoints = function(str) {
          var codePoints = [];
          var i2 = 0;
          var length = str.length;
          while (i2 < length) {
            var value = str.charCodeAt(i2++);
            if (value >= 55296 && value <= 56319 && i2 < length) {
              var extra = str.charCodeAt(i2++);
              if ((extra & 64512) === 56320) {
                codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                codePoints.push(value);
                i2--;
              }
            } else {
              codePoints.push(value);
            }
          }
          return codePoints;
        };
        var fromCodePoint = function() {
          var codePoints = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
          }
          if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
          }
          var length = codePoints.length;
          if (!length) {
            return "";
          }
          var codeUnits = [];
          var index = -1;
          var result = "";
          while (++index < length) {
            var codePoint = codePoints[index];
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
            }
            if (index + 1 === length || codeUnits.length > 16384) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        var UnicodeTrie = createTrieFromBase64(base64);
        var BREAK_NOT_ALLOWED = "\xD7";
        var BREAK_ALLOWED = "\xF7";
        var codePointToClass = function(codePoint) {
          return UnicodeTrie.get(codePoint);
        };
        var _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
          var prevIndex = index - 2;
          var prev = classTypes[prevIndex];
          var current = classTypes[index - 1];
          var next = classTypes[index];
          if (current === CR && next === LF) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === CR || current === LF || current === Control) {
            return BREAK_ALLOWED;
          }
          if (next === CR || next === LF || next === Control) {
            return BREAK_ALLOWED;
          }
          if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LV || current === V) && (next === V || next === T)) {
            return BREAK_NOT_ALLOWED;
          }
          if ((current === LVT || current === T) && next === T) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === ZWJ || next === Extend) {
            return BREAK_NOT_ALLOWED;
          }
          if (next === SpacingMark) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === Prepend) {
            return BREAK_NOT_ALLOWED;
          }
          if (current === ZWJ && next === Extended_Pictographic) {
            while (prev === Extend) {
              prev = classTypes[--prevIndex];
            }
            if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
            }
          }
          if (current === RI && next === RI) {
            var countRI = 0;
            while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
            }
            if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
            }
          }
          return BREAK_ALLOWED;
        };
        var GraphemeBreaker = function(str) {
          var codePoints = toCodePoints(str);
          var length = codePoints.length;
          var index = 0;
          var lastEnd = 0;
          var classTypes = codePoints.map(codePointToClass);
          return {
            next: function() {
              if (index >= length) {
                return {done: true, value: null};
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {
              }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
                var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
                lastEnd = index;
                return {value, done: false};
              }
              return {done: true, value: null};
            }
          };
        };
        var splitGraphemes = function(str) {
          var breaker = GraphemeBreaker(str);
          var graphemes = [];
          var bk;
          while (!(bk = breaker.next()).done) {
            if (bk.value) {
              graphemes.push(bk.value.slice());
            }
          }
          return graphemes;
        };
        var testRangeBounds = function(document2) {
          var TEST_HEIGHT = 123;
          if (document2.createRange) {
            var range = document2.createRange();
            if (range.getBoundingClientRect) {
              var testElement = document2.createElement("boundtest");
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = "block";
              document2.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document2.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                return true;
              }
            }
          }
          return false;
        };
        var testIOSLineBreak = function(document2) {
          var testElement = document2.createElement("boundtest");
          testElement.style.width = "50px";
          testElement.style.display = "block";
          testElement.style.fontSize = "12px";
          testElement.style.letterSpacing = "0px";
          testElement.style.wordSpacing = "0px";
          document2.body.appendChild(testElement);
          var range = document2.createRange();
          testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
          var node = testElement.firstChild;
          var textList = toCodePoints$1(node.data).map(function(i2) {
            return fromCodePoint$1(i2);
          });
          var offset = 0;
          var prev = {};
          var supports = textList.every(function(text2, i2) {
            range.setStart(node, offset);
            range.setEnd(node, offset + text2.length);
            var rect = range.getBoundingClientRect();
            offset += text2.length;
            var boundAhead = rect.x > prev.x || rect.y > prev.y;
            prev = rect;
            if (i2 === 0) {
              return true;
            }
            return boundAhead;
          });
          document2.body.removeChild(testElement);
          return supports;
        };
        var testCORS = function() {
          return typeof new Image().crossOrigin !== "undefined";
        };
        var testResponseType = function() {
          return typeof new XMLHttpRequest().responseType === "string";
        };
        var testSVG = function(document2) {
          var img = new Image();
          var canvas = document2.createElement("canvas");
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return false;
          }
          img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
          try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
          } catch (e2) {
            return false;
          }
          return true;
        };
        var isGreenPixel = function(data) {
          return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
        };
        var testForeignObject = function(document2) {
          var canvas = document2.createElement("canvas");
          var size = 100;
          canvas.width = size;
          canvas.height = size;
          var ctx = canvas.getContext("2d");
          if (!ctx) {
            return Promise.reject(false);
          }
          ctx.fillStyle = "rgb(0, 255, 0)";
          ctx.fillRect(0, 0, size, size);
          var img = new Image();
          var greenImageSrc = canvas.toDataURL();
          img.src = greenImageSrc;
          var svg = createForeignObjectSVG(size, size, 0, 0, img);
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          return loadSerializedSVG$1(svg).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            var data = ctx.getImageData(0, 0, size, size).data;
            ctx.fillStyle = "red";
            ctx.fillRect(0, 0, size, size);
            var node = document2.createElement("div");
            node.style.backgroundImage = "url(" + greenImageSrc + ")";
            node.style.height = size + "px";
            return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
          }).then(function(img2) {
            ctx.drawImage(img2, 0, 0);
            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
          }).catch(function() {
            return false;
          });
        };
        var createForeignObjectSVG = function(width, height, x, y, node) {
          var xmlns = "http://www.w3.org/2000/svg";
          var svg = document.createElementNS(xmlns, "svg");
          var foreignObject = document.createElementNS(xmlns, "foreignObject");
          svg.setAttributeNS(null, "width", width.toString());
          svg.setAttributeNS(null, "height", height.toString());
          foreignObject.setAttributeNS(null, "width", "100%");
          foreignObject.setAttributeNS(null, "height", "100%");
          foreignObject.setAttributeNS(null, "x", x.toString());
          foreignObject.setAttributeNS(null, "y", y.toString());
          foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
          svg.appendChild(foreignObject);
          foreignObject.appendChild(node);
          return svg;
        };
        var loadSerializedSVG$1 = function(svg) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              return resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
          });
        };
        var FEATURES = {
          get SUPPORT_RANGE_BOUNDS() {
            var value = testRangeBounds(document);
            Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", {value});
            return value;
          },
          get SUPPORT_WORD_BREAKING() {
            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
            Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", {value});
            return value;
          },
          get SUPPORT_SVG_DRAWING() {
            var value = testSVG(document);
            Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", {value});
            return value;
          },
          get SUPPORT_FOREIGNOBJECT_DRAWING() {
            var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
            Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", {value});
            return value;
          },
          get SUPPORT_CORS_IMAGES() {
            var value = testCORS();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", {value});
            return value;
          },
          get SUPPORT_RESPONSE_TYPE() {
            var value = testResponseType();
            Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", {value});
            return value;
          },
          get SUPPORT_CORS_XHR() {
            var value = "withCredentials" in new XMLHttpRequest();
            Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", {value});
            return value;
          }
        };
        var TextBounds = function() {
          function TextBounds2(text2, bounds) {
            this.text = text2;
            this.bounds = bounds;
          }
          return TextBounds2;
        }();
        var parseTextBounds = function(context, value, styles, node) {
          var textList = breakText(value, styles);
          var textBounds = [];
          var offset = 0;
          textList.forEach(function(text2) {
            if (styles.textDecorationLine.length || text2.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                if (!FEATURES.SUPPORT_WORD_BREAKING) {
                  textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, createRange(node, offset, text2.length).getClientRects())));
                } else {
                  textBounds.push(new TextBounds(text2, getRangeBounds(context, node, offset, text2.length)));
                }
              } else {
                var replacementNode = node.splitText(text2.length);
                textBounds.push(new TextBounds(text2, getWrapperBounds(context, node)));
                node = replacementNode;
              }
            } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node = node.splitText(text2.length);
            }
            offset += text2.length;
          });
          return textBounds;
        };
        var getWrapperBounds = function(context, node) {
          var ownerDocument = node.ownerDocument;
          if (ownerDocument) {
            var wrapper = ownerDocument.createElement("html2canvaswrapper");
            wrapper.appendChild(node.cloneNode(true));
            var parentNode = node.parentNode;
            if (parentNode) {
              parentNode.replaceChild(wrapper, node);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
            }
          }
          return Bounds.EMPTY;
        };
        var createRange = function(node, offset, length) {
          var ownerDocument = node.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Node has no owner document");
          }
          var range = ownerDocument.createRange();
          range.setStart(node, offset);
          range.setEnd(node, offset + length);
          return range;
        };
        var getRangeBounds = function(context, node, offset, length) {
          return Bounds.fromClientRect(context, createRange(node, offset, length).getBoundingClientRect());
        };
        var breakText = function(value, styles) {
          return styles.letterSpacing !== 0 ? splitGraphemes(value) : breakWords(value, styles);
        };
        var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
        var breakWords = function(str, styles) {
          var breaker = LineBreaker(str, {
            lineBreak: styles.lineBreak,
            wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
          });
          var words = [];
          var bk;
          var _loop_1 = function() {
            if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = "";
              codePoints.forEach(function(codePoint) {
                if (wordSeparators.indexOf(codePoint) === -1) {
                  word_1 += fromCodePoint$1(codePoint);
                } else {
                  if (word_1.length) {
                    words.push(word_1);
                  }
                  words.push(fromCodePoint$1(codePoint));
                  word_1 = "";
                }
              });
              if (word_1.length) {
                words.push(word_1);
              }
            }
          };
          while (!(bk = breaker.next()).done) {
            _loop_1();
          }
          return words;
        };
        var TextContainer = function() {
          function TextContainer2(context, node, styles) {
            this.text = transform(node.data, styles.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles, node);
          }
          return TextContainer2;
        }();
        var transform = function(text2, transform2) {
          switch (transform2) {
            case TEXT_TRANSFORM.LOWERCASE:
              return text2.toLowerCase();
            case TEXT_TRANSFORM.CAPITALIZE:
              return text2.replace(CAPITALIZE, capitalize);
            case TEXT_TRANSFORM.UPPERCASE:
              return text2.toUpperCase();
            default:
              return text2;
          }
        };
        var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
        var capitalize = function(m, p1, p2) {
          if (m.length > 0) {
            return p1 + p2.toUpperCase();
          }
          return m;
        };
        var ImageElementContainer = function(_super) {
          __extends2(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer);
        var CanvasElementContainer = function(_super) {
          __extends2(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer);
        var SVGElementContainer = function(_super) {
          __extends2(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer);
        var LIElementContainer = function(_super) {
          __extends2(LIElementContainer2, _super);
          function LIElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer);
        var OLElementContainer = function(_super) {
          __extends2(OLElementContainer2, _super);
          function OLElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.start = element2.start;
            _this.reversed = typeof element2.reversed === "boolean" && element2.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer);
        var CHECKBOX_BORDER_RADIUS = [
          {
            type: 15,
            flags: 0,
            unit: "px",
            number: 3
          }
        ];
        var RADIO_BORDER_RADIUS = [
          {
            type: 16,
            flags: 0,
            number: 50
          }
        ];
        var reformatInputBounds = function(bounds) {
          if (bounds.width > bounds.height) {
            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
          } else if (bounds.width < bounds.height) {
            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
          }
          return bounds;
        };
        var getInputValue = function(node) {
          var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
          return value.length === 0 ? node.placeholder || "" : value;
        };
        var CHECKBOX = "checkbox";
        var RADIO = "radio";
        var PASSWORD = "password";
        var INPUT_COLOR = 707406591;
        var InputElementContainer = function(_super) {
          __extends2(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = BORDER_STYLE.SOLID;
              _this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];
              _this.styles.backgroundOrigin = [0];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer);
        var SelectElementContainer = function(_super) {
          __extends2(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            var option = element2.options[element2.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer);
        var TextareaElementContainer = function(_super) {
          __extends2(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element2) {
            var _this = _super.call(this, context, element2) || this;
            _this.value = element2.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer);
        var IFrameElementContainer = function(_super) {
          __extends2(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e2) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer);
        var LIST_OWNERS = ["OL", "UL", "MENU"];
        var parseNodeTree = function(context, node, parent2, root) {
          for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
            nextNode = childNode.nextSibling;
            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent2.textNodes.push(new TextContainer(context, childNode, parent2.styles));
            } else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                childNode.assignedNodes().forEach(function(childNode2) {
                  return parseNodeTree(context, childNode2, parent2, root);
                });
              } else {
                var container = createContainer(context, childNode);
                if (container.styles.isVisible()) {
                  if (createsRealStackingContext(childNode, container, root)) {
                    container.flags |= 4;
                  } else if (createsStackingContext(container.styles)) {
                    container.flags |= 2;
                  }
                  if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                    container.flags |= 8;
                  }
                  parent2.elements.push(container);
                  childNode.slot;
                  if (childNode.shadowRoot) {
                    parseNodeTree(context, childNode.shadowRoot, container, root);
                  } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                    parseNodeTree(context, childNode, container, root);
                  }
                }
              }
            }
          }
        };
        var createContainer = function(context, element2) {
          if (isImageElement(element2)) {
            return new ImageElementContainer(context, element2);
          }
          if (isCanvasElement(element2)) {
            return new CanvasElementContainer(context, element2);
          }
          if (isSVGElement(element2)) {
            return new SVGElementContainer(context, element2);
          }
          if (isLIElement(element2)) {
            return new LIElementContainer(context, element2);
          }
          if (isOLElement(element2)) {
            return new OLElementContainer(context, element2);
          }
          if (isInputElement(element2)) {
            return new InputElementContainer(context, element2);
          }
          if (isSelectElement(element2)) {
            return new SelectElementContainer(context, element2);
          }
          if (isTextareaElement(element2)) {
            return new TextareaElementContainer(context, element2);
          }
          if (isIFrameElement(element2)) {
            return new IFrameElementContainer(context, element2);
          }
          return new ElementContainer(context, element2);
        };
        var parseTree = function(context, element2) {
          var container = createContainer(context, element2);
          container.flags |= 4;
          parseNodeTree(context, element2, container, container);
          return container;
        };
        var createsRealStackingContext = function(node, container, root) {
          return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
        };
        var createsStackingContext = function(styles) {
          return styles.isPositioned() || styles.isFloating();
        };
        var isTextNode = function(node) {
          return node.nodeType === Node.TEXT_NODE;
        };
        var isElementNode = function(node) {
          return node.nodeType === Node.ELEMENT_NODE;
        };
        var isHTMLElementNode = function(node) {
          return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
        };
        var isSVGElementNode = function(element2) {
          return typeof element2.className === "object";
        };
        var isLIElement = function(node) {
          return node.tagName === "LI";
        };
        var isOLElement = function(node) {
          return node.tagName === "OL";
        };
        var isInputElement = function(node) {
          return node.tagName === "INPUT";
        };
        var isHTMLElement = function(node) {
          return node.tagName === "HTML";
        };
        var isSVGElement = function(node) {
          return node.tagName === "svg";
        };
        var isBodyElement = function(node) {
          return node.tagName === "BODY";
        };
        var isCanvasElement = function(node) {
          return node.tagName === "CANVAS";
        };
        var isImageElement = function(node) {
          return node.tagName === "IMG";
        };
        var isIFrameElement = function(node) {
          return node.tagName === "IFRAME";
        };
        var isStyleElement = function(node) {
          return node.tagName === "STYLE";
        };
        var isScriptElement = function(node) {
          return node.tagName === "SCRIPT";
        };
        var isTextareaElement = function(node) {
          return node.tagName === "TEXTAREA";
        };
        var isSelectElement = function(node) {
          return node.tagName === "SELECT";
        };
        var isSlotElement = function(node) {
          return node.tagName === "SLOT";
        };
        var CounterState = function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name) {
            var counter4 = this.counters[name];
            if (counter4 && counter4.length) {
              return counter4[counter4.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name) {
            var counter4 = this.counters[name];
            return counter4 ? counter4 : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter4) {
              return _this.counters[counter4].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter4 = _this.counters[entry.counter];
                if (counter4 && entry.increment !== 0) {
                  canReset = false;
                  if (!counter4.length) {
                    counter4.push(1);
                  }
                  counter4[Math.max(0, counter4.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter4 = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter4) {
                  counter4 = _this.counters[entry.counter] = [];
                }
                counter4.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }();
        var ROMAN_UPPER = {
          integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
          values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
        };
        var ARMENIAN = {
          integers: [
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u0554",
            "\u0553",
            "\u0552",
            "\u0551",
            "\u0550",
            "\u054F",
            "\u054E",
            "\u054D",
            "\u054C",
            "\u054B",
            "\u054A",
            "\u0549",
            "\u0548",
            "\u0547",
            "\u0546",
            "\u0545",
            "\u0544",
            "\u0543",
            "\u0542",
            "\u0541",
            "\u0540",
            "\u053F",
            "\u053E",
            "\u053D",
            "\u053C",
            "\u053B",
            "\u053A",
            "\u0539",
            "\u0538",
            "\u0537",
            "\u0536",
            "\u0535",
            "\u0534",
            "\u0533",
            "\u0532",
            "\u0531"
          ]
        };
        var HEBREW = {
          integers: [
            1e4,
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            19,
            18,
            17,
            16,
            15,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u05D9\u05F3",
            "\u05D8\u05F3",
            "\u05D7\u05F3",
            "\u05D6\u05F3",
            "\u05D5\u05F3",
            "\u05D4\u05F3",
            "\u05D3\u05F3",
            "\u05D2\u05F3",
            "\u05D1\u05F3",
            "\u05D0\u05F3",
            "\u05EA",
            "\u05E9",
            "\u05E8",
            "\u05E7",
            "\u05E6",
            "\u05E4",
            "\u05E2",
            "\u05E1",
            "\u05E0",
            "\u05DE",
            "\u05DC",
            "\u05DB",
            "\u05D9\u05D8",
            "\u05D9\u05D7",
            "\u05D9\u05D6",
            "\u05D8\u05D6",
            "\u05D8\u05D5",
            "\u05D9",
            "\u05D8",
            "\u05D7",
            "\u05D6",
            "\u05D5",
            "\u05D4",
            "\u05D3",
            "\u05D2",
            "\u05D1",
            "\u05D0"
          ]
        };
        var GEORGIAN = {
          integers: [
            1e4,
            9e3,
            8e3,
            7e3,
            6e3,
            5e3,
            4e3,
            3e3,
            2e3,
            1e3,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          values: [
            "\u10F5",
            "\u10F0",
            "\u10EF",
            "\u10F4",
            "\u10EE",
            "\u10ED",
            "\u10EC",
            "\u10EB",
            "\u10EA",
            "\u10E9",
            "\u10E8",
            "\u10E7",
            "\u10E6",
            "\u10E5",
            "\u10E4",
            "\u10F3",
            "\u10E2",
            "\u10E1",
            "\u10E0",
            "\u10DF",
            "\u10DE",
            "\u10DD",
            "\u10F2",
            "\u10DC",
            "\u10DB",
            "\u10DA",
            "\u10D9",
            "\u10D8",
            "\u10D7",
            "\u10F1",
            "\u10D6",
            "\u10D5",
            "\u10D4",
            "\u10D3",
            "\u10D2",
            "\u10D1",
            "\u10D0"
          ]
        };
        var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
          if (value < min || value > max) {
            return createCounterText(value, fallback, suffix.length > 0);
          }
          return symbols.integers.reduce(function(string, integer, index) {
            while (value >= integer) {
              value -= integer;
              string += symbols.values[index];
            }
            return string;
          }, "") + suffix;
        };
        var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
          var string = "";
          do {
            if (!isNumeric) {
              value--;
            }
            string = resolver(value) + string;
            value /= codePointRangeLength;
          } while (value * codePointRangeLength >= codePointRangeLength);
          return string;
        };
        var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
          var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
          return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
            return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) + suffix);
        };
        var createCounterStyleFromSymbols = function(value, symbols, suffix) {
          if (suffix === void 0) {
            suffix = ". ";
          }
          var codePointRangeLength = symbols.length;
          return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
            return symbols[Math.floor(codePoint % codePointRangeLength)];
          }) + suffix;
        };
        var CJK_ZEROS = 1 << 0;
        var CJK_TEN_COEFFICIENTS = 1 << 1;
        var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
        var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
        var createCJKCounter = function(value, numbers6, multipliers, negativeSign, suffix, flags) {
          if (value < -9999 || value > 9999) {
            return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
          }
          var tmp = Math.abs(value);
          var string = suffix;
          if (tmp === 0) {
            return numbers6[0] + string;
          }
          for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
            var coefficient = tmp % 10;
            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
              string = numbers6[coefficient] + string;
            } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
              string = numbers6[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
            } else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
            }
            tmp = Math.floor(tmp / 10);
          }
          return (value < 0 ? negativeSign : "") + string;
        };
        var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
        var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
        var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
        var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
        var createCounterText = function(value, type, appendSuffix) {
          var defaultSuffix = appendSuffix ? ". " : "";
          var cjkSuffix = appendSuffix ? "\u3001" : "";
          var koreanSuffix = appendSuffix ? ", " : "";
          var spaceSuffix = appendSuffix ? " " : "";
          switch (type) {
            case LIST_STYLE_TYPE.DISC:
              return "\u2022" + spaceSuffix;
            case LIST_STYLE_TYPE.CIRCLE:
              return "\u25E6" + spaceSuffix;
            case LIST_STYLE_TYPE.SQUARE:
              return "\u25FE" + spaceSuffix;
            case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
            case LIST_STYLE_TYPE.CJK_DECIMAL:
              return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
            case LIST_STYLE_TYPE.LOWER_ROMAN:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.UPPER_ROMAN:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_GREEK:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ALPHA:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
            case LIST_STYLE_TYPE.UPPER_ALPHA:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
            case LIST_STYLE_TYPE.ARABIC_INDIC:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
            case LIST_STYLE_TYPE.ARMENIAN:
            case LIST_STYLE_TYPE.UPPER_ARMENIAN:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ARMENIAN:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.BENGALI:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
            case LIST_STYLE_TYPE.CAMBODIAN:
            case LIST_STYLE_TYPE.KHMER:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
            case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
              return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
            case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
              return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
            case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
            case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.JAPANESE_INFORMAL:
              return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
            case LIST_STYLE_TYPE.JAPANESE_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
              return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
              return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
            case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
              return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.DEVANAGARI:
              return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
            case LIST_STYLE_TYPE.GEORGIAN:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.GUJARATI:
              return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
            case LIST_STYLE_TYPE.GURMUKHI:
              return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
            case LIST_STYLE_TYPE.HEBREW:
              return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.HIRAGANA:
              return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
            case LIST_STYLE_TYPE.HIRAGANA_IROHA:
              return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
            case LIST_STYLE_TYPE.KANNADA:
              return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
            case LIST_STYLE_TYPE.KATAKANA:
              return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
            case LIST_STYLE_TYPE.KATAKANA_IROHA:
              return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
            case LIST_STYLE_TYPE.LAO:
              return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
            case LIST_STYLE_TYPE.MONGOLIAN:
              return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
            case LIST_STYLE_TYPE.MYANMAR:
              return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
            case LIST_STYLE_TYPE.ORIYA:
              return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
            case LIST_STYLE_TYPE.PERSIAN:
              return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
            case LIST_STYLE_TYPE.TAMIL:
              return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
            case LIST_STYLE_TYPE.TELUGU:
              return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
            case LIST_STYLE_TYPE.THAI:
              return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
            case LIST_STYLE_TYPE.TIBETAN:
              return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
            case LIST_STYLE_TYPE.DECIMAL:
            default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          }
        };
        var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
        var DocumentCloner = function() {
          function DocumentCloner2(context, element2, options) {
            this.context = context;
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element2;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element2.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element2.ownerDocument.documentElement);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a2.sent();
                      _a2.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node) {
            if (isDebugging(node, 2)) {
              debugger;
            }
            if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
            }
            if (isStyleElement(node)) {
              return this.createStyleClone(node);
            }
            var clone2 = node.cloneNode(false);
            if (isImageElement(clone2)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                clone2.src = node.currentSrc;
                clone2.srcset = "";
              }
              if (clone2.loading === "lazy") {
                clone2.loading = "eager";
              }
            }
            return clone2;
          };
          DocumentCloner2.prototype.createStyleClone = function(node) {
            try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css2 + rule.cssText;
                  }
                  return css2;
                }, "");
                var style = node.cloneNode(false);
                style.textContent = css;
                return style;
              }
            } catch (e2) {
              this.context.logger.error("Unable to access cssRules property", e2);
              if (e2.name !== "SecurityError") {
                throw e2;
              }
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a2;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e2) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e2) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.cloneNode = function(node) {
            if (isTextNode(node)) {
              return document.createTextNode(node.data);
            }
            if (!node.ownerDocument) {
              return node.cloneNode(false);
            }
            var window2 = node.ownerDocument.defaultView;
            if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone2 = this.createElementClone(node);
              clone2.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node);
              var styleBefore = window2.getComputedStyle(node, ":before");
              var styleAfter = window2.getComputedStyle(node, ":after");
              if (this.referenceElement === node && isHTMLElementNode(clone2)) {
                this.clonedReferenceElement = clone2;
              }
              if (isBodyElement(clone2)) {
                createPseudoHideStyles(clone2);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone2, styleBefore, PseudoElementType.BEFORE);
              for (var child = node.firstChild; child; child = child.nextSibling) {
                if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
                  if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                    clone2.appendChild(this.cloneNode(child));
                  }
                }
              }
              if (before) {
                clone2.insertBefore(before, clone2.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone2, styleAfter, PseudoElementType.AFTER);
              if (after) {
                clone2.appendChild(after);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) {
                copyCSSStyles(style, clone2);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                this.scrolledElements.push([clone2, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
                clone2.value = node.value;
              }
              return clone2;
            }
            return node.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node, clone2, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document2 = clone2.ownerDocument;
            if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document2.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr2 = token.values.filter(isIdentToken);
                  if (attr2.length) {
                    anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr2[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a2 = token.values.filter(nonFunctionArgSeparator), counter4 = _a2[0], counterStyle = _a2[1];
                  if (counter4 && isIdentToken(counter4)) {
                    var counterState = _this.counters.getCounterValue(counter4.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : LIST_STYLE_TYPE.DECIMAL;
                    anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b2 = token.values.filter(nonFunctionArgSeparator), counter4 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                  if (counter4 && isIdentToken(counter4)) {
                    var counterStates = _this.counters.getCounterValues(counter4.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : LIST_STYLE_TYPE.DECIMAL;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text2 = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document2.createTextNode(text2));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone2)) {
              clone2.className.baseValue += newClassName;
            } else {
              clone2.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }();
        var PseudoElementType;
        (function(PseudoElementType2) {
          PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
          PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
        })(PseudoElementType || (PseudoElementType = {}));
        var createIFrameContainer = function(ownerDocument, bounds) {
          var cloneIframeContainer = ownerDocument.createElement("iframe");
          cloneIframeContainer.className = "html2canvas-container";
          cloneIframeContainer.style.visibility = "hidden";
          cloneIframeContainer.style.position = "fixed";
          cloneIframeContainer.style.left = "-10000px";
          cloneIframeContainer.style.top = "0px";
          cloneIframeContainer.style.border = "0";
          cloneIframeContainer.width = bounds.width.toString();
          cloneIframeContainer.height = bounds.height.toString();
          cloneIframeContainer.scrolling = "no";
          cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
          ownerDocument.body.appendChild(cloneIframeContainer);
          return cloneIframeContainer;
        };
        var imageReady = function(img) {
          return new Promise(function(resolve) {
            if (img.complete) {
              resolve();
              return;
            }
            if (!img.src) {
              resolve();
              return;
            }
            img.onload = resolve;
            img.onerror = resolve;
          });
        };
        var imagesReady = function(document2) {
          return Promise.all([].slice.call(document2.images, 0).map(imageReady));
        };
        var iframeLoader = function(iframe) {
          return new Promise(function(resolve, reject) {
            var cloneWindow = iframe.contentWindow;
            if (!cloneWindow) {
              return reject("No window assigned for iframe");
            }
            var documentClone = cloneWindow.document;
            cloneWindow.onload = iframe.onload = function() {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                  clearInterval(interval);
                  resolve(iframe);
                }
              }, 50);
            };
          });
        };
        var ignoredStyleProperties = [
          "all",
          "d",
          "content"
        ];
        var copyCSSStyles = function(style, target) {
          for (var i2 = style.length - 1; i2 >= 0; i2--) {
            var property = style.item(i2);
            if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
            }
          }
          return target;
        };
        var serializeDoctype = function(doctype) {
          var str = "";
          if (doctype) {
            str += "<!DOCTYPE ";
            if (doctype.name) {
              str += doctype.name;
            }
            if (doctype.internalSubset) {
              str += doctype.internalSubset;
            }
            if (doctype.publicId) {
              str += '"' + doctype.publicId + '"';
            }
            if (doctype.systemId) {
              str += '"' + doctype.systemId + '"';
            }
            str += ">";
          }
          return str;
        };
        var restoreOwnerScroll = function(ownerDocument, x, y) {
          if (ownerDocument && ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x, y);
          }
        };
        var restoreNodeScroll = function(_a2) {
          var element2 = _a2[0], x = _a2[1], y = _a2[2];
          element2.scrollLeft = x;
          element2.scrollTop = y;
        };
        var PSEUDO_BEFORE = ":before";
        var PSEUDO_AFTER = ":after";
        var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
        var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
        var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
        var createPseudoHideStyles = function(body) {
          createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
        };
        var createStyles = function(body, styles) {
          var document2 = body.ownerDocument;
          if (document2) {
            var style = document2.createElement("style");
            style.textContent = styles;
            body.appendChild(style);
          }
        };
        var CacheStorage = function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url2) {
            var link = CacheStorage2._link;
            if (!link) {
              return "about:blank";
            }
            link.href = url2;
            link.href = link.href;
            return link.protocol + link.hostname + link.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }();
        var Cache = function() {
          function Cache2(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache2.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache2.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache2.prototype.loadImage = function(key) {
            return __awaiter(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [2];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve, reject) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve(img);
                      };
                      img.onerror = reject;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a2.sent()];
                }
              });
            });
          };
          Cache2.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache2.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache2.prototype.proxy = function(src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr2 = new XMLHttpRequest();
              xhr2.onload = function() {
                if (xhr2.status === 200) {
                  if (responseType === "text") {
                    resolve(xhr2.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e2) {
                      return reject(e2);
                    }, false);
                    reader_1.readAsDataURL(xhr2.response);
                  }
                } else {
                  reject("Failed to proxy resource " + key + " with status code " + xhr2.status);
                }
              };
              xhr2.onerror = reject;
              var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
              xhr2.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr2 instanceof XMLHttpRequest) {
                xhr2.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr2.timeout = timeout_1;
                xhr2.ontimeout = function() {
                  return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr2.send();
            });
          };
          return Cache2;
        }();
        var INLINE_SVG = /^data:image\/svg\+xml/i;
        var INLINE_BASE64 = /^data:image\/.*;base64,/i;
        var INLINE_IMG = /^data:image\/.*/i;
        var isRenderable = function(src) {
          return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
        };
        var isInlineImage = function(src) {
          return INLINE_IMG.test(src);
        };
        var isInlineBase64Image = function(src) {
          return INLINE_BASE64.test(src);
        };
        var isBlobImage = function(src) {
          return src.substr(0, 4) === "blob";
        };
        var isSVG = function(src) {
          return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
        };
        var PathType;
        (function(PathType2) {
          PathType2[PathType2["VECTOR"] = 0] = "VECTOR";
          PathType2[PathType2["BEZIER_CURVE"] = 1] = "BEZIER_CURVE";
        })(PathType || (PathType = {}));
        var equalPath = function(a2, b) {
          if (a2.length === b.length) {
            return a2.some(function(v, i2) {
              return v === b[i2];
            });
          }
          return false;
        };
        var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
          return path.map(function(point, index) {
            switch (index) {
              case 0:
                return point.add(deltaX, deltaY);
              case 1:
                return point.add(deltaX + deltaW, deltaY);
              case 2:
                return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                return point.add(deltaX, deltaY + deltaH);
            }
            return point;
          });
        };
        var Vector = function() {
          function Vector2(x, y) {
            this.type = PathType.VECTOR;
            this.x = x;
            this.y = y;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }();
        var lerp = function(a2, b, t) {
          return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
        };
        var BezierCurve = function() {
          function BezierCurve2(start, startControl, endControl, end) {
            this.type = PathType.BEZIER_CURVE;
            this.start = start;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
          }
          BezierCurve2.prototype.subdivide = function(t, firstHalf) {
            var ab = lerp(this.start, this.startControl, t);
            var bc = lerp(this.startControl, this.endControl, t);
            var cd = lerp(this.endControl, this.end, t);
            var abbc = lerp(ab, bc, t);
            var bccd = lerp(bc, cd, t);
            var dest = lerp(abbc, bccd, t);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }();
        var isBezierCurve = function(path) {
          return path.type === PathType.BEZIER_CURVE;
        };
        var BoundCurves = function() {
          function BoundCurves2(element2) {
            var styles = element2.styles;
            var bounds = element2.bounds;
            var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
            var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles.borderTopWidth;
            var borderRightWidth2 = styles.borderRightWidth;
            var borderBottomWidth2 = styles.borderBottomWidth;
            var borderLeftWidth2 = styles.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles.paddingTop, element2.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles.paddingRight, element2.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element2.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element2.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }();
        var CORNER;
        (function(CORNER2) {
          CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
          CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
          CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
          CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
        })(CORNER || (CORNER = {}));
        var getCurvePoints = function(x, y, r1, r2, position2) {
          var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
          var ox = r1 * kappa;
          var oy = r2 * kappa;
          var xm = x + r1;
          var ym = y + r2;
          switch (position2) {
            case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
            case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
            case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
            case CORNER.BOTTOM_LEFT:
            default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
          }
        };
        var calculateBorderBoxPath = function(curves) {
          return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
        };
        var calculateContentBoxPath = function(curves) {
          return [
            curves.topLeftContentBox,
            curves.topRightContentBox,
            curves.bottomRightContentBox,
            curves.bottomLeftContentBox
          ];
        };
        var calculatePaddingBoxPath = function(curves) {
          return [
            curves.topLeftPaddingBox,
            curves.topRightPaddingBox,
            curves.bottomRightPaddingBox,
            curves.bottomLeftPaddingBox
          ];
        };
        var TransformEffect = function() {
          function TransformEffect2(offsetX, offsetY, matrix2) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix2;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }();
        var ClipEffect = function() {
          function ClipEffect2(path, target) {
            this.path = path;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }();
        var OpacityEffect = function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }();
        var isTransformEffect = function(effect) {
          return effect.type === 0;
        };
        var isClipEffect = function(effect) {
          return effect.type === 1;
        };
        var isOpacityEffect = function(effect) {
          return effect.type === 2;
        };
        var StackingContext = function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }();
        var ElementPaint = function() {
          function ElementPaint2(container, parent2) {
            this.container = container;
            this.parent = parent2;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix2 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
            }
            if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(borderBox, 2 | 4));
              } else {
                this.effects.push(new ClipEffect(borderBox, 2));
                this.effects.push(new ClipEffect(paddingBox2, 4));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [POSITION.ABSOLUTE, POSITION.FIXED].indexOf(this.container.styles.position) === -1;
            var parent2 = this.parent;
            var effects = this.effects.slice(0);
            while (parent2) {
              var croplessEffects = parent2.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent2.container.styles.position !== POSITION.STATIC || !parent2.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [POSITION.ABSOLUTE, POSITION.FIXED].indexOf(parent2.container.styles.position) === -1;
                if (parent2.container.styles.overflowX !== OVERFLOW.VISIBLE) {
                  var borderBox = calculateBorderBoxPath(parent2.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent2.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent2 = parent2.parent;
            }
            return effects.filter(function(effect) {
              return contains(effect.target, target);
            });
          };
          return ElementPaint2;
        }();
        var parseStackTree = function(parent2, stackingContext, realStackingContext, listItems) {
          parent2.container.elements.forEach(function(child) {
            var treatAsRealStackingContext = contains(child.flags, 4);
            var createsStackingContext2 = contains(child.flags, 2);
            var paintContainer = new ElementPaint(child, parent2);
            if (contains(child.styles.display, 2048)) {
              listItems.push(paintContainer);
            }
            var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
            if (treatAsRealStackingContext || createsStackingContext2) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                var order_1 = child.styles.zIndex.order;
                if (order_1 < 0) {
                  var index_1 = 0;
                  parentStack.negativeZIndex.some(function(current, i2) {
                    if (order_1 > current.element.container.styles.zIndex.order) {
                      index_1 = i2;
                      return false;
                    } else if (index_1 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.negativeZIndex.splice(index_1, 0, stack);
                } else if (order_1 > 0) {
                  var index_2 = 0;
                  parentStack.positiveZIndex.some(function(current, i2) {
                    if (order_1 >= current.element.container.styles.zIndex.order) {
                      index_2 = i2 + 1;
                      return false;
                    } else if (index_2 > 0) {
                      return true;
                    }
                    return false;
                  });
                  parentStack.positiveZIndex.splice(index_2, 0, stack);
                } else {
                  parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                }
              } else {
                if (child.styles.isFloating()) {
                  parentStack.nonPositionedFloats.push(stack);
                } else {
                  parentStack.nonPositionedInlineLevel.push(stack);
                }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
            } else {
              if (child.styles.isInlineLevel()) {
                stackingContext.inlineLevel.push(paintContainer);
              } else {
                stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
            }
            if (contains(child.flags, 8)) {
              processListItems(child, listOwnerItems);
            }
          });
        };
        var processListItems = function(owner, elements) {
          var numbering = owner instanceof OLElementContainer ? owner.start : 1;
          var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
          for (var i2 = 0; i2 < elements.length; i2++) {
            var item = elements[i2];
            if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
              numbering = item.container.value;
            }
            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
            numbering += reversed ? -1 : 1;
          }
        };
        var parseStackingContexts = function(container) {
          var paintContainer = new ElementPaint(container, null);
          var root = new StackingContext(paintContainer);
          var listItems = [];
          parseStackTree(paintContainer, root, root, listItems);
          processListItems(paintContainer.container, listItems);
          return root;
        };
        var parsePathForBorder = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderDoubleOuter = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
          }
        };
        var parsePathForBorderDoubleInner = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
            case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
            case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
          }
        };
        var parsePathForBorderStroke = function(curves, borderSide) {
          switch (borderSide) {
            case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
            case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
            case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
            case 3:
            default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
          }
        };
        var createStrokePathFromCurves = function(outer1, outer2) {
          var path = [];
          if (isBezierCurve(outer1)) {
            path.push(outer1.subdivide(0.5, false));
          } else {
            path.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path.push(outer2.subdivide(0.5, true));
          } else {
            path.push(outer2);
          }
          return path;
        };
        var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
          var path = [];
          if (isBezierCurve(outer1)) {
            path.push(outer1.subdivide(0.5, false));
          } else {
            path.push(outer1);
          }
          if (isBezierCurve(outer2)) {
            path.push(outer2.subdivide(0.5, true));
          } else {
            path.push(outer2);
          }
          if (isBezierCurve(inner2)) {
            path.push(inner2.subdivide(0.5, true).reverse());
          } else {
            path.push(inner2);
          }
          if (isBezierCurve(inner1)) {
            path.push(inner1.subdivide(0.5, false).reverse());
          } else {
            path.push(inner1);
          }
          return path;
        };
        var paddingBox = function(element2) {
          var bounds = element2.bounds;
          var styles = element2.styles;
          return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
        };
        var contentBox = function(element2) {
          var styles = element2.styles;
          var bounds = element2.bounds;
          var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
          var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
          var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
          var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
          return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
        };
        var calculateBackgroundPositioningArea = function(backgroundOrigin2, element2) {
          if (backgroundOrigin2 === 0) {
            return element2.bounds;
          }
          if (backgroundOrigin2 === 2) {
            return contentBox(element2);
          }
          return paddingBox(element2);
        };
        var calculateBackgroundPaintingArea = function(backgroundClip2, element2) {
          if (backgroundClip2 === BACKGROUND_CLIP.BORDER_BOX) {
            return element2.bounds;
          }
          if (backgroundClip2 === BACKGROUND_CLIP.CONTENT_BOX) {
            return contentBox(element2);
          }
          return paddingBox(element2);
        };
        var calculateBackgroundRendering = function(container, index, intrinsicSize) {
          var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
          var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
          var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
          var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
          var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
          var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
          var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
          var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
          return [path, offsetX, offsetY, sizeWidth, sizeHeight];
        };
        var isAuto = function(token) {
          return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
        };
        var hasIntrinsicValue = function(value) {
          return typeof value === "number";
        };
        var calculateBackgroundSize = function(size, _a2, bounds) {
          var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
          var first = size[0], second = size[1];
          if (!first) {
            return [0, 0];
          }
          if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
          }
          var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
          if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
            if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
            }
            return [bounds.width, bounds.height];
          }
          var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
          var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
          var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
          if (isAuto(first) && (!second || isAuto(second))) {
            if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
            }
            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
            }
            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
            }
            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
            return [width_2, height_2];
          }
          if (hasIntrinsicProportion) {
            var width_3 = 0;
            var height_3 = 0;
            if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
            } else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
            }
            if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
            } else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
            }
            return [width_3, height_3];
          }
          var width = null;
          var height = null;
          if (isLengthPercentage(first)) {
            width = getAbsoluteValue(first, bounds.width);
          } else if (second && isLengthPercentage(second)) {
            height = getAbsoluteValue(second, bounds.height);
          }
          if (width !== null && (!second || isAuto(second))) {
            height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
          }
          if (height !== null && isAuto(first)) {
            width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
          }
          if (width !== null && height !== null) {
            return [width, height];
          }
          throw new Error("Unable to calculate background-size for element");
        };
        var getBackgroundValueForIndex = function(values, index) {
          var value = values[index];
          if (typeof value === "undefined") {
            return values[0];
          }
          return value;
        };
        var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
          var x = _a2[0], y = _a2[1];
          var width = _b2[0], height = _b2[1];
          switch (repeat) {
            case BACKGROUND_REPEAT.REPEAT_X:
              return [
                new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
              ];
            case BACKGROUND_REPEAT.REPEAT_Y:
              return [
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
              ];
            case BACKGROUND_REPEAT.NO_REPEAT:
              return [
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
              ];
            default:
              return [
                new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
              ];
          }
        };
        var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        var SAMPLE_TEXT = "Hidden Text";
        var FontMetrics = function() {
          function FontMetrics2(document2) {
            this._data = {};
            this._document = document2;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return {baseline, middle};
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }();
        var Renderer = function() {
          function Renderer2(context, options) {
            this.context = context;
            this.options = options;
          }
          return Renderer2;
        }();
        var MASK_OFFSET = 1e4;
        var CanvasRenderer = function(_super) {
          __extends2(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this._activeEffects = [];
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var styles;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    styles = stack.element.container.styles;
                    if (!styles.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (contains(paint.container.flags, 16)) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a2.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a2.sent();
                    _a2.label = 3;
                  case 3:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
            } else {
              var letters = splitGraphemes(text2.text);
              letters.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text2.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles) {
            var fontVariant2 = styles.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = styles.fontFamily.join(", ");
            var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
            return [
              [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
              var _this = this;
              return __generator(this, function(_c) {
                _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                this.ctx.font = font;
                this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                paintOrder2 = styles.paintOrder;
                text2.textBounds.forEach(function(text3) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case PAINT_ORDER_LAYER.FILL:
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text3.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                          styles.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case PAINT_ORDER_LAYER.STROKE:
                        if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x, textBounds, img, image2, url2, fontFamily2, bounds;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(4));
                    container = paint.container;
                    curves = paint.curves;
                    styles = container.styles;
                    _i = 0, _a2 = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    child = _a2[_i];
                    return [4, this.renderTextNode(child, styles)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x = 0;
                      switch (container.styles.textAlign) {
                        case TEXT_ALIGN.CENTER:
                          x += bounds.width / 2;
                          break;
                        case TEXT_ALIGN.RIGHT:
                          x += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains(container.styles.display, 2048))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === CSSImageType.URL))
                      return [3, 18];
                    image2 = void 0;
                    url2 = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url2)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url2);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {
                      fontFamily2 = this.createFontStyle(styles)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains(stack.element.container.flags, 16)) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a2 = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a2.length))
                      return [3, 5];
                    child = _a2[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b2 = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b2 < _c.length))
                      return [3, 10];
                    child = _c[_b2];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b2++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e.length))
                      return [3, 14];
                    child = _e[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point, index) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                _this.ctx.moveTo(start.x, start.y);
              } else {
                _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
            var _a2;
            if (image2.width === width && image2.height === height) {
              return image2;
            }
            var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width);
            canvas.height = Math.max(1, height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter(this, void 0, void 0, function() {
              var index, _loop_1, this_1, _i, _a2, backgroundImage2;
              return __generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    index = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url2, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                      return __generator(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === CSSImageType.URL))
                              return [3, 5];
                            image2 = void 0;
                            url2 = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url2)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url2);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                              this_1.renderRepeat(path, pattern, x, y);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                              _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width;
                              canvas.height = height;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width, height);
                              if (width > 0 && height > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path, pattern, x, y);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index, [
                                null,
                                null,
                                null
                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                              position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x = getAbsoluteValue(position2[0], width);
                              y = getAbsoluteValue(position2[position2.length - 1], height);
                              _g = calculateRadius(backgroundImage3, x, y, width, height), rx = _g[0], ry = _g[1];
                              if (rx > 0 && ry > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx !== ry) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f2 = ry / rx;
                                  invF = 1 / f2;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index--;
                            return [2];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                    _b2.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    backgroundImage2 = _a2[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b2.sent();
                    _b2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!(width < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a2.sent();
                    return [2];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(2));
                    styles = paint.container.styles;
                    hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                    borders = [
                      {style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth},
                      {style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth},
                      {style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth},
                      {style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth}
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent(styles.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a2.sent();
                    this.ctx.restore();
                    styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a2.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a2.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== BORDER_STYLE.NONE && !isTransparent(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === BORDER_STYLE.DASHED))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DASHED)];
                  case 4:
                    _a2.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === BORDER_STYLE.DOTTED))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, BORDER_STYLE.DOTTED)];
                  case 6:
                    _a2.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === BORDER_STYLE.DOUBLE))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a2.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a2.sent();
                    _a2.label = 11;
                  case 11:
                    side++;
                    _a2.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [2];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
            return __awaiter(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function(_a2) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === BORDER_STYLE.DASHED) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length = Math.abs(startX - endX);
                } else {
                  length = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === BORDER_STYLE.DOTTED) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width < 3 ? width * 3 : width * 2;
                spaceLength = width < 3 ? width * 2 : width;
                if (style === BORDER_STYLE.DOTTED) {
                  dashLength = width;
                  spaceLength = width;
                }
                useLineDash = true;
                if (length <= dashLength * 2) {
                  useLineDash = false;
                } else if (length <= dashLength * 2 + spaceLength) {
                  multiplier = length / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === BORDER_STYLE.DOTTED) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === BORDER_STYLE.DOTTED) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width;
                } else {
                  this.ctx.lineWidth = width * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === BORDER_STYLE.DASHED) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [2];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var stack;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element2);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a2.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer);
        var isTextInputElement = function(container) {
          if (container instanceof TextareaElementContainer) {
            return true;
          } else if (container instanceof SelectElementContainer) {
            return true;
          } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
            return true;
          }
          return false;
        };
        var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
          switch (clip) {
            case BACKGROUND_CLIP.BORDER_BOX:
              return calculateBorderBoxPath(curves);
            case BACKGROUND_CLIP.CONTENT_BOX:
              return calculateContentBoxPath(curves);
            case BACKGROUND_CLIP.PADDING_BOX:
            default:
              return calculatePaddingBoxPath(curves);
          }
        };
        var canvasTextAlign = function(textAlign2) {
          switch (textAlign2) {
            case TEXT_ALIGN.CENTER:
              return "center";
            case TEXT_ALIGN.RIGHT:
              return "right";
            case TEXT_ALIGN.LEFT:
            default:
              return "left";
          }
        };
        var ForeignObjectRenderer = function(_super) {
          __extends2(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options) {
            var _this = _super.call(this, context, options) || this;
            _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options;
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options.x, -options.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element2) {
            return __awaiter(this, void 0, void 0, function() {
              var svg, img;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element2);
                    return [4, loadSerializedSVG(svg)];
                  case 1:
                    img = _a2.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer);
        var loadSerializedSVG = function(svg) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
          });
        };
        var Logger = function() {
          function Logger2(_a2) {
            var id = _a2.id, enabled = _a2.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }();
        var Context = function() {
          function Context2(options, windowBounds) {
            var _a2;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({id: this.instanceName, enabled: options.logging});
            this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
          }
          Context2.instanceCount = 1;
          return Context2;
        }();
        var html2canvas2 = function(element2, options) {
          if (options === void 0) {
            options = {};
          }
          return renderElement(element2, options);
        };
        if (typeof window !== "undefined") {
          CacheStorage.setContext(window);
        }
        var renderElement = function(element2, opts) {
          return __awaiter(void 0, void 0, void 0, function() {
            var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
            var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
            return __generator(this, function(_u) {
              switch (_u.label) {
                case 0:
                  if (!element2 || typeof element2 !== "object") {
                    return [2, Promise.reject("Invalid element provided as first argument")];
                  }
                  ownerDocument = element2.ownerDocument;
                  if (!ownerDocument) {
                    throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                    throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                    allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                    imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                    proxy: opts.proxy,
                    useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign2({logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache}, resourceOptions);
                  windowOptions = {
                    windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                    windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                    scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                    scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                    allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                    onclone: opts.onclone,
                    ignoreElements: opts.ignoreElements,
                    inlineImages: foreignObjectRendering,
                    copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element2, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                    return [2, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
                case 1:
                  container = _u.sent();
                  _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
                  backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                    canvas: opts.canvas,
                    backgroundColor: backgroundColor2,
                    scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                    x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                    y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                    width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                    height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering)
                    return [3, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4, renderer.render(clonedElement)];
                case 2:
                  canvas = _u.sent();
                  return [3, 5];
                case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor2 === root.styles.backgroundColor) {
                    root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4, renderer.render(root)];
                case 4:
                  canvas = _u.sent();
                  _u.label = 5;
                case 5:
                  if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                    if (!DocumentCloner.destroy(container)) {
                      context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                    }
                  }
                  context.logger.debug("Finished rendering");
                  return [2, canvas];
              }
            });
          });
        };
        var parseBackgroundColor = function(context, element2, backgroundColorOverride) {
          var ownerDocument = element2.ownerDocument;
          var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
          var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
          return element2 === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
        };
        return html2canvas2;
      });
    })(html2canvas$1);
    var html2canvas = html2canvas$1.exports;
    var {Object: Object_1$2} = globals;
    var file$a = "src/components/Modal/ReportProblem.svelte";
    function create_if_block_1$1(ctx) {
      let img;
      let img_src_value;
      const block = {
        c: function create2() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = ctx[0].screenshot))
            attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "screenshot");
          attr_dev(img, "class", "mx-auto aspect-w-16 aspect-h-9 max-h-32");
          add_location(img, file$a, 24, 4, 611);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0].screenshot)) {
            attr_dev(img, "src", img_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(img);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(24:3) {#if $problemReport.screenshot}",
        ctx
      });
      return block;
    }
    function create_default_slot_3$2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Bidschirmfoto aufnehmen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$2.name,
        type: "slot",
        source: "(41:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_2$2(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_3$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 512) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$2.name,
        type: "slot",
        source: '(32:2) <Button    class=\\"whitespace-nowrap w-full\\"    on:click={() => {     html2canvas($svelteRenderParent).then((canvas) => {      const base64image = canvas.toDataURL(\\"image/png\\");      $problemReport.screenshot = base64image;     });    }}   >',
        ctx
      });
      return block;
    }
    function create_default_slot_1$2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Melden");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$2.name,
        type: "slot",
        source: "(96:3) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot$23(ctx) {
      let label;
      let current;
      label = new CommonLabel({
        props: {
          $$slots: {default: [create_default_slot_1$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 512) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$23.name,
        type: "slot",
        source: '(74:2) <Button    variant=\\"raised\\"    class=\\"w-full\\"    on:click={async () => {     let { data } = await axios.post(      `${backendURL}/api/problem`,      $problemReport     );     $problemReport = { problem_text: \\"\\" };     if (data) {      $notification = {       text: \\"Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.\\",       bg: \\"var(--mdc-theme-callout);\\",       color: \\"var(--mdc-theme-on-primary);\\",      };      setTimeout(() => {       $notification = undefined;      }, 5000);      $modal = {};     }    }}   >',
        ctx
      });
      return block;
    }
    function create_if_block$4(ctx) {
      let div;
      const block = {
        c: function create2() {
          div = element("div");
          div.textContent = `${ctx[4]}`;
          attr_dev(div, "class", "absolute top-60 w-full bg-green-500 text-white rounded");
          add_location(div, file$a, 100, 1, 2333);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(100:0) {#if response}",
        ctx
      });
      return block;
    }
    function create_fragment$b(ctx) {
      let section;
      let div1;
      let div0;
      let t0;
      let button0;
      let t1;
      let from;
      let textarea;
      let t2;
      let button1;
      let t3;
      let if_block1_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block0 = ctx[0].screenshot && create_if_block_1$1(ctx);
      button0 = new Button_1({
        props: {
          class: "whitespace-nowrap w-full",
          $$slots: {default: [create_default_slot_2$2]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button0.$on("click", ctx[5]);
      button1 = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot$23]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      button1.$on("click", ctx[7]);
      let if_block1 = ctx[4] && create_if_block$4(ctx);
      const block = {
        c: function create2() {
          section = element("section");
          div1 = element("div");
          div0 = element("div");
          if (if_block0)
            if_block0.c();
          t0 = space();
          create_component(button0.$$.fragment);
          t1 = space();
          from = element("from");
          textarea = element("textarea");
          t2 = space();
          create_component(button1.$$.fragment);
          t3 = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          attr_dev(div0, "class", "flex justify-center items-center");
          add_location(div0, file$a, 22, 2, 525);
          attr_dev(div1, "class", "flex justify-center items-center flex-col");
          add_location(div1, file$a, 21, 1, 467);
          attr_dev(textarea, "class", "w-full");
          attr_dev(textarea, "name", "problem_text");
          attr_dev(textarea, "rows", "4");
          attr_dev(textarea, "cols", "50");
          attr_dev(textarea, "placeholder", "Problem Beschreibung");
          add_location(textarea, file$a, 64, 2, 1576);
          attr_dev(from, "class", "flex flex-col gap-4 w-full");
          add_location(from, file$a, 43, 1, 1059);
          attr_dev(section, "class", "w-full grid grid-cols-1 md:grid-cols-2 justify-center items-center gap-8 p-4");
          add_location(section, file$a, 18, 0, 369);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div1);
          append_dev(div1, div0);
          if (if_block0)
            if_block0.m(div0, null);
          append_dev(div1, t0);
          mount_component(button0, div1, null);
          append_dev(section, t1);
          append_dev(section, from);
          append_dev(from, textarea);
          set_input_value(textarea, ctx[0].problem_text);
          append_dev(from, t2);
          mount_component(button1, from, null);
          insert_dev(target, t3, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(textarea, "input", ctx[6]),
              listen_dev(from, "submit", prevent_default(ctx[8]), false, true, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (ctx2[0].screenshot) {
            if (if_block0) {
              if_block0.p(ctx2, dirty);
            } else {
              if_block0 = create_if_block_1$1(ctx2);
              if_block0.c();
              if_block0.m(div0, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          const button0_changes = {};
          if (dirty & 512) {
            button0_changes.$$scope = {dirty, ctx: ctx2};
          }
          button0.$set(button0_changes);
          if (dirty & 1) {
            set_input_value(textarea, ctx2[0].problem_text);
          }
          const button1_changes = {};
          if (dirty & 512) {
            button1_changes.$$scope = {dirty, ctx: ctx2};
          }
          button1.$set(button1_changes);
          if (ctx2[4])
            if_block1.p(ctx2, dirty);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          if (if_block0)
            if_block0.d();
          destroy_component(button0);
          destroy_component(button1);
          if (detaching)
            detach_dev(t3);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$9($$self, $$props, $$invalidate) {
      let $problemReport;
      let $svelteRenderParent;
      let $notification;
      let $modal;
      validate_store(problemReport, "problemReport");
      component_subscribe($$self, problemReport, ($$value) => $$invalidate(0, $problemReport = $$value));
      validate_store(svelteRenderParent, "svelteRenderParent");
      component_subscribe($$self, svelteRenderParent, ($$value) => $$invalidate(1, $svelteRenderParent = $$value));
      validate_store(notification, "notification");
      component_subscribe($$self, notification, ($$value) => $$invalidate(2, $notification = $$value));
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(3, $modal = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("ReportProblem", slots, []);
      let response;
      const writable_props = [];
      Object_1$2.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<ReportProblem> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        html2canvas($svelteRenderParent).then((canvas) => {
          const base64image = canvas.toDataURL("image/png");
          set_store_value(problemReport, $problemReport.screenshot = base64image, $problemReport);
        });
      };
      function textarea_input_handler() {
        $problemReport.problem_text = this.value;
        problemReport.set($problemReport);
      }
      const click_handler_1 = async () => {
        let {data} = await axios.post(`${backendURL}/api/problem`, $problemReport);
        set_store_value(problemReport, $problemReport = {problem_text: ""}, $problemReport);
        if (data) {
          set_store_value(notification, $notification = {
            text: "Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
          }, 5e3);
          set_store_value(modal, $modal = {}, $modal);
        }
      };
      const submit_handler = async () => {
        let {data} = await axios.post(`${backendURL}/api/problem/`, $problemReport);
        set_store_value(problemReport, $problemReport = {problem_text: ""}, $problemReport);
        if (data) {
          set_store_value(notification, $notification = {
            text: "Dankesch\xF6n, wir k\xFCmmern uns schnellstm\xF6glich darum.",
            bg: "var(--mdc-theme-callout);",
            color: "var(--mdc-theme-on-primary);"
          }, $notification);
          setTimeout(() => {
            set_store_value(notification, $notification = void 0, $notification);
          }, 5e3);
          set_store_value(modal, $modal = {}, $modal);
        }
      };
      $$self.$capture_state = () => ({
        Button: Button_1,
        Label: CommonLabel,
        html2canvas,
        backendURL,
        problemReport,
        modal,
        notification,
        svelteRenderParent,
        axios,
        response,
        $problemReport,
        $svelteRenderParent,
        $notification,
        $modal
      });
      $$self.$inject_state = ($$props2) => {
        if ("response" in $$props2)
          $$invalidate(4, response = $$props2.response);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          if (!$problemReport || Object.keys($problemReport).length == 0) {
            set_store_value(problemReport, $problemReport.problem_text = "", $problemReport);
          }
        }
      };
      return [
        $problemReport,
        $svelteRenderParent,
        $notification,
        $modal,
        response,
        click_handler,
        textarea_input_handler,
        click_handler_1,
        submit_handler
      ];
    }
    var ReportProblem = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$9, create_fragment$b, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ReportProblem",
          options,
          id: create_fragment$b.name
        });
      }
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses6 = {
      FIXED_CLASS: "mdc-top-app-bar--fixed",
      FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
      SHORT_CLASS: "mdc-top-app-bar--short",
      SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
      SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
    };
    var numbers$12 = {
      DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
      MAX_TOP_APP_BAR_HEIGHT: 128
    };
    var strings$12 = {
      ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
      NAVIGATION_EVENT: "MDCTopAppBar:nav",
      NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
      ROOT_SELECTOR: ".mdc-top-app-bar",
      TITLE_SELECTOR: ".mdc-top-app-bar__title"
    };
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCTopAppBarBaseFoundation = function(_super) {
      __extends(MDCTopAppBarBaseFoundation2, _super);
      function MDCTopAppBarBaseFoundation2(adapter) {
        return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation2.defaultAdapter), adapter)) || this;
      }
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "strings", {
        get: function() {
          return strings$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "cssClasses", {
        get: function() {
          return cssClasses6;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "numbers", {
        get: function() {
          return numbers$12;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MDCTopAppBarBaseFoundation2, "defaultAdapter", {
        get: function() {
          return {
            addClass: function() {
              return void 0;
            },
            removeClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            setStyle: function() {
              return void 0;
            },
            getTopAppBarHeight: function() {
              return 0;
            },
            notifyNavigationIconClicked: function() {
              return void 0;
            },
            getViewportScrollY: function() {
              return 0;
            },
            getTotalActionItems: function() {
              return 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTopAppBarBaseFoundation2.prototype.handleTargetScroll = function() {
      };
      MDCTopAppBarBaseFoundation2.prototype.handleWindowResize = function() {
      };
      MDCTopAppBarBaseFoundation2.prototype.handleNavigationClick = function() {
        this.adapter.notifyNavigationIconClicked();
      };
      return MDCTopAppBarBaseFoundation2;
    }(MDCFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var INITIAL_VALUE = 0;
    var MDCTopAppBarFoundation = function(_super) {
      __extends(MDCTopAppBarFoundation2, _super);
      function MDCTopAppBarFoundation2(adapter) {
        var _this = _super.call(this, adapter) || this;
        _this.wasDocked_ = true;
        _this.isDockedShowing_ = true;
        _this.currentAppBarOffsetTop_ = 0;
        _this.isCurrentlyBeingResized_ = false;
        _this.resizeThrottleId_ = INITIAL_VALUE;
        _this.resizeDebounceId_ = INITIAL_VALUE;
        _this.lastScrollPosition_ = _this.adapter.getViewportScrollY();
        _this.topAppBarHeight_ = _this.adapter.getTopAppBarHeight();
        return _this;
      }
      MDCTopAppBarFoundation2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.adapter.setStyle("top", "");
      };
      MDCTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
        var diff = currentScrollPosition - this.lastScrollPosition_;
        this.lastScrollPosition_ = currentScrollPosition;
        if (!this.isCurrentlyBeingResized_) {
          this.currentAppBarOffsetTop_ -= diff;
          if (this.currentAppBarOffsetTop_ > 0) {
            this.currentAppBarOffsetTop_ = 0;
          } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
            this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
          }
          this.moveTopAppBar_();
        }
      };
      MDCTopAppBarFoundation2.prototype.handleWindowResize = function() {
        var _this = this;
        if (!this.resizeThrottleId_) {
          this.resizeThrottleId_ = setTimeout(function() {
            _this.resizeThrottleId_ = INITIAL_VALUE;
            _this.throttledResizeHandler_();
          }, numbers$12.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }
        this.isCurrentlyBeingResized_ = true;
        if (this.resizeDebounceId_) {
          clearTimeout(this.resizeDebounceId_);
        }
        this.resizeDebounceId_ = setTimeout(function() {
          _this.handleTargetScroll();
          _this.isCurrentlyBeingResized_ = false;
          _this.resizeDebounceId_ = INITIAL_VALUE;
        }, numbers$12.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
      };
      MDCTopAppBarFoundation2.prototype.checkForUpdate_ = function() {
        var offscreenBoundaryTop = -this.topAppBarHeight_;
        var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
        var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
        var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
        if (partiallyShowing) {
          this.wasDocked_ = false;
        } else {
          if (!this.wasDocked_) {
            this.wasDocked_ = true;
            return true;
          } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
            this.isDockedShowing_ = hasAnyPixelsOnscreen;
            return true;
          }
        }
        return partiallyShowing;
      };
      MDCTopAppBarFoundation2.prototype.moveTopAppBar_ = function() {
        if (this.checkForUpdate_()) {
          var offset = this.currentAppBarOffsetTop_;
          if (Math.abs(offset) >= this.topAppBarHeight_) {
            offset = -numbers$12.MAX_TOP_APP_BAR_HEIGHT;
          }
          this.adapter.setStyle("top", offset + "px");
        }
      };
      MDCTopAppBarFoundation2.prototype.throttledResizeHandler_ = function() {
        var currentHeight = this.adapter.getTopAppBarHeight();
        if (this.topAppBarHeight_ !== currentHeight) {
          this.wasDocked_ = false;
          this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
          this.topAppBarHeight_ = currentHeight;
        }
        this.handleTargetScroll();
      };
      return MDCTopAppBarFoundation2;
    }(MDCTopAppBarBaseFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFixedTopAppBarFoundation = function(_super) {
      __extends(MDCFixedTopAppBarFoundation2, _super);
      function MDCFixedTopAppBarFoundation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.wasScrolled_ = false;
        return _this;
      }
      MDCFixedTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        var currentScroll = this.adapter.getViewportScrollY();
        if (currentScroll <= 0) {
          if (this.wasScrolled_) {
            this.adapter.removeClass(cssClasses6.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = false;
          }
        } else {
          if (!this.wasScrolled_) {
            this.adapter.addClass(cssClasses6.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = true;
          }
        }
      };
      return MDCFixedTopAppBarFoundation2;
    }(MDCTopAppBarFoundation);
    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCShortTopAppBarFoundation = function(_super) {
      __extends(MDCShortTopAppBarFoundation2, _super);
      function MDCShortTopAppBarFoundation2(adapter) {
        var _this = _super.call(this, adapter) || this;
        _this.isCollapsed_ = false;
        _this.isAlwaysCollapsed_ = false;
        return _this;
      }
      Object.defineProperty(MDCShortTopAppBarFoundation2.prototype, "isCollapsed", {
        get: function() {
          return this.isCollapsed_;
        },
        enumerable: false,
        configurable: true
      });
      MDCShortTopAppBarFoundation2.prototype.init = function() {
        _super.prototype.init.call(this);
        if (this.adapter.getTotalActionItems() > 0) {
          this.adapter.addClass(cssClasses6.SHORT_HAS_ACTION_ITEM_CLASS);
        }
        this.setAlwaysCollapsed(this.adapter.hasClass(cssClasses6.SHORT_COLLAPSED_CLASS));
      };
      MDCShortTopAppBarFoundation2.prototype.setAlwaysCollapsed = function(value) {
        this.isAlwaysCollapsed_ = !!value;
        if (this.isAlwaysCollapsed_) {
          this.collapse_();
        } else {
          this.maybeCollapseBar_();
        }
      };
      MDCShortTopAppBarFoundation2.prototype.getAlwaysCollapsed = function() {
        return this.isAlwaysCollapsed_;
      };
      MDCShortTopAppBarFoundation2.prototype.handleTargetScroll = function() {
        this.maybeCollapseBar_();
      };
      MDCShortTopAppBarFoundation2.prototype.maybeCollapseBar_ = function() {
        if (this.isAlwaysCollapsed_) {
          return;
        }
        var currentScroll = this.adapter.getViewportScrollY();
        if (currentScroll <= 0) {
          if (this.isCollapsed_) {
            this.uncollapse_();
          }
        } else {
          if (!this.isCollapsed_) {
            this.collapse_();
          }
        }
      };
      MDCShortTopAppBarFoundation2.prototype.uncollapse_ = function() {
        this.adapter.removeClass(cssClasses6.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = false;
      };
      MDCShortTopAppBarFoundation2.prototype.collapse_ = function() {
        this.adapter.addClass(cssClasses6.SHORT_COLLAPSED_CLASS);
        this.isCollapsed_ = true;
      };
      return MDCShortTopAppBarFoundation2;
    }(MDCTopAppBarBaseFoundation);
    var {window: window_1} = globals;
    var file$9 = "node_modules/@smui/top-app-bar/TopAppBar.svelte";
    function create_fragment$a(ctx) {
      let header;
      let header_class_value;
      let header_style_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[22].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
      let header_levels = [
        {
          class: header_class_value = classMap({
            [ctx[2]]: true,
            "mdc-top-app-bar": true,
            "mdc-top-app-bar--short": ctx[4] === "short",
            "mdc-top-app-bar--short-collapsed": ctx[0],
            "mdc-top-app-bar--fixed": ctx[4] === "fixed",
            "smui-top-app-bar--static": ctx[4] === "static",
            "smui-top-app-bar--color-secondary": ctx[5] === "secondary",
            "mdc-top-app-bar--prominent": ctx[6],
            "mdc-top-app-bar--dense": ctx[7],
            ...ctx[11]
          })
        },
        {
          style: header_style_value = Object.entries(ctx[12]).map(func$13).concat([ctx[3]]).join(" ")
        },
        ctx[15]
      ];
      let header_data = {};
      for (let i = 0; i < header_levels.length; i += 1) {
        header_data = assign(header_data, header_levels[i]);
      }
      const block = {
        c: function create2() {
          header = element("header");
          if (default_slot)
            default_slot.c();
          set_attributes(header, header_data);
          add_location(header, file$9, 9, 0, 208);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, header, anchor);
          if (default_slot) {
            default_slot.m(header, null);
          }
          ctx[25](header);
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(window_1, "resize", ctx[23], false, false, false),
              listen_dev(window_1, "scroll", ctx[24], false, false, false),
              action_destroyer(useActions_action = useActions.call(null, header, ctx[1])),
              action_destroyer(ctx[13].call(null, header)),
              listen_dev(header, "SMUI:top-app-bar:icon-button:nav", ctx[26], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[0] & 2097152)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
            }
          }
          set_attributes(header, header_data = get_spread_update(header_levels, [
            (!current || dirty[0] & 2293 && header_class_value !== (header_class_value = classMap({
              [ctx2[2]]: true,
              "mdc-top-app-bar": true,
              "mdc-top-app-bar--short": ctx2[4] === "short",
              "mdc-top-app-bar--short-collapsed": ctx2[0],
              "mdc-top-app-bar--fixed": ctx2[4] === "fixed",
              "smui-top-app-bar--static": ctx2[4] === "static",
              "smui-top-app-bar--color-secondary": ctx2[5] === "secondary",
              "mdc-top-app-bar--prominent": ctx2[6],
              "mdc-top-app-bar--dense": ctx2[7],
              ...ctx2[11]
            }))) && {class: header_class_value},
            (!current || dirty[0] & 4104 && header_style_value !== (header_style_value = Object.entries(ctx2[12]).map(func$13).concat([ctx2[3]]).join(" "))) && {style: header_style_value},
            dirty[0] & 32768 && ctx2[15]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
            useActions_action.update.call(null, ctx2[1]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(header);
          if (default_slot)
            default_slot.d(detaching);
          ctx[25](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var func$13 = ([name, value]) => `${name}: ${value};`;
    function instance_1$13($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "variant",
        "color",
        "collapsed",
        "prominent",
        "dense",
        "scrollTarget",
        "getPropStore",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("TopAppBar", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let uninitializedValue = () => {
      };
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {variant = "standard"} = $$props;
      let {color = "primary"} = $$props;
      let {collapsed = uninitializedValue} = $$props;
      let {prominent = false} = $$props;
      let {dense = false} = $$props;
      let {scrollTarget = null} = $$props;
      let element2;
      let instance9;
      let internalClasses = {};
      let internalStyles = {};
      const alwaysCollapsed = collapsed !== uninitializedValue && !!collapsed;
      if (collapsed === uninitializedValue) {
        collapsed = false;
      }
      let propStoreSet;
      let propStore = readable({variant, prominent, dense}, (set) => {
        $$invalidate(18, propStoreSet = set);
      });
      let oldScrollTarget = null;
      let oldVariant = variant;
      onMount(() => {
        $$invalidate(9, instance9 = getInstance());
        instance9.init();
        return () => {
          instance9.destroy();
        };
      });
      function getInstance() {
        const Foundation = {
          static: MDCTopAppBarBaseFoundation,
          short: MDCShortTopAppBarFoundation,
          fixed: MDCFixedTopAppBarFoundation
        }[variant] || MDCTopAppBarFoundation;
        return new Foundation({
          hasClass,
          addClass,
          removeClass,
          setStyle: addStyle,
          getTopAppBarHeight: () => element2.clientHeight,
          notifyNavigationIconClicked: () => dispatch$12(element2, "MDCTopAppBar:nav"),
          getViewportScrollY: () => scrollTarget == null ? window.pageYOffset : scrollTarget.scrollTop,
          getTotalActionItems: () => element2.querySelectorAll(".mdc-top-app-bar__action-item").length
        });
      }
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(11, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name, value) {
        if (internalStyles[name] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name];
            $$invalidate(12, internalStyles), $$invalidate(20, oldVariant), $$invalidate(4, variant), $$invalidate(9, instance9);
          } else {
            $$invalidate(12, internalStyles[name] = value, internalStyles);
          }
        }
      }
      function handleTargetScroll() {
        if (instance9) {
          instance9.handleTargetScroll();
          if (variant === "short") {
            $$invalidate(0, collapsed = instance9.isCollapsed);
          }
        }
      }
      function getPropStore() {
        return propStore;
      }
      function getElement() {
        return element2;
      }
      const resize_handler = () => variant !== "short" && variant !== "fixed" && instance9 && instance9.handleWindowResize();
      const scroll_handler = () => scrollTarget == null && handleTargetScroll();
      function header_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(10, element2);
        });
      }
      const SMUI_top_app_bar_icon_button_nav_handler = () => instance9 && instance9.handleNavigationClick();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(2, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(3, style = $$new_props.style);
        if ("variant" in $$new_props)
          $$invalidate(4, variant = $$new_props.variant);
        if ("color" in $$new_props)
          $$invalidate(5, color = $$new_props.color);
        if ("collapsed" in $$new_props)
          $$invalidate(0, collapsed = $$new_props.collapsed);
        if ("prominent" in $$new_props)
          $$invalidate(6, prominent = $$new_props.prominent);
        if ("dense" in $$new_props)
          $$invalidate(7, dense = $$new_props.dense);
        if ("scrollTarget" in $$new_props)
          $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
        if ("$$scope" in $$new_props)
          $$invalidate(21, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        MDCTopAppBarBaseFoundation,
        MDCTopAppBarFoundation,
        MDCFixedTopAppBarFoundation,
        MDCShortTopAppBarFoundation,
        onMount,
        get_current_component,
        readable,
        forwardEventsBuilder,
        classMap,
        useActions,
        dispatch: dispatch$12,
        forwardEvents,
        uninitializedValue,
        use: use2,
        className,
        style,
        variant,
        color,
        collapsed,
        prominent,
        dense,
        scrollTarget,
        element: element2,
        instance: instance9,
        internalClasses,
        internalStyles,
        alwaysCollapsed,
        propStoreSet,
        propStore,
        oldScrollTarget,
        oldVariant,
        getInstance,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        handleTargetScroll,
        getPropStore,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("uninitializedValue" in $$props)
          uninitializedValue = $$new_props.uninitializedValue;
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(2, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(3, style = $$new_props.style);
        if ("variant" in $$props)
          $$invalidate(4, variant = $$new_props.variant);
        if ("color" in $$props)
          $$invalidate(5, color = $$new_props.color);
        if ("collapsed" in $$props)
          $$invalidate(0, collapsed = $$new_props.collapsed);
        if ("prominent" in $$props)
          $$invalidate(6, prominent = $$new_props.prominent);
        if ("dense" in $$props)
          $$invalidate(7, dense = $$new_props.dense);
        if ("scrollTarget" in $$props)
          $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
        if ("element" in $$props)
          $$invalidate(10, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(9, instance9 = $$new_props.instance);
        if ("internalClasses" in $$props)
          $$invalidate(11, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(12, internalStyles = $$new_props.internalStyles);
        if ("propStoreSet" in $$props)
          $$invalidate(18, propStoreSet = $$new_props.propStoreSet);
        if ("propStore" in $$props)
          propStore = $$new_props.propStore;
        if ("oldScrollTarget" in $$props)
          $$invalidate(19, oldScrollTarget = $$new_props.oldScrollTarget);
        if ("oldVariant" in $$props)
          $$invalidate(20, oldVariant = $$new_props.oldVariant);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 262352) {
          if (propStoreSet) {
            propStoreSet({variant, prominent, dense});
          }
        }
        if ($$self.$$.dirty[0] & 1049104) {
          if (oldVariant !== variant && instance9) {
            $$invalidate(20, oldVariant = variant);
            instance9.destroy();
            $$invalidate(11, internalClasses = {});
            $$invalidate(12, internalStyles = {});
            $$invalidate(9, instance9 = getInstance());
            instance9.init();
          }
        }
        if ($$self.$$.dirty[0] & 528) {
          if (instance9 && variant === "short") {
            instance9.setAlwaysCollapsed(alwaysCollapsed);
          }
        }
        if ($$self.$$.dirty[0] & 524544) {
          if (oldScrollTarget !== scrollTarget) {
            if (oldScrollTarget) {
              oldScrollTarget.removeEventListener("scroll", handleTargetScroll);
            }
            if (scrollTarget) {
              scrollTarget.addEventListener("scroll", handleTargetScroll);
            }
            $$invalidate(19, oldScrollTarget = scrollTarget);
          }
        }
      };
      return [
        collapsed,
        use2,
        className,
        style,
        variant,
        color,
        prominent,
        dense,
        scrollTarget,
        instance9,
        element2,
        internalClasses,
        internalStyles,
        forwardEvents,
        handleTargetScroll,
        $$restProps,
        getPropStore,
        getElement,
        propStoreSet,
        oldScrollTarget,
        oldVariant,
        $$scope,
        slots,
        resize_handler,
        scroll_handler,
        header_binding,
        SMUI_top_app_bar_icon_button_nav_handler
      ];
    }
    var TopAppBar = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_1$13, create_fragment$a, safe_not_equal, {
          use: 1,
          class: 2,
          style: 3,
          variant: 4,
          color: 5,
          collapsed: 0,
          prominent: 6,
          dense: 7,
          scrollTarget: 8,
          getPropStore: 16,
          getElement: 17
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "TopAppBar",
          options,
          id: create_fragment$a.name
        });
      }
      get use() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get variant() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set variant(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get color() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set color(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get collapsed() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set collapsed(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get prominent() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set prominent(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get dense() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set dense(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get scrollTarget() {
        throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set scrollTarget(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getPropStore() {
        return this.$$.ctx[16];
      }
      set getPropStore(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[17];
      }
      set getElement(value) {
        throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var Row = classAdderBuilder({
      class: "mdc-top-app-bar__row",
      component: Div
    });
    var file$8 = "node_modules/@smui/top-app-bar/Section.svelte";
    function create_fragment$9(ctx) {
      let section;
      let section_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[9].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
      let section_levels = [
        {
          class: section_class_value = classMap({
            [ctx[1]]: true,
            "mdc-top-app-bar__section": true,
            "mdc-top-app-bar__section--align-start": ctx[2] === "start",
            "mdc-top-app-bar__section--align-end": ctx[2] === "end"
          })
        },
        ctx[3] ? {role: "toolbar"} : {},
        ctx[6]
      ];
      let section_data = {};
      for (let i = 0; i < section_levels.length; i += 1) {
        section_data = assign(section_data, section_levels[i]);
      }
      const block = {
        c: function create2() {
          section = element("section");
          if (default_slot)
            default_slot.c();
          set_attributes(section, section_data);
          add_location(section, file$8, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          if (default_slot) {
            default_slot.m(section, null);
          }
          ctx[10](section);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, section, ctx[0])),
              action_destroyer(ctx[5].call(null, section))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 256)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
            }
          }
          set_attributes(section, section_data = get_spread_update(section_levels, [
            (!current || dirty & 6 && section_class_value !== (section_class_value = classMap({
              [ctx2[1]]: true,
              "mdc-top-app-bar__section": true,
              "mdc-top-app-bar__section--align-start": ctx2[2] === "start",
              "mdc-top-app-bar__section--align-end": ctx2[2] === "end"
            }))) && {class: section_class_value},
            dirty & 8 && (ctx2[3] ? {role: "toolbar"} : {}),
            dirty & 64 && ctx2[6]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(section);
          if (default_slot)
            default_slot.d(detaching);
          ctx[10](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$8($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "align", "toolbar", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Section", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {align = "start"} = $$props;
      let {toolbar = false} = $$props;
      let element2;
      setContext("SMUI:icon-button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
      setContext("SMUI:button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
      function getElement() {
        return element2;
      }
      function section_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(4, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("align" in $$new_props)
          $$invalidate(2, align = $$new_props.align);
        if ("toolbar" in $$new_props)
          $$invalidate(3, toolbar = $$new_props.toolbar);
        if ("$$scope" in $$new_props)
          $$invalidate(8, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        setContext,
        get_current_component,
        forwardEventsBuilder,
        classMap,
        useActions,
        forwardEvents,
        use: use2,
        className,
        align,
        toolbar,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("align" in $$props)
          $$invalidate(2, align = $$new_props.align);
        if ("toolbar" in $$props)
          $$invalidate(3, toolbar = $$new_props.toolbar);
        if ("element" in $$props)
          $$invalidate(4, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        use2,
        className,
        align,
        toolbar,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        section_binding
      ];
    }
    var Section = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$8, create_fragment$9, safe_not_equal, {
          use: 0,
          class: 1,
          align: 2,
          toolbar: 3,
          getElement: 7
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Section",
          options,
          id: create_fragment$9.name
        });
      }
      get use() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get align() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set align(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get toolbar() {
        throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set toolbar(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[7];
      }
      set getElement(value) {
        throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var Title2 = classAdderBuilder({
      class: "mdc-top-app-bar__title",
      component: Span
    });
    var file$7 = "node_modules/@smui/common/Img.svelte";
    function create_fragment$82(ctx) {
      let img;
      let useActions_action;
      let t;
      let current;
      let mounted;
      let dispose;
      let img_levels = [{alt: ctx[0]}, ctx[4]];
      let img_data = {};
      for (let i = 0; i < img_levels.length; i += 1) {
        img_data = assign(img_data, img_levels[i]);
      }
      const default_slot_template = ctx[7].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
      const block = {
        c: function create2() {
          img = element("img");
          t = space();
          if (default_slot)
            default_slot.c();
          set_attributes(img, img_data);
          add_location(img, file$7, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          ctx[8](img);
          insert_dev(target, t, anchor);
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions.call(null, img, ctx[1])),
              action_destroyer(ctx[3].call(null, img))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          set_attributes(img, img_data = get_spread_update(img_levels, [
            (!current || dirty & 1) && {alt: ctx2[0]},
            dirty & 16 && ctx2[4]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 2)
            useActions_action.update.call(null, ctx2[1]);
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 64)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(img);
          ctx[8](null);
          if (detaching)
            detach_dev(t);
          if (default_slot)
            default_slot.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$82.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$7($$self, $$props, $$invalidate) {
      const omit_props_names = ["alt", "use", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Img", slots, ["default"]);
      let {alt = ""} = $$props;
      let {use: use2 = []} = $$props;
      const forwardEvents = forwardEventsBuilder(get_current_component());
      let element2 = null;
      function getElement() {
        return element2;
      }
      function img_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(2, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("alt" in $$new_props)
          $$invalidate(0, alt = $$new_props.alt);
        if ("use" in $$new_props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("$$scope" in $$new_props)
          $$invalidate(6, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        get_current_component,
        forwardEventsBuilder,
        useActions,
        alt,
        use: use2,
        forwardEvents,
        element: element2,
        getElement
      });
      $$self.$inject_state = ($$new_props) => {
        if ("alt" in $$props)
          $$invalidate(0, alt = $$new_props.alt);
        if ("use" in $$props)
          $$invalidate(1, use2 = $$new_props.use);
        if ("element" in $$props)
          $$invalidate(2, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        alt,
        use2,
        element2,
        forwardEvents,
        $$restProps,
        getElement,
        $$scope,
        slots,
        img_binding
      ];
    }
    var Img = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$7, create_fragment$82, safe_not_equal, {alt: 0, use: 1, getElement: 5});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Img",
          options,
          id: create_fragment$82.name
        });
      }
      get alt() {
        throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set alt(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get use() {
        throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[5];
      }
      set getElement(value) {
        throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    function clickOutside(node) {
      const handleClick2 = (event) => {
        if (node && !node.contains(event.target) && !event.defaultPrevented) {
          node.dispatchEvent(new CustomEvent("click_outside", node));
        }
      };
      document.addEventListener("click", handleClick2, true);
      return {
        destroy() {
          document.removeEventListener("click", handleClick2, true);
        }
      };
    }
    var file$6 = "src/components/components/Menu.svelte";
    function create_if_block$3(ctx) {
      let div;
      let ul;
      let div_transition;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
      const block = {
        c: function create2() {
          div = element("div");
          ul = element("ul");
          if (default_slot)
            default_slot.c();
          add_location(ul, file$6, 18, 2, 397);
          attr_dev(div, "class", "absolute right-full top-0 rounded text-black py-2 text-xl bg-white shadow-xl");
          add_location(div, file$6, 7, 1, 153);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, ul);
          if (default_slot) {
            default_slot.m(ul, null);
          }
          current = true;
          if (!mounted) {
            dispose = [
              listen_dev(div, "click", ctx[3], false, false, false),
              action_destroyer(clickOutside.call(null, div)),
              listen_dev(div, "click_outside", ctx[4], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          add_render_callback(() => {
            if (!div_transition)
              div_transition = create_bidirectional_transition(div, fade, {}, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, {}, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          if (detaching && div_transition)
            div_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(7:0) {#if menuToggle}",
        ctx
      });
      return block;
    }
    function create_fragment$73(ctx) {
      let if_block_anchor;
      let current;
      let if_block = ctx[0] && create_if_block$3(ctx);
      const block = {
        c: function create2() {
          if (if_block)
            if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block)
            if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (ctx2[0]) {
            if (if_block) {
              if_block.p(ctx2, dirty);
              if (dirty & 1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$3(ctx2);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block)
            if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$73.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$63($$self, $$props, $$invalidate) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Menu", slots, ["default"]);
      let {menuToggle} = $$props;
      const writable_props = ["menuToggle"];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Menu> was created with unknown prop '${key}'`);
      });
      const click_handler = () => {
        $$invalidate(0, menuToggle = !menuToggle);
      };
      const click_outside_handler = () => {
        $$invalidate(0, menuToggle = false);
      };
      $$self.$$set = ($$props2) => {
        if ("menuToggle" in $$props2)
          $$invalidate(0, menuToggle = $$props2.menuToggle);
        if ("$$scope" in $$props2)
          $$invalidate(1, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => ({fade, clickOutside, menuToggle});
      $$self.$inject_state = ($$props2) => {
        if ("menuToggle" in $$props2)
          $$invalidate(0, menuToggle = $$props2.menuToggle);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [menuToggle, $$scope, slots, click_handler, click_outside_handler];
    }
    var Menu2 = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$63, create_fragment$73, safe_not_equal, {menuToggle: 0});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Menu",
          options,
          id: create_fragment$73.name
        });
        const {ctx} = this.$$;
        const props = options.props || {};
        if (ctx[0] === void 0 && !("menuToggle" in props)) {
          console.warn("<Menu> was created without expected prop 'menuToggle'");
        }
      }
      get menuToggle() {
        throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set menuToggle(value) {
        throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var file$52 = "src/components/auth/login.svelte";
    function create_else_block$2(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot_4$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(82:2) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$2(ctx) {
      let await_block_anchor;
      let promise2;
      let current;
      let info = {
        ctx,
        current: null,
        token: null,
        hasCatch: true,
        pending: create_pending_block,
        then: create_then_block,
        catch: create_catch_block,
        value: 8,
        error: 9,
        blocks: [, , ,]
      };
      handle_promise(promise2 = ctx[1], info);
      const block = {
        c: function create2() {
          await_block_anchor = empty();
          info.block.c();
        },
        m: function mount(target, anchor) {
          insert_dev(target, await_block_anchor, anchor);
          info.block.m(target, info.anchor = anchor);
          info.mount = () => await_block_anchor.parentNode;
          info.anchor = await_block_anchor;
          current = true;
        },
        p: function update2(new_ctx, dirty) {
          ctx = new_ctx;
          info.ctx = ctx;
          if (dirty & 2 && promise2 !== (promise2 = ctx[1]) && handle_promise(promise2, info))
            ;
          else {
            update_await_block_branch(info, ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(info.block);
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < 3; i += 1) {
            const block2 = info.blocks[i];
            transition_out(block2);
          }
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(await_block_anchor);
          info.block.d(detaching);
          info.token = null;
          info = null;
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(63:2) {#if loginPromise}",
        ctx
      });
      return block;
    }
    function create_default_slot_5$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: "(84:4) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_4$1(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_5$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: '(83:3) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_catch_block(ctx) {
      let div;
      let t0_value = ctx[9] + "";
      let t0;
      let t1;
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot_2$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          div = element("div");
          t0 = text(t0_value);
          t1 = space();
          create_component(button.$$.fragment);
          attr_dev(div, "class", "text-red-500");
          add_location(div, file$52, 74, 4, 1876);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          insert_dev(target, t1, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if ((!current || dirty & 2) && t0_value !== (t0_value = ctx2[9] + ""))
            set_data_dev(t0, t0_value);
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (detaching)
            detach_dev(t1);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_catch_block.name,
        type: "catch",
        source: "(74:3) {:catch err}",
        ctx
      });
      return block;
    }
    function create_default_slot_3$1(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(79:5) <Label>",
        ctx
      });
      return block;
    }
    function create_default_slot_2$1(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_3$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: '(78:4) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_then_block(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login sucessfull");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_then_block.name,
        type: "then",
        source: "(72:3) {:then data}",
        ctx
      });
      return block;
    }
    function create_pending_block(ctx) {
      let button;
      let current;
      button = new Button_1({
        props: {
          variant: "raised",
          class: "w-full",
          $$slots: {default: [create_default_slot$14]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const button_changes = {};
          if (dirty & 1024) {
            button_changes.$$scope = {dirty, ctx: ctx2};
          }
          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_pending_block.name,
        type: "pending",
        source: '(64:24)      <Button variant=\\"raised\\" class=\\"w-full\\">      <Label       ><span class=\\"material-icons animate-spin\\">        sync       </span></Label      >     </Button>    {:then data}',
        ctx
      });
      return block;
    }
    function create_default_slot_1$1(ctx) {
      let span;
      const block = {
        c: function create2() {
          span = element("span");
          span.textContent = "sync";
          attr_dev(span, "class", "material-icons animate-spin");
          add_location(span, file$52, 66, 7, 1722);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(66:5) <Label       >",
        ctx
      });
      return block;
    }
    function create_default_slot$14(ctx) {
      let label;
      let current;
      label = new Label({
        props: {
          $$slots: {default: [create_default_slot_1$1]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(label.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(label, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const label_changes = {};
          if (dirty & 1024) {
            label_changes.$$scope = {dirty, ctx: ctx2};
          }
          label.$set(label_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(label.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(label.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(label, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$14.name,
        type: "slot",
        source: '(65:4) <Button variant=\\"raised\\" class=\\"w-full\\">',
        ctx
      });
      return block;
    }
    function create_fragment$64(ctx) {
      let div;
      let form;
      let textfield0;
      let updating_value;
      let t0;
      let textfield1;
      let updating_value_1;
      let t1;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      function textfield0_value_binding(value) {
        ctx[3](value);
      }
      let textfield0_props = {variant: "filled", label: "Benutzername"};
      if (ctx[0].username !== void 0) {
        textfield0_props.value = ctx[0].username;
      }
      textfield0 = new Textfield({props: textfield0_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield0, "value", textfield0_value_binding));
      function textfield1_value_binding(value) {
        ctx[4](value);
      }
      let textfield1_props = {
        variant: "filled",
        type: "password",
        label: "Passwort"
      };
      if (ctx[0].password !== void 0) {
        textfield1_props.value = ctx[0].password;
      }
      textfield1 = new Textfield({props: textfield1_props, $$inline: true});
      binding_callbacks.push(() => bind3(textfield1, "value", textfield1_value_binding));
      const if_block_creators = [create_if_block$2, create_else_block$2];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[1])
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          div = element("div");
          form = element("form");
          create_component(textfield0.$$.fragment);
          t0 = space();
          create_component(textfield1.$$.fragment);
          t1 = space();
          if_block.c();
          attr_dev(form, "action", "");
          attr_dev(form, "class", "flex flex-col justify-center items-center gap-2");
          add_location(form, file$52, 45, 1, 1282);
          attr_dev(div, "class", "flex flex-col w-full justify-center items-center py-16");
          add_location(div, file$52, 44, 0, 1212);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, form);
          mount_component(textfield0, form, null);
          append_dev(form, t0);
          mount_component(textfield1, form, null);
          append_dev(form, t1);
          if_blocks[current_block_type_index].m(form, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(ctx[2]), false, true, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          const textfield0_changes = {};
          if (!updating_value && dirty & 1) {
            updating_value = true;
            textfield0_changes.value = ctx2[0].username;
            add_flush_callback(() => updating_value = false);
          }
          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};
          if (!updating_value_1 && dirty & 1) {
            updating_value_1 = true;
            textfield1_changes.value = ctx2[0].password;
            add_flush_callback(() => updating_value_1 = false);
          }
          textfield1.$set(textfield1_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(form, null);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          destroy_component(textfield0);
          destroy_component(textfield1);
          if_blocks[current_block_type_index].d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$64.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$54($$self, $$props, $$invalidate) {
      let $redirect;
      let $modal;
      let $user;
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(5, $redirect = $$value));
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(6, $modal = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(7, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Login", slots, []);
      let userSettings2 = {
        grant_type: "password",
        username: "",
        password: ""
      };
      let loginPromise;
      async function login() {
        if (!userSettings2.username || !userSettings2.password)
          return;
        $$invalidate(1, loginPromise = new Promise(async (res, rej) => {
          let bodyFormData = new FormData();
          bodyFormData.append("username", userSettings2.username);
          bodyFormData.append("password", userSettings2.password);
          try {
            let {data} = await axios.post(`${backendURL}/api/token`, bodyFormData, {
              headers: {
                "Content-Type": "multipart/form-data",
                Authorization: "Basic Og=="
              }
            });
            if (data && user) {
              set_store_value(user, $user = data, $user);
              localStorage.setItem("auth", JSON.stringify(data));
              set_store_value(modal, $modal = {}, $modal);
              bodyFormData = void 0;
              $redirect("/");
            }
            res(data);
          } catch (err) {
            rej(err.response?.data.detail);
          }
        }));
      }
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Login> was created with unknown prop '${key}'`);
      });
      function textfield0_value_binding(value) {
        if ($$self.$$.not_equal(userSettings2.username, value)) {
          userSettings2.username = value;
          $$invalidate(0, userSettings2);
        }
      }
      function textfield1_value_binding(value) {
        if ($$self.$$.not_equal(userSettings2.password, value)) {
          userSettings2.password = value;
          $$invalidate(0, userSettings2);
        }
      }
      $$self.$capture_state = () => ({
        Textfield,
        Button: Button_1,
        Label,
        axios,
        modal,
        user,
        backendURL,
        goto,
        redirect,
        userSettings: userSettings2,
        loginPromise,
        login,
        $redirect,
        $modal,
        $user
      });
      $$self.$inject_state = ($$props2) => {
        if ("userSettings" in $$props2)
          $$invalidate(0, userSettings2 = $$props2.userSettings);
        if ("loginPromise" in $$props2)
          $$invalidate(1, loginPromise = $$props2.loginPromise);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        userSettings2,
        loginPromise,
        login,
        textfield0_value_binding,
        textfield1_value_binding
      ];
    }
    var Login = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$54, create_fragment$64, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Login",
          options,
          id: create_fragment$64.name
        });
      }
    };
    var oldModifierRegex9 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    var newModifierRegex9 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder9(component) {
      let $on;
      let events2 = [];
      const componentOn = component.$on;
      component.$on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let destructor = () => {
        };
        if ($on) {
          destructor = $on(eventType, callback);
        } else {
          events2.push([eventType, callback]);
        }
        const oldModifierMatch = eventType.match(oldModifierRegex9);
        const newModifierMatch = eventType.match(newModifierRegex9);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (oldModifierMatch && console) {
          console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
        }
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
        }
        const componentDestructor = componentOn.call(component, eventType, callback);
        return (...args) => {
          destructor();
          return componentDestructor(...args);
        };
      };
      function forward(e) {
        bubble(component, e);
      }
      return (node) => {
        const destructors = [];
        const forwardDestructors = {};
        $on = (fullEventType, callback) => {
          let eventType = fullEventType;
          let handler = callback;
          let options = false;
          const oldModifierMatch = eventType.match(oldModifierRegex9);
          const newModifierMatch = eventType.match(newModifierRegex9);
          const modifierMatch = oldModifierMatch || newModifierMatch;
          if (modifierMatch) {
            const parts = eventType.split(oldModifierMatch ? ":" : "$");
            eventType = parts[0];
            options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
            if (options.nonpassive) {
              options.passive = false;
              delete options.nonpassive;
            }
            if (options.preventDefault) {
              handler = prevent_default(handler);
              delete options.preventDefault;
            }
            if (options.stopPropagation) {
              handler = stop_propagation(handler);
              delete options.stopPropagation;
            }
          }
          const off = listen(node, eventType, handler, options);
          const destructor = () => {
            off();
            const idx = destructors.indexOf(destructor);
            if (idx > -1) {
              destructors.splice(idx, 1);
            }
          };
          destructors.push(destructor);
          if (!eventType in forwardDestructors) {
            forwardDestructors[eventType] = listen(node, eventType, forward);
          }
          return destructor;
        };
        for (let i = 0; i < events2.length; i++) {
          $on(events2[i][0], events2[i][1]);
        }
        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
            for (let entry of Object.entries(forwardDestructors)) {
              entry[1]();
            }
          }
        };
      };
    }
    function classMap9(classObj) {
      return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
    }
    function dispatch5(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
      if (typeof Event !== "undefined" && element2) {
        const event = new Event(eventType, eventInit);
        event.detail = detail;
        const el = "getElement" in element2 ? element2.getElement() : element2;
        el.dispatchEvent(event);
        return event;
      }
    }
    function exclude3(obj, keys) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        const cashIndex = name.indexOf("$");
        if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
          continue;
        }
        if (keys.indexOf(name) !== -1) {
          continue;
        }
        newObj[name] = obj[name];
      }
      return newObj;
    }
    function prefixFilter3(obj, prefix) {
      let names = Object.getOwnPropertyNames(obj);
      const newObj = {};
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (name.substring(0, prefix.length) === prefix) {
          newObj[name.substring(prefix.length)] = obj[name];
        }
      }
      return newObj;
    }
    function useActions8(node, actions) {
      let objects = [];
      if (actions) {
        for (let i = 0; i < actions.length; i++) {
          const isArray2 = Array.isArray(actions[i]);
          const action = isArray2 ? actions[i][0] : actions[i];
          if (isArray2 && actions[i].length > 1) {
            objects.push(action(node, actions[i][1]));
          } else {
            objects.push(action(node));
          }
        }
      }
      return {
        update(actions2) {
          if ((actions2 && actions2.length || 0) != objects.length) {
            throw new Error("You must not change the length of an actions array.");
          }
          if (actions2) {
            for (let i = 0; i < actions2.length; i++) {
              if (objects[i] && "update" in objects[i]) {
                const isArray2 = Array.isArray(actions2[i]);
                if (isArray2 && actions2[i].length > 1) {
                  objects[i].update(actions2[i][1]);
                } else {
                  objects[i].update();
                }
              }
            }
          }
        },
        destroy() {
          for (let i = 0; i < objects.length; i++) {
            if (objects[i] && "destroy" in objects[i]) {
              objects[i].destroy();
            }
          }
        }
      };
    }
    var file$43 = "node_modules/@smui/tooltip/Wrapper.svelte";
    function create_else_block$1(ctx) {
      let current;
      const default_slot_template = ctx[12].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
      const block = {
        c: function create2() {
          if (default_slot)
            default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }
          current = true;
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2048)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot)
            default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(14:0) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block$13(ctx) {
      let div;
      let div_class_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[12].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
      let div_levels = [
        {
          class: div_class_value = classMap9({
            [ctx[1]]: true,
            "mdc-tooltip-wrapper--rich": true
          })
        },
        ctx[7]
      ];
      let div_data = {};
      for (let i = 0; i < div_levels.length; i += 1) {
        div_data = assign(div_data, div_levels[i]);
      }
      const block = {
        c: function create2() {
          div = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div, div_data);
          add_location(div, file$43, 1, 2, 13);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (default_slot) {
            default_slot.m(div, null);
          }
          ctx[13](div);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, div, ctx[0])),
              action_destroyer(ctx[4].call(null, div))
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2048)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
            }
          }
          set_attributes(div, div_data = get_spread_update(div_levels, [
            (!current || dirty & 2 && div_class_value !== (div_class_value = classMap9({
              [ctx2[1]]: true,
              "mdc-tooltip-wrapper--rich": true
            }))) && {class: div_class_value},
            dirty & 128 && ctx2[7]
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
          if (default_slot)
            default_slot.d(detaching);
          ctx[13](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$13.name,
        type: "if",
        source: "(1:0) {#if rich}",
        ctx
      });
      return block;
    }
    function create_fragment$54(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block$13, create_else_block$1];
      const if_blocks = [];
      function select_block_type(ctx2, dirty) {
        if (ctx2[2])
          return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx2);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$54.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$44($$self, $$props, $$invalidate) {
      const omit_props_names = ["use", "class", "rich", "getElement"];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $tooltip;
      let $anchor;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Wrapper", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {rich = false} = $$props;
      let element2;
      const anchor = writable(null);
      validate_store(anchor, "anchor");
      component_subscribe($$self, anchor, (value) => $$invalidate(10, $anchor = value));
      const tooltip = writable(null);
      validate_store(tooltip, "tooltip");
      component_subscribe($$self, tooltip, (value) => $$invalidate(9, $tooltip = value));
      setContext("SMUI:tooltip:wrapper:anchor", anchor);
      setContext("SMUI:tooltip:wrapper:tooltip", tooltip);
      setContext("SMUI:tooltip:rich", rich);
      function getElement() {
        return element2;
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(3, element2);
        });
      }
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("rich" in $$new_props)
          $$invalidate(2, rich = $$new_props.rich);
        if ("$$scope" in $$new_props)
          $$invalidate(11, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        setContext,
        writable,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        classMap: classMap9,
        useActions: useActions8,
        forwardEvents,
        use: use2,
        className,
        rich,
        element: element2,
        anchor,
        tooltip,
        getElement,
        $tooltip,
        $anchor
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("rich" in $$props)
          $$invalidate(2, rich = $$new_props.rich);
        if ("element" in $$props)
          $$invalidate(3, element2 = $$new_props.element);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1536) {
          if ($tooltip && !$anchor) {
            set_store_value(anchor, $anchor = $tooltip.previousElementSibling, $anchor);
          }
        }
      };
      return [
        use2,
        className,
        rich,
        element2,
        forwardEvents,
        anchor,
        tooltip,
        $$restProps,
        getElement,
        $tooltip,
        $anchor,
        $$scope,
        slots,
        div_binding
      ];
    }
    var Wrapper = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$44, create_fragment$54, safe_not_equal, {use: 0, class: 1, rich: 2, getElement: 8});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Wrapper",
          options,
          id: create_fragment$54.name
        });
      }
      get use() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get rich() {
        throw new Error("<Wrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set rich(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[8];
      }
      set getElement(value) {
        throw new Error("<Wrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var CssClasses;
    (function(CssClasses2) {
      CssClasses2["RICH"] = "mdc-tooltip--rich";
      CssClasses2["SHOWN"] = "mdc-tooltip--shown";
      CssClasses2["SHOWING"] = "mdc-tooltip--showing";
      CssClasses2["SHOWING_TRANSITION"] = "mdc-tooltip--showing-transition";
      CssClasses2["HIDE"] = "mdc-tooltip--hide";
      CssClasses2["HIDE_TRANSITION"] = "mdc-tooltip--hide-transition";
      CssClasses2["MULTILINE_TOOLTIP"] = "mdc-tooltip--multiline";
      CssClasses2["SURFACE"] = "mdc-tooltip__surface";
      CssClasses2["TOOLTIP_CARET_TOP"] = "mdc-tooltip__caret-surface-top";
      CssClasses2["TOOLTIP_CARET_BOTTOM"] = "mdc-tooltip__caret-surface-bottom";
    })(CssClasses || (CssClasses = {}));
    var numbers5 = {
      BOUNDED_ANCHOR_GAP: 4,
      UNBOUNDED_ANCHOR_GAP: 8,
      MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,
      HIDE_DELAY_MS: 600,
      SHOW_DELAY_MS: 500,
      MIN_HEIGHT: 24,
      MAX_WIDTH: 200,
      CARET_INDENTATION: 24
    };
    var attributes = {
      ARIA_EXPANDED: "aria-expanded",
      ARIA_HASPOPUP: "aria-haspopup",
      PERSISTENT: "data-mdc-tooltip-persistent",
      SCROLLABLE_ANCESTOR: "tooltip-scrollable-ancestor",
      HAS_CARET: "data-mdc-tooltip-has-caret"
    };
    var XPosition;
    (function(XPosition2) {
      XPosition2[XPosition2["DETECTED"] = 0] = "DETECTED";
      XPosition2[XPosition2["START"] = 1] = "START";
      XPosition2[XPosition2["CENTER"] = 2] = "CENTER";
      XPosition2[XPosition2["END"] = 3] = "END";
    })(XPosition || (XPosition = {}));
    var YPosition;
    (function(YPosition2) {
      YPosition2[YPosition2["DETECTED"] = 0] = "DETECTED";
      YPosition2[YPosition2["ABOVE"] = 1] = "ABOVE";
      YPosition2[YPosition2["BELOW"] = 2] = "BELOW";
    })(YPosition || (YPosition = {}));
    var AnchorBoundaryType;
    (function(AnchorBoundaryType2) {
      AnchorBoundaryType2[AnchorBoundaryType2["BOUNDED"] = 0] = "BOUNDED";
      AnchorBoundaryType2[AnchorBoundaryType2["UNBOUNDED"] = 1] = "UNBOUNDED";
    })(AnchorBoundaryType || (AnchorBoundaryType = {}));
    var strings6 = {
      LEFT: "left",
      RIGHT: "right",
      CENTER: "center",
      TOP: "top",
      BOTTOM: "bottom"
    };
    var PositionWithCaret;
    (function(PositionWithCaret2) {
      PositionWithCaret2[PositionWithCaret2["DETECTED"] = 0] = "DETECTED";
      PositionWithCaret2[PositionWithCaret2["ABOVE_START"] = 1] = "ABOVE_START";
      PositionWithCaret2[PositionWithCaret2["ABOVE_CENTER"] = 2] = "ABOVE_CENTER";
      PositionWithCaret2[PositionWithCaret2["ABOVE_END"] = 3] = "ABOVE_END";
      PositionWithCaret2[PositionWithCaret2["TOP_SIDE_START"] = 4] = "TOP_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_START"] = 5] = "CENTER_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_START"] = 6] = "BOTTOM_SIDE_START";
      PositionWithCaret2[PositionWithCaret2["TOP_SIDE_END"] = 7] = "TOP_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["CENTER_SIDE_END"] = 8] = "CENTER_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["BOTTOM_SIDE_END"] = 9] = "BOTTOM_SIDE_END";
      PositionWithCaret2[PositionWithCaret2["BELOW_START"] = 10] = "BELOW_START";
      PositionWithCaret2[PositionWithCaret2["BELOW_CENTER"] = 11] = "BELOW_CENTER";
      PositionWithCaret2[PositionWithCaret2["BELOW_END"] = 12] = "BELOW_END";
    })(PositionWithCaret || (PositionWithCaret = {}));
    /**
     * @license
     * Copyright 2020 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var RICH = CssClasses.RICH;
    var SHOWN = CssClasses.SHOWN;
    var SHOWING = CssClasses.SHOWING;
    var SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION;
    var HIDE = CssClasses.HIDE;
    var HIDE_TRANSITION = CssClasses.HIDE_TRANSITION;
    var MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;
    var AnimationKeys;
    (function(AnimationKeys2) {
      AnimationKeys2["POLL_ANCHOR"] = "poll_anchor";
    })(AnimationKeys || (AnimationKeys = {}));
    var HAS_WINDOW = typeof window !== "undefined";
    var MDCTooltipFoundation = function(_super) {
      __extends(MDCTooltipFoundation2, _super);
      function MDCTooltipFoundation2(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation2.defaultAdapter), adapter)) || this;
        _this.tooltipShown = false;
        _this.anchorGap = numbers5.BOUNDED_ANCHOR_GAP;
        _this.xTooltipPos = XPosition.DETECTED;
        _this.yTooltipPos = YPosition.DETECTED;
        _this.tooltipPositionWithCaret = PositionWithCaret.DETECTED;
        _this.minViewportTooltipThreshold = numbers5.MIN_VIEWPORT_TOOLTIP_THRESHOLD;
        _this.hideDelayMs = numbers5.HIDE_DELAY_MS;
        _this.showDelayMs = numbers5.SHOW_DELAY_MS;
        _this.anchorRect = null;
        _this.parentRect = null;
        _this.frameId = null;
        _this.hideTimeout = null;
        _this.showTimeout = null;
        _this.addAncestorScrollEventListeners = new Array();
        _this.removeAncestorScrollEventListeners = new Array();
        _this.animFrame = new AnimationFrame();
        _this.anchorBlurHandler = function(evt) {
          _this.handleAnchorBlur(evt);
        };
        _this.documentClickHandler = function(evt) {
          _this.handleDocumentClick(evt);
        };
        _this.documentKeydownHandler = function(evt) {
          _this.handleKeydown(evt);
        };
        _this.richTooltipMouseEnterHandler = function() {
          _this.handleRichTooltipMouseEnter();
        };
        _this.richTooltipMouseLeaveHandler = function() {
          _this.handleRichTooltipMouseLeave();
        };
        _this.richTooltipFocusOutHandler = function(evt) {
          _this.handleRichTooltipFocusOut(evt);
        };
        _this.windowScrollHandler = function() {
          _this.handleWindowChangeEvent();
        };
        _this.windowResizeHandler = function() {
          _this.handleWindowChangeEvent();
        };
        return _this;
      }
      Object.defineProperty(MDCTooltipFoundation2, "defaultAdapter", {
        get: function() {
          return {
            getAttribute: function() {
              return null;
            },
            setAttribute: function() {
              return void 0;
            },
            addClass: function() {
              return void 0;
            },
            hasClass: function() {
              return false;
            },
            removeClass: function() {
              return void 0;
            },
            getComputedStyleProperty: function() {
              return "";
            },
            setStyleProperty: function() {
              return void 0;
            },
            setSurfaceStyleProperty: function() {
              return void 0;
            },
            getViewportWidth: function() {
              return 0;
            },
            getViewportHeight: function() {
              return 0;
            },
            getTooltipSize: function() {
              return {width: 0, height: 0};
            },
            getAnchorBoundingRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            getParentBoundingRect: function() {
              return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
            },
            getAnchorAttribute: function() {
              return null;
            },
            setAnchorAttribute: function() {
              return null;
            },
            isRTL: function() {
              return false;
            },
            anchorContainsElement: function() {
              return false;
            },
            tooltipContainsElement: function() {
              return false;
            },
            focusAnchorElement: function() {
              return void 0;
            },
            registerEventHandler: function() {
              return void 0;
            },
            deregisterEventHandler: function() {
              return void 0;
            },
            registerAnchorEventHandler: function() {
              return void 0;
            },
            deregisterAnchorEventHandler: function() {
              return void 0;
            },
            registerDocumentEventHandler: function() {
              return void 0;
            },
            deregisterDocumentEventHandler: function() {
              return void 0;
            },
            registerWindowEventHandler: function() {
              return void 0;
            },
            deregisterWindowEventHandler: function() {
              return void 0;
            },
            notifyHidden: function() {
              return void 0;
            },
            getTooltipCaretSize: function() {
              return null;
            },
            setTooltipCaretStyle: function() {
              return void 0;
            },
            clearTooltipCaretStyles: function() {
              return void 0;
            }
          };
        },
        enumerable: false,
        configurable: true
      });
      MDCTooltipFoundation2.prototype.init = function() {
        this.richTooltip = this.adapter.hasClass(RICH);
        this.persistentTooltip = this.adapter.getAttribute(attributes.PERSISTENT) === "true";
        this.interactiveTooltip = !!this.adapter.getAnchorAttribute(attributes.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(attributes.ARIA_HASPOPUP) === "dialog";
        this.hasCaret = this.richTooltip && this.adapter.getAttribute(attributes.HAS_CARET) === "true";
      };
      MDCTooltipFoundation2.prototype.isShown = function() {
        return this.tooltipShown;
      };
      MDCTooltipFoundation2.prototype.isRich = function() {
        return this.richTooltip;
      };
      MDCTooltipFoundation2.prototype.isPersistent = function() {
        return this.persistentTooltip;
      };
      MDCTooltipFoundation2.prototype.handleAnchorMouseEnter = function() {
        var _this = this;
        if (this.tooltipShown) {
          this.show();
        } else {
          this.clearHideTimeout();
          this.showTimeout = setTimeout(function() {
            _this.show();
          }, this.showDelayMs);
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorTouchstart = function() {
        var _this = this;
        this.showTimeout = setTimeout(function() {
          _this.show();
        }, this.showDelayMs);
        this.adapter.registerWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
      };
      MDCTooltipFoundation2.prototype.preventContextMenuOnLongTouch = function(evt) {
        evt.preventDefault();
      };
      MDCTooltipFoundation2.prototype.handleAnchorTouchend = function() {
        this.clearShowTimeout();
        if (!this.isShown()) {
          this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorFocus = function(evt) {
        var _this = this;
        var relatedTarget = evt.relatedTarget;
        var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(relatedTarget);
        if (tooltipContainsRelatedTarget) {
          return;
        }
        this.showTimeout = setTimeout(function() {
          _this.show();
        }, this.showDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleAnchorMouseLeave = function() {
        var _this = this;
        this.clearShowTimeout();
        this.hideTimeout = setTimeout(function() {
          _this.hide();
        }, this.hideDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleAnchorClick = function() {
        if (this.tooltipShown) {
          this.hide();
        } else {
          this.show();
        }
      };
      MDCTooltipFoundation2.prototype.handleDocumentClick = function(evt) {
        var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.target) || this.adapter.tooltipContainsElement(evt.target));
        if (this.richTooltip && this.persistentTooltip && anchorOrTooltipContainsTargetElement) {
          return;
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleKeydown = function(evt) {
        var key = normalizeKey(evt);
        if (key === KEY.ESCAPE) {
          var tooltipContainsActiveElement = document.activeElement instanceof HTMLElement && this.adapter.tooltipContainsElement(document.activeElement);
          if (tooltipContainsActiveElement) {
            this.adapter.focusAnchorElement();
          }
          this.hide();
        }
      };
      MDCTooltipFoundation2.prototype.handleAnchorBlur = function(evt) {
        if (this.richTooltip) {
          var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(evt.relatedTarget);
          if (tooltipContainsRelatedTargetElement) {
            return;
          }
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipMouseEnter = function() {
        this.show();
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipMouseLeave = function() {
        var _this = this;
        this.clearShowTimeout();
        this.hideTimeout = setTimeout(function() {
          _this.hide();
        }, this.hideDelayMs);
      };
      MDCTooltipFoundation2.prototype.handleRichTooltipFocusOut = function(evt) {
        var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.relatedTarget) || this.adapter.tooltipContainsElement(evt.relatedTarget));
        if (anchorOrTooltipContainsRelatedTargetElement) {
          return;
        }
        this.hide();
      };
      MDCTooltipFoundation2.prototype.handleWindowChangeEvent = function() {
        var _this = this;
        this.animFrame.request(AnimationKeys.POLL_ANCHOR, function() {
          _this.repositionTooltipOnAnchorMove();
        });
      };
      MDCTooltipFoundation2.prototype.show = function() {
        var e_1, _a2;
        var _this = this;
        this.clearHideTimeout();
        this.clearShowTimeout();
        if (this.tooltipShown) {
          return;
        }
        this.tooltipShown = true;
        var showTooltipOptions = this.parseShowTooltipOptions();
        if (!showTooltipOptions.hideFromScreenreader) {
          this.adapter.setAttribute("aria-hidden", "false");
        }
        if (this.richTooltip) {
          if (this.interactiveTooltip) {
            this.adapter.setAnchorAttribute("aria-expanded", "true");
          }
          this.adapter.registerEventHandler("focusout", this.richTooltipFocusOutHandler);
          if (!this.persistentTooltip) {
            this.adapter.registerEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.registerEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.adapter.removeClass(HIDE);
        this.adapter.addClass(SHOWING);
        if (this.isTooltipMultiline() && !this.richTooltip) {
          this.adapter.addClass(MULTILINE_TOOLTIP);
        }
        this.anchorRect = this.adapter.getAnchorBoundingRect();
        this.parentRect = this.adapter.getParentBoundingRect();
        this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
        if (this.hasCaret) {
          this.setCaretPositionStyles(this.tooltipPositionWithCaret);
        }
        this.adapter.registerAnchorEventHandler("blur", this.anchorBlurHandler);
        this.adapter.registerDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.registerDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.registerWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
        try {
          for (var _b2 = __values(this.addAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.frameId = requestAnimationFrame(function() {
          _this.clearAllAnimationClasses();
          _this.adapter.addClass(SHOWN);
          _this.adapter.addClass(SHOWING_TRANSITION);
        });
      };
      MDCTooltipFoundation2.prototype.hide = function() {
        var e_2, _a2;
        this.clearHideTimeout();
        this.clearShowTimeout();
        if (!this.tooltipShown) {
          return;
        }
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
        }
        this.tooltipShown = false;
        this.adapter.setAttribute("aria-hidden", "true");
        this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
        if (this.richTooltip) {
          if (this.interactiveTooltip) {
            this.adapter.setAnchorAttribute("aria-expanded", "false");
          }
          if (!this.persistentTooltip) {
            this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.clearAllAnimationClasses();
        this.adapter.addClass(HIDE);
        this.adapter.addClass(HIDE_TRANSITION);
        this.adapter.removeClass(SHOWN);
        this.adapter.deregisterAnchorEventHandler("blur", this.anchorBlurHandler);
        this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
        this.adapter.deregisterWindowEventHandler("contextmenu", this.preventContextMenuOnLongTouch);
        try {
          for (var _b2 = __values(this.removeAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_2_1) {
          e_2 = {error: e_2_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      };
      MDCTooltipFoundation2.prototype.handleTransitionEnd = function() {
        var isHidingTooltip = this.adapter.hasClass(HIDE);
        this.adapter.removeClass(SHOWING);
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(HIDE);
        this.adapter.removeClass(HIDE_TRANSITION);
        if (isHidingTooltip) {
          this.adapter.notifyHidden();
        }
      };
      MDCTooltipFoundation2.prototype.clearAllAnimationClasses = function() {
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(HIDE_TRANSITION);
      };
      MDCTooltipFoundation2.prototype.setTooltipPosition = function(position) {
        var xPos = position.xPos, yPos = position.yPos, withCaretPos = position.withCaretPos;
        if (this.hasCaret && withCaretPos) {
          this.tooltipPositionWithCaret = withCaretPos;
          return;
        }
        if (xPos) {
          this.xTooltipPos = xPos;
        }
        if (yPos) {
          this.yTooltipPos = yPos;
        }
      };
      MDCTooltipFoundation2.prototype.setAnchorBoundaryType = function(type) {
        if (type === AnchorBoundaryType.UNBOUNDED) {
          this.anchorGap = numbers5.UNBOUNDED_ANCHOR_GAP;
        } else {
          this.anchorGap = numbers5.BOUNDED_ANCHOR_GAP;
        }
      };
      MDCTooltipFoundation2.prototype.parseShowTooltipOptions = function() {
        var hideFromScreenreader = Boolean(this.adapter.getAnchorAttribute("data-tooltip-id"));
        return {hideFromScreenreader};
      };
      MDCTooltipFoundation2.prototype.isTooltipMultiline = function() {
        var tooltipSize = this.adapter.getTooltipSize();
        return tooltipSize.height > numbers5.MIN_HEIGHT && tooltipSize.width >= numbers5.MAX_WIDTH;
      };
      MDCTooltipFoundation2.prototype.positionPlainTooltip = function() {
        var _a2 = this.calculateTooltipStyles(this.anchorRect), top = _a2.top, yTransformOrigin = _a2.yTransformOrigin, left = _a2.left, xTransformOrigin = _a2.xTransformOrigin;
        var transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
        this.adapter.setSurfaceStyleProperty(transformProperty + "-origin", yTransformOrigin + " " + xTransformOrigin);
        this.adapter.setStyleProperty("top", top + "px");
        this.adapter.setStyleProperty("left", left + "px");
      };
      MDCTooltipFoundation2.prototype.positionRichTooltip = function() {
        var _a2, _b2, _c, _d;
        var width = this.adapter.getComputedStyleProperty("width");
        this.adapter.setStyleProperty("width", width);
        var _e = this.calculateTooltipStyles(this.anchorRect), top = _e.top, yTransformOrigin = _e.yTransformOrigin, left = _e.left, xTransformOrigin = _e.xTransformOrigin;
        var transformProperty = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
        this.adapter.setSurfaceStyleProperty(transformProperty + "-origin", yTransformOrigin + " " + xTransformOrigin);
        var leftAdjustment = left - ((_b2 = (_a2 = this.parentRect) === null || _a2 === void 0 ? void 0 : _a2.left) !== null && _b2 !== void 0 ? _b2 : 0);
        var topAdjustment = top - ((_d = (_c = this.parentRect) === null || _c === void 0 ? void 0 : _c.top) !== null && _d !== void 0 ? _d : 0);
        this.adapter.setStyleProperty("top", topAdjustment + "px");
        this.adapter.setStyleProperty("left", leftAdjustment + "px");
      };
      MDCTooltipFoundation2.prototype.calculateTooltipStyles = function(anchorRect) {
        if (!anchorRect) {
          return {top: 0, left: 0};
        }
        var tooltipSize = this.adapter.getTooltipSize();
        var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);
        var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);
        return {
          top: top.distance,
          yTransformOrigin: top.yTransformOrigin,
          left: left.distance,
          xTransformOrigin: left.xTransformOrigin
        };
      };
      MDCTooltipFoundation2.prototype.calculateXTooltipDistance = function(anchorRect, tooltipWidth) {
        var isLTR = !this.adapter.isRTL();
        var startPos, endPos, centerPos;
        var startTransformOrigin, endTransformOrigin;
        if (this.richTooltip) {
          startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;
          endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;
          startTransformOrigin = isLTR ? strings6.RIGHT : strings6.LEFT;
          endTransformOrigin = isLTR ? strings6.LEFT : strings6.RIGHT;
        } else {
          startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;
          endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;
          centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;
          startTransformOrigin = isLTR ? strings6.LEFT : strings6.RIGHT;
          endTransformOrigin = isLTR ? strings6.RIGHT : strings6.LEFT;
        }
        var positionOptions = this.richTooltip ? this.determineValidPositionOptions(startPos, endPos) : this.determineValidPositionOptions(centerPos, startPos, endPos);
        if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {
          return {distance: startPos, xTransformOrigin: startTransformOrigin};
        }
        if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {
          return {distance: endPos, xTransformOrigin: endTransformOrigin};
        }
        if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {
          return {distance: centerPos, xTransformOrigin: strings6.CENTER};
        }
        var possiblePositions = this.richTooltip ? [
          {distance: endPos, xTransformOrigin: endTransformOrigin},
          {distance: startPos, xTransformOrigin: startTransformOrigin}
        ] : [
          {distance: centerPos, xTransformOrigin: strings6.CENTER},
          {distance: startPos, xTransformOrigin: startTransformOrigin},
          {distance: endPos, xTransformOrigin: endTransformOrigin}
        ];
        var validPosition = possiblePositions.find(function(_a2) {
          var distance2 = _a2.distance;
          return positionOptions.has(distance2);
        });
        if (validPosition) {
          return validPosition;
        }
        if (anchorRect.left < 0) {
          return {
            distance: this.minViewportTooltipThreshold,
            xTransformOrigin: strings6.LEFT
          };
        } else {
          var viewportWidth = this.adapter.getViewportWidth();
          var distance = viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);
          return {distance, xTransformOrigin: strings6.RIGHT};
        }
      };
      MDCTooltipFoundation2.prototype.determineValidPositionOptions = function() {
        var e_3, _a2;
        var positions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          positions[_i] = arguments[_i];
        }
        var posWithinThreshold = new Set();
        var posWithinViewport = new Set();
        try {
          for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
            var position = positions_1_1.value;
            if (this.positionHonorsViewportThreshold(position)) {
              posWithinThreshold.add(position);
            } else if (this.positionDoesntCollideWithViewport(position)) {
              posWithinViewport.add(position);
            }
          }
        } catch (e_3_1) {
          e_3 = {error: e_3_1};
        } finally {
          try {
            if (positions_1_1 && !positions_1_1.done && (_a2 = positions_1.return))
              _a2.call(positions_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
      };
      MDCTooltipFoundation2.prototype.positionHonorsViewportThreshold = function(leftPos) {
        var viewportWidth = this.adapter.getViewportWidth();
        var tooltipWidth = this.adapter.getTooltipSize().width;
        return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;
      };
      MDCTooltipFoundation2.prototype.positionDoesntCollideWithViewport = function(leftPos) {
        var viewportWidth = this.adapter.getViewportWidth();
        var tooltipWidth = this.adapter.getTooltipSize().width;
        return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;
      };
      MDCTooltipFoundation2.prototype.calculateYTooltipDistance = function(anchorRect, tooltipHeight) {
        var belowYPos = anchorRect.bottom + this.anchorGap;
        var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);
        var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);
        if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {
          return {distance: aboveYPos, yTransformOrigin: strings6.BOTTOM};
        } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {
          return {distance: belowYPos, yTransformOrigin: strings6.TOP};
        }
        if (yPositionOptions.has(belowYPos)) {
          return {distance: belowYPos, yTransformOrigin: strings6.TOP};
        }
        if (yPositionOptions.has(aboveYPos)) {
          return {distance: aboveYPos, yTransformOrigin: strings6.BOTTOM};
        }
        return {distance: belowYPos, yTransformOrigin: strings6.TOP};
      };
      MDCTooltipFoundation2.prototype.determineValidYPositionOptions = function(aboveAnchorPos, belowAnchorPos) {
        var posWithinThreshold = new Set();
        var posWithinViewport = new Set();
        if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {
          posWithinThreshold.add(aboveAnchorPos);
        } else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {
          posWithinViewport.add(aboveAnchorPos);
        }
        if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {
          posWithinThreshold.add(belowAnchorPos);
        } else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {
          posWithinViewport.add(belowAnchorPos);
        }
        return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
      };
      MDCTooltipFoundation2.prototype.yPositionHonorsViewportThreshold = function(yPos) {
        var viewportHeight = this.adapter.getViewportHeight();
        var tooltipHeight = this.adapter.getTooltipSize().height;
        return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;
      };
      MDCTooltipFoundation2.prototype.yPositionDoesntCollideWithViewport = function(yPos) {
        var viewportHeight = this.adapter.getViewportHeight();
        var tooltipHeight = this.adapter.getTooltipSize().height;
        return yPos + tooltipHeight <= viewportHeight && yPos >= 0;
      };
      MDCTooltipFoundation2.prototype.repositionTooltipOnAnchorMove = function() {
        var newAnchorRect = this.adapter.getAnchorBoundingRect();
        if (!newAnchorRect || !this.anchorRect)
          return;
        if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {
          this.anchorRect = newAnchorRect;
          this.parentRect = this.adapter.getParentBoundingRect();
          this.richTooltip ? this.positionRichTooltip() : this.positionPlainTooltip();
        }
      };
      MDCTooltipFoundation2.prototype.setCaretPositionStyles = function(position) {
        var values = this.calculateCaretPositionOnTooltip(position);
        if (!values) {
          return {yTransformOrigin: 0, xTransformOrigin: 0};
        }
        this.adapter.clearTooltipCaretStyles();
        this.adapter.setTooltipCaretStyle(values.yAlignment, values.yAxisPx);
        this.adapter.setTooltipCaretStyle(values.xAlignment, values.xAxisPx);
        this.adapter.setTooltipCaretStyle("transform", "rotate(" + values.rotation + ")");
        this.adapter.setTooltipCaretStyle("transform-origin", values.yAlignment + " " + values.xAlignment);
        return {yTransformOrigin: values.yAxisPx, xTransformOrigin: values.xAxisPx};
      };
      MDCTooltipFoundation2.prototype.calculateCaretPositionOnTooltip = function(tooltipPos) {
        var isLTR = !this.adapter.isRTL();
        var tooltipWidth = this.adapter.getComputedStyleProperty("width");
        var tooltipHeight = this.adapter.getComputedStyleProperty("height");
        var caretDimensions = this.adapter.getTooltipCaretSize();
        if (!tooltipWidth || !tooltipHeight || !caretDimensions) {
          return;
        }
        var caretDiagonal = caretDimensions.width * Math.sqrt(2);
        var midpointWidth = "calc((" + tooltipWidth + " - " + caretDiagonal + "px) / 2)";
        var midpointHeight = "calc((" + tooltipHeight + " - " + caretDiagonal + "px) / 2)";
        var flushWithEdge = "0";
        var indentedFromEdge = numbers5.CARET_INDENTATION + "px";
        var positiveRot = "45deg";
        var negativeRot = "-45deg";
        switch (tooltipPos) {
          case PositionWithCaret.BELOW_CENTER:
            return {
              yAlignment: strings6.TOP,
              xAlignment: strings6.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: midpointWidth,
              rotation: negativeRot
            };
          case PositionWithCaret.BELOW_END:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.RIGHT : strings6.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.BELOW_START:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.LEFT : strings6.RIGHT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.TOP_SIDE_END:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.LEFT : strings6.RIGHT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.CENTER_SIDE_END:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.LEFT : strings6.RIGHT,
              yAxisPx: midpointHeight,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.BOTTOM_SIDE_END:
            return {
              yAlignment: strings6.BOTTOM,
              xAlignment: isLTR ? strings6.LEFT : strings6.RIGHT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.TOP_SIDE_START:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.RIGHT : strings6.LEFT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.CENTER_SIDE_START:
            return {
              yAlignment: strings6.TOP,
              xAlignment: isLTR ? strings6.RIGHT : strings6.LEFT,
              yAxisPx: midpointHeight,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          case PositionWithCaret.BOTTOM_SIDE_START:
            return {
              yAlignment: strings6.BOTTOM,
              xAlignment: isLTR ? strings6.RIGHT : strings6.LEFT,
              yAxisPx: indentedFromEdge,
              xAxisPx: flushWithEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
          case PositionWithCaret.ABOVE_CENTER:
            return {
              yAlignment: strings6.BOTTOM,
              xAlignment: strings6.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: midpointWidth,
              rotation: positiveRot
            };
          case PositionWithCaret.ABOVE_END:
            return {
              yAlignment: strings6.BOTTOM,
              xAlignment: isLTR ? strings6.RIGHT : strings6.LEFT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? negativeRot : positiveRot
            };
          default:
          case PositionWithCaret.ABOVE_START:
            return {
              yAlignment: strings6.BOTTOM,
              xAlignment: isLTR ? strings6.LEFT : strings6.RIGHT,
              yAxisPx: flushWithEdge,
              xAxisPx: indentedFromEdge,
              rotation: isLTR ? positiveRot : negativeRot
            };
        }
      };
      MDCTooltipFoundation2.prototype.clearShowTimeout = function() {
        if (this.showTimeout) {
          clearTimeout(this.showTimeout);
          this.showTimeout = null;
        }
      };
      MDCTooltipFoundation2.prototype.clearHideTimeout = function() {
        if (this.hideTimeout) {
          clearTimeout(this.hideTimeout);
          this.hideTimeout = null;
        }
      };
      MDCTooltipFoundation2.prototype.attachScrollHandler = function(addEventListenerFn) {
        var _this = this;
        this.addAncestorScrollEventListeners.push(function() {
          addEventListenerFn("scroll", _this.windowScrollHandler);
        });
      };
      MDCTooltipFoundation2.prototype.removeScrollHandler = function(removeEventHandlerFn) {
        var _this = this;
        this.removeAncestorScrollEventListeners.push(function() {
          removeEventHandlerFn("scroll", _this.windowScrollHandler);
        });
      };
      MDCTooltipFoundation2.prototype.destroy = function() {
        var e_4, _a2;
        if (this.frameId) {
          cancelAnimationFrame(this.frameId);
          this.frameId = null;
        }
        this.clearHideTimeout();
        this.clearShowTimeout();
        this.adapter.removeClass(SHOWN);
        this.adapter.removeClass(SHOWING_TRANSITION);
        this.adapter.removeClass(SHOWING);
        this.adapter.removeClass(HIDE);
        this.adapter.removeClass(HIDE_TRANSITION);
        if (this.richTooltip) {
          this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
          if (!this.persistentTooltip) {
            this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
            this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
          }
        }
        this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
        this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
        this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
        this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
        try {
          for (var _b2 = __values(this.removeAncestorScrollEventListeners), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var fn = _c.value;
            fn();
          }
        } catch (e_4_1) {
          e_4 = {error: e_4_1};
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        this.animFrame.cancelAll();
      };
      return MDCTooltipFoundation2;
    }(MDCFoundation);
    var file$33 = "node_modules/@smui/tooltip/Tooltip.svelte";
    function create_fragment$44(ctx) {
      let div1;
      let div0;
      let div0_class_value;
      let div0_style_value;
      let div1_class_value;
      let div1_style_value;
      let div1_role_value;
      let div1_tabindex_value;
      let div1_data_mdc_tooltip_persist_value;
      let div1_data_mdc_tooltip_persistent_value;
      let useActions_action;
      let current;
      let mounted;
      let dispose;
      const default_slot_template = ctx[28].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
      let div0_levels = [
        {
          class: div0_class_value = classMap9({
            [ctx[6]]: true,
            "mdc-tooltip__surface": true,
            "mdc-tooltip__surface-animation": true
          })
        },
        {
          style: div0_style_value = Object.entries(ctx[13]).map(func5).concat([ctx[7]]).join(" ")
        },
        prefixFilter3(ctx[18], "surface$")
      ];
      let div0_data = {};
      for (let i = 0; i < div0_levels.length; i += 1) {
        div0_data = assign(div0_data, div0_levels[i]);
      }
      let div1_levels = [
        {
          class: div1_class_value = classMap9({
            [ctx[1]]: true,
            "mdc-tooltip": true,
            "mdc-tooltip--rich": ctx[17],
            ...ctx[10]
          })
        },
        {
          style: div1_style_value = Object.entries(ctx[11]).map(func_13).concat([ctx[2]]).join(" ")
        },
        {
          role: div1_role_value = ctx[17] && ctx[5] ? "dialog" : "tooltip"
        },
        {"aria-hidden": "true"},
        {id: ctx[3]},
        {
          tabindex: div1_tabindex_value = ctx[17] && ctx[4] ? "-1" : null
        },
        {
          "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value = ctx[17] && ctx[4] ? "true" : null
        },
        {
          "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value = ctx[17] && ctx[4] ? "true" : null
        },
        ctx[12],
        exclude3(ctx[18], ["surface$"])
      ];
      let div1_data = {};
      for (let i = 0; i < div1_levels.length; i += 1) {
        div1_data = assign(div1_data, div1_levels[i]);
      }
      const block = {
        c: function create2() {
          div1 = element("div");
          div0 = element("div");
          if (default_slot)
            default_slot.c();
          set_attributes(div0, div0_data);
          add_location(div0, file$33, 27, 2, 783);
          set_attributes(div1, div1_data);
          add_location(div1, file$33, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          if (default_slot) {
            default_slot.m(div0, null);
          }
          ctx[29](div1);
          current = true;
          if (!mounted) {
            dispose = [
              action_destroyer(useActions_action = useActions8.call(null, div1, ctx[0])),
              action_destroyer(ctx[14].call(null, div1)),
              listen_dev(div1, "transitionend", ctx[30], false, false, false)
            ];
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty[0] & 134217728)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[27], !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null), null);
            }
          }
          set_attributes(div0, div0_data = get_spread_update(div0_levels, [
            (!current || dirty[0] & 64 && div0_class_value !== (div0_class_value = classMap9({
              [ctx2[6]]: true,
              "mdc-tooltip__surface": true,
              "mdc-tooltip__surface-animation": true
            }))) && {class: div0_class_value},
            (!current || dirty[0] & 8320 && div0_style_value !== (div0_style_value = Object.entries(ctx2[13]).map(func5).concat([ctx2[7]]).join(" "))) && {style: div0_style_value},
            dirty[0] & 262144 && prefixFilter3(ctx2[18], "surface$")
          ]));
          set_attributes(div1, div1_data = get_spread_update(div1_levels, [
            (!current || dirty[0] & 1026 && div1_class_value !== (div1_class_value = classMap9({
              [ctx2[1]]: true,
              "mdc-tooltip": true,
              "mdc-tooltip--rich": ctx2[17],
              ...ctx2[10]
            }))) && {class: div1_class_value},
            (!current || dirty[0] & 2052 && div1_style_value !== (div1_style_value = Object.entries(ctx2[11]).map(func_13).concat([ctx2[2]]).join(" "))) && {style: div1_style_value},
            (!current || dirty[0] & 32 && div1_role_value !== (div1_role_value = ctx2[17] && ctx2[5] ? "dialog" : "tooltip")) && {role: div1_role_value},
            {"aria-hidden": "true"},
            (!current || dirty[0] & 8) && {id: ctx2[3]},
            (!current || dirty[0] & 16 && div1_tabindex_value !== (div1_tabindex_value = ctx2[17] && ctx2[4] ? "-1" : null)) && {tabindex: div1_tabindex_value},
            (!current || dirty[0] & 16 && div1_data_mdc_tooltip_persist_value !== (div1_data_mdc_tooltip_persist_value = ctx2[17] && ctx2[4] ? "true" : null)) && {
              "data-mdc-tooltip-persist": div1_data_mdc_tooltip_persist_value
            },
            (!current || dirty[0] & 16 && div1_data_mdc_tooltip_persistent_value !== (div1_data_mdc_tooltip_persistent_value = ctx2[17] && ctx2[4] ? "true" : null)) && {
              "data-mdc-tooltip-persistent": div1_data_mdc_tooltip_persistent_value
            },
            dirty[0] & 4096 && ctx2[12],
            dirty[0] & 262144 && exclude3(ctx2[18], ["surface$"])
          ]));
          if (useActions_action && is_function(useActions_action.update) && dirty[0] & 1)
            useActions_action.update.call(null, ctx2[0]);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div1);
          if (default_slot)
            default_slot.d(detaching);
          ctx[29](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$44.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    var counter3 = 0;
    var func5 = ([name, value]) => `${name}: ${value};`;
    var func_13 = ([name, value]) => `${name}: ${value};`;
    function instance_15($$self, $$props, $$invalidate) {
      const omit_props_names = [
        "use",
        "class",
        "style",
        "id",
        "unbounded",
        "xPos",
        "yPos",
        "persistent",
        "interactive",
        "surface$class",
        "surface$style",
        "attachScrollHandler",
        "removeScrollHandler",
        "getElement"
      ];
      let $$restProps = compute_rest_props($$props, omit_props_names);
      let $anchor;
      let $tooltip;
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Tooltip", slots, ["default"]);
      const forwardEvents = forwardEventsBuilder9(get_current_component());
      let {use: use2 = []} = $$props;
      let {class: className = ""} = $$props;
      let {style = ""} = $$props;
      let {id = "SMUI-tooltip-" + counter3++} = $$props;
      let {unbounded = false} = $$props;
      let {xPos = "detected"} = $$props;
      let {yPos = "detected"} = $$props;
      let {persistent = false} = $$props;
      let {interactive = persistent} = $$props;
      let {surface$class = ""} = $$props;
      let {surface$style = ""} = $$props;
      let element2;
      let instance9;
      let nonReactiveLocationStore = {
        setParent(value) {
          Object.defineProperty(this, "parent", {value});
        },
        setNextSibling(value) {
          Object.defineProperty(this, "nextSibling", {value});
        }
      };
      let internalClasses = {};
      let internalStyles = {};
      let internalAttrs = {};
      let surfaceStyles = {};
      let anchor = getContext("SMUI:tooltip:wrapper:anchor");
      validate_store(anchor, "anchor");
      component_subscribe($$self, anchor, (value) => $$invalidate(26, $anchor = value));
      let tooltip = getContext("SMUI:tooltip:wrapper:tooltip");
      validate_store(tooltip, "tooltip");
      component_subscribe($$self, tooltip, (value) => $$invalidate(31, $tooltip = value));
      const rich = getContext("SMUI:tooltip:rich");
      let previousAnchor = null;
      onMount(() => {
        $$invalidate(8, instance9 = new MDCTooltipFoundation({
          getAttribute: getAttr,
          setAttribute: addAttr,
          addClass,
          hasClass,
          removeClass,
          getComputedStyleProperty: (propertyName) => {
            const element3 = getElement();
            let style2 = getComputedStyle(element3).getPropertyValue(propertyName);
            if (style2 === "auto") {
              element3.classList.add("smui-banner--force-show");
              style2 = getComputedStyle(element3).getPropertyValue(propertyName);
              element3.classList.remove("smui-banner--force-show");
            }
            return style2;
          },
          setStyleProperty: addStyle,
          setSurfaceStyleProperty: addSurfaceStyle,
          getViewportWidth: () => window.innerWidth,
          getViewportHeight: () => window.innerHeight,
          getTooltipSize: () => {
            const element3 = getElement();
            let size = {
              width: element3.offsetWidth,
              height: element3.offsetHeight
            };
            if (size.width === 0 || size.height === 0) {
              element3.classList.add("smui-banner--force-show");
              size = {
                width: element3.offsetWidth,
                height: element3.offsetHeight
              };
              element3.classList.remove("smui-banner--force-show");
            }
            return size;
          },
          getAnchorBoundingRect: () => {
            return $anchor ? $anchor.getBoundingClientRect() : null;
          },
          getParentBoundingRect: () => {
            let parent2 = getElement().parentNode;
            if (!rich) {
              parent2 = document.body;
            }
            return parent2.getBoundingClientRect() || null;
          },
          getAnchorAttribute: (attr2) => {
            return $anchor ? $anchor.getAttribute(attr2) : null;
          },
          setAnchorAttribute: (attr2, value) => {
            $anchor && $anchor.setAttribute(attr2, value);
          },
          isRTL: () => getComputedStyle(getElement()).direction === "rtl",
          anchorContainsElement: (element3) => {
            return !!($anchor && $anchor.contains(element3));
          },
          tooltipContainsElement: (element3) => {
            return getElement().contains(element3);
          },
          focusAnchorElement: () => {
            $anchor && $anchor.focus();
          },
          registerEventHandler: (evt, handler) => {
            getElement().addEventListener(evt, handler);
          },
          deregisterEventHandler: (evt, handler) => {
            getElement().removeEventListener(evt, handler);
          },
          registerAnchorEventHandler: (evt, handler) => {
            $anchor && $anchor.addEventListener(evt, handler);
          },
          deregisterAnchorEventHandler: (evt, handler) => {
            $anchor && $anchor.removeEventListener(evt, handler);
          },
          registerDocumentEventHandler: (evt, handler) => {
            document.body.addEventListener(evt, handler);
          },
          deregisterDocumentEventHandler: (evt, handler) => {
            document.body.removeEventListener(evt, handler);
          },
          registerWindowEventHandler: (evt, handler) => {
            window.addEventListener(evt, handler, evt === "scroll" && {capture: true, passive: true});
          },
          deregisterWindowEventHandler: (evt, handler) => {
            window.removeEventListener(evt, handler, evt === "scroll" && {capture: true, passive: true});
          },
          notifyHidden: () => {
            dispatch5(getElement(), "MDCTooltip:hidden");
          }
        }));
        set_store_value(tooltip, $tooltip = element2, $tooltip);
        return () => {
          if ($anchor) {
            destroy($anchor);
          }
        };
      });
      onDestroy(() => {
        if (!rich && typeof document !== "undefined" && document.body === getElement().parentNode && nonReactiveLocationStore.parent.insertBefore) {
          nonReactiveLocationStore.parent.insertBefore(getElement(), nonReactiveLocationStore.nextSibling);
        }
      });
      function destroy(anchor2) {
        anchor2.removeEventListener("focusout", handleAnchorFocusOut);
        if (rich && persistent) {
          anchor2.removeEventListener("click", handleAnchorActivate);
          anchor2.removeEventListener("keydown", handleAnchorActivate);
        } else {
          anchor2.removeEventListener("mouseenter", handleAnchorMouseEnter);
          anchor2.removeEventListener("focusin", handleAnchorFocus);
          anchor2.removeEventListener("mouseleave", handleAnchorMouseLeave);
          anchor2.removeEventListener("touchstart", handleAnchorTouchStart);
          anchor2.removeEventListener("touchend", handleAnchorTouchEnd);
        }
        if (rich && interactive) {
          anchor2.removeAttribute("aria-haspopup");
          anchor2.removeAttribute("aria-expanded");
          anchor2.removeAttribute("data-tooltip-id");
        } else {
          anchor2.removeAttribute("aria-describedby");
        }
        instance9.destroy();
      }
      function init2(anchor2) {
        anchor2.addEventListener("focusout", handleAnchorFocusOut);
        if (rich && persistent) {
          anchor2.addEventListener("click", handleAnchorActivate);
          anchor2.addEventListener("keydown", handleAnchorActivate);
        } else {
          anchor2.addEventListener("mouseenter", handleAnchorMouseEnter);
          anchor2.addEventListener("focusin", handleAnchorFocus);
          anchor2.addEventListener("mouseleave", handleAnchorMouseLeave);
          anchor2.addEventListener("touchstart", handleAnchorTouchStart);
          anchor2.addEventListener("touchend", handleAnchorTouchEnd);
        }
        if (rich && interactive) {
          anchor2.setAttribute("aria-haspopup", "dialog");
          anchor2.setAttribute("aria-expanded", "false");
          anchor2.setAttribute("data-tooltip-id", id);
        } else {
          anchor2.setAttribute("aria-describedby", id);
        }
        if (!rich) {
          hoistToBody();
        }
        instance9.init();
      }
      function hasClass(className2) {
        return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
      }
      function addClass(className2) {
        if (!internalClasses[className2]) {
          $$invalidate(10, internalClasses[className2] = true, internalClasses);
        }
      }
      function removeClass(className2) {
        if (!(className2 in internalClasses) || internalClasses[className2]) {
          $$invalidate(10, internalClasses[className2] = false, internalClasses);
        }
      }
      function addStyle(name, value) {
        if (internalStyles[name] != value) {
          if (value === "" || value == null) {
            delete internalStyles[name];
            $$invalidate(11, internalStyles);
          } else {
            $$invalidate(11, internalStyles[name] = value, internalStyles);
          }
        }
      }
      function addSurfaceStyle(name, value) {
        if (surfaceStyles[name] != value) {
          if (value === "" || value == null) {
            delete surfaceStyles[name];
            $$invalidate(13, surfaceStyles);
          } else {
            $$invalidate(13, surfaceStyles[name] = value, surfaceStyles);
          }
        }
      }
      function getAttr(name) {
        return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
      }
      function addAttr(name, value) {
        if (internalAttrs[name] !== value) {
          $$invalidate(12, internalAttrs[name] = value, internalAttrs);
        }
      }
      function handleAnchorFocusOut(event) {
        if (element2.contains(event.relatedTarget)) {
          return;
        }
        instance9 && instance9.hide();
      }
      function handleAnchorActivate(event) {
        if (event.type === "keydown" && event.key !== "Enter" && event.key !== " ") {
          return;
        }
        instance9 && instance9.handleAnchorClick();
      }
      function handleAnchorMouseEnter() {
        instance9 && instance9.handleAnchorMouseEnter();
      }
      function handleAnchorFocus(event) {
        instance9 && instance9.handleAnchorFocus(event);
      }
      function handleAnchorMouseLeave() {
        instance9 && instance9.handleAnchorMouseLeave();
      }
      function handleAnchorTouchStart() {
        instance9 && instance9.handleAnchorTouchstart();
      }
      function handleAnchorTouchEnd() {
        instance9 && instance9.handleAnchorTouchend();
      }
      function hoistToBody() {
        if ($anchor && document.body !== getElement().parentNode) {
          nonReactiveLocationStore.setParent(getElement().parentNode);
          nonReactiveLocationStore.setNextSibling(getElement().nextSibling);
          document.body.appendChild(getElement());
        }
      }
      function attachScrollHandler(addEventListenerFn) {
        instance9 && instance9.attachScrollHandler(addEventListenerFn);
      }
      function removeScrollHandler(removeEventHandlerFn) {
        instance9 && instance9.removeScrollHandler(removeEventHandlerFn);
      }
      function getElement() {
        return element2;
      }
      function div1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          element2 = $$value;
          $$invalidate(9, element2);
        });
      }
      const transitionend_handler = () => instance9 && instance9.handleTransitionEnd();
      $$self.$$set = ($$new_props) => {
        $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
        $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
        if ("use" in $$new_props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("class" in $$new_props)
          $$invalidate(1, className = $$new_props.class);
        if ("style" in $$new_props)
          $$invalidate(2, style = $$new_props.style);
        if ("id" in $$new_props)
          $$invalidate(3, id = $$new_props.id);
        if ("unbounded" in $$new_props)
          $$invalidate(19, unbounded = $$new_props.unbounded);
        if ("xPos" in $$new_props)
          $$invalidate(20, xPos = $$new_props.xPos);
        if ("yPos" in $$new_props)
          $$invalidate(21, yPos = $$new_props.yPos);
        if ("persistent" in $$new_props)
          $$invalidate(4, persistent = $$new_props.persistent);
        if ("interactive" in $$new_props)
          $$invalidate(5, interactive = $$new_props.interactive);
        if ("surface$class" in $$new_props)
          $$invalidate(6, surface$class = $$new_props.surface$class);
        if ("surface$style" in $$new_props)
          $$invalidate(7, surface$style = $$new_props.surface$style);
        if ("$$scope" in $$new_props)
          $$invalidate(27, $$scope = $$new_props.$$scope);
      };
      $$self.$capture_state = () => ({
        counter: counter3,
        MDCTooltipFoundation,
        AnchorBoundaryType,
        XPosition,
        YPosition,
        onMount,
        onDestroy,
        getContext,
        get_current_component,
        forwardEventsBuilder: forwardEventsBuilder9,
        classMap: classMap9,
        exclude: exclude3,
        prefixFilter: prefixFilter3,
        useActions: useActions8,
        dispatch: dispatch5,
        forwardEvents,
        use: use2,
        className,
        style,
        id,
        unbounded,
        xPos,
        yPos,
        persistent,
        interactive,
        surface$class,
        surface$style,
        element: element2,
        instance: instance9,
        nonReactiveLocationStore,
        internalClasses,
        internalStyles,
        internalAttrs,
        surfaceStyles,
        anchor,
        tooltip,
        rich,
        previousAnchor,
        destroy,
        init: init2,
        hasClass,
        addClass,
        removeClass,
        addStyle,
        addSurfaceStyle,
        getAttr,
        addAttr,
        handleAnchorFocusOut,
        handleAnchorActivate,
        handleAnchorMouseEnter,
        handleAnchorFocus,
        handleAnchorMouseLeave,
        handleAnchorTouchStart,
        handleAnchorTouchEnd,
        hoistToBody,
        attachScrollHandler,
        removeScrollHandler,
        getElement,
        $anchor,
        $tooltip
      });
      $$self.$inject_state = ($$new_props) => {
        if ("use" in $$props)
          $$invalidate(0, use2 = $$new_props.use);
        if ("className" in $$props)
          $$invalidate(1, className = $$new_props.className);
        if ("style" in $$props)
          $$invalidate(2, style = $$new_props.style);
        if ("id" in $$props)
          $$invalidate(3, id = $$new_props.id);
        if ("unbounded" in $$props)
          $$invalidate(19, unbounded = $$new_props.unbounded);
        if ("xPos" in $$props)
          $$invalidate(20, xPos = $$new_props.xPos);
        if ("yPos" in $$props)
          $$invalidate(21, yPos = $$new_props.yPos);
        if ("persistent" in $$props)
          $$invalidate(4, persistent = $$new_props.persistent);
        if ("interactive" in $$props)
          $$invalidate(5, interactive = $$new_props.interactive);
        if ("surface$class" in $$props)
          $$invalidate(6, surface$class = $$new_props.surface$class);
        if ("surface$style" in $$props)
          $$invalidate(7, surface$style = $$new_props.surface$style);
        if ("element" in $$props)
          $$invalidate(9, element2 = $$new_props.element);
        if ("instance" in $$props)
          $$invalidate(8, instance9 = $$new_props.instance);
        if ("nonReactiveLocationStore" in $$props)
          nonReactiveLocationStore = $$new_props.nonReactiveLocationStore;
        if ("internalClasses" in $$props)
          $$invalidate(10, internalClasses = $$new_props.internalClasses);
        if ("internalStyles" in $$props)
          $$invalidate(11, internalStyles = $$new_props.internalStyles);
        if ("internalAttrs" in $$props)
          $$invalidate(12, internalAttrs = $$new_props.internalAttrs);
        if ("surfaceStyles" in $$props)
          $$invalidate(13, surfaceStyles = $$new_props.surfaceStyles);
        if ("anchor" in $$props)
          $$invalidate(15, anchor = $$new_props.anchor);
        if ("tooltip" in $$props)
          $$invalidate(16, tooltip = $$new_props.tooltip);
        if ("previousAnchor" in $$props)
          $$invalidate(25, previousAnchor = $$new_props.previousAnchor);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & 100663552) {
          if (instance9 && previousAnchor !== $anchor) {
            if (previousAnchor) {
              destroy(previousAnchor);
            }
            if ($anchor) {
              init2($anchor);
            }
            $$invalidate(25, previousAnchor = $anchor);
          }
        }
        if ($$self.$$.dirty[0] & 524544) {
          if (instance9) {
            instance9.setAnchorBoundaryType(AnchorBoundaryType[unbounded ? "UNBOUNDED" : "BOUNDED"]);
          }
        }
        if ($$self.$$.dirty[0] & 3145984) {
          if (instance9) {
            instance9.setTooltipPosition({
              xPos: XPosition[xPos.toUpperCase()],
              yPos: YPosition[yPos.toUpperCase()]
            });
          }
        }
      };
      return [
        use2,
        className,
        style,
        id,
        persistent,
        interactive,
        surface$class,
        surface$style,
        instance9,
        element2,
        internalClasses,
        internalStyles,
        internalAttrs,
        surfaceStyles,
        forwardEvents,
        anchor,
        tooltip,
        rich,
        $$restProps,
        unbounded,
        xPos,
        yPos,
        attachScrollHandler,
        removeScrollHandler,
        getElement,
        previousAnchor,
        $anchor,
        $$scope,
        slots,
        div1_binding,
        transitionend_handler
      ];
    }
    var Tooltip = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance_15, create_fragment$44, safe_not_equal, {
          use: 0,
          class: 1,
          style: 2,
          id: 3,
          unbounded: 19,
          xPos: 20,
          yPos: 21,
          persistent: 4,
          interactive: 5,
          surface$class: 6,
          surface$style: 7,
          attachScrollHandler: 22,
          removeScrollHandler: 23,
          getElement: 24
        }, null, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Tooltip",
          options,
          id: create_fragment$44.name
        });
      }
      get use() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set use(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get class() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set class(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get style() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set style(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get id() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set id(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get unbounded() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set unbounded(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get xPos() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set xPos(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get yPos() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set yPos(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get persistent() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set persistent(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get interactive() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set interactive(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get surface$class() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set surface$class(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get surface$style() {
        throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      set surface$style(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get attachScrollHandler() {
        return this.$$.ctx[22];
      }
      set attachScrollHandler(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get removeScrollHandler() {
        return this.$$.ctx[23];
      }
      set removeScrollHandler(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
      get getElement() {
        return this.$$.ctx[24];
      }
      set getElement(value) {
        throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }
    };
    var {Object: Object_1$1} = globals;
    var file$26 = "src/components/nav/main.svelte";
    function create_default_slot_15(ctx) {
      let icon;
      let current;
      icon = new CommonIcon({
        props: {
          component: Img,
          src: "/logo_pretzel.png",
          style: "width:180px;"
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current)
            return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_15.name,
        type: "slot",
        source: '(48:5) <Title class=\\"cursor-pointer p-2\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_14(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Planung");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_14.name,
        type: "slot",
        source: "(55:5) <Tooltip>",
        ctx
      });
      return block;
    }
    function create_default_slot_13(ctx) {
      let title;
      let t;
      let tooltip;
      let current;
      title = new Title2({
        props: {
          class: "cursor-pointer p-2",
          $$slots: {default: [create_default_slot_15]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_14]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(title.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(title, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const title_changes = {};
          if (dirty & 524288) {
            title_changes.$$scope = {dirty, ctx: ctx2};
          }
          title.$set(title_changes);
          const tooltip_changes = {};
          if (dirty & 524288) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(title.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(title.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(title, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(47:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_122(ctx) {
      let wrapper;
      let current;
      wrapper = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_13]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(wrapper.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(wrapper, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const wrapper_changes = {};
          if (dirty & 524288) {
            wrapper_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper.$set(wrapper_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(wrapper.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(wrapper.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(wrapper, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_122.name,
        type: "slot",
        source: '(46:3) <Section on:click={() => $goto(\\"/\\")}>',
        ctx
      });
      return block;
    }
    function create_default_slot_11(ctx) {
      let div;
      let t_value = (ctx[3]?.username || "DEMO") + "";
      let t;
      const block = {
        c: function create2() {
          div = element("div");
          t = text(t_value);
          attr_dev(div, "class", "sm:flex hidden");
          add_location(div, file$26, 59, 5, 1661);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
        },
        p: function update2(ctx2, dirty) {
          if (dirty & 8 && t_value !== (t_value = (ctx2[3]?.username || "DEMO") + ""))
            set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: "(59:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_else_block_2(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2.name,
        type: "else",
        source: "(66:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_32(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_32.name,
        type: "if",
        source: "(66:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_10(ctx) {
      let show_if;
      let if_block_anchor;
      function select_block_type(ctx2, dirty) {
        if (show_if == null || dirty & 16)
          show_if = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if)
          return create_if_block_32;
        return create_else_block_2;
      }
      let current_block_type = select_block_type(ctx, -1);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: '(65:5) <IconButton class=\\"material-icons\\" on:click={auth}       >',
        ctx
      });
      return block;
    }
    function create_else_block_12(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_12.name,
        type: "else",
        source: "(69:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_23(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_23.name,
        type: "if",
        source: "(69:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_92(ctx) {
      let show_if;
      let if_block_anchor;
      function select_block_type_1(ctx2, dirty) {
        if (show_if == null || dirty & 16)
          show_if = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if)
          return create_if_block_23;
        return create_else_block_12;
      }
      let current_block_type = select_block_type_1(ctx, -1);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create2() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
            if_block.d(1);
            if_block = current_block_type(ctx2);
            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching)
            detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_92.name,
        type: "slot",
        source: "(68:5) <Tooltip       >",
        ctx
      });
      return block;
    }
    function create_default_slot_82(ctx) {
      let iconbutton;
      let t;
      let tooltip;
      let current;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot_10]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[6]);
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_92]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(iconbutton.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconbutton, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const iconbutton_changes = {};
          if (dirty & 524304) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          const tooltip_changes = {};
          if (dirty & 524304) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconbutton.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconbutton.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconbutton, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_82.name,
        type: "slot",
        source: "(64:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_72(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("feedback");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_72.name,
        type: "slot",
        source: '(73:5) <IconButton class=\\"material-icons\\" on:click={reportProblem}>',
        ctx
      });
      return block;
    }
    function create_default_slot_62(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Idee oder Problem");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_62.name,
        type: "slot",
        source: "(76:5) <Tooltip>",
        ctx
      });
      return block;
    }
    function create_default_slot_52(ctx) {
      let iconbutton;
      let t;
      let tooltip;
      let current;
      iconbutton = new IconButton({
        props: {
          class: "material-icons",
          $$slots: {default: [create_default_slot_72]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      iconbutton.$on("click", ctx[7]);
      tooltip = new Tooltip({
        props: {
          $$slots: {default: [create_default_slot_62]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(iconbutton.$$.fragment);
          t = space();
          create_component(tooltip.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(iconbutton, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(tooltip, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const iconbutton_changes = {};
          if (dirty & 524288) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          iconbutton.$set(iconbutton_changes);
          const tooltip_changes = {};
          if (dirty & 524288) {
            tooltip_changes.$$scope = {dirty, ctx: ctx2};
          }
          tooltip.$set(tooltip_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(iconbutton.$$.fragment, local);
          transition_in(tooltip.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(iconbutton.$$.fragment, local);
          transition_out(tooltip.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(iconbutton, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(tooltip, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_52.name,
        type: "slot",
        source: "(72:4) <Wrapper>",
        ctx
      });
      return block;
    }
    function create_default_slot_42(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("menu");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_42.name,
        type: "slot",
        source: '(80:5) <IconButton       class=\\"material-icons\\"       on:click={() => (menuToggle = !menuToggle)}       bind:id={burger}       >',
        ctx
      });
      return block;
    }
    function create_else_block3(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Login");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block3.name,
        type: "else",
        source: "(88:53) {:else}",
        ctx
      });
      return block;
    }
    function create_if_block_13(ctx) {
      let t;
      const block = {
        c: function create2() {
          t = text("Logout");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(88:7) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_if_block6(ctx) {
      let li0;
      let t1;
      let li1;
      let t3;
      let li2;
      let mounted;
      let dispose;
      const block = {
        c: function create2() {
          li0 = element("li");
          li0.textContent = "Hilfe";
          t1 = space();
          li1 = element("li");
          li1.textContent = "Planung";
          t3 = space();
          li2 = element("li");
          li2.textContent = "Einstellungen";
          attr_dev(li0, "class", "cursor-pointer p-2");
          add_location(li0, file$26, 90, 5, 2642);
          attr_dev(li1, "class", "cursor-pointer p-2");
          add_location(li1, file$26, 96, 5, 2750);
          attr_dev(li2, "class", "cursor-pointer p-2");
          add_location(li2, file$26, 104, 5, 2876);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, li1, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, li2, anchor);
          if (!mounted) {
            dispose = [
              listen_dev(li0, "click", ctx[12], false, false, false),
              listen_dev(li1, "click", ctx[13], false, false, false),
              listen_dev(li2, "click", ctx[14], false, false, false)
            ];
            mounted = true;
          }
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(li0);
          if (detaching)
            detach_dev(t1);
          if (detaching)
            detach_dev(li1);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(li2);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block6.name,
        type: "if",
        source: "(90:5) {#if $user && Object.keys($user).length}",
        ctx
      });
      return block;
    }
    function create_default_slot_32(ctx) {
      let li;
      let show_if_1;
      let t;
      let show_if = ctx[4] && Object.keys(ctx[4]).length;
      let if_block1_anchor;
      let mounted;
      let dispose;
      function select_block_type_2(ctx2, dirty) {
        if (show_if_1 == null || dirty & 16)
          show_if_1 = !!(ctx2[4] && Object.keys(ctx2[4]).length);
        if (show_if_1)
          return create_if_block_13;
        return create_else_block3;
      }
      let current_block_type = select_block_type_2(ctx, -1);
      let if_block0 = current_block_type(ctx);
      let if_block1 = show_if && create_if_block6(ctx);
      const block = {
        c: function create2() {
          li = element("li");
          if_block0.c();
          t = space();
          if (if_block1)
            if_block1.c();
          if_block1_anchor = empty();
          attr_dev(li, "class", "cursor-pointer p-2");
          add_location(li, file$26, 86, 6, 2460);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          if_block0.m(li, null);
          insert_dev(target, t, anchor);
          if (if_block1)
            if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          if (!mounted) {
            dispose = listen_dev(li, "click", ctx[6], false, false, false);
            mounted = true;
          }
        },
        p: function update2(ctx2, dirty) {
          if (current_block_type !== (current_block_type = select_block_type_2(ctx2, dirty))) {
            if_block0.d(1);
            if_block0 = current_block_type(ctx2);
            if (if_block0) {
              if_block0.c();
              if_block0.m(li, null);
            }
          }
          if (dirty & 16)
            show_if = ctx2[4] && Object.keys(ctx2[4]).length;
          if (show_if) {
            if (if_block1) {
              if_block1.p(ctx2, dirty);
            } else {
              if_block1 = create_if_block6(ctx2);
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(li);
          if_block0.d();
          if (detaching)
            detach_dev(t);
          if (if_block1)
            if_block1.d(detaching);
          if (detaching)
            detach_dev(if_block1_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_32.name,
        type: "slot",
        source: "(86:5) <Menu bind:menuToggle>",
        ctx
      });
      return block;
    }
    function create_default_slot_22(ctx) {
      let wrapper0;
      let t0;
      let wrapper1;
      let t1;
      let wrapper2;
      let t2;
      let div;
      let iconbutton;
      let updating_id;
      let t3;
      let menu_1;
      let updating_menuToggle;
      let current;
      wrapper0 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_11]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      wrapper1 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_82]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      wrapper2 = new Wrapper({
        props: {
          $$slots: {default: [create_default_slot_52]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      function iconbutton_id_binding(value) {
        ctx[10](value);
      }
      let iconbutton_props = {
        class: "material-icons",
        $$slots: {default: [create_default_slot_42]},
        $$scope: {ctx}
      };
      if (ctx[0] !== void 0) {
        iconbutton_props.id = ctx[0];
      }
      iconbutton = new IconButton({props: iconbutton_props, $$inline: true});
      binding_callbacks.push(() => bind3(iconbutton, "id", iconbutton_id_binding));
      iconbutton.$on("click", ctx[11]);
      function menu_1_menuToggle_binding(value) {
        ctx[15](value);
      }
      let menu_1_props = {
        $$slots: {default: [create_default_slot_32]},
        $$scope: {ctx}
      };
      if (ctx[2] !== void 0) {
        menu_1_props.menuToggle = ctx[2];
      }
      menu_1 = new Menu2({props: menu_1_props, $$inline: true});
      binding_callbacks.push(() => bind3(menu_1, "menuToggle", menu_1_menuToggle_binding));
      const block = {
        c: function create2() {
          create_component(wrapper0.$$.fragment);
          t0 = space();
          create_component(wrapper1.$$.fragment);
          t1 = space();
          create_component(wrapper2.$$.fragment);
          t2 = space();
          div = element("div");
          create_component(iconbutton.$$.fragment);
          t3 = space();
          create_component(menu_1.$$.fragment);
          attr_dev(div, "class", "relative");
          add_location(div, file$26, 78, 4, 2253);
        },
        m: function mount(target, anchor) {
          mount_component(wrapper0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(wrapper1, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(wrapper2, target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, div, anchor);
          mount_component(iconbutton, div, null);
          append_dev(div, t3);
          mount_component(menu_1, div, null);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const wrapper0_changes = {};
          if (dirty & 524296) {
            wrapper0_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper0.$set(wrapper0_changes);
          const wrapper1_changes = {};
          if (dirty & 524304) {
            wrapper1_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper1.$set(wrapper1_changes);
          const wrapper2_changes = {};
          if (dirty & 524288) {
            wrapper2_changes.$$scope = {dirty, ctx: ctx2};
          }
          wrapper2.$set(wrapper2_changes);
          const iconbutton_changes = {};
          if (dirty & 524288) {
            iconbutton_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_id && dirty & 1) {
            updating_id = true;
            iconbutton_changes.id = ctx2[0];
            add_flush_callback(() => updating_id = false);
          }
          iconbutton.$set(iconbutton_changes);
          const menu_1_changes = {};
          if (dirty & 524336) {
            menu_1_changes.$$scope = {dirty, ctx: ctx2};
          }
          if (!updating_menuToggle && dirty & 4) {
            updating_menuToggle = true;
            menu_1_changes.menuToggle = ctx2[2];
            add_flush_callback(() => updating_menuToggle = false);
          }
          menu_1.$set(menu_1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(wrapper0.$$.fragment, local);
          transition_in(wrapper1.$$.fragment, local);
          transition_in(wrapper2.$$.fragment, local);
          transition_in(iconbutton.$$.fragment, local);
          transition_in(menu_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(wrapper0.$$.fragment, local);
          transition_out(wrapper1.$$.fragment, local);
          transition_out(wrapper2.$$.fragment, local);
          transition_out(iconbutton.$$.fragment, local);
          transition_out(menu_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(wrapper0, detaching);
          if (detaching)
            detach_dev(t0);
          destroy_component(wrapper1, detaching);
          if (detaching)
            detach_dev(t1);
          destroy_component(wrapper2, detaching);
          if (detaching)
            detach_dev(t2);
          if (detaching)
            detach_dev(div);
          destroy_component(iconbutton);
          destroy_component(menu_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_22.name,
        type: "slot",
        source: '(58:3) <Section align=\\"end\\">',
        ctx
      });
      return block;
    }
    function create_default_slot_16(ctx) {
      let section0;
      let t;
      let section1;
      let current;
      section0 = new Section({
        props: {
          $$slots: {default: [create_default_slot_122]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      section0.$on("click", ctx[9]);
      section1 = new Section({
        props: {
          align: "end",
          $$slots: {default: [create_default_slot_22]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(section0.$$.fragment);
          t = space();
          create_component(section1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(section0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(section1, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const section0_changes = {};
          if (dirty & 524288) {
            section0_changes.$$scope = {dirty, ctx: ctx2};
          }
          section0.$set(section0_changes);
          const section1_changes = {};
          if (dirty & 524349) {
            section1_changes.$$scope = {dirty, ctx: ctx2};
          }
          section1.$set(section1_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(section0.$$.fragment, local);
          transition_in(section1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(section0.$$.fragment, local);
          transition_out(section1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(section0, detaching);
          if (detaching)
            detach_dev(t);
          destroy_component(section1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_16.name,
        type: "slot",
        source: "(45:2) <Row>",
        ctx
      });
      return block;
    }
    function create_default_slot8(ctx) {
      let row;
      let current;
      row = new Row({
        props: {
          $$slots: {default: [create_default_slot_16]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          create_component(row.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p: function update2(ctx2, dirty) {
          const row_changes = {};
          if (dirty & 524349) {
            row_changes.$$scope = {dirty, ctx: ctx2};
          }
          row.$set(row_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(row, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot8.name,
        type: "slot",
        source: '(44:1) <TopAppBar variant=\\"static\\">',
        ctx
      });
      return block;
    }
    function create_fragment$36(ctx) {
      let header;
      let topappbar;
      let current;
      let mounted;
      let dispose;
      add_render_callback(ctx[8]);
      topappbar = new TopAppBar({
        props: {
          variant: "static",
          $$slots: {default: [create_default_slot8]},
          $$scope: {ctx}
        },
        $$inline: true
      });
      const block = {
        c: function create2() {
          header = element("header");
          create_component(topappbar.$$.fragment);
          add_location(header, file$26, 42, 0, 1297);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, header, anchor);
          mount_component(topappbar, header, null);
          current = true;
          if (!mounted) {
            dispose = listen_dev(window, "resize", ctx[8]);
            mounted = true;
          }
        },
        p: function update2(ctx2, [dirty]) {
          const topappbar_changes = {};
          if (dirty & 524349) {
            topappbar_changes.$$scope = {dirty, ctx: ctx2};
          }
          topappbar.$set(topappbar_changes);
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(topappbar.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(topappbar.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(header);
          destroy_component(topappbar);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$36.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$36($$self, $$props, $$invalidate) {
      let $modal;
      let $redirect;
      let $userSettings;
      let $user;
      let $goto;
      validate_store(modal, "modal");
      component_subscribe($$self, modal, ($$value) => $$invalidate(16, $modal = $$value));
      validate_store(redirect, "redirect");
      component_subscribe($$self, redirect, ($$value) => $$invalidate(17, $redirect = $$value));
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(3, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(4, $user = $$value));
      validate_store(goto, "goto");
      component_subscribe($$self, goto, ($$value) => $$invalidate(5, $goto = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Main", slots, []);
      let menu;
      let burger;
      let width;
      let menuToggle = false;
      function auth() {
        if ($user && Object.keys($user).length) {
          localStorage.clear();
          set_store_value(user, $user = {}, $user);
          set_store_value(userSettings, $userSettings = {}, $userSettings);
        } else {
          set_store_value(modal, $modal.title = "Login", $modal);
          set_store_value(modal, $modal.component = Login, $modal);
        }
        $redirect("/settings");
      }
      function reportProblem() {
        set_store_value(modal, $modal.title = "Idee oder Problem melden", $modal);
        set_store_value(modal, $modal.component = ReportProblem, $modal);
      }
      const writable_props = [];
      Object_1$1.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Main> was created with unknown prop '${key}'`);
      });
      function onwindowresize() {
        $$invalidate(1, width = window.outerWidth);
      }
      const click_handler = () => $goto("/");
      function iconbutton_id_binding(value) {
        burger = value;
        $$invalidate(0, burger);
      }
      const click_handler_1 = () => $$invalidate(2, menuToggle = !menuToggle);
      const click_handler_2 = () => $goto("/help");
      const click_handler_3 = () => {
        $goto("/");
      };
      const click_handler_4 = () => {
        $goto("/settings");
      };
      function menu_1_menuToggle_binding(value) {
        menuToggle = value;
        $$invalidate(2, menuToggle);
      }
      $$self.$capture_state = () => ({
        ReportProblem,
        modal,
        user,
        userSettings,
        TopAppBar,
        Row,
        Section,
        Title: Title2,
        IconButton,
        Img,
        Icon: CommonIcon,
        Menu: Menu2,
        Login,
        Wrapper,
        Tooltip,
        goto,
        redirect,
        menu,
        burger,
        width,
        menuToggle,
        auth,
        reportProblem,
        $modal,
        $redirect,
        $userSettings,
        $user,
        $goto
      });
      $$self.$inject_state = ($$props2) => {
        if ("menu" in $$props2)
          menu = $$props2.menu;
        if ("burger" in $$props2)
          $$invalidate(0, burger = $$props2.burger);
        if ("width" in $$props2)
          $$invalidate(1, width = $$props2.width);
        if ("menuToggle" in $$props2)
          $$invalidate(2, menuToggle = $$props2.menuToggle);
      };
      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }
      return [
        burger,
        width,
        menuToggle,
        $userSettings,
        $user,
        $goto,
        auth,
        reportProblem,
        onwindowresize,
        click_handler,
        iconbutton_id_binding,
        click_handler_1,
        click_handler_2,
        click_handler_3,
        click_handler_4,
        menu_1_menuToggle_binding
      ];
    }
    var Main = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$36, create_fragment$36, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Main",
          options,
          id: create_fragment$36.name
        });
      }
    };
    var file$18 = "src/components/Footer.svelte";
    function add_css$1(target) {
      append_styles(target, "svelte-1puri16", "footer.svelte-1puri16{background-color:var(--mdc-theme-footer)}.copyright.svelte-1puri16{color:#aaa;font-size:14px;display:inline-block;padding:5px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9vdGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFDQyxNQUFBLGVBQUEsQ0FBQSxBQUNDLGdCQUFBLENBQUEsSUFBQSxrQkFBQSxDQUF5QyxBQUMxQyxDQUFBLEFBQ0EsVUFBQSxlQUFBLENBQUEsQUFDQyxLQUFBLENBQUEsSUFBVyxDQUNYLFNBQUEsQ0FBQSxJQUFlLENBQ2YsT0FBQSxDQUFBLFlBQXFCLENBQ3JCLE9BQUEsQ0FBQSxHQUFZLEFBRWIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJzcmMvY29tcG9uZW50cy9zcmMvY29tcG9uZW50cy9Gb290ZXIuc3ZlbHRlIl19 */");
    }
    function create_fragment$28(ctx) {
      let footer;
      let div0;
      let t1;
      let div1;
      let t3;
      let div2;
      let t5;
      let div3;
      let t7;
      let div4;
      const block = {
        c: function create2() {
          footer = element("footer");
          div0 = element("div");
          div0.textContent = "\xA9 2021 ml4all";
          t1 = space();
          div1 = element("div");
          div1.textContent = "\u2022";
          t3 = space();
          div2 = element("div");
          div2.textContent = "Impressum";
          t5 = space();
          div3 = element("div");
          div3.textContent = "\u2022";
          t7 = space();
          div4 = element("div");
          div4.textContent = "Datenschutzerkl\xE4rung";
          attr_dev(div0, "class", "copyright svelte-1puri16");
          add_location(div0, file$18, 1, 1, 49);
          attr_dev(div1, "class", "copyright svelte-1puri16");
          add_location(div1, file$18, 2, 1, 93);
          attr_dev(div2, "class", "copyright svelte-1puri16");
          add_location(div2, file$18, 3, 1, 125);
          attr_dev(div3, "class", "copyright svelte-1puri16");
          add_location(div3, file$18, 4, 1, 165);
          attr_dev(div4, "class", "copyright svelte-1puri16");
          add_location(div4, file$18, 5, 1, 197);
          attr_dev(footer, "class", "mt-auto w-full p-4 text-center svelte-1puri16");
          add_location(footer, file$18, 0, 0, 0);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, footer, anchor);
          append_dev(footer, div0);
          append_dev(footer, t1);
          append_dev(footer, div1);
          append_dev(footer, t3);
          append_dev(footer, div2);
          append_dev(footer, t5);
          append_dev(footer, div3);
          append_dev(footer, t7);
          append_dev(footer, div4);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching)
            detach_dev(footer);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$28.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$27($$self, $$props) {
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Footer", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Footer> was created with unknown prop '${key}'`);
      });
      return [];
    }
    var Footer = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$27, create_fragment$28, safe_not_equal, {}, add_css$1);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Footer",
          options,
          id: create_fragment$28.name
        });
      }
    };
    var {Object: Object_12} = globals;
    function create_fragment$18(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$18.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance$17($$self, $$props, $$invalidate) {
      let $userSettings;
      let $user;
      validate_store(userSettings, "userSettings");
      component_subscribe($$self, userSettings, ($$value) => $$invalidate(1, $userSettings = $$value));
      validate_store(user, "user");
      component_subscribe($$self, user, ($$value) => $$invalidate(0, $user = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("BackendStores", slots, []);
      async function updateUserSettings() {
        if (!$user || Object.keys($user).length == 0) {
          return;
        }
        if ($user && Object.keys($user).length) {
          await axios.put(`${backendURL}/api/usersettings/`, $userSettings);
        }
      }
      async function getUserSettings() {
        if ($user && Object.keys($user).length) {
          let {data} = await axios.get(`${backendURL}/api/usersettings/`);
          set_store_value(userSettings, $userSettings = JSON.parse(JSON.stringify(data)), $userSettings);
        }
      }
      const writable_props = [];
      Object_12.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<BackendStores> was created with unknown prop '${key}'`);
      });
      $$self.$capture_state = () => ({
        axios,
        user,
        userSettings,
        backendURL,
        updateUserSettings,
        getUserSettings,
        $userSettings,
        $user
      });
      $$self.$$.update = () => {
        if ($$self.$$.dirty & 1) {
          if ($user) {
            getUserSettings();
            let startTime = new Date($user.expires);
            let interval = setInterval(() => {
              let currentTime = new Date();
              if (currentTime > startTime) {
                clearInterval(interval);
                localStorage.removeItem("auth");
                set_store_value(user, $user = {}, $user);
              }
            }, 1e3);
          }
        }
      };
      return [$user];
    }
    var BackendStores = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance$17, create_fragment$18, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "BackendStores",
          options,
          id: create_fragment$18.name
        });
      }
    };
    var file9 = "src/pages/_layout.svelte";
    function add_css2(target) {
      append_styles(target, "svelte-15xksm", ".svelte-15xksm{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__leading{border-radius:28px 0 0 28px;width:28px}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__trailing{border-radius:0 28px 28px 0}.svelte-15xksm .shaped-outlined\n			.mdc-notched-outline\n			.mdc-notched-outline__notch{max-width:calc(100% - 28px * 2)}.svelte-15xksm .shaped-outlined{width:100px;height:35px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2xheW91dC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBQ0MsY0FBQSxDQUFBLEFBQ0Msa0JBQUEsQ0FBQSxVQUE4QixDQUM5QixlQUFBLENBQUEsVUFBMkIsQ0FDM0IsVUFBQSxDQUFBLFVBQXNCLEFBQ3ZCLENBQUEsQUFFQSxjQUFBOztpQ0FJQyxhQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBNEIsQ0FDNUIsS0FBQSxDQUFBLElBQVcsQUFDWixDQUFBLEFBQ0EsY0FBQTs7a0NBSUMsYUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQSxDQUFBLENBQTRCLEFBQzdCLENBQUEsQUFDQSxjQUFBOzsrQkFJQyxTQUFBLENBQUEsS0FBQSxJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQyxBQUNqQyxDQUFBLEFBQ0EsY0FBQSxDQUFBLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFBQ0MsS0FBQSxDQUFBLEtBQVksQ0FDWixNQUFBLENBQUEsSUFBWSxBQUNiLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsic3JjL3BhZ2VzL3NyYy9wYWdlcy9fbGF5b3V0LnN2ZWx0ZSJdfQ== */");
    }
    function create_fragment10(ctx) {
      let backend;
      let t0;
      let link0;
      let link1;
      let link2;
      let link3;
      let link4;
      let t1;
      let notification2;
      let t2;
      let modal2;
      let t3;
      let main;
      let nav;
      let t4;
      let div;
      let t5;
      let footer;
      let current;
      backend = new BackendStores({$$inline: true});
      notification2 = new Notification({$$inline: true});
      modal2 = new Main$1({$$inline: true});
      nav = new Main({$$inline: true});
      const default_slot_template = ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
      footer = new Footer({$$inline: true});
      const block = {
        c: function create2() {
          create_component(backend.$$.fragment);
          t0 = space();
          link0 = element("link");
          link1 = element("link");
          link2 = element("link");
          link3 = element("link");
          link4 = element("link");
          t1 = space();
          create_component(notification2.$$.fragment);
          t2 = space();
          create_component(modal2.$$.fragment);
          t3 = space();
          main = element("main");
          create_component(nav.$$.fragment);
          t4 = space();
          div = element("div");
          if (default_slot)
            default_slot.c();
          t5 = space();
          create_component(footer.$$.fragment);
          attr_dev(link0, "rel", "stylesheet");
          attr_dev(link0, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
          attr_dev(link0, "class", "svelte-15xksm");
          add_location(link0, file9, 13, 1, 412);
          attr_dev(link1, "rel", "stylesheet");
          attr_dev(link1, "href", "https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700");
          attr_dev(link1, "class", "svelte-15xksm");
          add_location(link1, file9, 17, 1, 507);
          attr_dev(link2, "rel", "stylesheet");
          attr_dev(link2, "href", "https://unpkg.com/@material/typography@11.0.0/dist/mdc.typography.css");
          attr_dev(link2, "class", "svelte-15xksm");
          add_location(link2, file9, 23, 1, 644);
          attr_dev(link3, "rel", "stylesheet");
          attr_dev(link3, "href", "/foodsight.css");
          attr_dev(link3, "class", "svelte-15xksm");
          add_location(link3, file9, 29, 1, 769);
          attr_dev(link4, "rel", "stylesheet");
          attr_dev(link4, "href", "/bare.css");
          attr_dev(link4, "class", "svelte-15xksm");
          add_location(link4, file9, 30, 1, 818);
          attr_dev(div, "class", "p-2 h-full overflow-y-auto  svelte-15xksm");
          add_location(div, file9, 37, 1, 985);
          attr_dev(main, "class", "flex flex-col h-screen  svelte-15xksm");
          add_location(main, file9, 35, 0, 904);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(backend, target, anchor);
          insert_dev(target, t0, anchor);
          append_dev(document.head, link0);
          append_dev(document.head, link1);
          append_dev(document.head, link2);
          append_dev(document.head, link3);
          append_dev(document.head, link4);
          insert_dev(target, t1, anchor);
          mount_component(notification2, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(modal2, target, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, main, anchor);
          mount_component(nav, main, null);
          append_dev(main, t4);
          append_dev(main, div);
          if (default_slot) {
            default_slot.m(div, null);
          }
          append_dev(main, t5);
          mount_component(footer, main, null);
          ctx[3](main);
          current = true;
        },
        p: function update2(ctx2, [dirty]) {
          if (default_slot) {
            if (default_slot.p && (!current || dirty & 2)) {
              update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
            }
          }
        },
        i: function intro(local) {
          if (current)
            return;
          transition_in(backend.$$.fragment, local);
          transition_in(notification2.$$.fragment, local);
          transition_in(modal2.$$.fragment, local);
          transition_in(nav.$$.fragment, local);
          transition_in(default_slot, local);
          transition_in(footer.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(backend.$$.fragment, local);
          transition_out(notification2.$$.fragment, local);
          transition_out(modal2.$$.fragment, local);
          transition_out(nav.$$.fragment, local);
          transition_out(default_slot, local);
          transition_out(footer.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(backend, detaching);
          if (detaching)
            detach_dev(t0);
          detach_dev(link0);
          detach_dev(link1);
          detach_dev(link2);
          detach_dev(link3);
          detach_dev(link4);
          if (detaching)
            detach_dev(t1);
          destroy_component(notification2, detaching);
          if (detaching)
            detach_dev(t2);
          destroy_component(modal2, detaching);
          if (detaching)
            detach_dev(t3);
          if (detaching)
            detach_dev(main);
          destroy_component(nav);
          if (default_slot)
            default_slot.d(detaching);
          destroy_component(footer);
          ctx[3](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }
    function instance8($$self, $$props, $$invalidate) {
      let $svelteRenderParent;
      validate_store(svelteRenderParent, "svelteRenderParent");
      component_subscribe($$self, svelteRenderParent, ($$value) => $$invalidate(0, $svelteRenderParent = $$value));
      let {$$slots: slots = {}, $$scope} = $$props;
      validate_slots("Layout", slots, ["default"]);
      const writable_props = [];
      Object.keys($$props).forEach((key) => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
          console.warn(`<Layout> was created with unknown prop '${key}'`);
      });
      function main_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          $svelteRenderParent = $$value;
          svelteRenderParent.set($svelteRenderParent);
        });
      }
      $$self.$$set = ($$props2) => {
        if ("$$scope" in $$props2)
          $$invalidate(1, $$scope = $$props2.$$scope);
      };
      $$self.$capture_state = () => ({
        Notification,
        Modal: Main$1,
        Nav: Main,
        Footer,
        Backend: BackendStores,
        svelteRenderParent,
        $svelteRenderParent
      });
      return [$svelteRenderParent, $$scope, slots, main_binding];
    }
    var Layout = class extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init$1(this, options, instance8, create_fragment10, safe_not_equal, {}, add_css2);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Layout",
          options,
          id: create_fragment10.name
        });
      }
    };
  });

  // dist/build/main.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  function HMR(Component, options = {target: document.body}, id = "hmr", eventName = "app-loaded") {
    const prerenderedHtmlElement = document.getElementById(id);
    const target = document.createElement("div");
    target.style.visibility = "hidden";
    options.target.appendChild(target);
    if (!prerenderedHtmlElement)
      showApp();
    else
      addEventListener(eventName, showApp);
    function showApp() {
      removeEventListener(eventName, showApp);
      if (prerenderedHtmlElement)
        prerenderedHtmlElement.remove();
      target.style.visibility = null;
      target.setAttribute("id", id);
    }
    return new Component({...options, target});
  }
  function noop() {
  }
  var identity = (x) => x;
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return tar;
  }
  function is_promise(value) {
    return value && typeof value === "object" && typeof value.then === "function";
  }
  function add_location(element2, file9, line, column, char) {
    element2.__svelte_meta = {
      loc: {file: file9, line, column, char}
    };
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url2) {
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url2;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== "function") {
      throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function get_store_value(store) {
    let value;
    subscribe(store, (_2) => value = _2)();
    return value;
  }
  function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
  }
  function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
      const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
      return definition[0](slot_ctx);
    }
  }
  function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
  }
  function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
      const lets = definition[2](fn(dirty));
      if ($$scope.dirty === void 0) {
        return lets;
      }
      if (typeof lets === "object") {
        const merged = [];
        const len = Math.max($$scope.dirty.length, lets.length);
        for (let i = 0; i < len; i += 1) {
          merged[i] = $$scope.dirty[i] | lets[i];
        }
        return merged;
      }
      return $$scope.dirty | lets;
    }
    return $$scope.dirty;
  }
  function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
      const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
      slot.p(slot_context, slot_changes);
    }
  }
  function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
      const dirty = [];
      const length = $$scope.ctx.length / 32;
      for (let i = 0; i < length; i++) {
        dirty[i] = -1;
      }
      return dirty;
    }
    return -1;
  }
  function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
      if (k[0] !== "$")
        result[k] = props[k];
    return result;
  }
  function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
      if (!keys.has(k) && k[0] !== "$")
        rest[k] = props[k];
    return rest;
  }
  function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
      result[key] = true;
    }
    return result;
  }
  function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
  }
  function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
  }
  var is_client = typeof window !== "undefined";
  var now = is_client ? () => window.performance.now() : () => Date.now();
  var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
  var tasks = new Set();
  function run_tasks(now2) {
    tasks.forEach((task) => {
      if (!task.c(now2)) {
        tasks.delete(task);
        task.f();
      }
    });
    if (tasks.size !== 0)
      raf(run_tasks);
  }
  function loop(callback) {
    let task;
    if (tasks.size === 0)
      raf(run_tasks);
    return {
      promise: new Promise((fulfill) => {
        tasks.add(task = {c: callback, f: fulfill});
      }),
      abort() {
        tasks.delete(task);
      }
    };
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
      const style = element("style");
      style.id = style_sheet_id;
      style.textContent = styles;
      append_stylesheet(append_styles_to, style);
    }
  }
  function get_root_for_style(node) {
    if (!node)
      return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
      return root;
    }
    return node.ownerDocument;
  }
  function append_empty_stylesheet(node) {
    const style_element = element("style");
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
  }
  function append_stylesheet(node, style) {
    append(node.head || node, style);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function prevent_default(fn) {
    return function(event) {
      event.preventDefault();
      return fn.call(this, event);
    };
  }
  function stop_propagation(fn) {
    return function(event) {
      event.stopPropagation();
      return fn.call(this, event);
    };
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes) {
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
      if (attributes[key] == null) {
        node.removeAttribute(key);
      } else if (key === "style") {
        node.style.cssText = attributes[key];
      } else if (key === "__value") {
        node.value = node[key] = attributes[key];
      } else if (descriptors[key] && descriptors[key].set) {
        node[key] = attributes[key];
      } else {
        attr(node, key, attributes[key]);
      }
    }
  }
  function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
      attr(node, key, attributes[key]);
    }
  }
  function to_number(value) {
    return value === "" ? null : +value;
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? "important" : "");
  }
  function toggle_class(element2, name, toggle) {
    element2.classList[toggle ? "add" : "remove"](name);
  }
  function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent("CustomEvent");
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
  }
  var active_docs = new Set();
  var active = 0;
  function hash(str) {
    let hash2 = 5381;
    let i = str.length;
    while (i--)
      hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
    return hash2 >>> 0;
  }
  function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = "{\n";
    for (let p = 0; p <= 1; p += step) {
      const t = a + (b - a) * ease(p);
      keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
      current_rules[name] = true;
      stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || "";
    node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
  }
  function delete_rule(node, name) {
    const previous = (node.style.animation || "").split(", ");
    const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
    const deleted = previous.length - next.length;
    if (deleted) {
      node.style.animation = next.join(", ");
      active -= deleted;
      if (!active)
        clear_rules();
    }
  }
  function clear_rules() {
    raf(() => {
      if (active)
        return;
      active_docs.forEach((doc) => {
        const stylesheet = doc.__svelte_stylesheet;
        let i = stylesheet.cssRules.length;
        while (i--)
          stylesheet.deleteRule(i);
        doc.__svelte_rules = {};
      });
      active_docs.clear();
    });
  }
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
  }
  function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
  }
  function getContext(key) {
    return get_current_component().$$.context.get(key);
  }
  function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, event));
    }
  }
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function tick() {
    schedule_update();
    return resolved_promise;
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  var flushing = false;
  var seen_callbacks = new Set();
  function flush() {
    if (flushing)
      return;
    flushing = true;
    do {
      for (let i = 0; i < dirty_components.length; i += 1) {
        const component = dirty_components[i];
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  var promise;
  function wait() {
    if (!promise) {
      promise = Promise.resolve();
      promise.then(() => {
        promise = null;
      });
    }
    return promise;
  }
  function dispatch4(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
  }
  var outroing = new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    }
  }
  var null_transition = {duration: 0};
  function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
      if (animation_name)
        delete_rule(node, animation_name);
    }
    function go() {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      if (css)
        animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
      tick2(0, 1);
      const start_time = now() + delay;
      const end_time = start_time + duration;
      if (task)
        task.abort();
      running = true;
      add_render_callback(() => dispatch4(node, true, "start"));
      task = loop((now2) => {
        if (running) {
          if (now2 >= end_time) {
            tick2(1, 0);
            dispatch4(node, true, "end");
            cleanup();
            return running = false;
          }
          if (now2 >= start_time) {
            const t = easing((now2 - start_time) / duration);
            tick2(t, 1 - t);
          }
        }
        return running;
      });
    }
    let started = false;
    return {
      start() {
        if (started)
          return;
        started = true;
        delete_rule(node);
        if (is_function(config)) {
          config = config();
          wait().then(go);
        } else {
          go();
        }
      },
      invalidate() {
        started = false;
      },
      end() {
        if (running) {
          cleanup();
          running = false;
        }
      }
    };
  }
  function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      if (css)
        animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
      const start_time = now() + delay;
      const end_time = start_time + duration;
      add_render_callback(() => dispatch4(node, false, "start"));
      loop((now2) => {
        if (running) {
          if (now2 >= end_time) {
            tick2(0, 1);
            dispatch4(node, false, "end");
            if (!--group.r) {
              run_all(group.c);
            }
            return false;
          }
          if (now2 >= start_time) {
            const t = easing((now2 - start_time) / duration);
            tick2(1 - t, t);
          }
        }
        return running;
      });
    }
    if (is_function(config)) {
      wait().then(() => {
        config = config();
        go();
      });
    } else {
      go();
    }
    return {
      end(reset) {
        if (reset && config.tick) {
          config.tick(1, 0);
        }
        if (running) {
          if (animation_name)
            delete_rule(node, animation_name);
          running = false;
        }
      }
    };
  }
  function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
      if (animation_name)
        delete_rule(node, animation_name);
    }
    function init2(program, duration) {
      const d = program.b - t;
      duration *= Math.abs(d);
      return {
        a: t,
        b: program.b,
        d,
        duration,
        start: program.start,
        end: program.start + duration,
        group: program.group
      };
    }
    function go(b) {
      const {delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css} = config || null_transition;
      const program = {
        start: now() + delay,
        b
      };
      if (!b) {
        program.group = outros;
        outros.r += 1;
      }
      if (running_program || pending_program) {
        pending_program = program;
      } else {
        if (css) {
          clear_animation();
          animation_name = create_rule(node, t, b, duration, delay, easing, css);
        }
        if (b)
          tick2(0, 1);
        running_program = init2(program, duration);
        add_render_callback(() => dispatch4(node, b, "start"));
        loop((now2) => {
          if (pending_program && now2 > pending_program.start) {
            running_program = init2(pending_program, duration);
            pending_program = null;
            dispatch4(node, running_program.b, "start");
            if (css) {
              clear_animation();
              animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
            }
          }
          if (running_program) {
            if (now2 >= running_program.end) {
              tick2(t = running_program.b, 1 - t);
              dispatch4(node, running_program.b, "end");
              if (!pending_program) {
                if (running_program.b) {
                  clear_animation();
                } else {
                  if (!--running_program.group.r)
                    run_all(running_program.group.c);
                }
              }
              running_program = null;
            } else if (now2 >= running_program.start) {
              const p = now2 - running_program.start;
              t = running_program.a + running_program.d * easing(p / running_program.duration);
              tick2(t, 1 - t);
            }
          }
          return !!(running_program || pending_program);
        });
      }
    }
    return {
      run(b) {
        if (is_function(config)) {
          wait().then(() => {
            config = config();
            go(b);
          });
        } else {
          go(b);
        }
      },
      end() {
        clear_animation();
        running_program = pending_program = null;
      }
    };
  }
  function handle_promise(promise2, info) {
    const token = info.token = {};
    function update2(type, index, key, value) {
      if (info.token !== token)
        return;
      info.resolved = value;
      let child_ctx = info.ctx;
      if (key !== void 0) {
        child_ctx = child_ctx.slice();
        child_ctx[key] = value;
      }
      const block = type && (info.current = type)(child_ctx);
      let needs_flush = false;
      if (info.block) {
        if (info.blocks) {
          info.blocks.forEach((block2, i) => {
            if (i !== index && block2) {
              group_outros();
              transition_out(block2, 1, 1, () => {
                if (info.blocks[i] === block2) {
                  info.blocks[i] = null;
                }
              });
              check_outros();
            }
          });
        } else {
          info.block.d(1);
        }
        block.c();
        transition_in(block, 1);
        block.m(info.mount(), info.anchor);
        needs_flush = true;
      }
      info.block = block;
      if (info.blocks)
        info.blocks[index] = block;
      if (needs_flush) {
        flush();
      }
    }
    if (is_promise(promise2)) {
      const current_component2 = get_current_component();
      promise2.then((value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      }, (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      });
      if (info.current !== info.pending) {
        update2(info.pending, 0);
        return true;
      }
    } else {
      if (info.current !== info.then) {
        update2(info.then, 1, info.value, promise2);
        return true;
      }
      info.resolved = promise2;
    }
  }
  function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const {resolved} = info;
    if (info.current === info.then) {
      child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
      child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
  }
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
  }
  function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
      lookup.delete(block.key);
    });
  }
  function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
      old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
      const child_ctx = get_context(ctx, list, i);
      const key = get_key(child_ctx);
      let block = lookup.get(key);
      if (!block) {
        block = create_each_block2(key, child_ctx);
        block.c();
      } else if (dynamic) {
        block.p(child_ctx, dirty);
      }
      new_lookup.set(key, new_blocks[i] = block);
      if (key in old_indexes)
        deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert2(block) {
      transition_in(block, 1);
      block.m(node, next);
      lookup.set(block.key, block);
      next = block.first;
      n--;
    }
    while (o && n) {
      const new_block = new_blocks[n - 1];
      const old_block = old_blocks[o - 1];
      const new_key = new_block.key;
      const old_key = old_block.key;
      if (new_block === old_block) {
        next = new_block.first;
        o--;
        n--;
      } else if (!new_lookup.has(old_key)) {
        destroy(old_block, lookup);
        o--;
      } else if (!lookup.has(new_key) || will_move.has(new_key)) {
        insert2(new_block);
      } else if (did_move.has(old_key)) {
        o--;
      } else if (deltas.get(new_key) > deltas.get(old_key)) {
        did_move.add(new_key);
        insert2(new_block);
      } else {
        will_move.add(old_key);
        o--;
      }
    }
    while (o--) {
      const old_block = old_blocks[o];
      if (!new_lookup.has(old_block.key))
        destroy(old_block, lookup);
    }
    while (n)
      insert2(new_blocks[n - 1]);
    return new_blocks;
  }
  function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
      const key = get_key(get_context(ctx, list, i));
      if (keys.has(key)) {
        throw new Error("Cannot have duplicate keys in a keyed each");
      }
      keys.add(key);
    }
  }
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = {$$scope: 1};
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update2[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update2))
        update2[key] = void 0;
    }
    return update2;
  }
  function get_spread_object(spread_props) {
    return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
  }
  function bind3(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor, customElement) {
    const {fragment, on_mount, on_destroy, after_update} = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init$1(component, options, instance8, create_fragment10, not_equal, props, append_styles2, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: null,
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(parent_component ? parent_component.$$.context : options.context || []),
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles2 && append_styles2($$.root);
    let ready = false;
    $$.ctx = instance8 ? instance8(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteComponent = class {
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
  function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({version: "3.42.4"}, detail), true));
  }
  function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", {target, node});
    append(target, node);
  }
  function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", {target, node, anchor});
    insert(target, node, anchor);
  }
  function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", {node});
    detach(node);
  }
  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
      modifiers.push("preventDefault");
    if (has_stop_propagation)
      modifiers.push("stopPropagation");
    dispatch_dev("SvelteDOMAddEventListener", {node, event, handler, modifiers});
    const dispose = listen(node, event, handler, options);
    return () => {
      dispatch_dev("SvelteDOMRemoveEventListener", {node, event, handler, modifiers});
      dispose();
    };
  }
  function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
      dispatch_dev("SvelteDOMRemoveAttribute", {node, attribute});
    else
      dispatch_dev("SvelteDOMSetAttribute", {node, attribute, value});
  }
  function set_data_dev(text2, data) {
    data = "" + data;
    if (text2.wholeText === data)
      return;
    dispatch_dev("SvelteDOMSetData", {node: text2, data});
    text2.data = data;
  }
  function validate_each_argument(arg) {
    if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
      let msg = "{#each} only iterates over array-like objects.";
      if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
        msg += " You can use a spread to convert this iterable into an array.";
      }
      throw new Error(msg);
    }
  }
  function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
      if (!~keys.indexOf(slot_key)) {
        console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
      }
    }
  }
  var SvelteComponentDev = class extends SvelteComponent {
    constructor(options) {
      if (!options || !options.target && !options.$$inline) {
        throw new Error("'target' is a required option");
      }
      super();
    }
    $destroy() {
      super.$destroy();
      this.$destroy = () => {
        console.warn("Component was already destroyed");
      };
    }
    $capture_state() {
    }
    $inject_state() {
    }
  };
  var {console: console_1} = globals;
  function create_fragment$63(ctx) {
    const block = {
      c: noop,
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$63.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$62($$self, $$props) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Serviceworker", slots, []);
    if ("serviceWorker" in navigator) {
      Promise.resolve().then(() => require_workbox_window_prod_es5()).then(async ({Workbox}) => {
        const wb = new Workbox("/serviceworker.js");
        await wb.register();
        wb.addEventListener("redundant", () => {
          location.reload();
          console.log("updated app");
        });
      });
    }
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console_1.warn(`<Serviceworker> was created with unknown prop '${key}'`);
    });
    return [];
  }
  var Serviceworker = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$62, create_fragment$63, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Serviceworker",
        options,
        id: create_fragment$63.name
      });
    }
  };
  var defaultConfig = {
    queryHandler: {
      parse: (search) => fromEntries(new URLSearchParams(search)),
      stringify: (params) => "?" + new URLSearchParams(params).toString()
    },
    urlTransform: {
      apply: (x) => x,
      remove: (x) => x
    },
    useHash: false
  };
  function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) => {
      obj[key] = val;
      return obj;
    }, {});
  }
  var MATCH_PARAM = RegExp(/\:([^/()]+)/g);
  function handleScroll(element2, scrollToTop) {
    if (navigator.userAgent.includes("jsdom"))
      return false;
    if (scrollToTop)
      scrollAncestorsToTop(element2);
    handleHash();
  }
  function handleHash() {
    if (navigator.userAgent.includes("jsdom"))
      return false;
    const {hash: hash2} = window.location;
    if (hash2) {
      const validElementIdRegex = /^[A-Za-z]+[\w\-\:\.]*$/;
      if (validElementIdRegex.test(hash2.substring(1))) {
        const el = document.querySelector(hash2);
        if (el)
          el.scrollIntoView();
      }
    }
  }
  function scrollAncestorsToTop(element2) {
    if (element2 && element2.scrollTo && element2.dataset.routify !== "scroll-lock" && element2.dataset["routify-scroll"] !== "lock") {
      element2.style["scroll-behavior"] = "auto";
      element2.scrollTo({top: 0, behavior: "auto"});
      element2.style["scroll-behavior"] = "";
      scrollAncestorsToTop(element2.parentElement);
    }
  }
  var pathToRegex = (str, recursive) => {
    const suffix = recursive ? "" : "/?$";
    str = str.replace(/\/_fallback?$/, "(/|$)");
    str = str.replace(/\/index$/, "(/index)?");
    str = str.replace(MATCH_PARAM, "([^/]+)") + suffix;
    str = `^${str}`;
    return str;
  };
  var pathToParamKeys = (string) => {
    const paramsKeys = [];
    let matches2;
    while (matches2 = MATCH_PARAM.exec(string))
      paramsKeys.push(matches2[1]);
    return paramsKeys;
  };
  var pathToRank = ({path}) => {
    return path.split("/").filter(Boolean).map((str) => str === "_fallback" ? "A" : str.startsWith(":") ? "B" : "C").join("");
  };
  function suppressComponentWarnings(ctx, tick2) {
    suppressComponentWarnings._console = suppressComponentWarnings._console || {log: console.log, warn: console.warn};
    const {_console} = suppressComponentWarnings;
    const name = ctx.componentFile.name.replace(/Proxy<_?(.+)>/, "$1").replace(/^Index$/, ctx.component.shortPath.split("/").pop()).replace(/^./, (s) => s.toUpperCase()).replace(/\:(.+)/, "U5B$1u5D");
    const ignores = [
      `<${name}> received an unexpected slot "default".`,
      `<${name}> was created with unknown prop 'scoped'`,
      `<${name}> was created with unknown prop 'scopedSync'`
    ];
    for (const log of ["log", "warn"]) {
      console[log] = (...args) => {
        if (!ignores.includes(args[0]))
          _console[log](...args);
      };
      tick2().then(() => {
        console[log] = _console[log];
      });
    }
  }
  function currentLocation() {
    let dirtyFullpath = window.location.pathname + window.location.search + window.location.hash;
    const {url: url2, options} = resolvePrefetch(dirtyFullpath);
    const parsedUrl = parseUrl(url2);
    return {...parsedUrl, options};
  }
  function resolvePrefetch(dirtyFullpath) {
    const [url2, _options] = dirtyFullpath.split("__[[routify_url_options]]__");
    const options = JSON.parse(decodeURIComponent(_options || "") || "{}");
    window.routify = window.routify || {};
    window.routify.prefetched = options.prefetch;
    return {url: url2, options};
  }
  function parseUrl(url2) {
    if (defaultConfig.useHash)
      url2 = url2.replace(/.*#(.+)/, "$1");
    const origin = url2.startsWith("/") ? window.location.origin : void 0;
    const _url = new URL(url2, origin);
    const fullpath = _url.pathname + _url.search + _url.hash;
    return {url: _url, fullpath};
  }
  function resolveUrl(path, params, inheritedParams) {
    const hash2 = defaultConfig.useHash ? "#" : "";
    let url2;
    url2 = populateUrl(path, params, inheritedParams);
    url2 = defaultConfig.urlTransform.apply(url2);
    url2 = hash2 + url2;
    return url2;
  }
  function populateUrl(path, params, inheritedParams) {
    const allParams = Object.assign({}, inheritedParams, params);
    const queryString = getQueryString(path, params);
    for (const [key, value] of Object.entries(allParams))
      path = path.replace(`:${key}`, value);
    return `${path}${queryString}`;
  }
  function getQueryString(path, params) {
    if (!defaultConfig.queryHandler)
      return "";
    const ignoredKeys = pathToParamKeys(path);
    const queryParams = {};
    if (params)
      Object.entries(params).forEach(([key, value]) => {
        if (!ignoredKeys.includes(key))
          queryParams[key] = value;
      });
    return defaultConfig.queryHandler.stringify(queryParams).replace(/\?$/, "");
  }
  function create_fragment$53(ctx) {
    let current;
    const default_slot_template = ctx[2].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$53.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$53($$self, $$props, $$invalidate) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Noop", slots, ["default"]);
    let {scoped = {}} = $$props;
    const writable_props = ["scoped"];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Noop> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("$$scope" in $$props2)
        $$invalidate(1, $$scope = $$props2.$$scope);
    };
    $$self.$capture_state = () => ({scoped});
    $$self.$inject_state = ($$props2) => {
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [scoped, $$scope, slots];
  }
  var Noop = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$53, create_fragment$53, safe_not_equal, {scoped: 0});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Noop",
        options,
        id: create_fragment$53.name
      });
    }
    get scoped() {
      throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set scoped(value) {
      throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var subscriber_queue = [];
  function readable(value, start) {
    return {
      subscribe: writable(value, start).subscribe
    };
  }
  function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set(fn(value));
    }
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0) {
          stop();
          stop = null;
        }
      };
    }
    return {set, update: update2, subscribe: subscribe2};
  }
  function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
      let inited = false;
      const values = [];
      let pending = 0;
      let cleanup = noop;
      const sync = () => {
        if (pending) {
          return;
        }
        cleanup();
        const result = fn(single ? values[0] : values, set);
        if (auto) {
          set(result);
        } else {
          cleanup = is_function(result) ? result : noop;
        }
      };
      const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
        values[i] = value;
        pending &= ~(1 << i);
        if (inited) {
          sync();
        }
      }, () => {
        pending |= 1 << i;
      }));
      inited = true;
      sync();
      return function stop() {
        run_all(unsubscribers);
        cleanup();
      };
    });
  }
  window.routify = window.routify || {};
  var route = writable(null);
  var routes$1 = writable([]);
  routes$1.subscribe((routes2) => window.routify.routes = routes2);
  var rootContext = writable({component: {params: {}}});
  var urlRoute = writable(null);
  var isChangingPage = writable(true);
  async function onPageLoaded({page, metatags: metatags2, afterPageLoad: afterPageLoad2, parentNode}) {
    const scrollToTop = page.last !== page;
    setTimeout(() => handleScroll(parentNode, scrollToTop));
    const {path} = page;
    const {options} = currentLocation();
    const prefetchId = options.prefetch;
    for (const hook of afterPageLoad2._hooks) {
      if (hook)
        await hook(page.api);
    }
    metatags2.update();
    dispatchEvent(new CustomEvent("app-loaded"));
    parent.postMessage({
      msg: "app-loaded",
      prefetched: window.routify.prefetched,
      path,
      prefetchId
    }, "*");
    window["routify"].appLoaded = true;
    window["routify"].stopAutoReady = false;
  }
  function urlToRoute(url2, clone2 = false) {
    url2 = defaultConfig.urlTransform.remove(url2);
    let {pathname, search} = parseUrl(url2).url;
    const routes2 = get_store_value(routes$1);
    const matchingRoute = routes2.find((route3) => pathname === route3.meta.name) || routes2.find((route3) => pathname.match(route3.regex));
    if (!matchingRoute)
      throw new Error(`Route could not be found for "${pathname}".`);
    const _matchingRoute = clone2 ? Object.create(matchingRoute) : matchingRoute;
    const {route: route2, redirectPath, rewritePath} = resolveRedirects(_matchingRoute, routes2);
    if (rewritePath) {
      ({pathname, search} = parseUrl(resolveUrl(rewritePath, route2.params)).url);
      if (redirectPath)
        route2.redirectTo = resolveUrl(redirectPath, route2.params || {});
    }
    if (defaultConfig.queryHandler)
      route2.params = Object.assign({}, defaultConfig.queryHandler.parse(search));
    assignParamsToRouteAndLayouts(route2, pathname);
    route2.leftover = url2.replace(new RegExp(route2.regex), "");
    return route2;
  }
  function assignParamsToRouteAndLayouts(route2, pathname) {
    if (route2.paramKeys) {
      const layouts = layoutByPos(route2.layouts);
      const fragments = pathname.split("/").filter(Boolean);
      const routeProps = getRouteProps(route2.path);
      routeProps.forEach((prop, i) => {
        if (prop) {
          route2.params[prop] = fragments[i];
          if (layouts[i])
            layouts[i].param = {[prop]: fragments[i]};
          else
            route2.param = {[prop]: fragments[i]};
        }
      });
    }
  }
  function resolveRedirects(route2, routes2, redirectPath, rewritePath) {
    const {redirect: redirect2, rewrite} = route2.meta;
    if (redirect2 || rewrite) {
      redirectPath = redirect2 ? redirect2.path || redirect2 : redirectPath;
      rewritePath = rewrite ? rewrite.path || rewrite : redirectPath;
      const redirectParams = redirect2 && redirect2.params;
      const rewriteParams = rewrite && rewrite.params;
      const newRoute = routes2.find((r) => r.path.replace(/\/index$/, "") === rewritePath);
      if (newRoute === route2)
        console.error(`${rewritePath} is redirecting to itself`);
      if (!newRoute)
        console.error(`${route2.path} is redirecting to non-existent path: ${rewritePath}`);
      if (redirectParams || rewriteParams)
        newRoute.params = Object.assign({}, newRoute.params, redirectParams, rewriteParams);
      return resolveRedirects(newRoute, routes2, redirectPath, rewritePath);
    }
    return {route: route2, redirectPath, rewritePath};
  }
  function layoutByPos(layouts) {
    const arr = [];
    layouts.forEach((layout) => {
      arr[layout.path.split("/").filter(Boolean).length - 1] = layout;
    });
    return arr;
  }
  function getRouteProps(url2) {
    return url2.split("/").filter(Boolean).map((f) => f.match(/\:(.+)/)).map((f) => f && f[1]);
  }
  var file$17 = "node_modules/@roxi/routify/runtime/Prefetcher.svelte";
  function get_each_context$1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[1] = list[i];
    return child_ctx;
  }
  function create_each_block$1(key_1, ctx) {
    let iframe;
    let iframe_src_value;
    const block = {
      key: key_1,
      first: null,
      c: function create2() {
        iframe = element("iframe");
        if (!src_url_equal(iframe.src, iframe_src_value = ctx[1].url))
          attr_dev(iframe, "src", iframe_src_value);
        attr_dev(iframe, "frameborder", "0");
        attr_dev(iframe, "title", "routify prefetcher");
        add_location(iframe, file$17, 80, 4, 2274);
        this.first = iframe;
      },
      m: function mount(target, anchor) {
        insert_dev(target, iframe, anchor);
      },
      p: function update2(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 1 && !src_url_equal(iframe.src, iframe_src_value = ctx[1].url)) {
          attr_dev(iframe, "src", iframe_src_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(iframe);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_each_block$1.name,
      type: "each",
      source: "(80:2) {#each $actives as prefetch (prefetch.options.prefetch)}",
      ctx
    });
    return block;
  }
  function create_fragment$43(ctx) {
    let div;
    let each_blocks = [];
    let each_1_lookup = new Map();
    let each_value = ctx[0];
    validate_each_argument(each_value);
    const get_key = (ctx2) => ctx2[1].options.prefetch;
    validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    for (let i = 0; i < each_value.length; i += 1) {
      let child_ctx = get_each_context$1(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    }
    const block = {
      c: function create2() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr_dev(div, "id", "__routify_iframes");
        set_style(div, "display", "none");
        add_location(div, file$17, 78, 0, 2160);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div, null);
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (dirty & 1) {
          each_value = ctx2[0];
          validate_each_argument(each_value);
          validate_each_keys(ctx2, each_value, get_each_context$1, get_key);
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$1, null, get_each_context$1);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].d();
        }
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$43.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var iframeNum = 2;
  var defaults6 = {
    validFor: 60,
    timeout: 5e3,
    gracePeriod: 1e3
  };
  var queue = writable([]);
  var actives = derived(queue, (q) => q.slice(0, iframeNum));
  actives.subscribe((actives2) => actives2.forEach(({options}) => {
    setTimeout(() => removeFromQueue(options.prefetch), options.timeout);
  }));
  function prefetch(path, options = {}) {
    prefetch.id = prefetch.id || 1;
    path = path.href || path;
    options = {...defaults6, ...options};
    options.prefetch = prefetch.id++;
    if (window.routify.prefetched || navigator.userAgent.match("jsdom"))
      return false;
    queue.update((q) => {
      if (!q.some((e) => e.options.path === path))
        q.push({
          url: `${path}__[[routify_url_options]]__${encodeURIComponent(JSON.stringify(options))}`,
          options
        });
      return q;
    });
  }
  function removeFromQueue(idOrEvent) {
    const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent;
    if (!id)
      return null;
    const entry = get_store_value(queue).find((entry2) => entry2 && entry2.options.prefetch == id);
    if (entry) {
      const {gracePeriod} = entry.options;
      const gracePromise = new Promise((resolve) => setTimeout(resolve, gracePeriod));
      const idlePromise = new Promise((resolve) => {
        window.requestIdleCallback ? window.requestIdleCallback(resolve) : setTimeout(resolve, gracePeriod + 1e3);
      });
      Promise.all([gracePromise, idlePromise]).then(() => {
        queue.update((q) => q.filter((q2) => q2.options.prefetch != id));
      });
    }
  }
  addEventListener("message", removeFromQueue, false);
  function instance$43($$self, $$props, $$invalidate) {
    let $actives;
    validate_store(actives, "actives");
    component_subscribe($$self, actives, ($$value) => $$invalidate(0, $actives = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Prefetcher", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Prefetcher> was created with unknown prop '${key}'`);
    });
    $$self.$capture_state = () => ({
      writable,
      derived,
      get: get_store_value,
      iframeNum,
      defaults: defaults6,
      queue,
      actives,
      prefetch,
      removeFromQueue,
      $actives
    });
    return [$actives];
  }
  var Prefetcher = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$43, create_fragment$43, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Prefetcher",
        options,
        id: create_fragment$43.name
      });
    }
  };
  function getRoutifyContext() {
    return getContext("routify") || rootContext;
  }
  var afterPageLoad = {
    _hooks: [
      (event) => isChangingPage.set(false)
    ],
    subscribe: hookHandler
  };
  var beforeUrlChange = {
    _hooks: [],
    subscribe: hookHandler
  };
  function hookHandler(listener) {
    const hooks = this._hooks;
    const index = hooks.length;
    listener((callback) => {
      hooks[index] = callback;
    });
    return (...params) => {
      delete hooks[index];
      listener(...params);
    };
  }
  var url = {
    subscribe(listener) {
      const ctx = getRoutifyContext();
      return derived(ctx, (ctx2) => makeUrlHelper(ctx2, ctx2.route, ctx2.routes)).subscribe(listener);
    }
  };
  function makeUrlHelper($ctx, $currentRoute, $routes) {
    return function url2(path, params = {}, options) {
      const {component} = $ctx;
      const inheritedParams = Object.assign({}, $currentRoute.params, component.params);
      let el = path && path.nodeType && path;
      if (el)
        path = path.getAttribute("href");
      path = path ? resolvePath(path) : component.shortPath;
      const route2 = $routes.find((route3) => [route3.shortPath || "/", route3.path].includes(path));
      if (route2 && route2.meta.preload === "proximity" && window.requestIdleCallback) {
        const delay = routify.appLoaded ? 0 : 1500;
        setTimeout(() => {
          window.requestIdleCallback(() => route2.api.preload());
        }, delay);
      }
      const strict = options && options.strict !== false;
      if (!strict)
        path = path.replace(/index$/, "");
      let url3 = resolveUrl(path, params, inheritedParams);
      if (el) {
        el.href = url3;
        return {
          update(changedParams) {
            el.href = resolveUrl(path, changedParams, inheritedParams);
          }
        };
      }
      return url3;
      function resolvePath(path2) {
        if (path2.match(/^\.\.?\//)) {
          let [, breadcrumbs, relativePath] = path2.match(/^([\.\/]+)(.*)/);
          let dir = component.path.replace(/\/$/, "");
          const traverse = breadcrumbs.match(/\.\.\//g) || [];
          if (component.isPage)
            traverse.push(null);
          traverse.forEach(() => dir = dir.replace(/\/[^\/]+\/?$/, ""));
          path2 = `${dir}/${relativePath}`.replace(/\/$/, "");
          path2 = path2 || "/";
        } else if (path2.match(/^\//))
          ;
        else {
          const matchingRoute = $routes.find((route3) => route3.meta.name === path2);
          if (matchingRoute)
            path2 = matchingRoute.shortPath;
        }
        return path2;
      }
    };
  }
  var goto = {
    subscribe(listener) {
      const routifyUpdatePage = getContext("routifyupdatepage");
      return derived(url, (url2) => function goto2(path, params, _static, shallow) {
        const href = url2(path, params);
        if (!_static)
          history.pushState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }).subscribe(listener);
    }
  };
  var redirect = {
    subscribe(listener) {
      const routifyUpdatePage = getContext("routifyupdatepage");
      return derived(url, (url2) => function redirect2(path, params, _static, shallow) {
        const href = url2(path, params);
        if (!_static)
          history.replaceState({}, null, href);
        else
          routifyUpdatePage(href, shallow);
      }).subscribe(listener);
    }
  };
  var _metatags = {
    subscribe(listener) {
      this._origin = this.getOrigin();
      return listener(metatags);
    },
    props: {},
    templates: {},
    services: {
      plain: {propField: "name", valueField: "content"},
      twitter: {propField: "name", valueField: "content"},
      og: {propField: "property", valueField: "content"}
    },
    plugins: [
      {
        name: "applyTemplate",
        condition: () => true,
        action: (prop, value) => {
          const template = _metatags.getLongest(_metatags.templates, prop) || ((x) => x);
          return [prop, template(value)];
        }
      },
      {
        name: "createMeta",
        condition: () => true,
        action(prop, value) {
          _metatags.writeMeta(prop, value);
        }
      },
      {
        name: "createOG",
        condition: (prop) => !prop.match(":"),
        action(prop, value) {
          _metatags.writeMeta(`og:${prop}`, value);
        }
      },
      {
        name: "createTitle",
        condition: (prop) => prop === "title",
        action(prop, value) {
          document.title = value;
        }
      }
    ],
    getLongest(repo, name) {
      const providers = repo[name];
      if (providers) {
        const currentPath = get_store_value(route).path;
        const allPaths = Object.keys(repo[name]);
        const matchingPaths = allPaths.filter((path) => currentPath.includes(path));
        const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0];
        return providers[longestKey];
      }
    },
    writeMeta(prop, value) {
      const head = document.getElementsByTagName("head")[0];
      const match = prop.match(/(.+)\:/);
      const serviceName = match && match[1] || "plain";
      const {propField, valueField} = metatags.services[serviceName] || metatags.services.plain;
      const oldElement = document.querySelector(`meta[${propField}='${prop}']`);
      if (oldElement)
        oldElement.remove();
      const newElement = document.createElement("meta");
      newElement.setAttribute(propField, prop);
      newElement.setAttribute(valueField, value);
      newElement.setAttribute("data-origin", "routify");
      head.appendChild(newElement);
    },
    set(prop, value) {
      if (typeof prop === "string") {
        _metatags.plugins.forEach((plugin) => {
          if (plugin.condition(prop, value))
            [prop, value] = plugin.action(prop, value) || [prop, value];
        });
      }
    },
    clear() {
      const oldElement = document.querySelector(`meta`);
      if (oldElement)
        oldElement.remove();
    },
    template(name, fn) {
      const origin = _metatags.getOrigin;
      _metatags.templates[name] = _metatags.templates[name] || {};
      _metatags.templates[name][origin] = fn;
    },
    update() {
      Object.keys(_metatags.props).forEach((prop) => {
        let value = _metatags.getLongest(_metatags.props, prop);
        _metatags.plugins.forEach((plugin) => {
          if (plugin.condition(prop, value)) {
            [prop, value] = plugin.action(prop, value) || [prop, value];
          }
        });
      });
    },
    batchedUpdate() {
      if (!_metatags._pendingUpdate) {
        _metatags._pendingUpdate = true;
        setTimeout(() => {
          _metatags._pendingUpdate = false;
          this.update();
        });
      }
    },
    _updateQueued: false,
    _origin: false,
    getOrigin() {
      if (this._origin)
        return this._origin;
      const routifyCtx = getRoutifyContext();
      return routifyCtx && get_store_value(routifyCtx).path || "/";
    },
    _pendingUpdate: false
  };
  var metatags = new Proxy(_metatags, {
    set(target, name, value, receiver) {
      const {props} = target;
      if (Reflect.has(target, name))
        Reflect.set(target, name, value, receiver);
      else {
        props[name] = props[name] || {};
        props[name][target.getOrigin()] = value;
      }
      if (window["routify"].appLoaded)
        target.batchedUpdate();
      return true;
    }
  });
  var file8 = "node_modules/@roxi/routify/runtime/Route.svelte";
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[21] = list[i].component;
    child_ctx[22] = list[i].componentFile;
    child_ctx[2] = list[i].decorator;
    child_ctx[1] = list[i].nodes;
    return child_ctx;
  }
  function create_if_block_12(ctx) {
    let each_blocks = [];
    let each_1_lookup = new Map();
    let each_1_anchor;
    let current;
    let each_value = [ctx[4]];
    validate_each_argument(each_value);
    const get_key = (ctx2) => ctx2[7];
    validate_each_keys(ctx, each_value, get_each_context, get_key);
    for (let i = 0; i < 1; i += 1) {
      let child_ctx = get_each_context(ctx, each_value, i);
      let key = get_key(child_ctx);
      each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    }
    const block = {
      c: function create2() {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m: function mount(target, anchor) {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].m(target, anchor);
        }
        insert_dev(target, each_1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (dirty & 33554621) {
          each_value = [ctx2[4]];
          validate_each_argument(each_value);
          group_outros();
          validate_each_keys(ctx2, each_value, get_each_context, get_key);
          each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        for (let i = 0; i < 1; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o: function outro(local) {
        for (let i = 0; i < 1; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d: function destroy(detaching) {
        for (let i = 0; i < 1; i += 1) {
          each_blocks[i].d(detaching);
        }
        if (detaching)
          detach_dev(each_1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_12.name,
      type: "if",
      source: "(109:0) {#if $context}",
      ctx
    });
    return block;
  }
  function create_if_block_22(ctx) {
    let route_1;
    let current;
    route_1 = new Route({
      props: {
        decorator: ctx[2],
        nodes: ctx[1],
        scoped: {
          ...ctx[0],
          ...ctx[25]
        }
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(route_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(route_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const route_1_changes = {};
        if (dirty & 4)
          route_1_changes.decorator = ctx2[2];
        if (dirty & 16)
          route_1_changes.nodes = ctx2[1];
        if (dirty & 33554433)
          route_1_changes.scoped = {
            ...ctx2[0],
            ...ctx2[25]
          };
        route_1.$set(route_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(route_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(route_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(route_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_22.name,
      type: "if",
      source: "(120:8) {#if component && nodes.length}",
      ctx
    });
    return block;
  }
  function create_default_slot_12(ctx) {
    let if_block_anchor;
    let current;
    let if_block = ctx[21] && ctx[1].length && create_if_block_22(ctx);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[21] && ctx2[1].length) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 16) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_22(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_12.name,
      type: "slot",
      source: "(112:6) <svelte:component         this={componentFile}         let:scoped={scopeToChild}         let:decorator         {scoped}         {scopedSync}         {...node.param || {}}       >",
      ctx
    });
    return block;
  }
  function create_default_slot7(ctx) {
    let switch_instance;
    let t;
    let current;
    const switch_instance_spread_levels = [
      {scoped: ctx[0]},
      {scopedSync: ctx[5]},
      ctx[3].param || {}
    ];
    var switch_value = ctx[22];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {
          default: [
            create_default_slot_12,
            ({scoped: scopeToChild, decorator}) => ({25: scopeToChild, 2: decorator}),
            ({scoped: scopeToChild, decorator}) => (scopeToChild ? 33554432 : 0) | (decorator ? 4 : 0)
          ]
        },
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        t = space();
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, t, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty & 41 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 1 && {scoped: ctx2[0]},
          dirty & 32 && {scopedSync: ctx2[5]},
          dirty & 8 && get_spread_object(ctx2[3].param || {})
        ]) : {};
        if (dirty & 100663317) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[22])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, t.parentNode, t);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (switch_instance)
          destroy_component(switch_instance, detaching);
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot7.name,
      type: "slot",
      source: "(111:4) <svelte:component this={decorator} {scoped}>",
      ctx
    });
    return block;
  }
  function create_each_block(key_1, ctx) {
    let first;
    let switch_instance;
    let switch_instance_anchor;
    let current;
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      return {
        props: {
          scoped: ctx2[0],
          $$slots: {default: [create_default_slot7]},
          $$scope: {ctx: ctx2}
        },
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
    }
    const block = {
      key: key_1,
      first: null,
      c: function create2() {
        first = empty();
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
        this.first = first;
      },
      m: function mount(target, anchor) {
        insert_dev(target, first, anchor);
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(new_ctx, dirty) {
        ctx = new_ctx;
        const switch_instance_changes = {};
        if (dirty & 1)
          switch_instance_changes.scoped = ctx[0];
        if (dirty & 67108925) {
          switch_instance_changes.$$scope = {dirty, ctx};
        }
        if (switch_value !== (switch_value = ctx[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx));
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(first);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_each_block.name,
      type: "each",
      source: "(110:2) {#each [$context] as { component, componentFile, decorator, nodes }",
      ctx
    });
    return block;
  }
  function create_if_block$12(ctx) {
    let div;
    let mounted;
    let dispose;
    const block = {
      c: function create2() {
        div = element("div");
        set_style(div, "display", "contents");
        add_location(div, file8, 133, 2, 4153);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (!mounted) {
          dispose = action_destroyer(ctx[10].call(null, div));
          mounted = true;
        }
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block$12.name,
      type: "if",
      source: "(133:0) {#if !parentNode}",
      ctx
    });
    return block;
  }
  function create_fragment$35(ctx) {
    let t;
    let if_block1_anchor;
    let current;
    let if_block0 = ctx[4] && create_if_block_12(ctx);
    let if_block1 = !ctx[6] && create_if_block$12(ctx);
    const block = {
      c: function create2() {
        if (if_block0)
          if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (ctx2[4]) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & 16) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_12(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t.parentNode, t);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (!ctx2[6]) {
          if (if_block1)
            ;
          else {
            if_block1 = create_if_block$12(ctx2);
            if_block1.c();
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$35.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$35($$self, $$props, $$invalidate) {
    let id;
    let $context;
    let $route;
    let $parentContext;
    let $routes;
    validate_store(route, "route");
    component_subscribe($$self, route, ($$value) => $$invalidate(14, $route = $$value));
    validate_store(routes$1, "routes");
    component_subscribe($$self, routes$1, ($$value) => $$invalidate(16, $routes = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Route", slots, []);
    let {nodes = []} = $$props;
    let {scoped = {}} = $$props;
    let {decorator = void 0} = $$props;
    let node = null;
    let remainingNodes = null;
    let scopedSync = {};
    let parentNode;
    let invalidate = 1;
    const context = writable(null);
    validate_store(context, "context");
    component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
    const parentContext = getContext("routify") || rootContext;
    validate_store(parentContext, "parentContext");
    component_subscribe($$self, parentContext, (value) => $$invalidate(15, $parentContext = value));
    const setParentNode = (el) => $$invalidate(6, parentNode = el.parentNode);
    setContext("routify", context);
    let lastNodes = [];
    function setComponent(node2) {
      let PendingComponent = node2.component();
      if (PendingComponent instanceof Promise)
        PendingComponent.then(onComponentLoaded);
      else
        onComponentLoaded(PendingComponent);
    }
    function onComponentLoaded(componentFile) {
      $$invalidate(5, scopedSync = {...scoped});
      const ctx = {
        ...$context,
        nodes: remainingNodes,
        decorator: decorator || Noop,
        layout: node.isLayout ? node : $parentContext.layout,
        component: node,
        route: $route,
        routes: $routes,
        componentFile,
        parentNode: parentNode || $parentContext.parentNode
      };
      context.set(ctx);
      set_store_value(parentContext, $parentContext.child = node, $parentContext);
      if (remainingNodes.length === 0)
        onLastComponentLoaded();
    }
    async function onLastComponentLoaded() {
      await new Promise((resolve) => setTimeout(resolve));
      const isOnCurrentRoute = $context.component.path === $route.path;
      if (!window["routify"].stopAutoReady && isOnCurrentRoute)
        onPageLoaded({
          page: $context.component,
          metatags,
          afterPageLoad,
          parentNode
        });
    }
    function getID({meta, path, param, params}) {
      return JSON.stringify({
        path,
        invalidate,
        param: (meta["param-is-page"] || meta["slug-is-page"]) && param,
        queryParams: meta["query-params-is-page"] && params
      });
    }
    const writable_props = ["nodes", "scoped", "decorator"];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Route> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("nodes" in $$props2)
        $$invalidate(1, nodes = $$props2.nodes);
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("decorator" in $$props2)
        $$invalidate(2, decorator = $$props2.decorator);
    };
    $$self.$capture_state = () => ({
      suppressComponentWarnings,
      Noop,
      getContext,
      setContext,
      tick,
      writable,
      metatags,
      afterPageLoad,
      route,
      routes: routes$1,
      rootContext,
      handleScroll,
      onPageLoaded,
      nodes,
      scoped,
      decorator,
      node,
      remainingNodes,
      scopedSync,
      parentNode,
      invalidate,
      context,
      parentContext,
      setParentNode,
      lastNodes,
      setComponent,
      onComponentLoaded,
      onLastComponentLoaded,
      getID,
      id,
      $context,
      $route,
      $parentContext,
      $routes
    });
    $$self.$inject_state = ($$props2) => {
      if ("nodes" in $$props2)
        $$invalidate(1, nodes = $$props2.nodes);
      if ("scoped" in $$props2)
        $$invalidate(0, scoped = $$props2.scoped);
      if ("decorator" in $$props2)
        $$invalidate(2, decorator = $$props2.decorator);
      if ("node" in $$props2)
        $$invalidate(3, node = $$props2.node);
      if ("remainingNodes" in $$props2)
        remainingNodes = $$props2.remainingNodes;
      if ("scopedSync" in $$props2)
        $$invalidate(5, scopedSync = $$props2.scopedSync);
      if ("parentNode" in $$props2)
        $$invalidate(6, parentNode = $$props2.parentNode);
      if ("invalidate" in $$props2)
        $$invalidate(11, invalidate = $$props2.invalidate);
      if ("lastNodes" in $$props2)
        $$invalidate(12, lastNodes = $$props2.lastNodes);
      if ("id" in $$props2)
        $$invalidate(7, id = $$props2.id);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 6146) {
        if (lastNodes !== nodes) {
          $$invalidate(12, lastNodes = nodes);
          $$invalidate(3, [node, ...remainingNodes] = [...nodes], node);
          $$invalidate(3, node.api.reset = () => $$invalidate(11, invalidate++, invalidate), node);
        }
      }
      if ($$self.$$.dirty & 8) {
        setComponent(node);
      }
      if ($$self.$$.dirty & 2064) {
        $$invalidate(7, id = $context && invalidate && getID($context.component));
      }
      if ($$self.$$.dirty & 16) {
        $context && suppressComponentWarnings($context, tick);
      }
    };
    return [
      scoped,
      nodes,
      decorator,
      node,
      $context,
      scopedSync,
      parentNode,
      id,
      context,
      parentContext,
      setParentNode,
      invalidate,
      lastNodes
    ];
  }
  var Route = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$35, create_fragment$35, safe_not_equal, {nodes: 1, scoped: 0, decorator: 2});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Route",
        options,
        id: create_fragment$35.name
      });
    }
    get nodes() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nodes(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get scoped() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set scoped(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get decorator() {
      throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set decorator(value) {
      throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function init(routes2, callback) {
    let lastRoute = false;
    function updatePage(proxyToUrl, shallow) {
      const url2 = proxyToUrl || currentLocation().fullpath;
      const route$1 = urlToRoute(url2);
      if (route$1.redirectTo) {
        history.replaceStateNative({}, null, route$1.redirectTo);
        delete route$1.redirectTo;
      }
      const currentRoute = shallow && urlToRoute(currentLocation().fullpath, routes2);
      const contextRoute = currentRoute || route$1;
      const nodes = [...contextRoute.layouts, route$1];
      if (lastRoute)
        delete lastRoute.last;
      route$1.last = lastRoute;
      lastRoute = route$1;
      if (!proxyToUrl)
        urlRoute.set(route$1);
      route.set(route$1);
      route$1.api.preload().then(() => {
        isChangingPage.set(true);
        callback(nodes);
      });
    }
    const destroy = createEventListeners(updatePage);
    return {updatePage, destroy};
  }
  function createEventListeners(updatePage) {
    ["pushState", "replaceState"].forEach((eventName) => {
      if (!history[eventName + "Native"])
        history[eventName + "Native"] = history[eventName];
      history[eventName] = async function(state = {}, title, url2) {
        const currentUrl = location.pathname + location.search + location.hash;
        if (url2 === currentUrl)
          return false;
        const {id, path, params} = get_store_value(route);
        state = {id, path, params, ...state};
        const event = new Event(eventName.toLowerCase());
        Object.assign(event, {state, title, url: url2});
        const route$1 = await runHooksBeforeUrlChange(event, url2);
        if (route$1) {
          history[eventName + "Native"].apply(this, [state, title, url2]);
          return dispatchEvent(event);
        }
      };
    });
    let _ignoreNextPop = false;
    const listeners = {
      click: handleClick,
      pushstate: () => updatePage(),
      replacestate: () => updatePage(),
      popstate: async (event) => {
        if (_ignoreNextPop)
          _ignoreNextPop = false;
        else {
          if (await runHooksBeforeUrlChange(event, currentLocation().fullpath)) {
            updatePage();
          } else {
            _ignoreNextPop = true;
            event.preventDefault();
            history.go(1);
          }
        }
      }
    };
    Object.entries(listeners).forEach((args) => addEventListener(...args));
    const unregister = () => {
      Object.entries(listeners).forEach((args) => removeEventListener(...args));
    };
    return unregister;
  }
  function handleClick(event) {
    const el = event.target.closest("a");
    const href = el && el.href;
    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.defaultPrevented)
      return;
    if (!href || el.target || el.host !== location.host)
      return;
    const url2 = new URL(href);
    const relativeUrl = url2.pathname + url2.search + url2.hash;
    event.preventDefault();
    history.pushState({}, "", relativeUrl);
  }
  async function runHooksBeforeUrlChange(event, url2) {
    const route2 = urlToRoute(url2).api;
    for (const hook of beforeUrlChange._hooks.filter(Boolean)) {
      const result = await hook(event, route2, {url: url2});
      if (!result)
        return false;
    }
    return true;
  }
  var {Object: Object_1} = globals;
  function create_if_block5(ctx) {
    let route_1;
    let current;
    route_1 = new Route({
      props: {nodes: ctx[0]},
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(route_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(route_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const route_1_changes = {};
        if (dirty & 1)
          route_1_changes.nodes = ctx2[0];
        route_1.$set(route_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(route_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(route_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(route_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block5.name,
      type: "if",
      source: "(58:0) {#if nodes && $route !== null}",
      ctx
    });
    return block;
  }
  function create_fragment$27(ctx) {
    let t;
    let prefetcher;
    let current;
    let if_block = ctx[0] && ctx[1] !== null && create_if_block5(ctx);
    prefetcher = new Prefetcher({$$inline: true});
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        t = space();
        create_component(prefetcher.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        mount_component(prefetcher, target, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (ctx2[0] && ctx2[1] !== null) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 3) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block5(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        transition_in(prefetcher.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        transition_out(prefetcher.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(t);
        destroy_component(prefetcher, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$27.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$26($$self, $$props, $$invalidate) {
    let $route;
    validate_store(route, "route");
    component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Router", slots, []);
    let {routes: routes2} = $$props;
    let {config = {}} = $$props;
    let nodes;
    let navigator2;
    window.routify = window.routify || {};
    window.routify.inBrowser = !window.navigator.userAgent.match("jsdom");
    Object.assign(defaultConfig, config);
    const updatePage = (...args) => navigator2 && navigator2.updatePage(...args);
    setContext("routifyupdatepage", updatePage);
    const callback = (res) => $$invalidate(0, nodes = res);
    const cleanup = () => {
      if (!navigator2)
        return;
      navigator2.destroy();
      navigator2 = null;
    };
    let initTimeout = null;
    const doInit = () => {
      clearTimeout(initTimeout);
      initTimeout = setTimeout(() => {
        cleanup();
        navigator2 = init(routes2, callback);
        routes$1.set(routes2);
        navigator2.updatePage();
      });
    };
    onDestroy(cleanup);
    const writable_props = ["routes", "config"];
    Object_1.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Router> was created with unknown prop '${key}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("routes" in $$props2)
        $$invalidate(2, routes2 = $$props2.routes);
      if ("config" in $$props2)
        $$invalidate(3, config = $$props2.config);
    };
    $$self.$capture_state = () => ({
      setContext,
      onDestroy,
      Route,
      Prefetcher,
      init,
      route,
      routesStore: routes$1,
      defaultConfig,
      routes: routes2,
      config,
      nodes,
      navigator: navigator2,
      updatePage,
      callback,
      cleanup,
      initTimeout,
      doInit,
      $route
    });
    $$self.$inject_state = ($$props2) => {
      if ("routes" in $$props2)
        $$invalidate(2, routes2 = $$props2.routes);
      if ("config" in $$props2)
        $$invalidate(3, config = $$props2.config);
      if ("nodes" in $$props2)
        $$invalidate(0, nodes = $$props2.nodes);
      if ("navigator" in $$props2)
        navigator2 = $$props2.navigator;
      if ("initTimeout" in $$props2)
        initTimeout = $$props2.initTimeout;
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        if (routes2)
          doInit();
      }
    };
    return [nodes, $route, routes2, config];
  }
  var Router = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$26, create_fragment$27, safe_not_equal, {routes: 2, config: 3});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Router",
        options,
        id: create_fragment$27.name
      });
      const {ctx} = this.$$;
      const props = options.props || {};
      if (ctx[2] === void 0 && !("routes" in props)) {
        console.warn("<Router> was created without expected prop 'routes'");
      }
    }
    get routes() {
      throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set routes(value) {
      throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get config() {
      throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set config(value) {
      throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function createNodeMiddleware(fn) {
    const inner = async function execute(payload) {
      return await nodeMiddleware(fn, {
        file: payload.tree,
        state: {treePayload: payload},
        scope: {}
      });
    };
    inner.sync = function executeSync(payload) {
      return nodeMiddlewareSync(fn, {
        file: payload.tree,
        state: {treePayload: payload},
        scope: {}
      });
    };
    return inner;
  }
  async function nodeMiddleware(fn, payload) {
    const _file = await fn(payload);
    if (_file === false)
      return false;
    const file9 = _file || payload.file;
    if (file9.children) {
      const children2 = await Promise.all(file9.children.map(async (_file2) => nodeMiddleware(fn, {
        state: payload.state,
        scope: clone(payload.scope || {}),
        parent: payload.file,
        file: await _file2
      })));
      file9.children = children2.filter(Boolean);
    }
    return file9;
  }
  function nodeMiddlewareSync(fn, payload) {
    const _file = fn(payload);
    if (_file === false)
      return false;
    const file9 = _file || payload.file;
    if (file9.children) {
      const children2 = file9.children.map((_file2) => nodeMiddlewareSync(fn, {
        state: payload.state,
        scope: clone(payload.scope || {}),
        parent: payload.file,
        file: _file2
      }));
      file9.children = children2.filter(Boolean);
    }
    return file9;
  }
  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var setRegex = createNodeMiddleware(({file: file9}) => {
    if (file9.isPage || file9.isFallback)
      file9.regex = pathToRegex(file9.path, file9.isFallback);
  });
  var setParamKeys = createNodeMiddleware(({file: file9}) => {
    file9.paramKeys = pathToParamKeys(file9.path);
  });
  var setShortPath = createNodeMiddleware(({file: file9}) => {
    if (file9.isFallback || file9.isIndex)
      file9.shortPath = file9.path.replace(/\/[^/]+$/, "");
    else
      file9.shortPath = file9.path;
  });
  var setRank = createNodeMiddleware(({file: file9}) => {
    file9.ranking = pathToRank(file9);
  });
  var addMetaChildren = createNodeMiddleware(({file: file9}) => {
    const node = file9;
    const metaChildren = file9.meta && file9.meta.children || [];
    if (metaChildren.length) {
      node.children = node.children || [];
      node.children.push(...metaChildren.map((meta) => ({isMeta: true, ...meta, meta})));
    }
  });
  var setIsIndexable = createNodeMiddleware((payload) => {
    const {file: file9} = payload;
    const {isFallback, meta} = file9;
    const isDynamic = file9.path.split("/").pop().startsWith(":");
    const isIndex = file9.path.endsWith("/index");
    const isIndexed = meta.index || meta.index === 0;
    const isHidden = meta.index === false;
    file9.isIndexable = isIndexed || !isFallback && !isDynamic && !isIndex && !isHidden;
    file9.isNonIndexable = !file9.isIndexable;
  });
  var assignRelations = createNodeMiddleware(({file: file9, parent: parent2}) => {
    Object.defineProperty(file9, "parent", {get: () => parent2});
    Object.defineProperty(file9, "nextSibling", {get: () => _getSibling(file9, 1)});
    Object.defineProperty(file9, "prevSibling", {get: () => _getSibling(file9, -1)});
    Object.defineProperty(file9, "lineage", {get: () => _getLineage(parent2)});
  });
  function _getLineage(node, lineage = []) {
    if (node) {
      lineage.unshift(node);
      _getLineage(node.parent, lineage);
    }
    return lineage;
  }
  function _getSibling(file9, direction) {
    if (!file9.root) {
      const siblings = file9.parent.children.filter((c) => c.isIndexable);
      const index = siblings.indexOf(file9);
      return siblings[index + direction];
    }
  }
  var assignIndex = createNodeMiddleware(({file: file9, parent: parent2}) => {
    if (file9.isIndex)
      Object.defineProperty(parent2, "index", {get: () => file9});
  });
  var assignLayout = createNodeMiddleware(({file: file9, scope}) => {
    Object.defineProperty(file9, "layouts", {get: () => getLayouts(file9)});
    function getLayouts(file10) {
      if (!file10.isLayout && file10.meta.reset)
        return [];
      const {parent: parent2} = file10;
      const layout = parent2 && parent2.component && parent2;
      const isReset = layout && (layout.isReset || layout.meta.reset);
      const layouts = parent2 && !isReset && getLayouts(parent2) || [];
      if (layout)
        layouts.push(layout);
      return layouts;
    }
  });
  var createFlatList = (treePayload) => {
    createNodeMiddleware((payload) => {
      if (payload.file.isPage || payload.file.isFallback)
        payload.state.treePayload.routes.push(payload.file);
    }).sync(treePayload);
    treePayload.routes.sort((c, p) => c.ranking >= p.ranking ? -1 : 1);
  };
  var setPrototype = createNodeMiddleware(({file: file9}) => {
    const Prototype = file9.root ? Root : file9.children ? file9.isPage ? PageDir : Dir : file9.isReset ? Reset : file9.isLayout ? Layout : file9.isFallback ? Fallback : Page;
    Object.setPrototypeOf(file9, Prototype.prototype);
    function Layout() {
    }
    function Dir() {
    }
    function Fallback() {
    }
    function Page() {
    }
    function PageDir() {
    }
    function Reset() {
    }
    function Root() {
    }
  });
  var miscPlugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setRegex,
    setParamKeys,
    setShortPath,
    setRank,
    addMetaChildren,
    setIsIndexable,
    assignRelations,
    assignIndex,
    assignLayout,
    createFlatList,
    setPrototype
  });
  var defaultNode = {
    isDir: false,
    ext: "svelte",
    isLayout: false,
    isReset: false,
    isIndex: false,
    isFallback: false,
    isPage: false,
    ownMeta: {},
    meta: {
      recursive: true,
      preload: false,
      prerender: true
    },
    id: "__fallback"
  };
  function restoreDefaults(node) {
    Object.entries(defaultNode).forEach(([key, value]) => {
      if (typeof node[key] === "undefined")
        node[key] = value;
    });
    if (node.children)
      node.children = node.children.map(restoreDefaults);
    return node;
  }
  var assignAPI = createNodeMiddleware(({file: file9}) => {
    file9.api = new ClientApi(file9);
  });
  var ClientApi = class {
    constructor(file9) {
      this.__file = file9;
      Object.defineProperty(this, "__file", {enumerable: false});
      this.isMeta = !!file9.isMeta;
      this.path = file9.path;
      this.title = _prettyName(file9);
      this.meta = file9.meta;
    }
    get parent() {
      return !this.__file.root && this.__file.parent.api;
    }
    get children() {
      return (this.__file.children || this.__file.isLayout && this.__file.parent.children || []).filter((c) => !c.isNonIndexable).sort((a, b) => {
        if (a.isMeta && b.isMeta)
          return 0;
        a = (a.meta.index || a.meta.title || a.path).toString();
        b = (b.meta.index || b.meta.title || b.path).toString();
        return a.localeCompare(b, void 0, {numeric: true, sensitivity: "base"});
      }).map(({api}) => api);
    }
    get next() {
      return _navigate(this, 1);
    }
    get prev() {
      return _navigate(this, -1);
    }
    async preload() {
      const filePromises = [
        ...this.__file.layouts,
        this.__file,
        this.index && this.index.__file
      ].filter(Boolean).map((file9) => file9.component());
      await Promise.all(filePromises);
    }
    get component() {
      return this.__file.component ? this.__file.component() : this.__file.index ? this.__file.index.component() : false;
    }
    get componentWithIndex() {
      return new Promise((resolve) => Promise.all([
        this.component,
        this.index && this.index.component
      ]).then((res) => resolve(res)));
    }
    get index() {
      const child = this.__file.children && this.__file.children.find((child2) => child2.isIndex);
      return child && child.api;
    }
  };
  function _navigate(node, direction) {
    if (!node.__file.root) {
      const siblings = node.parent.children;
      const index = siblings.indexOf(node);
      return node.parent.children[index + direction];
    }
  }
  function _prettyName(file9) {
    if (typeof file9.meta.title !== "undefined")
      return file9.meta.title;
    else
      return (file9.shortPath || file9.path).split("/").pop().replace(/-/g, " ");
  }
  var plugins = {
    ...miscPlugins,
    restoreDefaults: ({tree: tree2}) => restoreDefaults(tree2),
    assignAPI
  };
  function buildClientTree(tree2) {
    const order = [
      "restoreDefaults",
      "setParamKeys",
      "setRegex",
      "setShortPath",
      "setRank",
      "assignLayout",
      "setPrototype",
      "addMetaChildren",
      "assignRelations",
      "setIsIndexable",
      "assignIndex",
      "assignAPI",
      "createFlatList"
    ];
    const payload = {tree: tree2, routes: []};
    for (let name of order) {
      const fn = plugins[name].sync || plugins[name];
      fn(payload);
    }
    return payload;
  }

  // dist/build/index.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex);
        const newModifierMatch = eventType.match(newModifierRegex);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function create_default_slot(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$3(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$3.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance$3($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals.contexts;
    const props = internals.props;
    let {component = internals.component} = $$props;
    Object.entries(internals.classMap).forEach(([name, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment$3.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults$3 = {...internals};
  function classAdderBuilder(props) {
    function Component(...args) {
      Object.assign(internals, defaults$3, props);
      return new ClassAdder(...args);
    }
    Component.prototype = ClassAdder;
    if (ClassAdder.$$render) {
      Component.$$render = (...args) => Object.assign(internals, defaults$3, props) && ClassAdder.$$render(...args);
    }
    if (ClassAdder.render) {
      Component.render = (...args) => Object.assign(internals, defaults$3, props) && ClassAdder.render(...args);
    }
    return Component;
  }
  function useActions(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file$2 = "node_modules/@smui/common/Div.svelte";
  function create_fragment$2(ctx) {
    let div;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let div_levels = [ctx[3]];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$2, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[7](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
            action_destroyer(ctx[2].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$2.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$2($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Div", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      div_binding
    ];
  }
  var Div = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Div",
        options,
        id: create_fragment$2.name
      });
    }
    get use() {
      throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var supportsCssVariables_;
  function supportsCssVariables(windowObj, forceRefresh) {
    if (forceRefresh === void 0) {
      forceRefresh = false;
    }
    var CSS = windowObj.CSS;
    var supportsCssVars = supportsCssVariables_;
    if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
      return supportsCssVariables_;
    }
    var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
    if (!supportsFunctionPresent) {
      return false;
    }
    var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
    var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
    supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVars;
    }
    return supportsCssVars;
  }
  function getNormalizedEventCoords(evt, pageOffset, clientRect) {
    if (!evt) {
      return {x: 0, y: 0};
    }
    var x = pageOffset.x, y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY;
    if (evt.type === "touchstart") {
      var touchEvent = evt;
      normalizedX = touchEvent.changedTouches[0].pageX - documentX;
      normalizedY = touchEvent.changedTouches[0].pageY - documentY;
    } else {
      var mouseEvent = evt;
      normalizedX = mouseEvent.pageX - documentX;
      normalizedY = mouseEvent.pageY - documentY;
    }
    return {x: normalizedX, y: normalizedY};
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {value: o && o[i++], done: !o};
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFoundation = function() {
    function MDCFoundation2(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation2, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation2.prototype.init = function() {
    };
    MDCFoundation2.prototype.destroy = function() {
    };
    return MDCFoundation2;
  }();
  /**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function applyPassive$1(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    return supportsPassiveOption(globalObj) ? {passive: true} : false;
  }
  function supportsPassiveOption(globalObj) {
    if (globalObj === void 0) {
      globalObj = window;
    }
    var passiveSupported = false;
    try {
      var options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      var handler = function() {
      };
      globalObj.document.addEventListener("test", handler, options);
      globalObj.document.removeEventListener("test", handler, options);
    } catch (err) {
      passiveSupported = false;
    }
    return passiveSupported;
  }
  var events = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    applyPassive: applyPassive$1
  });
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function closest(element2, selector) {
    if (element2.closest) {
      return element2.closest(selector);
    }
    var el = element2;
    while (el) {
      if (matches$1(el, selector)) {
        return el;
      }
      el = el.parentElement;
    }
    return null;
  }
  function matches$1(element2, selector) {
    var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
    return nativeMatches.call(element2, selector);
  }
  function estimateScrollWidth(element2) {
    var htmlEl = element2;
    if (htmlEl.offsetParent !== null) {
      return htmlEl.scrollWidth;
    }
    var clone2 = htmlEl.cloneNode(true);
    clone2.style.setProperty("position", "absolute");
    clone2.style.setProperty("transform", "translate(-9999px, -9999px)");
    document.documentElement.appendChild(clone2);
    var scrollWidth = clone2.scrollWidth;
    document.documentElement.removeChild(clone2);
    return scrollWidth;
  }
  var ponyfill = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    closest,
    matches: matches$1,
    estimateScrollWidth
  });
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses = {
    BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
    FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
    FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
    ROOT: "mdc-ripple-upgraded",
    UNBOUNDED: "mdc-ripple-upgraded--unbounded"
  };
  var strings = {
    VAR_FG_SCALE: "--mdc-ripple-fg-scale",
    VAR_FG_SIZE: "--mdc-ripple-fg-size",
    VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
    VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
    VAR_LEFT: "--mdc-ripple-left",
    VAR_TOP: "--mdc-ripple-top"
  };
  var numbers = {
    DEACTIVATION_TIMEOUT_MS: 225,
    FG_DEACTIVATION_MS: 150,
    INITIAL_ORIGIN_SCALE: 0.6,
    PADDING: 10,
    TAP_DELAY_MS: 300
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ACTIVATION_EVENT_TYPES = [
    "touchstart",
    "pointerdown",
    "mousedown",
    "keydown"
  ];
  var POINTER_DEACTIVATION_EVENT_TYPES = [
    "touchend",
    "pointerup",
    "mouseup",
    "contextmenu"
  ];
  var activatedTargets = [];
  var MDCRippleFoundation = function(_super) {
    __extends(MDCRippleFoundation2, _super);
    function MDCRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.activationAnimationHasEnded_ = false;
      _this.activationTimer_ = 0;
      _this.fgDeactivationRemovalTimer_ = 0;
      _this.fgScale_ = "0";
      _this.frame_ = {width: 0, height: 0};
      _this.initialSize_ = 0;
      _this.layoutFrame_ = 0;
      _this.maxRadius_ = 0;
      _this.unboundedCoords_ = {left: 0, top: 0};
      _this.activationState_ = _this.defaultActivationState_();
      _this.activationTimerCallback_ = function() {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };
      _this.activateHandler_ = function(e) {
        return _this.activate_(e);
      };
      _this.deactivateHandler_ = function() {
        return _this.deactivate_();
      };
      _this.focusHandler_ = function() {
        return _this.handleFocus();
      };
      _this.blurHandler_ = function() {
        return _this.handleBlur();
      };
      _this.resizeHandler_ = function() {
        return _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          browserSupportsCssVars: function() {
            return true;
          },
          computeBoundingRect: function() {
            return {top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0};
          },
          containsEventTarget: function() {
            return true;
          },
          deregisterDocumentInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          deregisterResizeHandler: function() {
            return void 0;
          },
          getWindowPageOffset: function() {
            return {x: 0, y: 0};
          },
          isSurfaceActive: function() {
            return true;
          },
          isSurfaceDisabled: function() {
            return true;
          },
          isUnbounded: function() {
            return true;
          },
          registerDocumentInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          registerResizeHandler: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          updateCssVariable: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRippleFoundation2.prototype.init = function() {
      var _this = this;
      var supportsPressRipple = this.supportsPressRipple_();
      this.registerRootHandlers_(supportsPressRipple);
      if (supportsPressRipple) {
        var _a2 = MDCRippleFoundation2.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.addClass(ROOT_1);
          if (_this.adapter.isUnbounded()) {
            _this.adapter.addClass(UNBOUNDED_1);
            _this.layoutInternal_();
          }
        });
      }
    };
    MDCRippleFoundation2.prototype.destroy = function() {
      var _this = this;
      if (this.supportsPressRipple_()) {
        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
        }
        if (this.fgDeactivationRemovalTimer_) {
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.fgDeactivationRemovalTimer_ = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
        }
        var _a2 = MDCRippleFoundation2.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.removeClass(ROOT_2);
          _this.adapter.removeClass(UNBOUNDED_2);
          _this.removeCssVars_();
        });
      }
      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();
    };
    MDCRippleFoundation2.prototype.activate = function(evt) {
      this.activate_(evt);
    };
    MDCRippleFoundation2.prototype.deactivate = function() {
      this.deactivate_();
    };
    MDCRippleFoundation2.prototype.layout = function() {
      var _this = this;
      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }
      this.layoutFrame_ = requestAnimationFrame(function() {
        _this.layoutInternal_();
        _this.layoutFrame_ = 0;
      });
    };
    MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
      var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
      if (unbounded) {
        this.adapter.addClass(UNBOUNDED);
      } else {
        this.adapter.removeClass(UNBOUNDED);
      }
    };
    MDCRippleFoundation2.prototype.handleFocus = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.handleBlur = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.supportsPressRipple_ = function() {
      return this.adapter.browserSupportsCssVars();
    };
    MDCRippleFoundation2.prototype.defaultActivationState_ = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: false,
        isActivated: false,
        isProgrammatic: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false
      };
    };
    MDCRippleFoundation2.prototype.registerRootHandlers_ = function(supportsPressRipple) {
      var _this = this;
      if (supportsPressRipple) {
        ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
          _this.adapter.registerInteractionHandler(evtType, _this.activateHandler_);
        });
        if (this.adapter.isUnbounded()) {
          this.adapter.registerResizeHandler(this.resizeHandler_);
        }
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler_);
      this.adapter.registerInteractionHandler("blur", this.blurHandler_);
    };
    MDCRippleFoundation2.prototype.registerDeactivationHandlers_ = function(evt) {
      var _this = this;
      if (evt.type === "keydown") {
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
          _this.adapter.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
        });
      }
    };
    MDCRippleFoundation2.prototype.deregisterRootHandlers_ = function() {
      var _this = this;
      ACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.deregisterInteractionHandler(evtType, _this.activateHandler_);
      });
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler_);
      this.adapter.deregisterInteractionHandler("blur", this.blurHandler_);
      if (this.adapter.isUnbounded()) {
        this.adapter.deregisterResizeHandler(this.resizeHandler_);
      }
    };
    MDCRippleFoundation2.prototype.deregisterDeactivationHandlers_ = function() {
      var _this = this;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function(evtType) {
        _this.adapter.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
      });
    };
    MDCRippleFoundation2.prototype.removeCssVars_ = function() {
      var _this = this;
      var rippleStrings = MDCRippleFoundation2.strings;
      var keys = Object.keys(rippleStrings);
      keys.forEach(function(key) {
        if (key.indexOf("VAR_") === 0) {
          _this.adapter.updateCssVariable(rippleStrings[key], null);
        }
      });
    };
    MDCRippleFoundation2.prototype.activate_ = function(evt) {
      var _this = this;
      if (this.adapter.isSurfaceDisabled()) {
        return;
      }
      var activationState = this.activationState_;
      if (activationState.isActivated) {
        return;
      }
      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
      if (isSameInteraction) {
        return;
      }
      activationState.isActivated = true;
      activationState.isProgrammatic = evt === void 0;
      activationState.activationEvent = evt;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
      var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
        return _this.adapter.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        this.resetActivationState_();
        return;
      }
      if (evt !== void 0) {
        activatedTargets.push(evt.target);
        this.registerDeactivationHandlers_(evt);
      }
      activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
      if (activationState.wasElementMadeActive) {
        this.animateActivation_();
      }
      requestAnimationFrame(function() {
        activatedTargets = [];
        if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
          activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
          if (activationState.wasElementMadeActive) {
            _this.animateActivation_();
          }
        }
        if (!activationState.wasElementMadeActive) {
          _this.activationState_ = _this.defaultActivationState_();
        }
      });
    };
    MDCRippleFoundation2.prototype.checkElementMadeActive_ = function(evt) {
      return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
    };
    MDCRippleFoundation2.prototype.animateActivation_ = function() {
      var _this = this;
      var _a2 = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
      var _b2 = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b2.FG_DEACTIVATION, FG_ACTIVATION = _b2.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal_();
      var translateStart = "";
      var translateEnd = "";
      if (!this.adapter.isUnbounded()) {
        var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
        translateStart = startPoint.x + "px, " + startPoint.y + "px";
        translateEnd = endPoint.x + "px, " + endPoint.y + "px";
      }
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter.removeClass(FG_DEACTIVATION);
      this.adapter.computeBoundingRect();
      this.adapter.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function() {
        return _this.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation2.prototype.getFgTranslationCoordinates_ = function() {
      var _a2 = this.activationState_, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
      var startPoint;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      }
      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };
      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };
      return {startPoint, endPoint};
    };
    MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady_ = function() {
      var _this = this;
      var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
      var _a2 = this.activationState_, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;
      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function() {
          _this.adapter.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    };
    MDCRippleFoundation2.prototype.rmBoundedActivationClasses_ = function() {
      var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter.computeBoundingRect();
    };
    MDCRippleFoundation2.prototype.resetActivationState_ = function() {
      var _this = this;
      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_();
      setTimeout(function() {
        return _this.previousActivationEvent_ = void 0;
      }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation2.prototype.deactivate_ = function() {
      var _this = this;
      var activationState = this.activationState_;
      if (!activationState.isActivated) {
        return;
      }
      var state = __assign({}, activationState);
      if (activationState.isProgrammatic) {
        requestAnimationFrame(function() {
          return _this.animateDeactivation_(state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function() {
          _this.activationState_.hasDeactivationUXRun = true;
          _this.animateDeactivation_(state);
          _this.resetActivationState_();
        });
      }
    };
    MDCRippleFoundation2.prototype.animateDeactivation_ = function(_a2) {
      var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    };
    MDCRippleFoundation2.prototype.layoutInternal_ = function() {
      var _this = this;
      this.frame_ = this.adapter.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width);
      var getBoundedRadius = function() {
        var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
      };
      this.maxRadius_ = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
      var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
      if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
        this.initialSize_ = initialSize - 1;
      } else {
        this.initialSize_ = initialSize;
      }
      this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
      this.updateLayoutCssVars_();
    };
    MDCRippleFoundation2.prototype.updateLayoutCssVars_ = function() {
      var _a2 = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
      this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
      this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
      if (this.adapter.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };
        this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
        this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
      }
    };
    return MDCRippleFoundation2;
  }(MDCFoundation);
  var {applyPassive} = events;
  var {matches} = ponyfill;
  function Ripple(node, {
    ripple = true,
    surface = false,
    unbounded = false,
    disabled = false,
    color = null,
    active: active2 = null,
    eventTarget = null,
    activeTarget = null,
    addClass = (className) => node.classList.add(className),
    removeClass = (className) => node.classList.remove(className),
    addStyle = (name, value) => node.style.setProperty(name, value),
    initPromise = Promise.resolve()
  } = {}) {
    let instance8;
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let oldActive = active2;
    let oldEventTarget = eventTarget;
    let oldActiveTarget = activeTarget;
    function handleProps() {
      if (surface) {
        addClass("mdc-ripple-surface");
        if (color === "primary") {
          addClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        } else if (color === "secondary") {
          removeClass("smui-ripple-surface--primary");
          addClass("smui-ripple-surface--secondary");
        } else {
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
      }
      if (instance8 && oldActive !== active2) {
        oldActive = active2;
        if (active2) {
          instance8.activate();
        } else if (active2 === false) {
          instance8.deactivate();
        }
      }
      if (ripple && !instance8) {
        instance8 = new MDCRippleFoundation({
          addClass,
          browserSupportsCssVars: () => supportsCssVariables(window),
          computeBoundingRect: () => node.getBoundingClientRect(),
          containsEventTarget: (target) => node.contains(target),
          deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
          deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
          deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
          getWindowPageOffset: () => ({
            x: window.pageXOffset,
            y: window.pageYOffset
          }),
          isSurfaceActive: () => active2 == null ? matches(activeTarget || node, ":active") : active2,
          isSurfaceDisabled: () => !!disabled,
          isUnbounded: () => !!unbounded,
          registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
          registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
          registerResizeHandler: (handler) => window.addEventListener("resize", handler),
          removeClass,
          updateCssVariable: addStyle
        });
        initPromise.then(() => {
          instance8.init();
          instance8.setUnbounded(unbounded);
        });
      } else if (instance8 && !ripple) {
        initPromise.then(() => {
          instance8.destroy();
          instance8 = null;
        });
      }
      if (instance8 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
        oldEventTarget = eventTarget;
        oldActiveTarget = activeTarget;
        instance8.destroy();
        requestAnimationFrame(() => {
          if (instance8) {
            instance8.init();
            instance8.setUnbounded(unbounded);
          }
        });
      }
      if (!ripple && unbounded) {
        addClass("mdc-ripple-upgraded--unbounded");
      }
    }
    handleProps();
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    function layout() {
      if (instance8) {
        instance8.layout();
      }
    }
    return {
      update(props) {
        ({
          ripple,
          surface,
          unbounded,
          disabled,
          color,
          active: active2,
          eventTarget,
          activeTarget,
          addClass,
          removeClass,
          addStyle,
          initPromise
        } = {
          ripple: true,
          surface: false,
          unbounded: false,
          disabled: false,
          color: null,
          active: null,
          eventTarget: null,
          activeTarget: null,
          addClass: (className) => node.classList.add(className),
          removeClass: (className) => node.classList.remove(className),
          addStyle: (name, value) => node.style.setProperty(name, value),
          initPromise: Promise.resolve(),
          ...props
        });
        handleProps();
      },
      destroy() {
        if (instance8) {
          instance8.destroy();
          instance8 = null;
          removeClass("mdc-ripple-surface");
          removeClass("smui-ripple-surface--primary");
          removeClass("smui-ripple-surface--secondary");
        }
        if (removeLayoutListener) {
          removeLayoutListener();
        }
      }
    };
  }
  var file$1 = "node_modules/@smui/common/A.svelte";
  function create_fragment$1(ctx) {
    let a;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[7].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
    let a_levels = [{href: ctx[0]}, ctx[4]];
    let a_data = {};
    for (let i = 0; i < a_levels.length; i += 1) {
      a_data = assign(a_data, a_levels[i]);
    }
    const block = {
      c: function create2() {
        a = element("a");
        if (default_slot)
          default_slot.c();
        set_attributes(a, a_data);
        add_location(a, file$1, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        if (default_slot) {
          default_slot.m(a, null);
        }
        ctx[8](a);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, a, ctx[1])),
            action_destroyer(ctx[3].call(null, a))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 64)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
          }
        }
        set_attributes(a, a_data = get_spread_update(a_levels, [
          (!current || dirty & 1) && {href: ctx2[0]},
          dirty & 16 && ctx2[4]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 2)
          useActions_action.update.call(null, ctx2[1]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(a);
        if (default_slot)
          default_slot.d(detaching);
        ctx[8](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$1.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$1($$self, $$props, $$invalidate) {
    const omit_props_names = ["href", "use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("A", slots, ["default"]);
    let {href = "javascript:void(0);"} = $$props;
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function a_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(2, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("href" in $$new_props)
        $$invalidate(0, href = $$new_props.href);
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(6, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      href,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("href" in $$props)
        $$invalidate(0, href = $$new_props.href);
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(2, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      href,
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      a_binding
    ];
  }
  var A = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {href: 0, use: 1, getElement: 5});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "A",
        options,
        id: create_fragment$1.name
      });
    }
    get href() {
      throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get use() {
      throw new Error("<A>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[5];
    }
    set getElement(value) {
      throw new Error("<A>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file = "node_modules/@smui/common/Span.svelte";
  function create_fragment(ctx) {
    let span;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let span_levels = [ctx[3]];
    let span_data = {};
    for (let i = 0; i < span_levels.length; i += 1) {
      span_data = assign(span_data, span_levels[i]);
    }
    const block = {
      c: function create2() {
        span = element("span");
        if (default_slot)
          default_slot.c();
        set_attributes(span, span_data);
        add_location(span, file, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        if (default_slot) {
          default_slot.m(span, null);
        }
        ctx[7](span);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, span, ctx[0])),
            action_destroyer(ctx[2].call(null, span))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(span, span_data = get_spread_update(span_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Span", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function span_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      span_binding
    ];
  }
  var Span = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance, create_fragment, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Span",
        options,
        id: create_fragment.name
      });
    }
    get use() {
      throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var axios$2 = {exports: {}};
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  var utils$d = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM
  };
  var utils$c = utils$d;
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url2, params, paramsSerializer) {
    if (!params) {
      return url2;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$c.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$c.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$c.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$c.forEach(val, function parseValue(v) {
          if (utils$c.isDate(v)) {
            v = v.toISOString();
          } else if (utils$c.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  };
  var utils$b = utils$d;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$b.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$a = utils$d;
  var transformData$1 = function transformData(data, headers, fns) {
    utils$a.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$9 = utils$d;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$9.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  var enhanceError$1 = function enhanceError(error, config, code, request2, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request2;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  var enhanceError2 = enhanceError$1;
  var createError$2 = function createError(message, config, code, request2, response) {
    var error = new Error(message);
    return enhanceError2(error, config, code, request2, response);
  };
  var createError$1 = createError$2;
  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
  var utils$8 = utils$d;
  var cookies$1 = utils$8.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$8.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$8.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$8.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL2 = isAbsoluteURL$1;
  var combineURLs2 = combineURLs$1;
  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$7 = utils$d;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$7.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$7.trim(line.substr(0, i)).toLowerCase();
      val = utils$7.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$6 = utils$d;
  var isURLSameOrigin$1 = utils$6.isStandardBrowserEnv() ? function standardBrowserEnv2() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url2) {
      var href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils$6.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  var utils$5 = utils$d;
  var settle2 = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath2 = buildFullPath$1;
  var parseHeaders2 = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError2 = createError$2;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils$5.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(resolve, reject, response);
        request2 = null;
      };
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError2("Network Error", config, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError2(timeoutErrorMessage, config, "ECONNABORTED", request2));
        request2 = null;
      };
      if (utils$5.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils$5.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$5.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request2.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request2) {
            return;
          }
          request2.abort();
          reject(cancel);
          request2 = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  var utils$4 = utils$d;
  var normalizeHeaderName2 = normalizeHeaderName$1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$4.isUndefined(headers) && utils$4.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  var defaults$2 = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils$4.isFormData(data) || utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data)) {
        return data;
      }
      if (utils$4.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$4.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils$4.isObject(data)) {
        setContentTypeIfUnset(headers, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$2.headers = {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  };
  utils$4.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$2.headers[method] = {};
  });
  utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$2.headers[method] = utils$4.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$2;
  var utils$3 = utils$d;
  var transformData2 = transformData$1;
  var isCancel2 = isCancel$1;
  var defaults$1 = defaults_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2(config.data, config.headers, config.transformRequest);
    config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$2 = utils$d;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source2) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
        return utils$2.merge(target, source2);
      } else if (utils$2.isPlainObject(source2)) {
        return utils$2.merge({}, source2);
      } else if (utils$2.isArray(source2)) {
        return source2.slice();
      }
      return source2;
    }
    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge2(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
  var utils$1 = utils$d;
  var buildURL2 = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest2 = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest2, void 0];
    var promise2 = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor2) {
      chain.unshift(interceptor2.fulfilled, interceptor2.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor2) {
      chain.push(interceptor2.fulfilled, interceptor2.rejected);
    });
    while (chain.length) {
      promise2 = promise2.then(chain.shift(), chain.shift());
    }
    return promise2;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
    Axios$1.prototype[method] = function(url2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
    Axios$1.prototype[method] = function(url2, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url: url2,
        data
      }));
    };
  });
  var Axios_1 = Axios$1;
  function Cancel$1(message) {
    this.message = message;
  }
  Cancel$1.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;
  var Cancel = Cancel_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  var utils = utils$d;
  var bind2 = bind$2;
  var Axios = Axios_1;
  var mergeConfig2 = mergeConfig$2;
  var defaults = defaults_1;
  function createInstance(defaultConfig2) {
    var context = new Axios(defaultConfig2);
    var instance8 = bind2(Axios.prototype.request, context);
    utils.extend(instance8, Axios.prototype, context);
    utils.extend(instance8, context);
    return instance8;
  }
  var axios$1 = createInstance(defaults);
  axios$1.Axios = Axios;
  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(axios$1.defaults, instanceConfig));
  };
  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  var backendURL = "https://foodsight.ml4all.com";
  var modal = writable({});
  var user = writable(localStorage.getItem("user") ? JSON.parse(localStorage.getItem("user")) : {});
  var userSettings = writable({});
  var screenShotMode = writable(false);
  var problemReport = writable({});
  var notification = writable({});
  var svelteRenderParent = writable();
  var interceptor;
  user.subscribe((val) => {
    localStorage.setItem("user", JSON.stringify(val));
    if (val && Object.keys(val).length) {
      interceptor = axios.interceptors.request.use((config) => {
        config.headers.authorization = `Bearer ${val.access_token}`;
        return config;
      }, (error) => {
        return Promise.reject(error);
      });
    } else {
      axios.interceptors.request.eject(interceptor);
    }
  });
  function cubicInOut(t) {
    return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;
  }
  function cubicOut(t) {
    const f = t - 1;
    return f * f * f + 1;
  }
  function quintOut(t) {
    return --t * t * t * t * t + 1;
  }
  function blur(node, {delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0} = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === "none" ? "" : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
      delay,
      duration,
      easing,
      css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * amount}px);`
    };
  }
  function fade(node, {delay = 0, duration = 400, easing = identity} = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
      delay,
      duration,
      easing,
      css: (t) => `opacity: ${t * o}`
    };
  }
  function fly(node, {delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0} = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === "none" ? "" : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
      delay,
      duration,
      easing,
      css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
    };
  }

  // dist/build/Subtitle.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var oldModifierRegex2 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex2 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder2(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex2);
      const newModifierMatch = eventType.match(newModifierRegex2);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex2);
        const newModifierMatch = eventType.match(newModifierRegex2);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap2(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function create_default_slot2(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot2.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$32(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap2({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot2]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap2({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$32.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals2 = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance$32($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals2.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals2.contexts;
    const props = internals2.props;
    let {component = internals2.component} = $$props;
    Object.entries(internals2.classMap).forEach(([name, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder2(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals: internals2,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder2,
      classMap: classMap2,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder2 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$32, create_fragment$32, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment$32.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults2 = {...internals2};
  function classAdderBuilder2(props) {
    function Component(...args) {
      Object.assign(internals2, defaults2, props);
      return new ClassAdder2(...args);
    }
    Component.prototype = ClassAdder2;
    if (ClassAdder2.$$render) {
      Component.$$render = (...args) => Object.assign(internals2, defaults2, props) && ClassAdder2.$$render(...args);
    }
    if (ClassAdder2.render) {
      Component.render = (...args) => Object.assign(internals2, defaults2, props) && ClassAdder2.render(...args);
    }
    return Component;
  }
  function useActions2(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file$22 = "node_modules/@smui/paper/Paper.svelte";
  function create_fragment$22(ctx) {
    let div;
    let div_class_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[11].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
    let div_levels = [
      {
        class: div_class_value = classMap2({
          [ctx[1]]: true,
          "smui-paper": true,
          ["smui-paper--elevation-z" + ctx[4]]: ctx[4] !== 0,
          "smui-paper--rounded": !ctx[2],
          ["smui-paper--color-" + ctx[3]]: ctx[3] !== "default",
          "smui-paper-transition": ctx[5]
        })
      },
      ctx[8]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$22, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[12](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions2.call(null, div, ctx[0])),
            action_destroyer(ctx[7].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1024)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[10], !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty & 62 && div_class_value !== (div_class_value = classMap2({
            [ctx2[1]]: true,
            "smui-paper": true,
            ["smui-paper--elevation-z" + ctx2[4]]: ctx2[4] !== 0,
            "smui-paper--rounded": !ctx2[2],
            ["smui-paper--color-" + ctx2[3]]: ctx2[3] !== "default",
            "smui-paper-transition": ctx2[5]
          }))) && {class: div_class_value},
          dirty & 256 && ctx2[8]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[12](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$22.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$22($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "square", "color", "elevation", "transition", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Paper", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder2(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {square = false} = $$props;
    let {color = "default"} = $$props;
    let {elevation = 1} = $$props;
    let {transition = false} = $$props;
    let element2;
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(6, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("square" in $$new_props)
        $$invalidate(2, square = $$new_props.square);
      if ("color" in $$new_props)
        $$invalidate(3, color = $$new_props.color);
      if ("elevation" in $$new_props)
        $$invalidate(4, elevation = $$new_props.elevation);
      if ("transition" in $$new_props)
        $$invalidate(5, transition = $$new_props.transition);
      if ("$$scope" in $$new_props)
        $$invalidate(10, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder2,
      classMap: classMap2,
      useActions: useActions2,
      forwardEvents,
      use: use2,
      className,
      square,
      color,
      elevation,
      transition,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("square" in $$props)
        $$invalidate(2, square = $$new_props.square);
      if ("color" in $$props)
        $$invalidate(3, color = $$new_props.color);
      if ("elevation" in $$props)
        $$invalidate(4, elevation = $$new_props.elevation);
      if ("transition" in $$props)
        $$invalidate(5, transition = $$new_props.transition);
      if ("element" in $$props)
        $$invalidate(6, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      square,
      color,
      elevation,
      transition,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      div_binding
    ];
  }
  var Paper = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$22, create_fragment$22, safe_not_equal, {
        use: 0,
        class: 1,
        square: 2,
        color: 3,
        elevation: 4,
        transition: 5,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Paper",
        options,
        id: create_fragment$22.name
      });
    }
    get use() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get square() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set square(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get elevation() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set elevation(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get transition() {
      throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set transition(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Content = classAdderBuilder2({
    class: "smui-paper__content",
    component: Div
  });
  var file$12 = "node_modules/@smui/common/H5.svelte";
  function create_fragment$12(ctx) {
    let h5;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h5_levels = [ctx[3]];
    let h5_data = {};
    for (let i = 0; i < h5_levels.length; i += 1) {
      h5_data = assign(h5_data, h5_levels[i]);
    }
    const block = {
      c: function create2() {
        h5 = element("h5");
        if (default_slot)
          default_slot.c();
        set_attributes(h5, h5_data);
        add_location(h5, file$12, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h5, anchor);
        if (default_slot) {
          default_slot.m(h5, null);
        }
        ctx[7](h5);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h5, ctx[0])),
            action_destroyer(ctx[2].call(null, h5))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h5, h5_data = get_spread_update(h5_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h5);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$12.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$12($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H5", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h5_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h5_binding
    ];
  }
  var H5 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$12, create_fragment$12, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H5",
        options,
        id: create_fragment$12.name
      });
    }
    get use() {
      throw new Error("<H5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Title = classAdderBuilder2({
    class: "smui-paper__title",
    component: H5
  });
  var file2 = "node_modules/@smui/common/H6.svelte";
  function create_fragment2(ctx) {
    let h6;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h6_levels = [ctx[3]];
    let h6_data = {};
    for (let i = 0; i < h6_levels.length; i += 1) {
      h6_data = assign(h6_data, h6_levels[i]);
    }
    const block = {
      c: function create2() {
        h6 = element("h6");
        if (default_slot)
          default_slot.c();
        set_attributes(h6, h6_data);
        add_location(h6, file2, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h6, anchor);
        if (default_slot) {
          default_slot.m(h6, null);
        }
        ctx[7](h6);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h6, ctx[0])),
            action_destroyer(ctx[2].call(null, h6))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h6, h6_data = get_spread_update(h6_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h6);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment2.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance2($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H6", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h6_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h6_binding
    ];
  }
  var H6 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance2, create_fragment2, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H6",
        options,
        id: create_fragment2.name
      });
    }
    get use() {
      throw new Error("<H6>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H6>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H6>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  classAdderBuilder2({
    class: "smui-paper__subtitle",
    component: H6
  });

  // dist/build/CommonLabel.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var oldModifierRegex3 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex3 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder3(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex3);
      const newModifierMatch = eventType.match(newModifierRegex3);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex3);
        const newModifierMatch = eventType.match(newModifierRegex3);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap3(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function dispatch(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  var file$13 = "node_modules/@smui/common/Button.svelte";
  function create_fragment$23(ctx) {
    let button;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let button_levels = [ctx[3]];
    let button_data = {};
    for (let i = 0; i < button_levels.length; i += 1) {
      button_data = assign(button_data, button_levels[i]);
    }
    const block = {
      c: function create2() {
        button = element("button");
        if (default_slot)
          default_slot.c();
        set_attributes(button, button_data);
        add_location(button, file$13, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, button, anchor);
        if (default_slot) {
          default_slot.m(button, null);
        }
        if (button.autofocus)
          button.focus();
        ctx[7](button);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, button, ctx[0])),
            action_destroyer(ctx[2].call(null, button))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(button, button_data = get_spread_update(button_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(button);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$23.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$23($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Button", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function button_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      button_binding
    ];
  }
  var Button = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$23, create_fragment$23, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Button",
        options,
        id: create_fragment$23.name
      });
    }
    get use() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file3 = "node_modules/@smui/button/Button.svelte";
  function create_if_block(ctx) {
    let div;
    const block = {
      c: function create2() {
        div = element("div");
        attr_dev(div, "class", "mdc-button__touch");
        add_location(div, file3, 49, 21, 1522);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block.name,
      type: "if",
      source: "(50:10) {#if touch}",
      ctx
    });
    return block;
  }
  function create_default_slot$1(ctx) {
    let div;
    let t;
    let if_block_anchor;
    let current;
    const default_slot_template = ctx[26].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[28], null);
    let if_block = ctx[6] && create_if_block(ctx);
    const block = {
      c: function create2() {
        div = element("div");
        t = space();
        if (default_slot)
          default_slot.c();
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
        attr_dev(div, "class", "mdc-button__ripple");
        add_location(div, file3, 48, 3, 1466);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        insert_dev(target, t, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 268435456)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[28], !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(default_slot_template, ctx2[28], dirty, null), null);
          }
        }
        if (ctx2[6]) {
          if (if_block)
            ;
          else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (detaching)
          detach_dev(t);
        if (default_slot)
          default_slot.d(detaching);
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$1.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: false,         color,         disabled: !!$$restProps.disabled,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-button': true,     'mdc-button--raised': variant === 'raised',     'mdc-button--unelevated': variant === 'unelevated',     'mdc-button--outlined': variant === 'outlined',     'smui-button--color-secondary': color === 'secondary',     'mdc-button--touch': touch,     'mdc-card__action': context === 'card:action',     'mdc-card__action--button': context === 'card:action',     'mdc-dialog__button': context === 'dialog:action',     'mdc-top-app-bar__navigation-icon': context === 'top-app-bar:navigation',     'mdc-top-app-bar__action-item': context === 'top-app-bar:action',     'mdc-snackbar__action': context === 'snackbar:actions',     'mdc-banner__secondary-action': context === 'banner' && secondary,     'mdc-banner__primary-action': context === 'banner' && !secondary,     'mdc-tooltip__action': context === 'tooltip:rich-actions',     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...actionProp}   {...defaultProp}   {...secondaryProp}   {href}   on:click={handleClick}   {...$$restProps}   >",
      ctx
    });
    return block;
  }
  function create_fragment$13(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [
          [
            Ripple,
            {
              ripple: ctx[3],
              unbounded: false,
              color: ctx[4],
              disabled: !!ctx[22].disabled,
              addClass: ctx[18],
              removeClass: ctx[19],
              addStyle: ctx[20]
            }
          ],
          ctx[16],
          ...ctx[0]
        ]
      },
      {
        class: classMap3({
          [ctx[1]]: true,
          "mdc-button": true,
          "mdc-button--raised": ctx[5] === "raised",
          "mdc-button--unelevated": ctx[5] === "unelevated",
          "mdc-button--outlined": ctx[5] === "outlined",
          "smui-button--color-secondary": ctx[4] === "secondary",
          "mdc-button--touch": ctx[6],
          "mdc-card__action": ctx[17] === "card:action",
          "mdc-card__action--button": ctx[17] === "card:action",
          "mdc-dialog__button": ctx[17] === "dialog:action",
          "mdc-top-app-bar__navigation-icon": ctx[17] === "top-app-bar:navigation",
          "mdc-top-app-bar__action-item": ctx[17] === "top-app-bar:action",
          "mdc-snackbar__action": ctx[17] === "snackbar:actions",
          "mdc-banner__secondary-action": ctx[17] === "banner" && ctx[8],
          "mdc-banner__primary-action": ctx[17] === "banner" && !ctx[8],
          "mdc-tooltip__action": ctx[17] === "tooltip:rich-actions",
          ...ctx[11]
        })
      },
      {
        style: Object.entries(ctx[12]).map(func).concat([ctx[2]]).join(" ")
      },
      ctx[15],
      ctx[14],
      ctx[13],
      {href: ctx[7]},
      ctx[22]
    ];
    var switch_value = ctx[9];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$1]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[27](switch_instance);
      switch_instance.$on("click", ctx[21]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 6289919 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 6094873 && {
            use: [
              [
                Ripple,
                {
                  ripple: ctx2[3],
                  unbounded: false,
                  color: ctx2[4],
                  disabled: !!ctx2[22].disabled,
                  addClass: ctx2[18],
                  removeClass: ctx2[19],
                  addStyle: ctx2[20]
                }
              ],
              ctx2[16],
              ...ctx2[0]
            ]
          },
          dirty & 133490 && {
            class: classMap3({
              [ctx2[1]]: true,
              "mdc-button": true,
              "mdc-button--raised": ctx2[5] === "raised",
              "mdc-button--unelevated": ctx2[5] === "unelevated",
              "mdc-button--outlined": ctx2[5] === "outlined",
              "smui-button--color-secondary": ctx2[4] === "secondary",
              "mdc-button--touch": ctx2[6],
              "mdc-card__action": ctx2[17] === "card:action",
              "mdc-card__action--button": ctx2[17] === "card:action",
              "mdc-dialog__button": ctx2[17] === "dialog:action",
              "mdc-top-app-bar__navigation-icon": ctx2[17] === "top-app-bar:navigation",
              "mdc-top-app-bar__action-item": ctx2[17] === "top-app-bar:action",
              "mdc-snackbar__action": ctx2[17] === "snackbar:actions",
              "mdc-banner__secondary-action": ctx2[17] === "banner" && ctx2[8],
              "mdc-banner__primary-action": ctx2[17] === "banner" && !ctx2[8],
              "mdc-tooltip__action": ctx2[17] === "tooltip:rich-actions",
              ...ctx2[11]
            })
          },
          dirty & 4100 && {
            style: Object.entries(ctx2[12]).map(func).concat([ctx2[2]]).join(" ")
          },
          dirty & 32768 && get_spread_object(ctx2[15]),
          dirty & 16384 && get_spread_object(ctx2[14]),
          dirty & 8192 && get_spread_object(ctx2[13]),
          dirty & 128 && {href: ctx2[7]},
          dirty & 4194304 && get_spread_object(ctx2[22])
        ]) : {};
        if (dirty & 268435520) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[9])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[27](switch_instance);
            switch_instance.$on("click", ctx2[21]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[27](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$13.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func = ([name, value]) => `${name}: ${value};`;
  function instance$13($$self, $$props, $$invalidate) {
    let actionProp;
    let defaultProp;
    let secondaryProp;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "ripple",
      "color",
      "variant",
      "touch",
      "href",
      "action",
      "default",
      "secondary",
      "component",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Button", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder3(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {ripple = true} = $$props;
    let {color = "primary"} = $$props;
    let {variant = "text"} = $$props;
    let {touch = false} = $$props;
    let {href = null} = $$props;
    let {action = "close"} = $$props;
    let {default: defaultAction = false} = $$props;
    let {secondary = false} = $$props;
    let element2;
    let internalClasses = {};
    let internalStyles = {};
    let context = getContext("SMUI:button:context");
    let {component = href == null ? Button : A} = $$props;
    setContext("SMUI:label:context", "button");
    setContext("SMUI:icon:context", "button");
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(11, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(11, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name, value) {
      if (internalStyles[name] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name];
          $$invalidate(12, internalStyles);
        } else {
          $$invalidate(12, internalStyles[name] = value, internalStyles);
        }
      }
    }
    function handleClick2() {
      if (context === "banner") {
        dispatch(getElement(), secondary ? "SMUI:banner:button:secondaryActionClick" : "SMUI:banner:button:primaryActionClick");
      }
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(10, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
      $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(2, style = $$new_props.style);
      if ("ripple" in $$new_props)
        $$invalidate(3, ripple = $$new_props.ripple);
      if ("color" in $$new_props)
        $$invalidate(4, color = $$new_props.color);
      if ("variant" in $$new_props)
        $$invalidate(5, variant = $$new_props.variant);
      if ("touch" in $$new_props)
        $$invalidate(6, touch = $$new_props.touch);
      if ("href" in $$new_props)
        $$invalidate(7, href = $$new_props.href);
      if ("action" in $$new_props)
        $$invalidate(23, action = $$new_props.action);
      if ("default" in $$new_props)
        $$invalidate(24, defaultAction = $$new_props.default);
      if ("secondary" in $$new_props)
        $$invalidate(8, secondary = $$new_props.secondary);
      if ("component" in $$new_props)
        $$invalidate(9, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(28, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      setContext,
      getContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder3,
      classMap: classMap3,
      dispatch,
      Ripple,
      A,
      Button,
      forwardEvents,
      use: use2,
      className,
      style,
      ripple,
      color,
      variant,
      touch,
      href,
      action,
      defaultAction,
      secondary,
      element: element2,
      internalClasses,
      internalStyles,
      context,
      component,
      addClass,
      removeClass,
      addStyle,
      handleClick: handleClick2,
      getElement,
      secondaryProp,
      defaultProp,
      actionProp
    });
    $$self.$inject_state = ($$new_props) => {
      $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(2, style = $$new_props.style);
      if ("ripple" in $$props)
        $$invalidate(3, ripple = $$new_props.ripple);
      if ("color" in $$props)
        $$invalidate(4, color = $$new_props.color);
      if ("variant" in $$props)
        $$invalidate(5, variant = $$new_props.variant);
      if ("touch" in $$props)
        $$invalidate(6, touch = $$new_props.touch);
      if ("href" in $$props)
        $$invalidate(7, href = $$new_props.href);
      if ("action" in $$props)
        $$invalidate(23, action = $$new_props.action);
      if ("defaultAction" in $$props)
        $$invalidate(24, defaultAction = $$new_props.defaultAction);
      if ("secondary" in $$props)
        $$invalidate(8, secondary = $$new_props.secondary);
      if ("element" in $$props)
        $$invalidate(10, element2 = $$new_props.element);
      if ("internalClasses" in $$props)
        $$invalidate(11, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(12, internalStyles = $$new_props.internalStyles);
      if ("context" in $$props)
        $$invalidate(17, context = $$new_props.context);
      if ("component" in $$props)
        $$invalidate(9, component = $$new_props.component);
      if ("secondaryProp" in $$props)
        $$invalidate(13, secondaryProp = $$new_props.secondaryProp);
      if ("defaultProp" in $$props)
        $$invalidate(14, defaultProp = $$new_props.defaultProp);
      if ("actionProp" in $$props)
        $$invalidate(15, actionProp = $$new_props.actionProp);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      $$invalidate(15, actionProp = context === "dialog:action" && action != null ? {"data-mdc-dialog-action": action} : {action: $$props.action});
      $$invalidate(14, defaultProp = context === "dialog:action" && defaultAction ? {"data-mdc-dialog-button-default": ""} : {default: $$props.default});
      $$invalidate(13, secondaryProp = context === "banner" ? {} : {secondary: $$props.secondary});
    };
    $$props = exclude_internal_props($$props);
    return [
      use2,
      className,
      style,
      ripple,
      color,
      variant,
      touch,
      href,
      secondary,
      component,
      element2,
      internalClasses,
      internalStyles,
      secondaryProp,
      defaultProp,
      actionProp,
      forwardEvents,
      context,
      addClass,
      removeClass,
      addStyle,
      handleClick2,
      $$restProps,
      action,
      defaultAction,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var Button_1 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$13, create_fragment$13, safe_not_equal, {
        use: 0,
        class: 1,
        style: 2,
        ripple: 3,
        color: 4,
        variant: 5,
        touch: 6,
        href: 7,
        action: 23,
        default: 24,
        secondary: 8,
        component: 9,
        getElement: 25
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Button_1",
        options,
        id: create_fragment$13.name
      });
    }
    get use() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get variant() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set variant(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get touch() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set touch(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get href() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get action() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set action(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get default() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set default(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get secondary() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set secondary(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[25];
    }
    set getElement(value) {
      throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot3(ctx) {
    let current;
    const default_slot_template = ctx[9].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2048)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot3.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment3(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[4], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-button__label": ctx[5] === "button",
          "mdc-fab__label": ctx[5] === "fab",
          "mdc-tab__text-label": ctx[5] === "tab",
          "mdc-image-list__label": ctx[5] === "image-list",
          "mdc-snackbar__label": ctx[5] === "snackbar",
          "mdc-banner__text": ctx[5] === "banner",
          "mdc-segmented-button__label": ctx[5] === "segmented-button",
          "mdc-data-table__pagination-rows-per-page-label": ctx[5] === "data-table:pagination",
          "mdc-data-table__header-cell-label": ctx[5] === "data-table:sortable-header-cell"
        })
      },
      ctx[5] === "snackbar" ? {"aria-atomic": "false"} : {},
      {tabindex: ctx[6]},
      ctx[7]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot3]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[10](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 243 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 17 && {
            use: [ctx2[4], ...ctx2[0]]
          },
          dirty & 34 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-button__label": ctx2[5] === "button",
              "mdc-fab__label": ctx2[5] === "fab",
              "mdc-tab__text-label": ctx2[5] === "tab",
              "mdc-image-list__label": ctx2[5] === "image-list",
              "mdc-snackbar__label": ctx2[5] === "snackbar",
              "mdc-banner__text": ctx2[5] === "banner",
              "mdc-segmented-button__label": ctx2[5] === "segmented-button",
              "mdc-data-table__pagination-rows-per-page-label": ctx2[5] === "data-table:pagination",
              "mdc-data-table__header-cell-label": ctx2[5] === "data-table:sortable-header-cell"
            })
          },
          dirty & 32 && get_spread_object(ctx2[5] === "snackbar" ? {"aria-atomic": "false"} : {}),
          dirty & 64 && {tabindex: ctx2[6]},
          dirty & 128 && get_spread_object(ctx2[7])
        ]) : {};
        if (dirty & 2048) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[10](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[10](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment3.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance3($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("CommonLabel", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    let {component = Span} = $$props;
    const context = getContext("SMUI:label:context");
    const tabindex = getContext("SMUI:label:tabindex");
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(11, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      useActions,
      Span,
      forwardEvents,
      use: use2,
      className,
      element: element2,
      component,
      context,
      tabindex,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      forwardEvents,
      context,
      tabindex,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var CommonLabel = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance3, create_fragment3, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 8
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "CommonLabel",
        options,
        id: create_fragment3.name
      });
    }
    get use() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[8];
    }
    set getElement(value) {
      throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/classAdderBuilder.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var KEY = {
    UNKNOWN: "Unknown",
    BACKSPACE: "Backspace",
    ENTER: "Enter",
    SPACEBAR: "Spacebar",
    PAGE_UP: "PageUp",
    PAGE_DOWN: "PageDown",
    END: "End",
    HOME: "Home",
    ARROW_LEFT: "ArrowLeft",
    ARROW_UP: "ArrowUp",
    ARROW_RIGHT: "ArrowRight",
    ARROW_DOWN: "ArrowDown",
    DELETE: "Delete",
    ESCAPE: "Escape",
    TAB: "Tab"
  };
  var normalizedKeys = new Set();
  normalizedKeys.add(KEY.BACKSPACE);
  normalizedKeys.add(KEY.ENTER);
  normalizedKeys.add(KEY.SPACEBAR);
  normalizedKeys.add(KEY.PAGE_UP);
  normalizedKeys.add(KEY.PAGE_DOWN);
  normalizedKeys.add(KEY.END);
  normalizedKeys.add(KEY.HOME);
  normalizedKeys.add(KEY.ARROW_LEFT);
  normalizedKeys.add(KEY.ARROW_UP);
  normalizedKeys.add(KEY.ARROW_RIGHT);
  normalizedKeys.add(KEY.ARROW_DOWN);
  normalizedKeys.add(KEY.DELETE);
  normalizedKeys.add(KEY.ESCAPE);
  normalizedKeys.add(KEY.TAB);
  var KEY_CODE = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46,
    ESCAPE: 27,
    TAB: 9
  };
  var mappedKeyCodes = new Map();
  mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
  mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
  mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
  mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
  mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
  mappedKeyCodes.set(KEY_CODE.END, KEY.END);
  mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
  mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
  mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
  mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
  mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
  mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
  mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
  mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
  var navigationKeys = new Set();
  navigationKeys.add(KEY.PAGE_UP);
  navigationKeys.add(KEY.PAGE_DOWN);
  navigationKeys.add(KEY.END);
  navigationKeys.add(KEY.HOME);
  navigationKeys.add(KEY.ARROW_LEFT);
  navigationKeys.add(KEY.ARROW_UP);
  navigationKeys.add(KEY.ARROW_RIGHT);
  navigationKeys.add(KEY.ARROW_DOWN);
  function normalizeKey(evt) {
    var key = evt.key;
    if (normalizedKeys.has(key)) {
      return key;
    }
    var mappedKey = mappedKeyCodes.get(evt.keyCode);
    if (mappedKey) {
      return mappedKey;
    }
    return KEY.UNKNOWN;
  }
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssPropertyNameMap = {
    animation: {
      prefixed: "-webkit-animation",
      standard: "animation"
    },
    transform: {
      prefixed: "-webkit-transform",
      standard: "transform"
    },
    transition: {
      prefixed: "-webkit-transition",
      standard: "transition"
    }
  };
  function isWindow(windowObj) {
    return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
  }
  function getCorrectPropertyName(windowObj, cssProperty) {
    if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
      var el = windowObj.document.createElement("div");
      var _a2 = cssPropertyNameMap[cssProperty], standard = _a2.standard, prefixed = _a2.prefixed;
      var isStandard = standard in el.style;
      return isStandard ? standard : prefixed;
    }
    return cssProperty;
  }
  var oldModifierRegex4 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex4 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder4(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex4);
      const newModifierMatch = eventType.match(newModifierRegex4);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex4);
        const newModifierMatch = eventType.match(newModifierRegex4);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap4(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function create_default_slot4(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot4.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment4(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap4({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot4]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap4({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment4.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals3 = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance4($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals3.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals3.contexts;
    const props = internals3.props;
    let {component = internals3.component} = $$props;
    Object.entries(internals3.classMap).forEach(([name, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder4(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals: internals3,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder4,
      classMap: classMap4,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder3 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance4, create_fragment4, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment4.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults3 = {...internals3};
  function classAdderBuilder3(props) {
    function Component(...args) {
      Object.assign(internals3, defaults3, props);
      return new ClassAdder3(...args);
    }
    Component.prototype = ClassAdder3;
    if (ClassAdder3.$$render) {
      Component.$$render = (...args) => Object.assign(internals3, defaults3, props) && ClassAdder3.$$render(...args);
    }
    if (ClassAdder3.render) {
      Component.render = (...args) => Object.assign(internals3, defaults3, props) && ClassAdder3.render(...args);
    }
    return Component;
  }

  // dist/build/Subheader.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$2 = {
    ANCHOR: "mdc-menu-surface--anchor",
    ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
    ANIMATING_OPEN: "mdc-menu-surface--animating-open",
    FIXED: "mdc-menu-surface--fixed",
    IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
    OPEN: "mdc-menu-surface--open",
    ROOT: "mdc-menu-surface"
  };
  var strings$2 = {
    CLOSED_EVENT: "MDCMenuSurface:closed",
    CLOSING_EVENT: "MDCMenuSurface:closing",
    OPENED_EVENT: "MDCMenuSurface:opened",
    FOCUSABLE_ELEMENTS: [
      "button:not(:disabled)",
      '[href]:not([aria-disabled="true"])',
      "input:not(:disabled)",
      "select:not(:disabled)",
      "textarea:not(:disabled)",
      '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
    ].join(", ")
  };
  var numbers$2 = {
    TRANSITION_OPEN_DURATION: 120,
    TRANSITION_CLOSE_DURATION: 75,
    MARGIN_TO_EDGE: 32,
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
  };
  var CornerBit;
  (function(CornerBit2) {
    CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
    CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
    CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
    CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
  })(CornerBit || (CornerBit = {}));
  var Corner;
  (function(Corner2) {
    Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
    Corner2[Corner2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
    Corner2[Corner2["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
    Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
    Corner2[Corner2["TOP_START"] = 8] = "TOP_START";
    Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
    Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
    Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
  })(Corner || (Corner = {}));
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var _a;
  var _b;
  var cssClasses$1 = {
    LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
    LIST_ITEM_CLASS: "mdc-list-item",
    LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
    LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
    LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
    LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
    ROOT: "mdc-list"
  };
  _a = {}, _a["" + cssClasses$1.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses$1.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses$1.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses$1.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses$1.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses$1.ROOT] = "mdc-list", _a;
  var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses$1.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b["" + cssClasses$1.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b["" + cssClasses$1.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b["" + cssClasses$1.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b["" + cssClasses$1.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b["" + cssClasses$1.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b["" + cssClasses$1.ROOT] = "mdc-deprecated-list", _b);
  var strings$1 = {
    ACTION_EVENT: "MDCList:action",
    ARIA_CHECKED: "aria-checked",
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: "aria-current",
    ARIA_DISABLED: "aria-disabled",
    ARIA_ORIENTATION: "aria-orientation",
    ARIA_ORIENTATION_HORIZONTAL: "horizontal",
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: "aria-selected",
    ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
    ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$1.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$1.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + " a\n  ",
    DEPRECATED_SELECTOR: ".mdc-deprecated-list",
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$1.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$1.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$1.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses$1.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$1.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
    RADIO_SELECTOR: 'input[type="radio"]',
    SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
  };
  var numbers$1 = {
    UNSET_INDEX: -1,
    TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
  };
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
  var preventDefaultEvent = function(evt) {
    var target = evt.target;
    if (!target) {
      return;
    }
    var tagName = ("" + target.tagName).toLowerCase();
    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
      evt.preventDefault();
    }
  };
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function initState() {
    var state = {
      bufferClearTimeout: 0,
      currentFirstChar: "",
      sortedIndexCursor: 0,
      typeaheadBuffer: ""
    };
    return state;
  }
  function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
    var sortedIndexByFirstChar = new Map();
    for (var i = 0; i < listItemCount; i++) {
      var primaryText = getPrimaryTextByItemIndex(i).trim();
      if (!primaryText) {
        continue;
      }
      var firstChar = primaryText[0].toLowerCase();
      if (!sortedIndexByFirstChar.has(firstChar)) {
        sortedIndexByFirstChar.set(firstChar, []);
      }
      sortedIndexByFirstChar.get(firstChar).push({text: primaryText.toLowerCase(), index: i});
    }
    sortedIndexByFirstChar.forEach(function(values) {
      values.sort(function(first, second) {
        return first.index - second.index;
      });
    });
    return sortedIndexByFirstChar;
  }
  function matchItem(opts, state) {
    var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    clearTimeout(state.bufferClearTimeout);
    state.bufferClearTimeout = setTimeout(function() {
      clearBuffer(state);
    }, numbers$1.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
    state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
    var index;
    if (state.typeaheadBuffer.length === 1) {
      index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
    } else {
      index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
    }
    if (index !== -1 && !skipFocus) {
      focusItemAtIndex(index);
    }
    return index;
  }
  function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
      return -1;
    }
    if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
      state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
      var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
      if (!isItemAtIndexDisabled(newIndex)) {
        return newIndex;
      }
    }
    state.currentFirstChar = firstChar;
    var newCursorPosition = -1;
    var cursorPosition;
    for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
      if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
        newCursorPosition = cursorPosition;
        break;
      }
    }
    for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
      if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
        newCursorPosition = cursorPosition;
        break;
      }
    }
    if (newCursorPosition !== -1) {
      state.sortedIndexCursor = newCursorPosition;
      return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
  }
  function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
      return -1;
    }
    var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
    if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
      return startingItem.index;
    }
    var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var nextCursorPosition = -1;
    while (cursorPosition !== state.sortedIndexCursor) {
      var currentItem = itemsMatchingFirstChar[cursorPosition];
      var matches2 = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
      var isEnabled = !isItemAtIndexDisabled(currentItem.index);
      if (matches2 && isEnabled) {
        nextCursorPosition = cursorPosition;
        break;
      }
      cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
    }
    if (nextCursorPosition !== -1) {
      state.sortedIndexCursor = nextCursorPosition;
      return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
  }
  function isTypingInProgress(state) {
    return state.typeaheadBuffer.length > 0;
  }
  function clearBuffer(state) {
    state.typeaheadBuffer = "";
  }
  function handleKeydown(opts, state) {
    var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    var isArrowLeft = normalizeKey(event) === "ArrowLeft";
    var isArrowUp = normalizeKey(event) === "ArrowUp";
    var isArrowRight = normalizeKey(event) === "ArrowRight";
    var isArrowDown = normalizeKey(event) === "ArrowDown";
    var isHome = normalizeKey(event) === "Home";
    var isEnd = normalizeKey(event) === "End";
    var isEnter = normalizeKey(event) === "Enter";
    var isSpace = normalizeKey(event) === "Spacebar";
    if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
      return -1;
    }
    var isCharacterKey = !isSpace && event.key.length === 1;
    if (isCharacterKey) {
      preventDefaultEvent(event);
      var matchItemOpts = {
        focusItemAtIndex,
        focusedItemIndex,
        nextChar: event.key.toLowerCase(),
        sortedIndexByFirstChar,
        skipFocus: false,
        isItemAtIndexDisabled
      };
      return matchItem(matchItemOpts, state);
    }
    if (!isSpace) {
      return -1;
    }
    if (isTargetListItem) {
      preventDefaultEvent(event);
    }
    var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
    if (typeaheadOnListItem) {
      var matchItemOpts = {
        focusItemAtIndex,
        focusedItemIndex,
        nextChar: " ",
        sortedIndexByFirstChar,
        skipFocus: false,
        isItemAtIndexDisabled
      };
      return matchItem(matchItemOpts, state);
    }
    return -1;
  }
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  function isNumberArray(selectedIndex) {
    return selectedIndex instanceof Array;
  }
  var MDCListFoundation = function(_super) {
    __extends(MDCListFoundation2, _super);
    function MDCListFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
      _this.wrapFocus_ = false;
      _this.isVertical_ = true;
      _this.isSingleSelectionList_ = false;
      _this.selectedIndex_ = numbers$1.UNSET_INDEX;
      _this.focusedItemIndex = numbers$1.UNSET_INDEX;
      _this.useActivatedClass_ = false;
      _this.useSelectedAttr_ = false;
      _this.ariaCurrentAttrValue_ = null;
      _this.isCheckboxList_ = false;
      _this.isRadioList_ = false;
      _this.hasTypeahead = false;
      _this.typeaheadState = initState();
      _this.sortedIndexByFirstChar = new Map();
      return _this;
    }
    Object.defineProperty(MDCListFoundation2, "strings", {
      get: function() {
        return strings$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "numbers", {
      get: function() {
        return numbers$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassForElementIndex: function() {
            return void 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          getAttributeForElementIndex: function() {
            return null;
          },
          getFocusedElementIndex: function() {
            return 0;
          },
          getListItemCount: function() {
            return 0;
          },
          hasCheckboxAtIndex: function() {
            return false;
          },
          hasRadioAtIndex: function() {
            return false;
          },
          isCheckboxCheckedAtIndex: function() {
            return false;
          },
          isFocusInsideList: function() {
            return false;
          },
          isRootFocused: function() {
            return false;
          },
          listItemAtIndexHasClass: function() {
            return false;
          },
          notifyAction: function() {
            return void 0;
          },
          removeClassForElementIndex: function() {
            return void 0;
          },
          setAttributeForElementIndex: function() {
            return void 0;
          },
          setCheckedCheckboxOrRadioAtIndex: function() {
            return void 0;
          },
          setTabIndexForListItemChildren: function() {
            return void 0;
          },
          getPrimaryTextAtIndex: function() {
            return "";
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCListFoundation2.prototype.layout = function() {
      if (this.adapter.getListItemCount() === 0) {
        return;
      }
      if (this.adapter.hasCheckboxAtIndex(0)) {
        this.isCheckboxList_ = true;
      } else if (this.adapter.hasRadioAtIndex(0)) {
        this.isRadioList_ = true;
      } else {
        this.maybeInitializeSingleSelection();
      }
      if (this.hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.setWrapFocus = function(value) {
      this.wrapFocus_ = value;
    };
    MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
      this.isVertical_ = value;
    };
    MDCListFoundation2.prototype.setSingleSelection = function(value) {
      this.isSingleSelectionList_ = value;
      if (value) {
        this.maybeInitializeSingleSelection();
      }
    };
    MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
      var listItemsCount = this.adapter.getListItemCount();
      for (var i = 0; i < listItemsCount; i++) {
        var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$1.LIST_ITEM_SELECTED_CLASS);
        var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses$1.LIST_ITEM_ACTIVATED_CLASS);
        if (!(hasSelectedClass || hasActivatedClass)) {
          continue;
        }
        if (hasActivatedClass) {
          this.setUseActivatedClass(true);
        }
        this.isSingleSelectionList_ = true;
        this.selectedIndex_ = i;
        return;
      }
    };
    MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
      this.hasTypeahead = hasTypeahead;
      if (hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
      return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
    };
    MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
      this.useActivatedClass_ = useActivated;
    };
    MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
      this.useSelectedAttr_ = useSelected;
    };
    MDCListFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex_;
    };
    MDCListFoundation2.prototype.setSelectedIndex = function(index) {
      if (!this.isIndexValid_(index)) {
        return;
      }
      if (this.isCheckboxList_) {
        this.setCheckboxAtIndex_(index);
      } else if (this.isRadioList_) {
        this.setRadioAtIndex_(index);
      } else {
        this.setSingleSelectionAtIndex_(index);
      }
    };
    MDCListFoundation2.prototype.handleFocusIn = function(_2, listItemIndex) {
      if (listItemIndex >= 0) {
        this.focusedItemIndex = listItemIndex;
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
      }
    };
    MDCListFoundation2.prototype.handleFocusOut = function(_2, listItemIndex) {
      var _this = this;
      if (listItemIndex >= 0) {
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
      }
      setTimeout(function() {
        if (!_this.adapter.isFocusInsideList()) {
          _this.setTabindexToFirstSelectedOrFocusedItem();
        }
      }, 0);
    };
    MDCListFoundation2.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
      var _this = this;
      var isArrowLeft = normalizeKey(event) === "ArrowLeft";
      var isArrowUp = normalizeKey(event) === "ArrowUp";
      var isArrowRight = normalizeKey(event) === "ArrowRight";
      var isArrowDown = normalizeKey(event) === "ArrowDown";
      var isHome = normalizeKey(event) === "Home";
      var isEnd = normalizeKey(event) === "End";
      var isEnter = normalizeKey(event) === "Enter";
      var isSpace = normalizeKey(event) === "Spacebar";
      var isLetterA = event.key === "A" || event.key === "a";
      if (this.adapter.isRootFocused()) {
        if (isArrowUp || isEnd) {
          event.preventDefault();
          this.focusLastElement();
        } else if (isArrowDown || isHome) {
          event.preventDefault();
          this.focusFirstElement();
        }
        if (this.hasTypeahead) {
          var handleKeydownOpts = {
            event,
            focusItemAtIndex: function(index) {
              _this.focusItemAtIndex(index);
            },
            focusedItemIndex: -1,
            isTargetListItem: isRootListItem,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: function(index) {
              return _this.adapter.listItemAtIndexHasClass(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
            }
          };
          handleKeydown(handleKeydownOpts, this.typeaheadState);
        }
        return;
      }
      var currentIndex = this.adapter.getFocusedElementIndex();
      if (currentIndex === -1) {
        currentIndex = listItemIndex;
        if (currentIndex < 0) {
          return;
        }
      }
      if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
        preventDefaultEvent(event);
        this.focusNextElement(currentIndex);
      } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
        preventDefaultEvent(event);
        this.focusPrevElement(currentIndex);
      } else if (isHome) {
        preventDefaultEvent(event);
        this.focusFirstElement();
      } else if (isEnd) {
        preventDefaultEvent(event);
        this.focusLastElement();
      } else if (isLetterA && event.ctrlKey && this.isCheckboxList_) {
        event.preventDefault();
        this.toggleAll(this.selectedIndex_ === numbers$1.UNSET_INDEX ? [] : this.selectedIndex_);
      } else if (isEnter || isSpace) {
        if (isRootListItem) {
          var target = event.target;
          if (target && target.tagName === "A" && isEnter) {
            return;
          }
          preventDefaultEvent(event);
          if (this.adapter.listItemAtIndexHasClass(currentIndex, cssClasses$1.LIST_ITEM_DISABLED_CLASS)) {
            return;
          }
          if (!this.isTypeaheadInProgress()) {
            if (this.isSelectableList_()) {
              this.setSelectedIndexOnAction_(currentIndex);
            }
            this.adapter.notifyAction(currentIndex);
          }
        }
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event,
          focusItemAtIndex: function(index) {
            _this.focusItemAtIndex(index);
          },
          focusedItemIndex: this.focusedItemIndex,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index) {
            return _this.adapter.listItemAtIndexHasClass(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
    };
    MDCListFoundation2.prototype.handleClick = function(index, toggleCheckbox) {
      if (index === numbers$1.UNSET_INDEX) {
        return;
      }
      if (this.adapter.listItemAtIndexHasClass(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS)) {
        return;
      }
      if (this.isSelectableList_()) {
        this.setSelectedIndexOnAction_(index, toggleCheckbox);
      }
      this.adapter.notifyAction(index);
    };
    MDCListFoundation2.prototype.focusNextElement = function(index) {
      var count = this.adapter.getListItemCount();
      var nextIndex = index + 1;
      if (nextIndex >= count) {
        if (this.wrapFocus_) {
          nextIndex = 0;
        } else {
          return index;
        }
      }
      this.focusItemAtIndex(nextIndex);
      return nextIndex;
    };
    MDCListFoundation2.prototype.focusPrevElement = function(index) {
      var prevIndex = index - 1;
      if (prevIndex < 0) {
        if (this.wrapFocus_) {
          prevIndex = this.adapter.getListItemCount() - 1;
        } else {
          return index;
        }
      }
      this.focusItemAtIndex(prevIndex);
      return prevIndex;
    };
    MDCListFoundation2.prototype.focusFirstElement = function() {
      this.focusItemAtIndex(0);
      return 0;
    };
    MDCListFoundation2.prototype.focusLastElement = function() {
      var lastIndex = this.adapter.getListItemCount() - 1;
      this.focusItemAtIndex(lastIndex);
      return lastIndex;
    };
    MDCListFoundation2.prototype.focusInitialElement = function() {
      var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.focusItemAtIndex(initialIndex);
      return initialIndex;
    };
    MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
      if (!this.isIndexValid_(itemIndex)) {
        return;
      }
      if (isEnabled) {
        this.adapter.removeClassForElementIndex(itemIndex, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$1.ARIA_DISABLED, "false");
      } else {
        this.adapter.addClassForElementIndex(itemIndex, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$1.ARIA_DISABLED, "true");
      }
    };
    MDCListFoundation2.prototype.setSingleSelectionAtIndex_ = function(index) {
      if (this.selectedIndex_ === index) {
        return;
      }
      var selectedClassName = cssClasses$1.LIST_ITEM_SELECTED_CLASS;
      if (this.useActivatedClass_) {
        selectedClassName = cssClasses$1.LIST_ITEM_ACTIVATED_CLASS;
      }
      if (this.selectedIndex_ !== numbers$1.UNSET_INDEX) {
        this.adapter.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
      }
      this.setAriaForSingleSelectionAtIndex_(index);
      this.setTabindexAtIndex(index);
      if (index !== numbers$1.UNSET_INDEX) {
        this.adapter.addClassForElementIndex(index, selectedClassName);
      }
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex_ = function(index) {
      if (this.selectedIndex_ === numbers$1.UNSET_INDEX) {
        this.ariaCurrentAttrValue_ = this.adapter.getAttributeForElementIndex(index, strings$1.ARIA_CURRENT);
      }
      var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
      var ariaAttribute = isAriaCurrent ? strings$1.ARIA_CURRENT : strings$1.ARIA_SELECTED;
      if (this.selectedIndex_ !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, "false");
      }
      if (index !== numbers$1.UNSET_INDEX) {
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : "true";
        this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
      }
    };
    MDCListFoundation2.prototype.getSelectionAttribute = function() {
      return this.useSelectedAttr_ ? strings$1.ARIA_SELECTED : strings$1.ARIA_CHECKED;
    };
    MDCListFoundation2.prototype.setRadioAtIndex_ = function(index) {
      var selectionAttribute = this.getSelectionAttribute();
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
      if (this.selectedIndex_ !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, selectionAttribute, "false");
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setCheckboxAtIndex_ = function(index) {
      var selectionAttribute = this.getSelectionAttribute();
      for (var i = 0; i < this.adapter.getListItemCount(); i++) {
        var isChecked = false;
        if (index.indexOf(i) >= 0) {
          isChecked = true;
        }
        this.adapter.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
        this.adapter.setAttributeForElementIndex(i, selectionAttribute, isChecked ? "true" : "false");
      }
      this.selectedIndex_ = index;
    };
    MDCListFoundation2.prototype.setTabindexAtIndex = function(index) {
      if (this.focusedItemIndex === numbers$1.UNSET_INDEX && index !== 0) {
        this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
      } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
        this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
      }
      if (!(this.selectedIndex_ instanceof Array) && this.selectedIndex_ !== index) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex_, "tabindex", "-1");
      }
      if (index !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
      }
    };
    MDCListFoundation2.prototype.isSelectableList_ = function() {
      return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
    };
    MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
      var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.setTabindexAtIndex(targetIndex);
    };
    MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
      var targetIndex = this.focusedItemIndex >= 0 ? this.focusedItemIndex : 0;
      if (this.isSelectableList_()) {
        if (typeof this.selectedIndex_ === "number" && this.selectedIndex_ !== numbers$1.UNSET_INDEX) {
          targetIndex = this.selectedIndex_;
        } else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
          targetIndex = this.selectedIndex_.reduce(function(currentIndex, minIndex) {
            return Math.min(currentIndex, minIndex);
          });
        }
      }
      return targetIndex;
    };
    MDCListFoundation2.prototype.isIndexValid_ = function(index) {
      var _this = this;
      if (index instanceof Array) {
        if (!this.isCheckboxList_) {
          throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
        }
        if (index.length === 0) {
          return true;
        } else {
          return index.some(function(i) {
            return _this.isIndexInRange_(i);
          });
        }
      } else if (typeof index === "number") {
        if (this.isCheckboxList_) {
          throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
        }
        return this.isIndexInRange_(index) || this.isSingleSelectionList_ && index === numbers$1.UNSET_INDEX;
      } else {
        return false;
      }
    };
    MDCListFoundation2.prototype.isIndexInRange_ = function(index) {
      var listSize = this.adapter.getListItemCount();
      return index >= 0 && index < listSize;
    };
    MDCListFoundation2.prototype.setSelectedIndexOnAction_ = function(index, toggleCheckbox) {
      if (toggleCheckbox === void 0) {
        toggleCheckbox = true;
      }
      if (this.isCheckboxList_) {
        this.toggleCheckboxAtIndex_(index, toggleCheckbox);
      } else {
        this.setSelectedIndex(index);
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxAtIndex_ = function(index, toggleCheckbox) {
      var selectionAttribute = this.getSelectionAttribute();
      var isChecked = this.adapter.isCheckboxCheckedAtIndex(index);
      if (toggleCheckbox) {
        isChecked = !isChecked;
        this.adapter.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, isChecked ? "true" : "false");
      var selectedIndexes = this.selectedIndex_ === numbers$1.UNSET_INDEX ? [] : this.selectedIndex_.slice();
      if (isChecked) {
        selectedIndexes.push(index);
      } else {
        selectedIndexes = selectedIndexes.filter(function(i) {
          return i !== index;
        });
      }
      this.selectedIndex_ = selectedIndexes;
    };
    MDCListFoundation2.prototype.focusItemAtIndex = function(index) {
      this.adapter.focusItemAtIndex(index);
      this.focusedItemIndex = index;
    };
    MDCListFoundation2.prototype.toggleAll = function(currentlySelectedIndexes) {
      var count = this.adapter.getListItemCount();
      if (currentlySelectedIndexes.length === count) {
        this.setCheckboxAtIndex_([]);
      } else {
        var allIndexes = [];
        for (var i = 0; i < count; i++) {
          if (!this.adapter.listItemAtIndexHasClass(i, cssClasses$1.LIST_ITEM_DISABLED_CLASS) || currentlySelectedIndexes.indexOf(i) > -1) {
            allIndexes.push(i);
          }
        }
        this.setCheckboxAtIndex_(allIndexes);
      }
    };
    MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
      var _this = this;
      if (skipFocus === void 0) {
        skipFocus = false;
      }
      var opts = {
        focusItemAtIndex: function(index) {
          _this.focusItemAtIndex(index);
        },
        focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
        nextChar,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        skipFocus,
        isItemAtIndexDisabled: function(index) {
          return _this.adapter.listItemAtIndexHasClass(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
        }
      };
      return matchItem(opts, this.typeaheadState);
    };
    MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
      return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
    };
    MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
      clearBuffer(this.typeaheadState);
    };
    return MDCListFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCMenuSurfaceFoundation = function(_super) {
    __extends(MDCMenuSurfaceFoundation2, _super);
    function MDCMenuSurfaceFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation2.defaultAdapter), adapter)) || this;
      _this.isSurfaceOpen = false;
      _this.isQuickOpen = false;
      _this.isHoistedElement = false;
      _this.isFixedPosition = false;
      _this.isHorizontallyCenteredOnViewport = false;
      _this.maxHeight = 0;
      _this.openAnimationEndTimerId = 0;
      _this.closeAnimationEndTimerId = 0;
      _this.animationRequestId = 0;
      _this.anchorCorner = Corner.TOP_START;
      _this.originCorner = Corner.TOP_START;
      _this.anchorMargin = {top: 0, right: 0, bottom: 0, left: 0};
      _this.position = {x: 0, y: 0};
      return _this;
    }
    Object.defineProperty(MDCMenuSurfaceFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "strings", {
      get: function() {
        return strings$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "numbers", {
      get: function() {
        return numbers$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "Corner", {
      get: function() {
        return Corner;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          hasAnchor: function() {
            return false;
          },
          isElementInContainer: function() {
            return false;
          },
          isFocused: function() {
            return false;
          },
          isRtl: function() {
            return false;
          },
          getInnerDimensions: function() {
            return {height: 0, width: 0};
          },
          getAnchorDimensions: function() {
            return null;
          },
          getWindowDimensions: function() {
            return {height: 0, width: 0};
          },
          getBodyDimensions: function() {
            return {height: 0, width: 0};
          },
          getWindowScroll: function() {
            return {x: 0, y: 0};
          },
          setPosition: function() {
            return void 0;
          },
          setMaxHeight: function() {
            return void 0;
          },
          setTransformOrigin: function() {
            return void 0;
          },
          saveFocus: function() {
            return void 0;
          },
          restoreFocus: function() {
            return void 0;
          },
          notifyClose: function() {
            return void 0;
          },
          notifyOpen: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuSurfaceFoundation2.prototype.init = function() {
      var _a2 = MDCMenuSurfaceFoundation2.cssClasses, ROOT = _a2.ROOT, OPEN = _a2.OPEN;
      if (!this.adapter.hasClass(ROOT)) {
        throw new Error(ROOT + " class required in root element.");
      }
      if (this.adapter.hasClass(OPEN)) {
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.destroy = function() {
      clearTimeout(this.openAnimationEndTimerId);
      clearTimeout(this.closeAnimationEndTimerId);
      cancelAnimationFrame(this.animationRequestId);
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorCorner = function(corner) {
      this.anchorCorner = corner;
    };
    MDCMenuSurfaceFoundation2.prototype.flipCornerHorizontally = function() {
      this.originCorner = this.originCorner ^ CornerBit.RIGHT;
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorMargin = function(margin) {
      this.anchorMargin.top = margin.top || 0;
      this.anchorMargin.right = margin.right || 0;
      this.anchorMargin.bottom = margin.bottom || 0;
      this.anchorMargin.left = margin.left || 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHoisted = function(isHoisted) {
      this.isHoistedElement = isHoisted;
    };
    MDCMenuSurfaceFoundation2.prototype.setFixedPosition = function(isFixedPosition) {
      this.isFixedPosition = isFixedPosition;
    };
    MDCMenuSurfaceFoundation2.prototype.setAbsolutePosition = function(x, y) {
      this.position.x = this.isFinite(x) ? x : 0;
      this.position.y = this.isFinite(y) ? y : 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHorizontallyCenteredOnViewport = function(isCentered) {
      this.isHorizontallyCenteredOnViewport = isCentered;
    };
    MDCMenuSurfaceFoundation2.prototype.setQuickOpen = function(quickOpen) {
      this.isQuickOpen = quickOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.setMaxHeight = function(maxHeight) {
      this.maxHeight = maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.isOpen = function() {
      return this.isSurfaceOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.open = function() {
      var _this = this;
      if (this.isSurfaceOpen) {
        return;
      }
      this.adapter.saveFocus();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = true;
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.dimensions = this.adapter.getInnerDimensions();
        this.autoposition();
        this.adapter.notifyOpen();
      } else {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
        this.animationRequestId = requestAnimationFrame(function() {
          _this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
          _this.dimensions = _this.adapter.getInnerDimensions();
          _this.autoposition();
          _this.openAnimationEndTimerId = setTimeout(function() {
            _this.openAnimationEndTimerId = 0;
            _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
            _this.adapter.notifyOpen();
          }, numbers$2.TRANSITION_OPEN_DURATION);
        });
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.close = function(skipRestoreFocus) {
      var _this = this;
      if (skipRestoreFocus === void 0) {
        skipRestoreFocus = false;
      }
      if (!this.isSurfaceOpen) {
        return;
      }
      this.adapter.notifyClosing();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = false;
        if (!skipRestoreFocus) {
          this.maybeRestoreFocus();
        }
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        this.adapter.notifyClose();
        return;
      }
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
      requestAnimationFrame(function() {
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        _this.closeAnimationEndTimerId = setTimeout(function() {
          _this.closeAnimationEndTimerId = 0;
          _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
          _this.adapter.notifyClose();
        }, numbers$2.TRANSITION_CLOSE_DURATION);
      });
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.handleBodyClick = function(evt) {
      var el = evt.target;
      if (this.adapter.isElementInContainer(el)) {
        return;
      }
      this.close();
    };
    MDCMenuSurfaceFoundation2.prototype.handleKeydown = function(evt) {
      var keyCode = evt.keyCode, key = evt.key;
      var isEscape = key === "Escape" || keyCode === 27;
      if (isEscape) {
        this.close();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.autoposition = function() {
      var _a2;
      this.measurements = this.getAutoLayoutmeasurements();
      var corner = this.getoriginCorner();
      var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
      var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
      var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
      var horizontalOffset = this.getHorizontalOriginOffset(corner);
      var verticalOffset = this.getVerticalOriginOffset(corner);
      var _b2 = this.measurements, anchorSize = _b2.anchorSize, surfaceSize = _b2.surfaceSize;
      var position = (_a2 = {}, _a2[horizontalAlignment] = horizontalOffset, _a2[verticalAlignment] = verticalOffset, _a2);
      if (anchorSize.width / surfaceSize.width > numbers$2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
        horizontalAlignment = "center";
      }
      if (this.isHoistedElement || this.isFixedPosition) {
        this.adjustPositionForHoistedElement(position);
      }
      this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
      this.adapter.setPosition(position);
      this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
      if (!this.hasBit(corner, CornerBit.BOTTOM)) {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      }
    };
    MDCMenuSurfaceFoundation2.prototype.getAutoLayoutmeasurements = function() {
      var anchorRect = this.adapter.getAnchorDimensions();
      var bodySize = this.adapter.getBodyDimensions();
      var viewportSize = this.adapter.getWindowDimensions();
      var windowScroll = this.adapter.getWindowScroll();
      if (!anchorRect) {
        anchorRect = {
          top: this.position.y,
          right: this.position.x,
          bottom: this.position.y,
          left: this.position.x,
          width: 0,
          height: 0
        };
      }
      return {
        anchorSize: anchorRect,
        bodySize,
        surfaceSize: this.dimensions,
        viewportDistance: {
          top: anchorRect.top,
          right: viewportSize.width - anchorRect.right,
          bottom: viewportSize.height - anchorRect.bottom,
          left: anchorRect.left
        },
        viewportSize,
        windowScroll
      };
    };
    MDCMenuSurfaceFoundation2.prototype.getoriginCorner = function() {
      var corner = this.originCorner;
      var _a2 = this.measurements, viewportDistance = _a2.viewportDistance, anchorSize = _a2.anchorSize, surfaceSize = _a2.surfaceSize;
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var availableTop;
      var availableBottom;
      if (isAnchoredToBottom) {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
      } else {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
      }
      var isAvailableBottom = availableBottom - surfaceSize.height > 0;
      if (!isAvailableBottom && availableTop > availableBottom) {
        corner = this.setBit(corner, CornerBit.BOTTOM);
      }
      var isRtl = this.adapter.isRtl();
      var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
      var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
      var isAnchoredToRight = false;
      if (isRtl && isFlipRtl) {
        isAnchoredToRight = !hasRightBit;
      } else {
        isAnchoredToRight = hasRightBit;
      }
      var availableLeft;
      var availableRight;
      if (isAnchoredToRight) {
        availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
        availableRight = viewportDistance.right - this.anchorMargin.right;
      } else {
        availableLeft = viewportDistance.left + this.anchorMargin.left;
        availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
      }
      var isAvailableLeft = availableLeft - surfaceSize.width > 0;
      var isAvailableRight = availableRight - surfaceSize.width > 0;
      var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
      if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
        corner = this.unsetBit(corner, CornerBit.RIGHT);
      } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
        corner = this.setBit(corner, CornerBit.RIGHT);
      }
      return corner;
    };
    MDCMenuSurfaceFoundation2.prototype.getMenuSurfaceMaxHeight = function(corner) {
      if (this.maxHeight > 0) {
        return this.maxHeight;
      }
      var viewportDistance = this.measurements.viewportDistance;
      var maxHeight = 0;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      if (isBottomAligned) {
        maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
        if (!isBottomAnchored) {
          maxHeight += this.measurements.anchorSize.height;
        }
      } else {
        maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
        if (isBottomAnchored) {
          maxHeight -= this.measurements.anchorSize.height;
        }
      }
      return maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.getHorizontalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
      var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
        if (this.isHoistedElement || this.isFixedPosition) {
          return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
        }
        return rightOffset;
      }
      return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
    };
    MDCMenuSurfaceFoundation2.prototype.getVerticalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var y = 0;
      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
      } else {
        y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
      }
      return y;
    };
    MDCMenuSurfaceFoundation2.prototype.adjustPositionForHoistedElement = function(position) {
      var e_1, _a2;
      var _b2 = this.measurements, windowScroll = _b2.windowScroll, viewportDistance = _b2.viewportDistance, surfaceSize = _b2.surfaceSize, viewportSize = _b2.viewportSize;
      var props = Object.keys(position);
      try {
        for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
          var prop = props_1_1.value;
          var value = position[prop] || 0;
          if (this.isHorizontallyCenteredOnViewport && (prop === "left" || prop === "right")) {
            position[prop] = (viewportSize.width - surfaceSize.width) / 2;
            continue;
          }
          value += viewportDistance[prop];
          if (!this.isFixedPosition) {
            if (prop === "top") {
              value += windowScroll.y;
            } else if (prop === "bottom") {
              value -= windowScroll.y;
            } else if (prop === "left") {
              value += windowScroll.x;
            } else {
              value -= windowScroll.x;
            }
          }
          position[prop] = value;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (props_1_1 && !props_1_1.done && (_a2 = props_1.return))
            _a2.call(props_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCMenuSurfaceFoundation2.prototype.maybeRestoreFocus = function() {
      var isRootFocused = this.adapter.isFocused();
      var childHasFocus = document.activeElement && this.adapter.isElementInContainer(document.activeElement);
      if (isRootFocused || childHasFocus) {
        this.adapter.restoreFocus();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.hasBit = function(corner, bit) {
      return Boolean(corner & bit);
    };
    MDCMenuSurfaceFoundation2.prototype.setBit = function(corner, bit) {
      return corner | bit;
    };
    MDCMenuSurfaceFoundation2.prototype.unsetBit = function(corner, bit) {
      return corner ^ bit;
    };
    MDCMenuSurfaceFoundation2.prototype.isFinite = function(num) {
      return typeof num === "number" && isFinite(num);
    };
    return MDCMenuSurfaceFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses2 = {
    MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
    MENU_SELECTION_GROUP: "mdc-menu__selection-group",
    ROOT: "mdc-menu"
  };
  var strings2 = {
    ARIA_CHECKED_ATTR: "aria-checked",
    ARIA_DISABLED_ATTR: "aria-disabled",
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
    SELECTED_EVENT: "MDCMenu:selected"
  };
  var numbers2 = {
    FOCUS_ROOT_INDEX: -1
  };
  var DefaultFocusState;
  (function(DefaultFocusState2) {
    DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
    DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
    DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
    DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
  })(DefaultFocusState || (DefaultFocusState = {}));
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCMenuFoundation = function(_super) {
    __extends(MDCMenuFoundation2, _super);
    function MDCMenuFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
      _this.closeAnimationEndTimerId_ = 0;
      _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
      return _this;
    }
    Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "numbers", {
      get: function() {
        return numbers2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassToElementAtIndex: function() {
            return void 0;
          },
          removeClassFromElementAtIndex: function() {
            return void 0;
          },
          addAttributeToElementAtIndex: function() {
            return void 0;
          },
          removeAttributeFromElementAtIndex: function() {
            return void 0;
          },
          elementContainsClass: function() {
            return false;
          },
          closeSurface: function() {
            return void 0;
          },
          getElementIndex: function() {
            return -1;
          },
          notifySelected: function() {
            return void 0;
          },
          getMenuItemCount: function() {
            return 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          focusListRoot: function() {
            return void 0;
          },
          getSelectedSiblingOfItemAtIndex: function() {
            return -1;
          },
          isSelectableItemAtIndex: function() {
            return false;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuFoundation2.prototype.destroy = function() {
      if (this.closeAnimationEndTimerId_) {
        clearTimeout(this.closeAnimationEndTimerId_);
      }
      this.adapter.closeSurface();
    };
    MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
      var key = evt.key, keyCode = evt.keyCode;
      var isTab = key === "Tab" || keyCode === 9;
      if (isTab) {
        this.adapter.closeSurface(true);
      }
    };
    MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
      var _this = this;
      var index = this.adapter.getElementIndex(listItem);
      if (index < 0) {
        return;
      }
      this.adapter.notifySelected({index});
      this.adapter.closeSurface();
      this.closeAnimationEndTimerId_ = setTimeout(function() {
        var recomputedIndex = _this.adapter.getElementIndex(listItem);
        if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
          _this.setSelectedIndex(recomputedIndex);
        }
      }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
      switch (this.defaultFocusState_) {
        case DefaultFocusState.FIRST_ITEM:
          this.adapter.focusItemAtIndex(0);
          break;
        case DefaultFocusState.LAST_ITEM:
          this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
          break;
        case DefaultFocusState.NONE:
          break;
        default:
          this.adapter.focusListRoot();
          break;
      }
    };
    MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
      this.defaultFocusState_ = focusState;
    };
    MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
      this.validatedIndex_(index);
      if (!this.adapter.isSelectableItemAtIndex(index)) {
        throw new Error("MDCMenuFoundation: No selection group at specified index.");
      }
      var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
      if (prevSelectedIndex >= 0) {
        this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings2.ARIA_CHECKED_ATTR);
        this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses2.MENU_SELECTED_LIST_ITEM);
      }
      this.adapter.addClassToElementAtIndex(index, cssClasses2.MENU_SELECTED_LIST_ITEM);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_CHECKED_ATTR, "true");
    };
    MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
      this.validatedIndex_(index);
      if (isEnabled) {
        this.adapter.removeClassFromElementAtIndex(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "false");
      } else {
        this.adapter.addClassToElementAtIndex(index, cssClasses$1.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "true");
      }
    };
    MDCMenuFoundation2.prototype.validatedIndex_ = function(index) {
      var menuSize = this.adapter.getMenuItemCount();
      var isIndexInRange = index >= 0 && index < menuSize;
      if (!isIndexInRange) {
        throw new Error("MDCMenuFoundation: No list item at specified index.");
      }
    };
    return MDCMenuFoundation2;
  }(MDCFoundation);
  var oldModifierRegex$1 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex$1 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder$1(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex$1);
      const newModifierMatch = eventType.match(newModifierRegex$1);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex$1);
        const newModifierMatch = eventType.match(newModifierRegex$1);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap$1(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function create_default_slot$3(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$3.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$8(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap$1({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$3]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap$1({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$8.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals4 = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance$5($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals4.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals4.contexts;
    const props = internals4.props;
    let {component = internals4.component} = $$props;
    Object.entries(internals4.classMap).forEach(([name, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder$1(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals: internals4,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder$1,
      classMap: classMap$1,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder4 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$5, create_fragment$8, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment$8.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults4 = {...internals4};
  function classAdderBuilder4(props) {
    function Component(...args) {
      Object.assign(internals4, defaults4, props);
      return new ClassAdder4(...args);
    }
    Component.prototype = ClassAdder4;
    if (ClassAdder4.$$render) {
      Component.$$render = (...args) => Object.assign(internals4, defaults4, props) && ClassAdder4.$$render(...args);
    }
    if (ClassAdder4.render) {
      Component.render = (...args) => Object.assign(internals4, defaults4, props) && ClassAdder4.render(...args);
    }
    return Component;
  }
  function dispatch$2(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  var oldModifierRegex5 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex5 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder5(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex5);
      const newModifierMatch = eventType.match(newModifierRegex5);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex5);
        const newModifierMatch = eventType.match(newModifierRegex5);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap5(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function dispatch$1(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  function useActions3(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var {document: document_1} = globals;
  var file$5 = "node_modules/@smui/menu-surface/MenuSurface.svelte";
  function create_fragment$7(ctx) {
    let t;
    let div;
    let div_class_value;
    let div_style_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[26].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
    let div_levels = [
      {
        class: div_class_value = classMap5({
          [ctx[2]]: true,
          "mdc-menu-surface": true,
          "mdc-menu-surface--fixed": ctx[5],
          "mdc-menu-surface--open": ctx[4],
          "smui-menu-surface--static": ctx[4],
          "mdc-menu-surface--fullwidth": ctx[6],
          ...ctx[9]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[10]).map(func$1).concat([ctx[3]]).join(" ")
      },
      ctx[12]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        t = space();
        div = element("div");
        if (default_slot)
          default_slot.c();
        set_attributes(div, div_data);
        add_location(div, file$5, 4, 0, 105);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        ctx[28](div);
        current = true;
        if (!mounted) {
          dispose = [
            listen_dev(document_1.body, "click", ctx[27], true, false, false),
            action_destroyer(useActions_action = useActions3.call(null, div, ctx[1])),
            action_destroyer(ctx[11].call(null, div)),
            listen_dev(div, "keydown", ctx[29], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty[0] & 33554432)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[25], !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null), null);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty[0] & 628 && div_class_value !== (div_class_value = classMap5({
            [ctx2[2]]: true,
            "mdc-menu-surface": true,
            "mdc-menu-surface--fixed": ctx2[5],
            "mdc-menu-surface--open": ctx2[4],
            "smui-menu-surface--static": ctx2[4],
            "mdc-menu-surface--fullwidth": ctx2[6],
            ...ctx2[9]
          }))) && {class: div_class_value},
          (!current || dirty[0] & 1032 && div_style_value !== (div_style_value = Object.entries(ctx2[10]).map(func$1).concat([ctx2[3]]).join(" "))) && {style: div_style_value},
          dirty[0] & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
          useActions_action.update.call(null, ctx2[1]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        ctx[28](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$7.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$1 = ([name, value]) => `${name}: ${value};`;
  function instance_1$2($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "static",
      "anchor",
      "fixed",
      "open",
      "fullWidth",
      "quickOpen",
      "anchorElement",
      "anchorCorner",
      "anchorMargin",
      "maxHeight",
      "horizontallyCenteredOnViewport",
      "isOpen",
      "setOpen",
      "setAbsolutePosition",
      "setIsHoisted",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("MenuSurface", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder5(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {static: isStatic = false} = $$props;
    let {anchor = true} = $$props;
    let {fixed = false} = $$props;
    let {open = isStatic} = $$props;
    let {fullWidth = false} = $$props;
    let {quickOpen = false} = $$props;
    let {anchorElement = null} = $$props;
    let {anchorCorner = null} = $$props;
    let {anchorMargin = {top: 0, right: 0, bottom: 0, left: 0}} = $$props;
    let {maxHeight = 0} = $$props;
    let {horizontallyCenteredOnViewport = false} = $$props;
    let element2;
    let instance8;
    let internalClasses = {};
    let internalStyles = {};
    let previousFocus;
    setContext("SMUI:list:role", "menu");
    setContext("SMUI:list:item:role", "menuitem");
    const iCorner = Corner;
    const iCornerBit = CornerBit;
    onMount(() => {
      $$invalidate(8, instance8 = new MDCMenuSurfaceFoundation({
        addClass,
        removeClass,
        hasClass,
        hasAnchor: () => !!anchorElement,
        notifyClose: () => {
          $$invalidate(0, open = isStatic);
          if (!open) {
            dispatch$1(element2, "MDCMenuSurface:closed");
          }
        },
        notifyClosing: () => {
          $$invalidate(0, open = isStatic);
          if (!open) {
            dispatch$1(element2, "MDCMenuSurface:closing");
          }
        },
        notifyOpen: () => {
          $$invalidate(0, open = true);
          dispatch$1(element2, "MDCMenuSurface:opened");
        },
        isElementInContainer: (el) => element2.contains(el),
        isRtl: () => getComputedStyle(element2).getPropertyValue("direction") === "rtl",
        setTransformOrigin: (origin) => {
          const propertyName = `${getCorrectPropertyName(window, "transform")}-origin`;
          $$invalidate(10, internalStyles[propertyName] = origin, internalStyles);
        },
        isFocused: () => document.activeElement === element2,
        saveFocus: () => {
          previousFocus = document.activeElement;
        },
        restoreFocus: () => {
          if (element2.contains(document.activeElement) && previousFocus && previousFocus.focus) {
            previousFocus.focus();
          }
        },
        getInnerDimensions: () => {
          return {
            width: element2.offsetWidth,
            height: element2.offsetHeight
          };
        },
        getAnchorDimensions: () => anchorElement ? anchorElement.getBoundingClientRect() : null,
        getWindowDimensions: () => {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getBodyDimensions: () => {
          return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
          };
        },
        getWindowScroll: () => {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        },
        setPosition: (position) => {
          $$invalidate(10, internalStyles.left = "left" in position ? `${position.left}px` : "", internalStyles);
          $$invalidate(10, internalStyles.right = "right" in position ? `${position.right}px` : "", internalStyles);
          $$invalidate(10, internalStyles.top = "top" in position ? `${position.top}px` : "", internalStyles);
          $$invalidate(10, internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "", internalStyles);
        },
        setMaxHeight: (height) => {
          $$invalidate(10, internalStyles.maxHeight = height, internalStyles);
        }
      }));
      dispatch$1(element2, "SMUI:menu-surface:mount", {
        get open() {
          return open;
        },
        set open(value) {
          $$invalidate(0, open = value);
        },
        closeProgrammatic
      });
      instance8.init();
      return () => {
        const isHoisted = instance8.isHoistedElement;
        instance8.destroy();
        if (isHoisted) {
          element2.parentNode.removeChild(element2);
        }
      };
    });
    onDestroy(() => {
      if (anchor) {
        element2 && element2.parentNode.classList.remove("mdc-menu-surface--anchor");
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(9, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(9, internalClasses[className2] = false, internalClasses);
      }
    }
    function closeProgrammatic(skipRestoreFocus) {
      instance8.close(skipRestoreFocus);
      $$invalidate(0, open = false);
    }
    function isOpen() {
      return open;
    }
    function setOpen(value) {
      $$invalidate(0, open = value);
    }
    function setAbsolutePosition(...args) {
      return instance8.setAbsolutePosition(...args);
    }
    function setIsHoisted(...args) {
      return instance8.setIsHoisted(...args);
    }
    function getElement() {
      return element2;
    }
    const click_handler = (event) => instance8 && open && instance8.handleBodyClick(event);
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    const keydown_handler = (event) => instance8 && instance8.handleKeydown(event);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("static" in $$new_props)
        $$invalidate(4, isStatic = $$new_props.static);
      if ("anchor" in $$new_props)
        $$invalidate(14, anchor = $$new_props.anchor);
      if ("fixed" in $$new_props)
        $$invalidate(5, fixed = $$new_props.fixed);
      if ("open" in $$new_props)
        $$invalidate(0, open = $$new_props.open);
      if ("fullWidth" in $$new_props)
        $$invalidate(6, fullWidth = $$new_props.fullWidth);
      if ("quickOpen" in $$new_props)
        $$invalidate(15, quickOpen = $$new_props.quickOpen);
      if ("anchorElement" in $$new_props)
        $$invalidate(13, anchorElement = $$new_props.anchorElement);
      if ("anchorCorner" in $$new_props)
        $$invalidate(16, anchorCorner = $$new_props.anchorCorner);
      if ("anchorMargin" in $$new_props)
        $$invalidate(17, anchorMargin = $$new_props.anchorMargin);
      if ("maxHeight" in $$new_props)
        $$invalidate(18, maxHeight = $$new_props.maxHeight);
      if ("horizontallyCenteredOnViewport" in $$new_props)
        $$invalidate(19, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
      if ("$$scope" in $$new_props)
        $$invalidate(25, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      Corner,
      CornerBit,
      MDCMenuSurfaceFoundation,
      getCorrectPropertyName,
      onMount,
      onDestroy,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder5,
      classMap: classMap5,
      useActions: useActions3,
      dispatch: dispatch$1,
      forwardEvents,
      use: use2,
      className,
      style,
      isStatic,
      anchor,
      fixed,
      open,
      fullWidth,
      quickOpen,
      anchorElement,
      anchorCorner,
      anchorMargin,
      maxHeight,
      horizontallyCenteredOnViewport,
      element: element2,
      instance: instance8,
      internalClasses,
      internalStyles,
      previousFocus,
      iCorner,
      iCornerBit,
      hasClass,
      addClass,
      removeClass,
      closeProgrammatic,
      isOpen,
      setOpen,
      setAbsolutePosition,
      setIsHoisted,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("isStatic" in $$props)
        $$invalidate(4, isStatic = $$new_props.isStatic);
      if ("anchor" in $$props)
        $$invalidate(14, anchor = $$new_props.anchor);
      if ("fixed" in $$props)
        $$invalidate(5, fixed = $$new_props.fixed);
      if ("open" in $$props)
        $$invalidate(0, open = $$new_props.open);
      if ("fullWidth" in $$props)
        $$invalidate(6, fullWidth = $$new_props.fullWidth);
      if ("quickOpen" in $$props)
        $$invalidate(15, quickOpen = $$new_props.quickOpen);
      if ("anchorElement" in $$props)
        $$invalidate(13, anchorElement = $$new_props.anchorElement);
      if ("anchorCorner" in $$props)
        $$invalidate(16, anchorCorner = $$new_props.anchorCorner);
      if ("anchorMargin" in $$props)
        $$invalidate(17, anchorMargin = $$new_props.anchorMargin);
      if ("maxHeight" in $$props)
        $$invalidate(18, maxHeight = $$new_props.maxHeight);
      if ("horizontallyCenteredOnViewport" in $$props)
        $$invalidate(19, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
      if ("element" in $$props)
        $$invalidate(7, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(8, instance8 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(9, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(10, internalStyles = $$new_props.internalStyles);
      if ("previousFocus" in $$props)
        previousFocus = $$new_props.previousFocus;
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 16512) {
        if (element2 && anchor && !element2.parentNode.classList.contains("mdc-menu-surface--anchor")) {
          element2.parentNode.classList.add("mdc-menu-surface--anchor");
          $$invalidate(13, anchorElement = element2.parentNode);
        }
      }
      if ($$self.$$.dirty[0] & 257) {
        if (instance8 && instance8.isOpen() !== open) {
          if (open) {
            instance8.open();
          } else {
            instance8.close();
          }
        }
      }
      if ($$self.$$.dirty[0] & 33024) {
        if (instance8) {
          instance8.setQuickOpen(quickOpen);
        }
      }
      if ($$self.$$.dirty[0] & 288) {
        if (instance8) {
          instance8.setFixedPosition(fixed);
        }
      }
      if ($$self.$$.dirty[0] & 262400) {
        if (instance8 && maxHeight > 0) {
          instance8.setMaxHeight(maxHeight);
        }
      }
      if ($$self.$$.dirty[0] & 524544) {
        if (instance8) {
          instance8.setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport);
        }
      }
      if ($$self.$$.dirty[0] & 65792) {
        if (instance8 && anchorCorner != null) {
          if (iCorner.hasOwnProperty(anchorCorner)) {
            instance8.setAnchorCorner(iCorner[anchorCorner]);
          } else if (iCornerBit.hasOwnProperty(anchorCorner)) {
            instance8.setAnchorCorner(iCornerBit[anchorCorner]);
          } else {
            instance8.setAnchorCorner(anchorCorner);
          }
        }
      }
      if ($$self.$$.dirty[0] & 131328) {
        if (instance8) {
          instance8.setAnchorMargin(anchorMargin);
        }
      }
    };
    return [
      open,
      use2,
      className,
      style,
      isStatic,
      fixed,
      fullWidth,
      element2,
      instance8,
      internalClasses,
      internalStyles,
      forwardEvents,
      $$restProps,
      anchorElement,
      anchor,
      quickOpen,
      anchorCorner,
      anchorMargin,
      maxHeight,
      horizontallyCenteredOnViewport,
      isOpen,
      setOpen,
      setAbsolutePosition,
      setIsHoisted,
      getElement,
      $$scope,
      slots,
      click_handler,
      div_binding,
      keydown_handler
    ];
  }
  var MenuSurface = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$2, create_fragment$7, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        static: 4,
        anchor: 14,
        fixed: 5,
        open: 0,
        fullWidth: 6,
        quickOpen: 15,
        anchorElement: 13,
        anchorCorner: 16,
        anchorMargin: 17,
        maxHeight: 18,
        horizontallyCenteredOnViewport: 19,
        isOpen: 20,
        setOpen: 21,
        setAbsolutePosition: 22,
        setIsHoisted: 23,
        getElement: 24
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "MenuSurface",
        options,
        id: create_fragment$7.name
      });
    }
    get use() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get static() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set static(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchor() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchor(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get fixed() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set fixed(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get open() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set open(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get fullWidth() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set fullWidth(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get quickOpen() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set quickOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorElement() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorElement(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorCorner() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorCorner(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get anchorMargin() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set anchorMargin(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get maxHeight() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set maxHeight(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get horizontallyCenteredOnViewport() {
      throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set horizontallyCenteredOnViewport(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get isOpen() {
      return this.$$.ctx[20];
    }
    set isOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setOpen() {
      return this.$$.ctx[21];
    }
    set setOpen(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setAbsolutePosition() {
      return this.$$.ctx[22];
    }
    set setAbsolutePosition(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setIsHoisted() {
      return this.$$.ctx[23];
    }
    set setIsHoisted(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[24];
    }
    set getElement(value) {
      throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$2(ctx) {
    let current;
    const default_slot_template = ctx[14].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 1048576)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[20], !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$2.name,
      type: "slot",
      source: "(1:0) <MenuSurface   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-menu': true,   })}   bind:open   on:SMUI:menu-surface:mount={handleMenuSurfaceAccessor}   on:SMUI:list:mount={handleListAccessor}   on:MDCMenuSurface:opened={() =>     instance && instance.handleMenuSurfaceOpened()}   on:keydown={(event) => instance && instance.handleKeydown(event)}   on:MDCList:action={(event) =>     instance &&     instance.handleItemAction(       listAccessor.getOrderedList()[event.detail.index].element     )}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$6(ctx) {
    let menusurface;
    let updating_open;
    let current;
    const menusurface_spread_levels = [
      {
        use: [ctx[6], ...ctx[1]]
      },
      {
        class: classMap$1({
          [ctx[2]]: true,
          "mdc-menu": true
        })
      },
      ctx[9]
    ];
    function menusurface_open_binding(value) {
      ctx[16](value);
    }
    let menusurface_props = {
      $$slots: {default: [create_default_slot$2]},
      $$scope: {ctx}
    };
    for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
      menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      menusurface_props.open = ctx[0];
    }
    menusurface = new MenuSurface({props: menusurface_props, $$inline: true});
    ctx[15](menusurface);
    binding_callbacks.push(() => bind3(menusurface, "open", menusurface_open_binding));
    menusurface.$on("SMUI:menu-surface:mount", ctx[7]);
    menusurface.$on("SMUI:list:mount", ctx[8]);
    menusurface.$on("MDCMenuSurface:opened", ctx[17]);
    menusurface.$on("keydown", ctx[18]);
    menusurface.$on("MDCList:action", ctx[19]);
    const block = {
      c: function create2() {
        create_component(menusurface.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        mount_component(menusurface, target, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const menusurface_changes = dirty & 582 ? get_spread_update(menusurface_spread_levels, [
          dirty & 66 && {
            use: [ctx2[6], ...ctx2[1]]
          },
          dirty & 4 && {
            class: classMap$1({
              [ctx2[2]]: true,
              "mdc-menu": true
            })
          },
          dirty & 512 && get_spread_object(ctx2[9])
        ]) : {};
        if (dirty & 1048576) {
          menusurface_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (!updating_open && dirty & 1) {
          updating_open = true;
          menusurface_changes.open = ctx2[0];
          add_flush_callback(() => updating_open = false);
        }
        menusurface.$set(menusurface_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(menusurface.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(menusurface.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[15](null);
        destroy_component(menusurface, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$6.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance_1$1($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "open", "isOpen", "setOpen", "setDefaultFocusState", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Menu", slots, ["default"]);
    const {closest: closest2} = ponyfill;
    const forwardEvents = forwardEventsBuilder$1(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {open = false} = $$props;
    let element2;
    let instance8;
    let menuSurfaceAccessor;
    let listAccessor;
    onMount(() => {
      $$invalidate(4, instance8 = new MDCMenuFoundation({
        addClassToElementAtIndex: (index, className2) => {
          listAccessor.addClassForElementIndex(index, className2);
        },
        removeClassFromElementAtIndex: (index, className2) => {
          listAccessor.removeClassForElementIndex(index, className2);
        },
        addAttributeToElementAtIndex: (index, attr2, value) => {
          listAccessor.setAttributeForElementIndex(index, attr2, value);
        },
        removeAttributeFromElementAtIndex: (index, attr2) => {
          listAccessor.removeAttributeForElementIndex(index, attr2);
        },
        elementContainsClass: (element3, className2) => element3.classList.contains(className2),
        closeSurface: (skipRestoreFocus) => menuSurfaceAccessor.closeProgrammatic(skipRestoreFocus),
        getElementIndex: (element3) => listAccessor.getOrderedList().map((accessor) => accessor.element).indexOf(element3),
        notifySelected: (evtData) => dispatch$2(element2, "MDCMenu:selected", {
          index: evtData.index,
          item: listAccessor.getOrderedList()[evtData.index].element
        }),
        getMenuItemCount: () => listAccessor.items.length,
        focusItemAtIndex: (index) => listAccessor.focusItemAtIndex(index),
        focusListRoot: () => listAccessor.element.focus(),
        isSelectableItemAtIndex: (index) => !!closest2(listAccessor.getOrderedList()[index].element, `.${cssClasses2.MENU_SELECTION_GROUP}`),
        getSelectedSiblingOfItemAtIndex: (index) => {
          const orderedList = listAccessor.getOrderedList();
          const selectionGroupEl = closest2(orderedList[index].element, `.${cssClasses2.MENU_SELECTION_GROUP}`);
          const selectedItemEl = selectionGroupEl.querySelector(`.${cssClasses2.MENU_SELECTED_LIST_ITEM}`);
          return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
        }
      }));
      dispatch$2(element2, "SMUI:menu:mount", instance8);
      instance8.init();
      return () => {
        instance8.destroy();
      };
    });
    function handleMenuSurfaceAccessor(event) {
      if (!menuSurfaceAccessor) {
        menuSurfaceAccessor = event.detail;
      }
    }
    function handleListAccessor(event) {
      if (!listAccessor) {
        $$invalidate(5, listAccessor = event.detail);
      }
    }
    function isOpen() {
      return open;
    }
    function setOpen(value) {
      $$invalidate(0, open = value);
    }
    function setDefaultFocusState(focusState) {
      instance8.setDefaultFocusState(focusState);
    }
    function getElement() {
      return element2.getElement();
    }
    function menusurface_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    function menusurface_open_binding(value) {
      open = value;
      $$invalidate(0, open);
    }
    const MDCMenuSurface_opened_handler = () => instance8 && instance8.handleMenuSurfaceOpened();
    const keydown_handler = (event) => instance8 && instance8.handleKeydown(event);
    const MDCList_action_handler = (event) => instance8 && instance8.handleItemAction(listAccessor.getOrderedList()[event.detail.index].element);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("open" in $$new_props)
        $$invalidate(0, open = $$new_props.open);
      if ("$$scope" in $$new_props)
        $$invalidate(20, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCMenuFoundation,
      cssClasses: cssClasses2,
      ponyfill,
      onMount,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder$1,
      classMap: classMap$1,
      dispatch: dispatch$2,
      MenuSurface,
      closest: closest2,
      forwardEvents,
      use: use2,
      className,
      open,
      element: element2,
      instance: instance8,
      menuSurfaceAccessor,
      listAccessor,
      handleMenuSurfaceAccessor,
      handleListAccessor,
      isOpen,
      setOpen,
      setDefaultFocusState,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("open" in $$props)
        $$invalidate(0, open = $$new_props.open);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(4, instance8 = $$new_props.instance);
      if ("menuSurfaceAccessor" in $$props)
        menuSurfaceAccessor = $$new_props.menuSurfaceAccessor;
      if ("listAccessor" in $$props)
        $$invalidate(5, listAccessor = $$new_props.listAccessor);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      open,
      use2,
      className,
      element2,
      instance8,
      listAccessor,
      forwardEvents,
      handleMenuSurfaceAccessor,
      handleListAccessor,
      $$restProps,
      isOpen,
      setOpen,
      setDefaultFocusState,
      getElement,
      slots,
      menusurface_binding,
      menusurface_open_binding,
      MDCMenuSurface_opened_handler,
      keydown_handler,
      MDCList_action_handler,
      $$scope
    ];
  }
  var Menu = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$1, create_fragment$6, safe_not_equal, {
        use: 1,
        class: 2,
        open: 0,
        isOpen: 10,
        setOpen: 11,
        setDefaultFocusState: 12,
        getElement: 13
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Menu",
        options,
        id: create_fragment$6.name
      });
    }
    get use() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get open() {
      throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set open(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get isOpen() {
      return this.$$.ctx[10];
    }
    set isOpen(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setOpen() {
      return this.$$.ctx[11];
    }
    set setOpen(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setDefaultFocusState() {
      return this.$$.ctx[12];
    }
    set setDefaultFocusState(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[13];
    }
    set getElement(value) {
      throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function dispatch2(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  var file$4 = "node_modules/@smui/common/Ul.svelte";
  function create_fragment$5(ctx) {
    let ul;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let ul_levels = [ctx[3]];
    let ul_data = {};
    for (let i = 0; i < ul_levels.length; i += 1) {
      ul_data = assign(ul_data, ul_levels[i]);
    }
    const block = {
      c: function create2() {
        ul = element("ul");
        if (default_slot)
          default_slot.c();
        set_attributes(ul, ul_data);
        add_location(ul, file$4, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, ul, anchor);
        if (default_slot) {
          default_slot.m(ul, null);
        }
        ctx[7](ul);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, ul, ctx[0])),
            action_destroyer(ctx[2].call(null, ul))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(ul);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$5.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$4($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Ul", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function ul_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      ul_binding
    ];
  }
  var Ul = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$4, create_fragment$5, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Ul",
        options,
        id: create_fragment$5.name
      });
    }
    get use() {
      throw new Error("<Ul>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$3 = "node_modules/@smui/common/Nav.svelte";
  function create_fragment$4(ctx) {
    let nav;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let nav_levels = [ctx[3]];
    let nav_data = {};
    for (let i = 0; i < nav_levels.length; i += 1) {
      nav_data = assign(nav_data, nav_levels[i]);
    }
    const block = {
      c: function create2() {
        nav = element("nav");
        if (default_slot)
          default_slot.c();
        set_attributes(nav, nav_data);
        add_location(nav, file$3, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, nav, anchor);
        if (default_slot) {
          default_slot.m(nav, null);
        }
        ctx[7](nav);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, nav, ctx[0])),
            action_destroyer(ctx[2].call(null, nav))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(nav, nav_data = get_spread_update(nav_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(nav);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$4.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$33($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Nav", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function nav_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      nav_binding
    ];
  }
  var Nav = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$33, create_fragment$4, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Nav",
        options,
        id: create_fragment$4.name
      });
    }
    get use() {
      throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$12(ctx) {
    let current;
    const default_slot_template = ctx[38].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[44], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty[1] & 8192)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[44], !current ? get_all_dirty_from_scope(ctx2[44]) : get_slot_changes(default_slot_template, ctx2[44], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$12.name,
      type: "slot",
      source: `(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-deprecated-list': true,     'mdc-deprecated-list--non-interactive': nonInteractive,     'mdc-deprecated-list--dense': dense,     'mdc-deprecated-list--textual-list': textualList,     'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,     'mdc-deprecated-list--icon-list': iconList,     'mdc-deprecated-list--image-list': imageList,     'mdc-deprecated-list--thumbnail-list': thumbnailList,     'mdc-deprecated-list--video-list': videoList,     'mdc-deprecated-list--two-line': twoLine,     'smui-list--three-line': threeLine && !twoLine,   })}   {role}   on:keydown={(event) =>     instance &&     instance.handleKeydown(       event,       event.target.classList.contains('mdc-deprecated-list-item'),       getListItemIndex(event.target)     )}   on:focusin={(event) =>     instance && instance.handleFocusIn(event, getListItemIndex(event.target))}   on:focusout={(event) =>     instance && instance.handleFocusOut(event, getListItemIndex(event.target))}   on:click={(event) =>     instance &&     instance.handleClick(       getListItemIndex(event.target),       !matches(event.target, 'input[type=\\"checkbox\\"], input[type=\\"radio\\"]')     )}   on:SMUI:list:item:mount={handleItemMount}   on:SMUI:list:item:unmount={handleItemUnmount}   on:SMUI:action={handleAction}   {...$$restProps} >`,
      ctx
    });
    return block;
  }
  function create_fragment$33(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[17], ...ctx[0]]
      },
      {
        class: classMap4({
          [ctx[1]]: true,
          "mdc-deprecated-list": true,
          "mdc-deprecated-list--non-interactive": ctx[2],
          "mdc-deprecated-list--dense": ctx[3],
          "mdc-deprecated-list--textual-list": ctx[4],
          "mdc-deprecated-list--avatar-list": ctx[5] || ctx[18],
          "mdc-deprecated-list--icon-list": ctx[6],
          "mdc-deprecated-list--image-list": ctx[7],
          "mdc-deprecated-list--thumbnail-list": ctx[8],
          "mdc-deprecated-list--video-list": ctx[9],
          "mdc-deprecated-list--two-line": ctx[10],
          "smui-list--three-line": ctx[11] && !ctx[10]
        })
      },
      {role: ctx[15]},
      ctx[23]
    ];
    var switch_value = ctx[12];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$12]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[39](switch_instance);
      switch_instance.$on("keydown", ctx[40]);
      switch_instance.$on("focusin", ctx[41]);
      switch_instance.$on("focusout", ctx[42]);
      switch_instance.$on("click", ctx[43]);
      switch_instance.$on("SMUI:list:item:mount", ctx[19]);
      switch_instance.$on("SMUI:list:item:unmount", ctx[20]);
      switch_instance.$on("SMUI:action", ctx[21]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty[0] & 8818687 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & 131073 && {
            use: [ctx2[17], ...ctx2[0]]
          },
          dirty[0] & 266238 && {
            class: classMap4({
              [ctx2[1]]: true,
              "mdc-deprecated-list": true,
              "mdc-deprecated-list--non-interactive": ctx2[2],
              "mdc-deprecated-list--dense": ctx2[3],
              "mdc-deprecated-list--textual-list": ctx2[4],
              "mdc-deprecated-list--avatar-list": ctx2[5] || ctx2[18],
              "mdc-deprecated-list--icon-list": ctx2[6],
              "mdc-deprecated-list--image-list": ctx2[7],
              "mdc-deprecated-list--thumbnail-list": ctx2[8],
              "mdc-deprecated-list--video-list": ctx2[9],
              "mdc-deprecated-list--two-line": ctx2[10],
              "smui-list--three-line": ctx2[11] && !ctx2[10]
            })
          },
          dirty[0] & 32768 && {role: ctx2[15]},
          dirty[0] & 8388608 && get_spread_object(ctx2[23])
        ]) : {};
        if (dirty[1] & 8192) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[12])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[39](switch_instance);
            switch_instance.$on("keydown", ctx2[40]);
            switch_instance.$on("focusin", ctx2[41]);
            switch_instance.$on("focusout", ctx2[42]);
            switch_instance.$on("click", ctx2[43]);
            switch_instance.$on("SMUI:list:item:mount", ctx2[19]);
            switch_instance.$on("SMUI:list:item:unmount", ctx2[20]);
            switch_instance.$on("SMUI:action", ctx2[21]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[39](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$33.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance_1($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "nonInteractive",
      "dense",
      "textualList",
      "avatarList",
      "iconList",
      "imageList",
      "thumbnailList",
      "videoList",
      "twoLine",
      "threeLine",
      "vertical",
      "wrapFocus",
      "singleSelection",
      "selectedIndex",
      "radioList",
      "checkList",
      "hasTypeahead",
      "radiolist",
      "checklist",
      "component",
      "layout",
      "setEnabled",
      "getTypeaheadInProgress",
      "getSelectedIndex",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("List", slots, ["default"]);
    const {closest: closest2, matches: matches2} = ponyfill;
    const forwardEvents = forwardEventsBuilder4(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {nonInteractive = false} = $$props;
    let {dense = false} = $$props;
    let {textualList = false} = $$props;
    let {avatarList = false} = $$props;
    let {iconList = false} = $$props;
    let {imageList = false} = $$props;
    let {thumbnailList = false} = $$props;
    let {videoList = false} = $$props;
    let {twoLine = false} = $$props;
    let {threeLine = false} = $$props;
    let {vertical = true} = $$props;
    let {wrapFocus = getContext("SMUI:list:wrapFocus") || false} = $$props;
    let {singleSelection = false} = $$props;
    let {selectedIndex = -1} = $$props;
    let {radioList = false} = $$props;
    let {checkList = false} = $$props;
    let {hasTypeahead = false} = $$props;
    let {radiolist = false} = $$props;
    if (radiolist) {
      radioList = true;
    }
    let {checklist = false} = $$props;
    if (checklist) {
      checkList = true;
    }
    let element2;
    let instance8;
    let items = [];
    let role = getContext("SMUI:list:role");
    let nav = getContext("SMUI:list:nav");
    const itemAccessorMap = new WeakMap();
    let selectionDialog = getContext("SMUI:dialog:selection");
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let {component = nav ? Nav : Ul} = $$props;
    setContext("SMUI:list:nonInteractive", nonInteractive);
    setContext("SMUI:separator:context", "list");
    if (!role) {
      if (singleSelection) {
        role = "listbox";
        setContext("SMUI:list:item:role", "option");
      } else if (radioList) {
        role = "radiogroup";
        setContext("SMUI:list:item:role", "radio");
      } else if (checkList) {
        role = "group";
        setContext("SMUI:list:item:role", "checkbox");
      } else {
        role = "list";
        setContext("SMUI:list:item:role", void 0);
      }
    }
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    onMount(() => {
      $$invalidate(13, instance8 = new MDCListFoundation({
        addClassForElementIndex,
        focusItemAtIndex,
        getAttributeForElementIndex: (index, name) => getOrderedList()[index].getAttr(name),
        getFocusedElementIndex: () => getOrderedList().map((accessor) => accessor.element).indexOf(document.activeElement),
        getListItemCount: () => items.length,
        getPrimaryTextAtIndex,
        hasCheckboxAtIndex: (index) => getOrderedList()[index].hasCheckbox,
        hasRadioAtIndex: (index) => getOrderedList()[index].hasRadio,
        isCheckboxCheckedAtIndex: (index) => {
          const listItem = getOrderedList()[index];
          return listItem.hasCheckbox && listItem.checked;
        },
        isFocusInsideList: () => getElement() !== document.activeElement && getElement().contains(document.activeElement),
        isRootFocused: () => document.activeElement === getElement(),
        listItemAtIndexHasClass,
        notifyAction: (index) => {
          $$invalidate(24, selectedIndex = index);
          dispatch2(element2, "MDCList:action", {index});
        },
        removeClassForElementIndex,
        setAttributeForElementIndex,
        setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
          getOrderedList()[index].checked = isChecked;
        },
        setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
          const listItem = getOrderedList()[listItemIndex];
          const selector = "button:not(:disabled), a";
          Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
            el.setAttribute("tabindex", tabIndexValue);
          });
        }
      }));
      dispatch2(element2, "SMUI:list:mount", {
        get element() {
          return getElement();
        },
        get items() {
          return items;
        },
        get typeaheadInProgress() {
          return instance8.isTypeaheadInProgress();
        },
        typeaheadMatchItem(nextChar, startingIndex) {
          return instance8.typeaheadMatchItem(nextChar, startingIndex, true);
        },
        getOrderedList,
        focusItemAtIndex,
        addClassForElementIndex,
        removeClassForElementIndex,
        setAttributeForElementIndex,
        removeAttributeForElementIndex,
        getPrimaryTextAtIndex
      });
      instance8.init();
      return () => {
        instance8.destroy();
      };
    });
    onDestroy(() => {
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    });
    function handleItemMount(event) {
      items.push(event.detail);
      itemAccessorMap.set(event.detail.element, event.detail);
      if (singleSelection && event.detail.selected) {
        $$invalidate(24, selectedIndex = getListItemIndex(event.detail.element));
      }
      event.stopPropagation();
    }
    function handleItemUnmount(event) {
      const idx = items.indexOf(event.detail);
      if (idx !== -1) {
        items.splice(idx, 1);
        items = items;
      }
      itemAccessorMap.delete(event.detail.element);
      event.stopPropagation();
    }
    function handleAction(event) {
      if (radioList || checkList) {
        const index = getListItemIndex(event.target);
        if (index !== -1) {
          const item = getOrderedList()[index];
          if (radioList && !item.checked || checkList) {
            item.checked = !item.checked;
            item.activateRipple();
            window.requestAnimationFrame(() => {
              item.deactivateRipple();
            });
          }
        }
      }
    }
    function getOrderedList() {
      return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
    }
    function focusItemAtIndex(index) {
      const accessor = getOrderedList()[index];
      accessor && accessor.element.focus();
    }
    function listItemAtIndexHasClass(index, className2) {
      const accessor = getOrderedList()[index];
      return accessor && accessor.hasClass(className2);
    }
    function addClassForElementIndex(index, className2) {
      const accessor = getOrderedList()[index];
      accessor && accessor.addClass(className2);
    }
    function removeClassForElementIndex(index, className2) {
      const accessor = getOrderedList()[index];
      accessor && accessor.removeClass(className2);
    }
    function setAttributeForElementIndex(index, name, value) {
      const accessor = getOrderedList()[index];
      accessor && accessor.addAttr(name, value);
    }
    function removeAttributeForElementIndex(index, name) {
      const accessor = getOrderedList()[index];
      accessor && accessor.removeAttr(name);
    }
    function getPrimaryTextAtIndex(index) {
      const accessor = getOrderedList()[index];
      return accessor && accessor.getPrimaryText();
    }
    function getListItemIndex(element3) {
      const nearestParent = closest2(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
      if (nearestParent && matches2(nearestParent, ".mdc-deprecated-list-item")) {
        return getOrderedList().map((item) => item.element).indexOf(nearestParent);
      }
      return -1;
    }
    function layout() {
      return instance8.layout();
    }
    function setEnabled(...args) {
      return instance8.setEnabled(...args);
    }
    function getTypeaheadInProgress() {
      return instance8.isTypeaheadInProgress();
    }
    function getSelectedIndex() {
      return instance8.getSelectedIndex();
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(14, element2);
      });
    }
    const keydown_handler = (event) => instance8 && instance8.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
    const focusin_handler = (event) => instance8 && instance8.handleFocusIn(event, getListItemIndex(event.target));
    const focusout_handler = (event) => instance8 && instance8.handleFocusOut(event, getListItemIndex(event.target));
    const click_handler = (event) => instance8 && instance8.handleClick(getListItemIndex(event.target), !matches2(event.target, 'input[type="checkbox"], input[type="radio"]'));
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("nonInteractive" in $$new_props)
        $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
      if ("dense" in $$new_props)
        $$invalidate(3, dense = $$new_props.dense);
      if ("textualList" in $$new_props)
        $$invalidate(4, textualList = $$new_props.textualList);
      if ("avatarList" in $$new_props)
        $$invalidate(5, avatarList = $$new_props.avatarList);
      if ("iconList" in $$new_props)
        $$invalidate(6, iconList = $$new_props.iconList);
      if ("imageList" in $$new_props)
        $$invalidate(7, imageList = $$new_props.imageList);
      if ("thumbnailList" in $$new_props)
        $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
      if ("videoList" in $$new_props)
        $$invalidate(9, videoList = $$new_props.videoList);
      if ("twoLine" in $$new_props)
        $$invalidate(10, twoLine = $$new_props.twoLine);
      if ("threeLine" in $$new_props)
        $$invalidate(11, threeLine = $$new_props.threeLine);
      if ("vertical" in $$new_props)
        $$invalidate(27, vertical = $$new_props.vertical);
      if ("wrapFocus" in $$new_props)
        $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
      if ("singleSelection" in $$new_props)
        $$invalidate(29, singleSelection = $$new_props.singleSelection);
      if ("selectedIndex" in $$new_props)
        $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
      if ("radioList" in $$new_props)
        $$invalidate(25, radioList = $$new_props.radioList);
      if ("checkList" in $$new_props)
        $$invalidate(26, checkList = $$new_props.checkList);
      if ("hasTypeahead" in $$new_props)
        $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
      if ("radiolist" in $$new_props)
        $$invalidate(31, radiolist = $$new_props.radiolist);
      if ("checklist" in $$new_props)
        $$invalidate(32, checklist = $$new_props.checklist);
      if ("component" in $$new_props)
        $$invalidate(12, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(44, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCListFoundation,
      ponyfill,
      onMount,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder4,
      classMap: classMap4,
      dispatch: dispatch2,
      Ul,
      Nav,
      closest: closest2,
      matches: matches2,
      forwardEvents,
      use: use2,
      className,
      nonInteractive,
      dense,
      textualList,
      avatarList,
      iconList,
      imageList,
      thumbnailList,
      videoList,
      twoLine,
      threeLine,
      vertical,
      wrapFocus,
      singleSelection,
      selectedIndex,
      radioList,
      checkList,
      hasTypeahead,
      radiolist,
      checklist,
      element: element2,
      instance: instance8,
      items,
      role,
      nav,
      itemAccessorMap,
      selectionDialog,
      addLayoutListener,
      removeLayoutListener,
      component,
      handleItemMount,
      handleItemUnmount,
      handleAction,
      getOrderedList,
      focusItemAtIndex,
      listItemAtIndexHasClass,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getPrimaryTextAtIndex,
      getListItemIndex,
      layout,
      setEnabled,
      getTypeaheadInProgress,
      getSelectedIndex,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("nonInteractive" in $$props)
        $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
      if ("dense" in $$props)
        $$invalidate(3, dense = $$new_props.dense);
      if ("textualList" in $$props)
        $$invalidate(4, textualList = $$new_props.textualList);
      if ("avatarList" in $$props)
        $$invalidate(5, avatarList = $$new_props.avatarList);
      if ("iconList" in $$props)
        $$invalidate(6, iconList = $$new_props.iconList);
      if ("imageList" in $$props)
        $$invalidate(7, imageList = $$new_props.imageList);
      if ("thumbnailList" in $$props)
        $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
      if ("videoList" in $$props)
        $$invalidate(9, videoList = $$new_props.videoList);
      if ("twoLine" in $$props)
        $$invalidate(10, twoLine = $$new_props.twoLine);
      if ("threeLine" in $$props)
        $$invalidate(11, threeLine = $$new_props.threeLine);
      if ("vertical" in $$props)
        $$invalidate(27, vertical = $$new_props.vertical);
      if ("wrapFocus" in $$props)
        $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
      if ("singleSelection" in $$props)
        $$invalidate(29, singleSelection = $$new_props.singleSelection);
      if ("selectedIndex" in $$props)
        $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
      if ("radioList" in $$props)
        $$invalidate(25, radioList = $$new_props.radioList);
      if ("checkList" in $$props)
        $$invalidate(26, checkList = $$new_props.checkList);
      if ("hasTypeahead" in $$props)
        $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
      if ("radiolist" in $$props)
        $$invalidate(31, radiolist = $$new_props.radiolist);
      if ("checklist" in $$props)
        $$invalidate(32, checklist = $$new_props.checklist);
      if ("element" in $$props)
        $$invalidate(14, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(13, instance8 = $$new_props.instance);
      if ("items" in $$props)
        items = $$new_props.items;
      if ("role" in $$props)
        $$invalidate(15, role = $$new_props.role);
      if ("nav" in $$props)
        nav = $$new_props.nav;
      if ("selectionDialog" in $$props)
        $$invalidate(18, selectionDialog = $$new_props.selectionDialog);
      if ("addLayoutListener" in $$props)
        addLayoutListener = $$new_props.addLayoutListener;
      if ("removeLayoutListener" in $$props)
        removeLayoutListener = $$new_props.removeLayoutListener;
      if ("component" in $$props)
        $$invalidate(12, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 134225920) {
        if (instance8) {
          instance8.setVerticalOrientation(vertical);
        }
      }
      if ($$self.$$.dirty[0] & 268443648) {
        if (instance8) {
          instance8.setWrapFocus(wrapFocus);
        }
      }
      if ($$self.$$.dirty[0] & 1073750016) {
        if (instance8) {
          instance8.setHasTypeahead(hasTypeahead);
        }
      }
      if ($$self.$$.dirty[0] & 536879104) {
        if (instance8) {
          instance8.setSingleSelection(singleSelection);
        }
      }
      if ($$self.$$.dirty[0] & 553656320) {
        if (instance8 && singleSelection && getSelectedIndex() !== selectedIndex) {
          instance8.setSelectedIndex(selectedIndex);
        }
      }
    };
    return [
      use2,
      className,
      nonInteractive,
      dense,
      textualList,
      avatarList,
      iconList,
      imageList,
      thumbnailList,
      videoList,
      twoLine,
      threeLine,
      component,
      instance8,
      element2,
      role,
      matches2,
      forwardEvents,
      selectionDialog,
      handleItemMount,
      handleItemUnmount,
      handleAction,
      getListItemIndex,
      $$restProps,
      selectedIndex,
      radioList,
      checkList,
      vertical,
      wrapFocus,
      singleSelection,
      hasTypeahead,
      radiolist,
      checklist,
      layout,
      setEnabled,
      getTypeaheadInProgress,
      getSelectedIndex,
      getElement,
      slots,
      switch_instance_binding,
      keydown_handler,
      focusin_handler,
      focusout_handler,
      click_handler,
      $$scope
    ];
  }
  var List = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1, create_fragment$33, safe_not_equal, {
        use: 0,
        class: 1,
        nonInteractive: 2,
        dense: 3,
        textualList: 4,
        avatarList: 5,
        iconList: 6,
        imageList: 7,
        thumbnailList: 8,
        videoList: 9,
        twoLine: 10,
        threeLine: 11,
        vertical: 27,
        wrapFocus: 28,
        singleSelection: 29,
        selectedIndex: 24,
        radioList: 25,
        checkList: 26,
        hasTypeahead: 30,
        radiolist: 31,
        checklist: 32,
        component: 12,
        layout: 33,
        setEnabled: 34,
        getTypeaheadInProgress: 35,
        getSelectedIndex: 36,
        getElement: 37
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "List",
        options,
        id: create_fragment$33.name
      });
    }
    get use() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get nonInteractive() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nonInteractive(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dense() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dense(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get textualList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set textualList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get avatarList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set avatarList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get iconList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set iconList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get imageList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set imageList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get thumbnailList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set thumbnailList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get videoList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set videoList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get twoLine() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set twoLine(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get threeLine() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set threeLine(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get vertical() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set vertical(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get wrapFocus() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set wrapFocus(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get singleSelection() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set singleSelection(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get selectedIndex() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set selectedIndex(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get radioList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set radioList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get checkList() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set checkList(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get hasTypeahead() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set hasTypeahead(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get radiolist() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set radiolist(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get checklist() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set checklist(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get layout() {
      return this.$$.ctx[33];
    }
    set layout(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setEnabled() {
      return this.$$.ctx[34];
    }
    set setEnabled(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getTypeaheadInProgress() {
      return this.$$.ctx[35];
    }
    set getTypeaheadInProgress(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getSelectedIndex() {
      return this.$$.ctx[36];
    }
    set getSelectedIndex(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[37];
    }
    set getElement(value) {
      throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$23 = "node_modules/@smui/common/Li.svelte";
  function create_fragment$24(ctx) {
    let li;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let li_levels = [ctx[3]];
    let li_data = {};
    for (let i = 0; i < li_levels.length; i += 1) {
      li_data = assign(li_data, li_levels[i]);
    }
    const block = {
      c: function create2() {
        li = element("li");
        if (default_slot)
          default_slot.c();
        set_attributes(li, li_data);
        add_location(li, file$23, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        if (default_slot) {
          default_slot.m(li, null);
        }
        ctx[7](li);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, li, ctx[0])),
            action_destroyer(ctx[2].call(null, li))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(li);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$24.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$24($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Li", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function li_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      li_binding
    ];
  }
  var Li = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$24, create_fragment$24, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Li",
        options,
        id: create_fragment$24.name
      });
    }
    get use() {
      throw new Error("<Li>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Li>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Li>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$14 = "node_modules/@smui/list/Item.svelte";
  function create_if_block2(ctx) {
    let span;
    const block = {
      c: function create2() {
        span = element("span");
        attr_dev(span, "class", "mdc-deprecated-list-item__ripple");
        add_location(span, file$14, 55, 15, 1654);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block2.name,
      type: "if",
      source: "(56:3) {#if ripple}",
      ctx
    });
    return block;
  }
  function create_default_slot5(ctx) {
    let if_block_anchor;
    let current;
    let if_block = ctx[6] && create_if_block2(ctx);
    const default_slot_template = ctx[30].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[34], null);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[6]) {
          if (if_block)
            ;
          else {
            if_block = create_if_block2(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (default_slot) {
          if (default_slot.p && (!current || dirty[1] & 8)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[34], !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(default_slot_template, ctx2[34], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot5.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     ...(nonInteractive       ? []       : [           [             Ripple,             {               ripple: !input,               unbounded: false,               color:                 (activated || selected) && color == null ? 'primary' : color,               disabled,               addClass,               removeClass,               addStyle,             },           ],         ]),     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-deprecated-list-item': true,     'mdc-deprecated-list-item--activated': activated,     'mdc-deprecated-list-item--selected': selected,     'mdc-deprecated-list-item--disabled': disabled,     'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,     'smui-menu-item--non-interactive': nonInteractive,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...nav && activated ? { 'aria-current': 'page' } : {}}   {...!nav ? { role } : {}}   {...!nav && role === 'option'     ? { 'aria-selected': selected ? 'true' : 'false' }     : {}}   {...!nav && (role === 'radio' || role === 'checkbox')     ? { 'aria-checked': input && input.checked ? 'true' : 'false' }     : {}}   {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}   {tabindex}   on:click={action}   on:keydown={handleKeydown}   on:SMUI:generic:input:mount={(event) => (input = event.detail)}   on:SMUI:generic:input:unmount={() => (input = undefined)}   {href}   {...internalAttrs}   {...$$restProps}   >",
      ctx
    });
    return block;
  }
  function create_fragment$14(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [
          ...ctx[5] ? [] : [
            [
              Ripple,
              {
                ripple: !ctx[12],
                unbounded: false,
                color: (ctx[7] || ctx[0]) && ctx[4] == null ? "primary" : ctx[4],
                disabled: ctx[9],
                addClass: ctx[20],
                removeClass: ctx[21],
                addStyle: ctx[22]
              }
            ]
          ],
          ctx[18],
          ...ctx[1]
        ]
      },
      {
        class: classMap4({
          [ctx[2]]: true,
          "mdc-deprecated-list-item": true,
          "mdc-deprecated-list-item--activated": ctx[7],
          "mdc-deprecated-list-item--selected": ctx[0],
          "mdc-deprecated-list-item--disabled": ctx[9],
          "mdc-menu-item--selected": !ctx[19] && ctx[8] === "menuitem" && ctx[0],
          "smui-menu-item--non-interactive": ctx[5],
          ...ctx[14]
        })
      },
      {
        style: Object.entries(ctx[15]).map(func2).concat([ctx[3]]).join(" ")
      },
      ctx[19] && ctx[7] ? {"aria-current": "page"} : {},
      !ctx[19] ? {role: ctx[8]} : {},
      !ctx[19] && ctx[8] === "option" ? {
        "aria-selected": ctx[0] ? "true" : "false"
      } : {},
      !ctx[19] && (ctx[8] === "radio" || ctx[8] === "checkbox") ? {
        "aria-checked": ctx[12] && ctx[12].checked ? "true" : "false"
      } : {},
      !ctx[19] ? {
        "aria-disabled": ctx[9] ? "true" : "false"
      } : {},
      {tabindex: ctx[17]},
      {href: ctx[10]},
      ctx[16],
      ctx[25]
    ];
    var switch_value = ctx[11];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot5]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[31](switch_instance);
      switch_instance.$on("click", ctx[23]);
      switch_instance.$on("keydown", ctx[24]);
      switch_instance.$on("SMUI:generic:input:mount", ctx[32]);
      switch_instance.$on("SMUI:generic:input:unmount", ctx[33]);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const switch_instance_changes = dirty[0] & 41932735 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & 7606963 && {
            use: [
              ...ctx2[5] ? [] : [
                [
                  Ripple,
                  {
                    ripple: !ctx2[12],
                    unbounded: false,
                    color: (ctx2[7] || ctx2[0]) && ctx2[4] == null ? "primary" : ctx2[4],
                    disabled: ctx2[9],
                    addClass: ctx2[20],
                    removeClass: ctx2[21],
                    addStyle: ctx2[22]
                  }
                ]
              ],
              ctx2[18],
              ...ctx2[1]
            ]
          },
          dirty[0] & 541605 && {
            class: classMap4({
              [ctx2[2]]: true,
              "mdc-deprecated-list-item": true,
              "mdc-deprecated-list-item--activated": ctx2[7],
              "mdc-deprecated-list-item--selected": ctx2[0],
              "mdc-deprecated-list-item--disabled": ctx2[9],
              "mdc-menu-item--selected": !ctx2[19] && ctx2[8] === "menuitem" && ctx2[0],
              "smui-menu-item--non-interactive": ctx2[5],
              ...ctx2[14]
            })
          },
          dirty[0] & 32776 && {
            style: Object.entries(ctx2[15]).map(func2).concat([ctx2[3]]).join(" ")
          },
          dirty[0] & 524416 && get_spread_object(ctx2[19] && ctx2[7] ? {"aria-current": "page"} : {}),
          dirty[0] & 524544 && get_spread_object(!ctx2[19] ? {role: ctx2[8]} : {}),
          dirty[0] & 524545 && get_spread_object(!ctx2[19] && ctx2[8] === "option" ? {
            "aria-selected": ctx2[0] ? "true" : "false"
          } : {}),
          dirty[0] & 528640 && get_spread_object(!ctx2[19] && (ctx2[8] === "radio" || ctx2[8] === "checkbox") ? {
            "aria-checked": ctx2[12] && ctx2[12].checked ? "true" : "false"
          } : {}),
          dirty[0] & 524800 && get_spread_object(!ctx2[19] ? {
            "aria-disabled": ctx2[9] ? "true" : "false"
          } : {}),
          dirty[0] & 131072 && {tabindex: ctx2[17]},
          dirty[0] & 1024 && {href: ctx2[10]},
          dirty[0] & 65536 && get_spread_object(ctx2[16]),
          dirty[0] & 33554432 && get_spread_object(ctx2[25])
        ]) : {};
        if (dirty[0] & 64 | dirty[1] & 8) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[11])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[31](switch_instance);
            switch_instance.$on("click", ctx2[23]);
            switch_instance.$on("keydown", ctx2[24]);
            switch_instance.$on("SMUI:generic:input:mount", ctx2[32]);
            switch_instance.$on("SMUI:generic:input:unmount", ctx2[33]);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[31](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$14.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var counter = 0;
  var func2 = ([name, value]) => `${name}: ${value};`;
  function instance$14($$self, $$props, $$invalidate) {
    let tabindex;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "color",
      "nonInteractive",
      "ripple",
      "activated",
      "role",
      "selected",
      "disabled",
      "tabindex",
      "inputId",
      "href",
      "component",
      "getPrimaryText",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Item", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder4(get_current_component());
    let uninitializedValue = () => {
    };
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {color = null} = $$props;
    let {nonInteractive = getContext("SMUI:list:nonInteractive")} = $$props;
    setContext("SMUI:list:nonInteractive", void 0);
    let {ripple = !nonInteractive} = $$props;
    let {activated = false} = $$props;
    let {role = getContext("SMUI:list:item:role")} = $$props;
    setContext("SMUI:list:item:role", void 0);
    let {selected = false} = $$props;
    let {disabled = false} = $$props;
    let {tabindex: tabindexProp = uninitializedValue} = $$props;
    let {inputId = "SMUI-form-field-list-" + counter++} = $$props;
    let {href = null} = $$props;
    let element2;
    let internalClasses = {};
    let internalStyles = {};
    let internalAttrs = {};
    let input;
    let addTabindexIfNoItemsSelectedRaf;
    let nav = getContext("SMUI:list:item:nav");
    let {component = nav ? href ? A : Span : Li} = $$props;
    setContext("SMUI:generic:input:props", {id: inputId});
    setContext("SMUI:separator:context", void 0);
    onMount(() => {
      if (!selected && !nonInteractive) {
        let first = true;
        let el = element2;
        while (el.previousSibling) {
          el = el.previousSibling;
          if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
            first = false;
            break;
          }
        }
        if (first) {
          addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
        }
      }
      const accessor = {
        _smui_list_item_accessor: true,
        get element() {
          return getElement();
        },
        get selected() {
          return selected;
        },
        set selected(value) {
          $$invalidate(0, selected = value);
        },
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getPrimaryText,
        get checked() {
          return input && input.checked;
        },
        set checked(value) {
          if (input) {
            $$invalidate(12, input.checked = value, input);
          }
        },
        get hasCheckbox() {
          return !!(input && input._smui_checkbox_accessor);
        },
        get hasRadio() {
          return !!(input && input._smui_radio_accessor);
        },
        activateRipple() {
          if (input) {
            input.activateRipple();
          }
        },
        deactivateRipple() {
          if (input) {
            input.deactivateRipple();
          }
        },
        getValue() {
          return $$restProps.value;
        }
      };
      dispatch2(element2, "SMUI:list:item:mount", accessor);
      return () => {
        dispatch2(element2, "SMUI:list:item:unmount", accessor);
      };
    });
    onDestroy(() => {
      if (addTabindexIfNoItemsSelectedRaf) {
        window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(14, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(14, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name, value) {
      if (internalStyles[name] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name];
          $$invalidate(15, internalStyles);
        } else {
          $$invalidate(15, internalStyles[name] = value, internalStyles);
        }
      }
    }
    function getAttr(name) {
      return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
    }
    function addAttr(name, value) {
      if (internalAttrs[name] !== value) {
        $$invalidate(16, internalAttrs[name] = value, internalAttrs);
      }
    }
    function removeAttr(name) {
      if (!(name in internalAttrs) || internalAttrs[name] != null) {
        $$invalidate(16, internalAttrs[name] = void 0, internalAttrs);
      }
    }
    function addTabindexIfNoItemsSelected() {
      let noneSelected = true;
      let el = element2;
      while (el.nextSibling) {
        el = el.nextSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && el.attributes["tabindex"] && el.attributes["tabindex"].value === "0") {
          noneSelected = false;
          break;
        }
      }
      if (noneSelected) {
        $$invalidate(17, tabindex = "0");
      }
    }
    function action(e) {
      if (!disabled) {
        dispatch2(element2, "SMUI:action", e);
      }
    }
    function handleKeydown2(e) {
      const isEnter = e.key === "Enter" || e.keyCode === 13;
      const isSpace = e.key === "Space" || e.keyCode === 32;
      if (isEnter || isSpace) {
        action(e);
      }
    }
    function getPrimaryText() {
      const element3 = getElement();
      const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
      if (primaryText) {
        return primaryText.textContent;
      }
      const text2 = element3.querySelector(".mdc-deprecated-list-item__text");
      if (text2) {
        return text2.textContent;
      }
      return element3.textContent;
    }
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(13, element2);
      });
    }
    const SMUI_generic_input_mount_handler = (event) => $$invalidate(12, input = event.detail);
    const SMUI_generic_input_unmount_handler = () => $$invalidate(12, input = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("color" in $$new_props)
        $$invalidate(4, color = $$new_props.color);
      if ("nonInteractive" in $$new_props)
        $$invalidate(5, nonInteractive = $$new_props.nonInteractive);
      if ("ripple" in $$new_props)
        $$invalidate(6, ripple = $$new_props.ripple);
      if ("activated" in $$new_props)
        $$invalidate(7, activated = $$new_props.activated);
      if ("role" in $$new_props)
        $$invalidate(8, role = $$new_props.role);
      if ("selected" in $$new_props)
        $$invalidate(0, selected = $$new_props.selected);
      if ("disabled" in $$new_props)
        $$invalidate(9, disabled = $$new_props.disabled);
      if ("tabindex" in $$new_props)
        $$invalidate(26, tabindexProp = $$new_props.tabindex);
      if ("inputId" in $$new_props)
        $$invalidate(27, inputId = $$new_props.inputId);
      if ("href" in $$new_props)
        $$invalidate(10, href = $$new_props.href);
      if ("component" in $$new_props)
        $$invalidate(11, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(34, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      counter,
      onMount,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder4,
      classMap: classMap4,
      dispatch: dispatch2,
      Ripple,
      A,
      Span,
      Li,
      forwardEvents,
      uninitializedValue,
      use: use2,
      className,
      style,
      color,
      nonInteractive,
      ripple,
      activated,
      role,
      selected,
      disabled,
      tabindexProp,
      inputId,
      href,
      element: element2,
      internalClasses,
      internalStyles,
      internalAttrs,
      input,
      addTabindexIfNoItemsSelectedRaf,
      nav,
      component,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      getAttr,
      addAttr,
      removeAttr,
      addTabindexIfNoItemsSelected,
      action,
      handleKeydown: handleKeydown2,
      getPrimaryText,
      getElement,
      tabindex
    });
    $$self.$inject_state = ($$new_props) => {
      if ("uninitializedValue" in $$props)
        $$invalidate(36, uninitializedValue = $$new_props.uninitializedValue);
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("color" in $$props)
        $$invalidate(4, color = $$new_props.color);
      if ("nonInteractive" in $$props)
        $$invalidate(5, nonInteractive = $$new_props.nonInteractive);
      if ("ripple" in $$props)
        $$invalidate(6, ripple = $$new_props.ripple);
      if ("activated" in $$props)
        $$invalidate(7, activated = $$new_props.activated);
      if ("role" in $$props)
        $$invalidate(8, role = $$new_props.role);
      if ("selected" in $$props)
        $$invalidate(0, selected = $$new_props.selected);
      if ("disabled" in $$props)
        $$invalidate(9, disabled = $$new_props.disabled);
      if ("tabindexProp" in $$props)
        $$invalidate(26, tabindexProp = $$new_props.tabindexProp);
      if ("inputId" in $$props)
        $$invalidate(27, inputId = $$new_props.inputId);
      if ("href" in $$props)
        $$invalidate(10, href = $$new_props.href);
      if ("element" in $$props)
        $$invalidate(13, element2 = $$new_props.element);
      if ("internalClasses" in $$props)
        $$invalidate(14, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(15, internalStyles = $$new_props.internalStyles);
      if ("internalAttrs" in $$props)
        $$invalidate(16, internalAttrs = $$new_props.internalAttrs);
      if ("input" in $$props)
        $$invalidate(12, input = $$new_props.input);
      if ("addTabindexIfNoItemsSelectedRaf" in $$props)
        addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
      if ("nav" in $$props)
        $$invalidate(19, nav = $$new_props.nav);
      if ("component" in $$props)
        $$invalidate(11, component = $$new_props.component);
      if ("tabindex" in $$props)
        $$invalidate(17, tabindex = $$new_props.tabindex);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 67113505) {
        $$invalidate(17, tabindex = tabindexProp == uninitializedValue ? !nonInteractive && !disabled && (selected || input && input.checked) && "0" || "-1" : tabindexProp);
      }
    };
    return [
      selected,
      use2,
      className,
      style,
      color,
      nonInteractive,
      ripple,
      activated,
      role,
      disabled,
      href,
      component,
      input,
      element2,
      internalClasses,
      internalStyles,
      internalAttrs,
      tabindex,
      forwardEvents,
      nav,
      addClass,
      removeClass,
      addStyle,
      action,
      handleKeydown2,
      $$restProps,
      tabindexProp,
      inputId,
      getPrimaryText,
      getElement,
      slots,
      switch_instance_binding,
      SMUI_generic_input_mount_handler,
      SMUI_generic_input_unmount_handler,
      $$scope
    ];
  }
  var Item = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$14, create_fragment$14, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        color: 4,
        nonInteractive: 5,
        ripple: 6,
        activated: 7,
        role: 8,
        selected: 0,
        disabled: 9,
        tabindex: 26,
        inputId: 27,
        href: 10,
        component: 11,
        getPrimaryText: 28,
        getElement: 29
      }, null, [-1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Item",
        options,
        id: create_fragment$14.name
      });
    }
    get use() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get color() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set color(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get nonInteractive() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set nonInteractive(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get activated() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set activated(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get role() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set role(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get selected() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set selected(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get disabled() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set disabled(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get tabindex() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set tabindex(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get inputId() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set inputId(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get href() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set href(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getPrimaryText() {
      return this.$$.ctx[28];
    }
    set getPrimaryText(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[29];
    }
    set getElement(value) {
      throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Text = classAdderBuilder3({
    class: "mdc-deprecated-list-item__text",
    component: Span
  });
  classAdderBuilder3({
    class: "mdc-deprecated-list-item__primary-text",
    component: Span
  });
  classAdderBuilder3({
    class: "mdc-deprecated-list-item__secondary-text",
    component: Span
  });
  classAdderBuilder3({
    class: "mdc-deprecated-list-item__meta",
    component: Span
  });
  classAdderBuilder3({
    class: "mdc-deprecated-list-group",
    component: Div
  });
  var file4 = "node_modules/@smui/common/H3.svelte";
  function create_fragment5(ctx) {
    let h3;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let h3_levels = [ctx[3]];
    let h3_data = {};
    for (let i = 0; i < h3_levels.length; i += 1) {
      h3_data = assign(h3_data, h3_levels[i]);
    }
    const block = {
      c: function create2() {
        h3 = element("h3");
        if (default_slot)
          default_slot.c();
        set_attributes(h3, h3_data);
        add_location(h3, file4, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h3, anchor);
        if (default_slot) {
          default_slot.m(h3, null);
        }
        ctx[7](h3);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, h3, ctx[0])),
            action_destroyer(ctx[2].call(null, h3))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(h3, h3_data = get_spread_update(h3_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(h3);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment5.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance5($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("H3", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function h3_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      h3_binding
    ];
  }
  var H3 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance5, create_fragment5, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "H3",
        options,
        id: create_fragment5.name
      });
    }
    get use() {
      throw new Error("<H3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<H3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var Subheader = classAdderBuilder3({
    class: "mdc-deprecated-list-group__subheader",
    component: H3
  });

  // dist/build/useActions.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function useActions4(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }

  // dist/build/NotchedOutline.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$22 = {
    LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
    LABEL_REQUIRED: "mdc-floating-label--required",
    LABEL_SHAKE: "mdc-floating-label--shake",
    ROOT: "mdc-floating-label"
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFloatingLabelFoundation = function(_super) {
    __extends(MDCFloatingLabelFoundation2, _super);
    function MDCFloatingLabelFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
      _this.shakeAnimationEndHandler_ = function() {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          getWidth: function() {
            return 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFloatingLabelFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler_);
    };
    MDCFloatingLabelFoundation2.prototype.getWidth = function() {
      return this.adapter.getWidth();
    };
    MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      if (shouldShake) {
        this.adapter.addClass(LABEL_SHAKE);
      } else {
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
      var _a2 = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a2.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a2.LABEL_SHAKE;
      if (shouldFloat) {
        this.adapter.addClass(LABEL_FLOAT_ABOVE);
      } else {
        this.adapter.removeClass(LABEL_FLOAT_ABOVE);
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
      var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
      if (isRequired) {
        this.adapter.addClass(LABEL_REQUIRED);
      } else {
        this.adapter.removeClass(LABEL_REQUIRED);
      }
    };
    MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd_ = function() {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      this.adapter.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$12 = {
    LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
    LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
  };
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCLineRippleFoundation = function(_super) {
    __extends(MDCLineRippleFoundation2, _super);
    function MDCLineRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.transitionEndHandler_ = function(evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$12;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          setStyle: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCLineRippleFoundation2.prototype.init = function() {
      this.adapter.registerEventHandler("transitionend", this.transitionEndHandler_);
    };
    MDCLineRippleFoundation2.prototype.destroy = function() {
      this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler_);
    };
    MDCLineRippleFoundation2.prototype.activate = function() {
      this.adapter.removeClass(cssClasses$12.LINE_RIPPLE_DEACTIVATING);
      this.adapter.addClass(cssClasses$12.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
      this.adapter.setStyle("transform-origin", xCoordinate + "px center");
    };
    MDCLineRippleFoundation2.prototype.deactivate = function() {
      this.adapter.addClass(cssClasses$12.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
      var isDeactivating = this.adapter.hasClass(cssClasses$12.LINE_RIPPLE_DEACTIVATING);
      if (evt.propertyName === "opacity") {
        if (isDeactivating) {
          this.adapter.removeClass(cssClasses$12.LINE_RIPPLE_ACTIVE);
          this.adapter.removeClass(cssClasses$12.LINE_RIPPLE_DEACTIVATING);
        }
      }
    };
    return MDCLineRippleFoundation2;
  }(MDCFoundation);
  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var strings3 = {
    NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
  };
  var numbers3 = {
    NOTCH_ELEMENT_PADDING: 8
  };
  var cssClasses3 = {
    NO_LABEL: "mdc-notched-outline--no-label",
    OUTLINE_NOTCHED: "mdc-notched-outline--notched",
    OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCNotchedOutlineFoundation = function(_super) {
    __extends(MDCNotchedOutlineFoundation2, _super);
    function MDCNotchedOutlineFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
      get: function() {
        return strings3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
      get: function() {
        return cssClasses3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
      get: function() {
        return numbers3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setNotchWidthProperty: function() {
            return void 0;
          },
          removeNotchWidthProperty: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      if (notchWidth > 0) {
        notchWidth += numbers3.NOTCH_ELEMENT_PADDING;
      }
      this.adapter.setNotchWidthProperty(notchWidth);
      this.adapter.addClass(OUTLINE_NOTCHED);
    };
    MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      this.adapter.removeClass(OUTLINE_NOTCHED);
      this.adapter.removeNotchWidthProperty();
    };
    return MDCNotchedOutlineFoundation2;
  }(MDCFoundation);
  var oldModifierRegex$2 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex$2 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder$2(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex$2);
      const newModifierMatch = eventType.match(newModifierRegex$2);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex$2);
        const newModifierMatch = eventType.match(newModifierRegex$2);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap$2(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function dispatch3(element2, eventType, detail = {}, eventInit = {bubbles: true}) {
    if (typeof Event !== "undefined" && element2) {
      const event = new Event(eventType, eventInit);
      event.detail = detail;
      const el = "getElement" in element2 ? element2.getElement() : element2;
      el.dispatchEvent(event);
      return event;
    }
  }
  function useActions$2(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file$24 = "node_modules/@smui/floating-label/FloatingLabel.svelte";
  function create_else_block(ctx) {
    let label;
    let label_class_value;
    let label_style_value;
    let label_for_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[22].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
    let label_levels = [
      {
        class: label_class_value = classMap$2({
          [ctx[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx[0],
          "mdc-floating-label--required": ctx[1],
          ...ctx[8]
        })
      },
      {
        style: label_style_value = Object.entries(ctx[9]).map(func_1).concat([ctx[4]]).join(" ")
      },
      {
        for: label_for_value = ctx[5] || (ctx[11] ? ctx[11].id : null)
      },
      ctx[12]
    ];
    let label_data = {};
    for (let i = 0; i < label_levels.length; i += 1) {
      label_data = assign(label_data, label_levels[i]);
    }
    const block = {
      c: function create2() {
        label = element("label");
        if (default_slot)
          default_slot.c();
        set_attributes(label, label_data);
        add_location(label, file$24, 19, 2, 494);
      },
      m: function mount(target, anchor) {
        insert_dev(target, label, anchor);
        if (default_slot) {
          default_slot.m(label, null);
        }
        ctx[24](label);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions$2.call(null, label, ctx[2])),
            action_destroyer(ctx[10].call(null, label))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2097152)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
          }
        }
        set_attributes(label, label_data = get_spread_update(label_levels, [
          (!current || dirty & 267 && label_class_value !== (label_class_value = classMap$2({
            [ctx2[3]]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": ctx2[0],
            "mdc-floating-label--required": ctx2[1],
            ...ctx2[8]
          }))) && {class: label_class_value},
          (!current || dirty & 528 && label_style_value !== (label_style_value = Object.entries(ctx2[9]).map(func_1).concat([ctx2[4]]).join(" "))) && {style: label_style_value},
          (!current || dirty & 32 && label_for_value !== (label_for_value = ctx2[5] || (ctx2[11] ? ctx2[11].id : null))) && {for: label_for_value},
          dirty & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 4)
          useActions_action.update.call(null, ctx2[2]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(label);
        if (default_slot)
          default_slot.d(detaching);
        ctx[24](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block.name,
      type: "else",
      source: "(19:0) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block$1(ctx) {
    let span;
    let span_class_value;
    let span_style_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[22].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
    let span_levels = [
      {
        class: span_class_value = classMap$2({
          [ctx[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx[0],
          "mdc-floating-label--required": ctx[1],
          ...ctx[8]
        })
      },
      {
        style: span_style_value = Object.entries(ctx[9]).map(func$2).concat([ctx[4]]).join(" ")
      },
      ctx[12]
    ];
    let span_data = {};
    for (let i = 0; i < span_levels.length; i += 1) {
      span_data = assign(span_data, span_levels[i]);
    }
    const block = {
      c: function create2() {
        span = element("span");
        if (default_slot)
          default_slot.c();
        set_attributes(span, span_data);
        add_location(span, file$24, 1, 2, 16);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        if (default_slot) {
          default_slot.m(span, null);
        }
        ctx[23](span);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions$2.call(null, span, ctx[2])),
            action_destroyer(ctx[10].call(null, span))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2097152)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[21], !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null), null);
          }
        }
        set_attributes(span, span_data = get_spread_update(span_levels, [
          (!current || dirty & 267 && span_class_value !== (span_class_value = classMap$2({
            [ctx2[3]]: true,
            "mdc-floating-label": true,
            "mdc-floating-label--float-above": ctx2[0],
            "mdc-floating-label--required": ctx2[1],
            ...ctx2[8]
          }))) && {class: span_class_value},
          (!current || dirty & 528 && span_style_value !== (span_style_value = Object.entries(ctx2[9]).map(func$2).concat([ctx2[4]]).join(" "))) && {style: span_style_value},
          dirty & 4096 && ctx2[12]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 4)
          useActions_action.update.call(null, ctx2[2]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        if (default_slot)
          default_slot.d(detaching);
        ctx[23](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block$1.name,
      type: "if",
      source: "(1:0) {#if wrapped}",
      ctx
    });
    return block;
  }
  function create_fragment$25(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block$1, create_else_block];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[6])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    const block = {
      c: function create2() {
        if_block.c();
        if_block_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if_blocks[current_block_type_index].d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$25.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$2 = ([name, value]) => `${name}: ${value};`;
  var func_1 = ([name, value]) => `${name}: ${value};`;
  function instance_1$22($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "for",
      "floatAbove",
      "required",
      "wrapped",
      "shake",
      "float",
      "setRequired",
      "getWidth",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("FloatingLabel", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder$2(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {for: forId = null} = $$props;
    let {floatAbove = false} = $$props;
    let {required = false} = $$props;
    let {wrapped = false} = $$props;
    let element2;
    let instance8;
    let internalClasses = {};
    let internalStyles = {};
    let inputProps = getContext("SMUI:generic:input:props") || {};
    let previousFloatAbove = floatAbove;
    let previousRequired = required;
    onMount(() => {
      $$invalidate(18, instance8 = new MDCFloatingLabelFoundation({
        addClass,
        removeClass,
        getWidth: () => {
          const el = getElement();
          const clone2 = el.cloneNode(true);
          el.parentNode.appendChild(clone2);
          clone2.classList.add("smui-floating-label--remove-transition");
          clone2.classList.add("smui-floating-label--force-size");
          clone2.classList.remove("mdc-floating-label--float-above");
          const scrollWidth = clone2.scrollWidth;
          el.parentNode.removeChild(clone2);
          return scrollWidth;
        },
        registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
      }));
      const accessor = {
        get element() {
          return getElement();
        },
        addStyle,
        removeStyle
      };
      dispatch3(element2, "SMUI:floating-label:mount", accessor);
      instance8.init();
      return () => {
        dispatch3(element2, "SMUI:floating-label:unmount", accessor);
        instance8.destroy();
      };
    });
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(8, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(8, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name, value) {
      if (internalStyles[name] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name];
          $$invalidate(9, internalStyles);
        } else {
          $$invalidate(9, internalStyles[name] = value, internalStyles);
        }
      }
    }
    function removeStyle(name) {
      if (name in internalStyles) {
        delete internalStyles[name];
        $$invalidate(9, internalStyles);
      }
    }
    function shake(shouldShake) {
      instance8.shake(shouldShake);
    }
    function float(shouldFloat) {
      $$invalidate(0, floatAbove = shouldFloat);
    }
    function setRequired(isRequired) {
      $$invalidate(1, required = isRequired);
    }
    function getWidth() {
      return instance8.getWidth();
    }
    function getElement() {
      return element2;
    }
    function span_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    function label_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(7, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(2, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(3, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(4, style = $$new_props.style);
      if ("for" in $$new_props)
        $$invalidate(5, forId = $$new_props.for);
      if ("floatAbove" in $$new_props)
        $$invalidate(0, floatAbove = $$new_props.floatAbove);
      if ("required" in $$new_props)
        $$invalidate(1, required = $$new_props.required);
      if ("wrapped" in $$new_props)
        $$invalidate(6, wrapped = $$new_props.wrapped);
      if ("$$scope" in $$new_props)
        $$invalidate(21, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCFloatingLabelFoundation,
      onMount,
      getContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder$2,
      classMap: classMap$2,
      useActions: useActions$2,
      dispatch: dispatch3,
      forwardEvents,
      use: use2,
      className,
      style,
      forId,
      floatAbove,
      required,
      wrapped,
      element: element2,
      instance: instance8,
      internalClasses,
      internalStyles,
      inputProps,
      previousFloatAbove,
      previousRequired,
      addClass,
      removeClass,
      addStyle,
      removeStyle,
      shake,
      float,
      setRequired,
      getWidth,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(2, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(3, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(4, style = $$new_props.style);
      if ("forId" in $$props)
        $$invalidate(5, forId = $$new_props.forId);
      if ("floatAbove" in $$props)
        $$invalidate(0, floatAbove = $$new_props.floatAbove);
      if ("required" in $$props)
        $$invalidate(1, required = $$new_props.required);
      if ("wrapped" in $$props)
        $$invalidate(6, wrapped = $$new_props.wrapped);
      if ("element" in $$props)
        $$invalidate(7, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(18, instance8 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(8, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(9, internalStyles = $$new_props.internalStyles);
      if ("inputProps" in $$props)
        $$invalidate(11, inputProps = $$new_props.inputProps);
      if ("previousFloatAbove" in $$props)
        $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
      if ("previousRequired" in $$props)
        $$invalidate(20, previousRequired = $$new_props.previousRequired);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 786433) {
        if (previousFloatAbove !== floatAbove) {
          $$invalidate(19, previousFloatAbove = floatAbove);
          instance8.float(floatAbove);
        }
      }
      if ($$self.$$.dirty & 1310722) {
        if (previousRequired !== required) {
          $$invalidate(20, previousRequired = required);
          instance8.setRequired(required);
        }
      }
    };
    return [
      floatAbove,
      required,
      use2,
      className,
      style,
      forId,
      wrapped,
      element2,
      internalClasses,
      internalStyles,
      forwardEvents,
      inputProps,
      $$restProps,
      shake,
      float,
      setRequired,
      getWidth,
      getElement,
      instance8,
      previousFloatAbove,
      previousRequired,
      $$scope,
      slots,
      span_binding,
      label_binding
    ];
  }
  var FloatingLabel = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$22, create_fragment$25, safe_not_equal, {
        use: 2,
        class: 3,
        style: 4,
        for: 5,
        floatAbove: 0,
        required: 1,
        wrapped: 6,
        shake: 13,
        float: 14,
        setRequired: 15,
        getWidth: 16,
        getElement: 17
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "FloatingLabel",
        options,
        id: create_fragment$25.name
      });
    }
    get use() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get for() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set for(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get floatAbove() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set floatAbove(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get required() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set required(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get wrapped() {
      throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set wrapped(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get shake() {
      return this.$$.ctx[13];
    }
    set shake(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get float() {
      return this.$$.ctx[14];
    }
    set float(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setRequired() {
      return this.$$.ctx[15];
    }
    set setRequired(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getWidth() {
      return this.$$.ctx[16];
    }
    set getWidth(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[17];
    }
    set getElement(value) {
      throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var oldModifierRegex$12 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex$12 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder$12(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex$12);
      const newModifierMatch = eventType.match(newModifierRegex$12);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex$12);
        const newModifierMatch = eventType.match(newModifierRegex$12);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap$12(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function useActions$1(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file$15 = "node_modules/@smui/line-ripple/LineRipple.svelte";
  function create_fragment$15(ctx) {
    let div;
    let div_class_value;
    let div_style_value;
    let useActions_action;
    let mounted;
    let dispose;
    let div_levels = [
      {
        class: div_class_value = classMap$12({
          [ctx[1]]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": ctx[3],
          ...ctx[5]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[6]).map(func$12).concat([ctx[2]]).join(" ")
      },
      ctx[8]
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        set_attributes(div, div_data);
        add_location(div, file$15, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        ctx[13](div);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions$1.call(null, div, ctx[0])),
            action_destroyer(ctx[7].call(null, div))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(div, div_data = get_spread_update(div_levels, [
          dirty & 42 && div_class_value !== (div_class_value = classMap$12({
            [ctx2[1]]: true,
            "mdc-line-ripple": true,
            "mdc-line-ripple--active": ctx2[3],
            ...ctx2[5]
          })) && {class: div_class_value},
          dirty & 68 && div_style_value !== (div_style_value = Object.entries(ctx2[6]).map(func$12).concat([ctx2[2]]).join(" ")) && {style: div_style_value},
          dirty & 256 && ctx2[8]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        ctx[13](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$15.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func$12 = ([name, value]) => `${name}: ${value};`;
  function instance_1$12($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "active",
      "activate",
      "deactivate",
      "setRippleCenter",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("LineRipple", slots, []);
    const forwardEvents = forwardEventsBuilder$12(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {active: active2 = false} = $$props;
    let element2;
    let instance8;
    let internalClasses = {};
    let internalStyles = {};
    onMount(() => {
      instance8 = new MDCLineRippleFoundation({
        addClass,
        removeClass,
        hasClass,
        setStyle: addStyle,
        registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
      });
      instance8.init();
      return () => {
        instance8.destroy();
      };
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(5, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(5, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name, value) {
      if (internalStyles[name] != value) {
        if (value === "" || value == null) {
          delete internalStyles[name];
          $$invalidate(6, internalStyles);
        } else {
          $$invalidate(6, internalStyles[name] = value, internalStyles);
        }
      }
    }
    function activate() {
      instance8.activate();
    }
    function deactivate() {
      instance8.deactivate();
    }
    function setRippleCenter(xCoordinate) {
      instance8.setRippleCenter(xCoordinate);
    }
    function getElement() {
      return element2;
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(4, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(2, style = $$new_props.style);
      if ("active" in $$new_props)
        $$invalidate(3, active2 = $$new_props.active);
    };
    $$self.$capture_state = () => ({
      MDCLineRippleFoundation,
      onMount,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder$12,
      classMap: classMap$12,
      useActions: useActions$1,
      forwardEvents,
      use: use2,
      className,
      style,
      active: active2,
      element: element2,
      instance: instance8,
      internalClasses,
      internalStyles,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      activate,
      deactivate,
      setRippleCenter,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(2, style = $$new_props.style);
      if ("active" in $$props)
        $$invalidate(3, active2 = $$new_props.active);
      if ("element" in $$props)
        $$invalidate(4, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance8 = $$new_props.instance;
      if ("internalClasses" in $$props)
        $$invalidate(5, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(6, internalStyles = $$new_props.internalStyles);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      style,
      active2,
      element2,
      internalClasses,
      internalStyles,
      forwardEvents,
      $$restProps,
      activate,
      deactivate,
      setRippleCenter,
      getElement,
      div_binding
    ];
  }
  var LineRipple = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_1$12, create_fragment$15, safe_not_equal, {
        use: 0,
        class: 1,
        style: 2,
        active: 3,
        activate: 9,
        deactivate: 10,
        setRippleCenter: 11,
        getElement: 12
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "LineRipple",
        options,
        id: create_fragment$15.name
      });
    }
    get use() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get active() {
      throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set active(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get activate() {
      return this.$$.ctx[9];
    }
    set activate(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get deactivate() {
      return this.$$.ctx[10];
    }
    set deactivate(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get setRippleCenter() {
      return this.$$.ctx[11];
    }
    set setRippleCenter(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[12];
    }
    set getElement(value) {
      throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var oldModifierRegex6 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex6 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder6(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex6);
      const newModifierMatch = eventType.match(newModifierRegex6);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex6);
        const newModifierMatch = eventType.match(newModifierRegex6);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap6(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function useActions5(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file5 = "node_modules/@smui/notched-outline/NotchedOutline.svelte";
  function create_if_block3(ctx) {
    let div;
    let div_style_value;
    let current;
    const default_slot_template = ctx[14].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        attr_dev(div, "class", "mdc-notched-outline__notch");
        attr_dev(div, "style", div_style_value = Object.entries(ctx[7]).map(func3).join(" "));
        add_location(div, file5, 17, 4, 500);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 8192)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null), null);
          }
        }
        if (!current || dirty & 128 && div_style_value !== (div_style_value = Object.entries(ctx2[7]).map(func3).join(" "))) {
          attr_dev(div, "style", div_style_value);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block3.name,
      type: "if",
      source: "(17:2) {#if !noLabel}",
      ctx
    });
    return block;
  }
  function create_fragment6(ctx) {
    let div2;
    let div0;
    let t0;
    let t1;
    let div1;
    let div2_class_value;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    let if_block = !ctx[3] && create_if_block3(ctx);
    let div2_levels = [
      {
        class: div2_class_value = classMap6({
          [ctx[1]]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": ctx[2],
          "mdc-notched-outline--no-label": ctx[3],
          ...ctx[6]
        })
      },
      ctx[9]
    ];
    let div2_data = {};
    for (let i = 0; i < div2_levels.length; i += 1) {
      div2_data = assign(div2_data, div2_levels[i]);
    }
    const block = {
      c: function create2() {
        div2 = element("div");
        div0 = element("div");
        t0 = space();
        if (if_block)
          if_block.c();
        t1 = space();
        div1 = element("div");
        attr_dev(div0, "class", "mdc-notched-outline__leading");
        add_location(div0, file5, 15, 2, 434);
        attr_dev(div1, "class", "mdc-notched-outline__trailing");
        add_location(div1, file5, 26, 2, 703);
        set_attributes(div2, div2_data);
        add_location(div2, file5, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        append_dev(div2, t0);
        if (if_block)
          if_block.m(div2, null);
        append_dev(div2, t1);
        append_dev(div2, div1);
        ctx[15](div2);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions5.call(null, div2, ctx[0])),
            action_destroyer(ctx[8].call(null, div2)),
            listen_dev(div2, "SMUI:floating-label:mount", ctx[16], false, false, false),
            listen_dev(div2, "SMUI:floating-label:unmount", ctx[17], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (!ctx2[3]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & 8) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block3(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div2, t1);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        set_attributes(div2, div2_data = get_spread_update(div2_levels, [
          (!current || dirty & 78 && div2_class_value !== (div2_class_value = classMap6({
            [ctx2[1]]: true,
            "mdc-notched-outline": true,
            "mdc-notched-outline--notched": ctx2[2],
            "mdc-notched-outline--no-label": ctx2[3],
            ...ctx2[6]
          }))) && {class: div2_class_value},
          dirty & 512 && ctx2[9]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div2);
        if (if_block)
          if_block.d();
        ctx[15](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment6.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func3 = ([name, value]) => `${name}: ${value};`;
  function instance_12($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("NotchedOutline", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder6(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {notched = false} = $$props;
    let {noLabel = false} = $$props;
    let element2;
    let instance8;
    let floatingLabel;
    let internalClasses = {};
    let notchStyles = {};
    onMount(() => {
      instance8 = new MDCNotchedOutlineFoundation({
        addClass,
        removeClass,
        setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
        removeNotchWidthProperty: () => removeNotchStyle("width")
      });
      instance8.init();
      return () => {
        instance8.destroy();
      };
    });
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(6, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(6, internalClasses[className2] = false, internalClasses);
      }
    }
    function addNotchStyle(name, value) {
      if (notchStyles[name] != value) {
        if (value === "" || value == null) {
          delete notchStyles[name];
          $$invalidate(7, notchStyles);
        } else {
          $$invalidate(7, notchStyles[name] = value, notchStyles);
        }
      }
    }
    function removeNotchStyle(name) {
      if (name in notchStyles) {
        delete notchStyles[name];
        $$invalidate(7, notchStyles);
      }
    }
    function notch(notchWidth) {
      instance8.notch(notchWidth);
    }
    function closeNotch() {
      instance8.closeNotch();
    }
    function getElement() {
      return element2;
    }
    function div2_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    const SMUI_floating_label_mount_handler = (event) => $$invalidate(4, floatingLabel = event.detail);
    const SMUI_floating_label_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("notched" in $$new_props)
        $$invalidate(2, notched = $$new_props.notched);
      if ("noLabel" in $$new_props)
        $$invalidate(3, noLabel = $$new_props.noLabel);
      if ("$$scope" in $$new_props)
        $$invalidate(13, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCNotchedOutlineFoundation,
      onMount,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder6,
      classMap: classMap6,
      useActions: useActions5,
      forwardEvents,
      use: use2,
      className,
      notched,
      noLabel,
      element: element2,
      instance: instance8,
      floatingLabel,
      internalClasses,
      notchStyles,
      addClass,
      removeClass,
      addNotchStyle,
      removeNotchStyle,
      notch,
      closeNotch,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("notched" in $$props)
        $$invalidate(2, notched = $$new_props.notched);
      if ("noLabel" in $$props)
        $$invalidate(3, noLabel = $$new_props.noLabel);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance8 = $$new_props.instance;
      if ("floatingLabel" in $$props)
        $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
      if ("internalClasses" in $$props)
        $$invalidate(6, internalClasses = $$new_props.internalClasses);
      if ("notchStyles" in $$props)
        $$invalidate(7, notchStyles = $$new_props.notchStyles);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 16) {
        if (floatingLabel) {
          floatingLabel.addStyle("transition-duration", "0s");
          addClass("mdc-notched-outline--upgraded");
          requestAnimationFrame(() => {
            floatingLabel.removeStyle("transition-duration");
          });
        } else {
          removeClass("mdc-notched-outline--upgraded");
        }
      }
    };
    return [
      use2,
      className,
      notched,
      noLabel,
      floatingLabel,
      element2,
      internalClasses,
      notchStyles,
      forwardEvents,
      $$restProps,
      notch,
      closeNotch,
      getElement,
      $$scope,
      slots,
      div2_binding,
      SMUI_floating_label_mount_handler,
      SMUI_floating_label_unmount_handler
    ];
  }
  var NotchedOutline = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_12, create_fragment6, safe_not_equal, {
        use: 0,
        class: 1,
        notched: 2,
        noLabel: 3,
        notch: 10,
        closeNotch: 11,
        getElement: 12
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "NotchedOutline",
        options,
        id: create_fragment6.name
      });
    }
    get use() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notched() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set notched(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noLabel() {
      throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noLabel(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notch() {
      return this.$$.ctx[10];
    }
    set notch(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get closeNotch() {
      return this.$$.ctx[11];
    }
    set closeNotch(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[12];
    }
    set getElement(value) {
      throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/Textfield.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  var file$42 = "node_modules/@smui/common/I.svelte";
  function create_fragment$72(ctx) {
    let i;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let i_levels = [ctx[3]];
    let i_data = {};
    for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
      i_data = assign(i_data, i_levels[i2]);
    }
    const block = {
      c: function create2() {
        i = element("i");
        if (default_slot)
          default_slot.c();
        set_attributes(i, i_data);
        add_location(i, file$42, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, i, anchor);
        if (default_slot) {
          default_slot.m(i, null);
        }
        ctx[7](i);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, i, ctx[0])),
            action_destroyer(ctx[2].call(null, i))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_attributes(i, i_data = get_spread_update(i_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(i);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$72.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$6($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("I", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function i_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      i_binding
    ];
  }
  var I = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$6, create_fragment$72, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "I",
        options,
        id: create_fragment$72.name
      });
    }
    get use() {
      throw new Error("<I>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$32 = "node_modules/@smui/common/Svg.svelte";
  function create_fragment$62(ctx) {
    let svg;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[6].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
    let svg_levels = [ctx[3]];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    const block = {
      c: function create2() {
        svg = svg_element("svg");
        if (default_slot)
          default_slot.c();
        set_svg_attributes(svg, svg_data);
        add_location(svg, file$32, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, svg, anchor);
        if (default_slot) {
          default_slot.m(svg, null);
        }
        ctx[7](svg);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions.call(null, svg, ctx[0])),
            action_destroyer(ctx[2].call(null, svg))
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 32)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
          }
        }
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & 8 && ctx2[3]]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(svg);
        if (default_slot)
          default_slot.d(detaching);
        ctx[7](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$62.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$52($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Svg", slots, ["default"]);
    let {use: use2 = []} = $$props;
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let element2 = null;
    function getElement() {
      return element2;
    }
    function svg_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(1, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("$$scope" in $$new_props)
        $$invalidate(5, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      get_current_component,
      forwardEventsBuilder,
      useActions,
      use: use2,
      forwardEvents,
      element: element2,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("element" in $$props)
        $$invalidate(1, element2 = $$new_props.element);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      element2,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      svg_binding
    ];
  }
  var Svg = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$52, create_fragment$62, safe_not_equal, {use: 0, getElement: 4});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Svg",
        options,
        id: create_fragment$62.name
      });
    }
    get use() {
      throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[4];
    }
    set getElement(value) {
      throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  function create_default_slot$22(ctx) {
    let current;
    const default_slot_template = ctx[9].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 2048)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$22.name,
      type: "slot",
      source: `(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden=\\"true\\"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>`,
      ctx
    });
    return block;
  }
  function create_fragment$52(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[5], ...ctx[0]]
      },
      {
        class: classMap({
          [ctx[1]]: true,
          "mdc-button__icon": ctx[6] === "button",
          "mdc-fab__icon": ctx[6] === "fab",
          "mdc-icon-button__icon": ctx[6] === "icon-button",
          "mdc-icon-button__icon--on": ctx[6] === "icon-button" && ctx[2],
          "mdc-tab__icon": ctx[6] === "tab",
          "mdc-banner__icon": ctx[6] === "banner",
          "mdc-segmented-button__icon": ctx[6] === "segmented-button"
        })
      },
      {"aria-hidden": "true"},
      ctx[3] === Svg ? {focusable: "false", tabindex: "-1"} : {},
      ctx[7]
    ];
    var switch_value = ctx[3];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$22]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[10](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 239 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 33 && {
            use: [ctx2[5], ...ctx2[0]]
          },
          dirty & 70 && {
            class: classMap({
              [ctx2[1]]: true,
              "mdc-button__icon": ctx2[6] === "button",
              "mdc-fab__icon": ctx2[6] === "fab",
              "mdc-icon-button__icon": ctx2[6] === "icon-button",
              "mdc-icon-button__icon--on": ctx2[6] === "icon-button" && ctx2[2],
              "mdc-tab__icon": ctx2[6] === "tab",
              "mdc-banner__icon": ctx2[6] === "banner",
              "mdc-segmented-button__icon": ctx2[6] === "segmented-button"
            })
          },
          switch_instance_spread_levels[2],
          dirty & 8 && get_spread_object(ctx2[3] === Svg ? {focusable: "false", tabindex: "-1"} : {}),
          dirty & 128 && get_spread_object(ctx2[7])
        ]) : {};
        if (dirty & 2048) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[3])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[10](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[10](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$52.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$42($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "on", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("CommonIcon", slots, ["default"]);
    const forwardEvents = forwardEventsBuilder(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {on = false} = $$props;
    let element2;
    let {component = I} = $$props;
    const context = getContext("SMUI:icon:context");
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(4, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("on" in $$new_props)
        $$invalidate(2, on = $$new_props.on);
      if ("component" in $$new_props)
        $$invalidate(3, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(11, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      getContext,
      get_current_component,
      forwardEventsBuilder,
      classMap,
      I,
      Svg,
      forwardEvents,
      use: use2,
      className,
      on,
      element: element2,
      component,
      context,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("on" in $$props)
        $$invalidate(2, on = $$new_props.on);
      if ("element" in $$props)
        $$invalidate(4, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(3, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      on,
      component,
      element2,
      forwardEvents,
      context,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var CommonIcon = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$42, create_fragment$52, safe_not_equal, {
        use: 0,
        class: 1,
        on: 2,
        component: 3,
        getElement: 8
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "CommonIcon",
        options,
        id: create_fragment$52.name
      });
    }
    get use() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get on() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set on(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[8];
    }
    set getElement(value) {
      throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var strings4 = {
    ARIA_CONTROLS: "aria-controls",
    ARIA_DESCRIBEDBY: "aria-describedby",
    INPUT_SELECTOR: ".mdc-text-field__input",
    LABEL_SELECTOR: ".mdc-floating-label",
    LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
    LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
    OUTLINE_SELECTOR: ".mdc-notched-outline",
    PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
    SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
    TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
  };
  var cssClasses4 = {
    DISABLED: "mdc-text-field--disabled",
    FOCUSED: "mdc-text-field--focused",
    HELPER_LINE: "mdc-text-field-helper-line",
    INVALID: "mdc-text-field--invalid",
    LABEL_FLOATING: "mdc-text-field--label-floating",
    NO_LABEL: "mdc-text-field--no-label",
    OUTLINED: "mdc-text-field--outlined",
    ROOT: "mdc-text-field",
    TEXTAREA: "mdc-text-field--textarea",
    WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
    WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon"
  };
  var numbers4 = {
    LABEL_SCALE: 0.75
  };
  var VALIDATION_ATTR_WHITELIST = [
    "pattern",
    "min",
    "max",
    "required",
    "step",
    "minlength",
    "maxlength"
  ];
  var ALWAYS_FLOAT_TYPES = [
    "color",
    "date",
    "datetime-local",
    "month",
    "range",
    "time",
    "week"
  ];
  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var POINTERDOWN_EVENTS = ["mousedown", "touchstart"];
  var INTERACTION_EVENTS = ["click", "keydown"];
  var MDCTextFieldFoundation = function(_super) {
    __extends(MDCTextFieldFoundation2, _super);
    function MDCTextFieldFoundation2(adapter, foundationMap) {
      if (foundationMap === void 0) {
        foundationMap = {};
      }
      var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation2.defaultAdapter), adapter)) || this;
      _this.isFocused_ = false;
      _this.receivedUserInput_ = false;
      _this.isValid_ = true;
      _this.useNativeValidation_ = true;
      _this.validateOnValueChange_ = true;
      _this.helperText_ = foundationMap.helperText;
      _this.characterCounter_ = foundationMap.characterCounter;
      _this.leadingIcon_ = foundationMap.leadingIcon;
      _this.trailingIcon_ = foundationMap.trailingIcon;
      _this.inputFocusHandler_ = function() {
        return _this.activateFocus();
      };
      _this.inputBlurHandler_ = function() {
        return _this.deactivateFocus();
      };
      _this.inputInputHandler_ = function() {
        return _this.handleInput();
      };
      _this.setPointerXOffset_ = function(evt) {
        return _this.setTransformOrigin(evt);
      };
      _this.textFieldInteractionHandler_ = function() {
        return _this.handleTextFieldInteraction();
      };
      _this.validationAttributeChangeHandler_ = function(attributesList) {
        return _this.handleValidationAttributeChange(attributesList);
      };
      return _this;
    }
    Object.defineProperty(MDCTextFieldFoundation2, "cssClasses", {
      get: function() {
        return cssClasses4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "strings", {
      get: function() {
        return strings4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "numbers", {
      get: function() {
        return numbers4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldAlwaysFloat_", {
      get: function() {
        var type = this.getNativeInput_().type;
        return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldFloat", {
      get: function() {
        return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldShake", {
      get: function() {
        return !this.isFocused_ && !this.isValid() && !!this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return true;
          },
          setInputAttr: function() {
            return void 0;
          },
          removeInputAttr: function() {
            return void 0;
          },
          registerTextFieldInteractionHandler: function() {
            return void 0;
          },
          deregisterTextFieldInteractionHandler: function() {
            return void 0;
          },
          registerInputInteractionHandler: function() {
            return void 0;
          },
          deregisterInputInteractionHandler: function() {
            return void 0;
          },
          registerValidationAttributeChangeHandler: function() {
            return new MutationObserver(function() {
              return void 0;
            });
          },
          deregisterValidationAttributeChangeHandler: function() {
            return void 0;
          },
          getNativeInput: function() {
            return null;
          },
          isFocused: function() {
            return false;
          },
          activateLineRipple: function() {
            return void 0;
          },
          deactivateLineRipple: function() {
            return void 0;
          },
          setLineRippleTransformOrigin: function() {
            return void 0;
          },
          shakeLabel: function() {
            return void 0;
          },
          floatLabel: function() {
            return void 0;
          },
          setLabelRequired: function() {
            return void 0;
          },
          hasLabel: function() {
            return false;
          },
          getLabelWidth: function() {
            return 0;
          },
          hasOutline: function() {
            return false;
          },
          notchOutline: function() {
            return void 0;
          },
          closeOutline: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTextFieldFoundation2.prototype.init = function() {
      var _this = this;
      if (this.adapter.hasLabel() && this.getNativeInput_().required) {
        this.adapter.setLabelRequired(true);
      }
      if (this.adapter.isFocused()) {
        this.inputFocusHandler_();
      } else if (this.adapter.hasLabel() && this.shouldFloat) {
        this.notchOutline(true);
        this.adapter.floatLabel(true);
        this.styleFloating_(true);
      }
      this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler_);
      this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler_);
      this.adapter.registerInputInteractionHandler("input", this.inputInputHandler_);
      POINTERDOWN_EVENTS.forEach(function(evtType) {
        _this.adapter.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
      });
      INTERACTION_EVENTS.forEach(function(evtType) {
        _this.adapter.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
      });
      this.validationObserver_ = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation2.prototype.destroy = function() {
      var _this = this;
      this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler_);
      this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler_);
      this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler_);
      POINTERDOWN_EVENTS.forEach(function(evtType) {
        _this.adapter.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
      });
      INTERACTION_EVENTS.forEach(function(evtType) {
        _this.adapter.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
      });
      this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver_);
    };
    MDCTextFieldFoundation2.prototype.handleTextFieldInteraction = function() {
      var nativeInput = this.adapter.getNativeInput();
      if (nativeInput && nativeInput.disabled) {
        return;
      }
      this.receivedUserInput_ = true;
    };
    MDCTextFieldFoundation2.prototype.handleValidationAttributeChange = function(attributesList) {
      var _this = this;
      attributesList.some(function(attributeName) {
        if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
          _this.styleValidity_(true);
          _this.adapter.setLabelRequired(_this.getNativeInput_().required);
          return true;
        }
        return false;
      });
      if (attributesList.indexOf("maxlength") > -1) {
        this.setCharacterCounter_(this.getValue().length);
      }
    };
    MDCTextFieldFoundation2.prototype.notchOutline = function(openNotch) {
      if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
        return;
      }
      if (openNotch) {
        var labelWidth = this.adapter.getLabelWidth() * numbers4.LABEL_SCALE;
        this.adapter.notchOutline(labelWidth);
      } else {
        this.adapter.closeOutline();
      }
    };
    MDCTextFieldFoundation2.prototype.activateFocus = function() {
      this.isFocused_ = true;
      this.styleFocused_(this.isFocused_);
      this.adapter.activateLineRipple();
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        this.adapter.shakeLabel(this.shouldShake);
      }
      if (this.helperText_ && (this.helperText_.isPersistent() || !this.helperText_.isValidation() || !this.isValid_)) {
        this.helperText_.showToScreenReader();
      }
    };
    MDCTextFieldFoundation2.prototype.setTransformOrigin = function(evt) {
      if (this.isDisabled() || this.adapter.hasOutline()) {
        return;
      }
      var touches = evt.touches;
      var targetEvent = touches ? touches[0] : evt;
      var targetClientRect = targetEvent.target.getBoundingClientRect();
      var normalizedX = targetEvent.clientX - targetClientRect.left;
      this.adapter.setLineRippleTransformOrigin(normalizedX);
    };
    MDCTextFieldFoundation2.prototype.handleInput = function() {
      this.autoCompleteFocus();
      this.setCharacterCounter_(this.getValue().length);
    };
    MDCTextFieldFoundation2.prototype.autoCompleteFocus = function() {
      if (!this.receivedUserInput_) {
        this.activateFocus();
      }
    };
    MDCTextFieldFoundation2.prototype.deactivateFocus = function() {
      this.isFocused_ = false;
      this.adapter.deactivateLineRipple();
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      this.styleFocused_(this.isFocused_);
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        this.adapter.shakeLabel(this.shouldShake);
      }
      if (!this.shouldFloat) {
        this.receivedUserInput_ = false;
      }
    };
    MDCTextFieldFoundation2.prototype.getValue = function() {
      return this.getNativeInput_().value;
    };
    MDCTextFieldFoundation2.prototype.setValue = function(value) {
      if (this.getValue() !== value) {
        this.getNativeInput_().value = value;
      }
      this.setCharacterCounter_(value.length);
      if (this.validateOnValueChange_) {
        var isValid = this.isValid();
        this.styleValidity_(isValid);
      }
      if (this.adapter.hasLabel()) {
        this.notchOutline(this.shouldFloat);
        this.adapter.floatLabel(this.shouldFloat);
        this.styleFloating_(this.shouldFloat);
        if (this.validateOnValueChange_) {
          this.adapter.shakeLabel(this.shouldShake);
        }
      }
    };
    MDCTextFieldFoundation2.prototype.isValid = function() {
      return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
    };
    MDCTextFieldFoundation2.prototype.setValid = function(isValid) {
      this.isValid_ = isValid;
      this.styleValidity_(isValid);
      var shouldShake = !isValid && !this.isFocused_ && !!this.getValue();
      if (this.adapter.hasLabel()) {
        this.adapter.shakeLabel(shouldShake);
      }
    };
    MDCTextFieldFoundation2.prototype.setValidateOnValueChange = function(shouldValidate) {
      this.validateOnValueChange_ = shouldValidate;
    };
    MDCTextFieldFoundation2.prototype.getValidateOnValueChange = function() {
      return this.validateOnValueChange_;
    };
    MDCTextFieldFoundation2.prototype.setUseNativeValidation = function(useNativeValidation) {
      this.useNativeValidation_ = useNativeValidation;
    };
    MDCTextFieldFoundation2.prototype.isDisabled = function() {
      return this.getNativeInput_().disabled;
    };
    MDCTextFieldFoundation2.prototype.setDisabled = function(disabled) {
      this.getNativeInput_().disabled = disabled;
      this.styleDisabled_(disabled);
    };
    MDCTextFieldFoundation2.prototype.setHelperTextContent = function(content) {
      if (this.helperText_) {
        this.helperText_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
      if (this.leadingIcon_) {
        this.leadingIcon_.setAriaLabel(label);
      }
    };
    MDCTextFieldFoundation2.prototype.setLeadingIconContent = function(content) {
      if (this.leadingIcon_) {
        this.leadingIcon_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setTrailingIconAriaLabel = function(label) {
      if (this.trailingIcon_) {
        this.trailingIcon_.setAriaLabel(label);
      }
    };
    MDCTextFieldFoundation2.prototype.setTrailingIconContent = function(content) {
      if (this.trailingIcon_) {
        this.trailingIcon_.setContent(content);
      }
    };
    MDCTextFieldFoundation2.prototype.setCharacterCounter_ = function(currentLength) {
      if (!this.characterCounter_) {
        return;
      }
      var maxLength = this.getNativeInput_().maxLength;
      if (maxLength === -1) {
        throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
      }
      this.characterCounter_.setCounterValue(currentLength, maxLength);
    };
    MDCTextFieldFoundation2.prototype.isBadInput_ = function() {
      return this.getNativeInput_().validity.badInput || false;
    };
    MDCTextFieldFoundation2.prototype.isNativeInputValid_ = function() {
      return this.getNativeInput_().validity.valid;
    };
    MDCTextFieldFoundation2.prototype.styleValidity_ = function(isValid) {
      var INVALID = MDCTextFieldFoundation2.cssClasses.INVALID;
      if (isValid) {
        this.adapter.removeClass(INVALID);
      } else {
        this.adapter.addClass(INVALID);
      }
      if (this.helperText_) {
        this.helperText_.setValidity(isValid);
        var helperTextValidation = this.helperText_.isValidation();
        if (!helperTextValidation) {
          return;
        }
        var helperTextVisible = this.helperText_.isVisible();
        var helperTextId = this.helperText_.getId();
        if (helperTextVisible && helperTextId) {
          this.adapter.setInputAttr(strings4.ARIA_DESCRIBEDBY, helperTextId);
        } else {
          this.adapter.removeInputAttr(strings4.ARIA_DESCRIBEDBY);
        }
      }
    };
    MDCTextFieldFoundation2.prototype.styleFocused_ = function(isFocused) {
      var FOCUSED = MDCTextFieldFoundation2.cssClasses.FOCUSED;
      if (isFocused) {
        this.adapter.addClass(FOCUSED);
      } else {
        this.adapter.removeClass(FOCUSED);
      }
    };
    MDCTextFieldFoundation2.prototype.styleDisabled_ = function(isDisabled) {
      var _a2 = MDCTextFieldFoundation2.cssClasses, DISABLED = _a2.DISABLED, INVALID = _a2.INVALID;
      if (isDisabled) {
        this.adapter.addClass(DISABLED);
        this.adapter.removeClass(INVALID);
      } else {
        this.adapter.removeClass(DISABLED);
      }
      if (this.leadingIcon_) {
        this.leadingIcon_.setDisabled(isDisabled);
      }
      if (this.trailingIcon_) {
        this.trailingIcon_.setDisabled(isDisabled);
      }
    };
    MDCTextFieldFoundation2.prototype.styleFloating_ = function(isFloating) {
      var LABEL_FLOATING = MDCTextFieldFoundation2.cssClasses.LABEL_FLOATING;
      if (isFloating) {
        this.adapter.addClass(LABEL_FLOATING);
      } else {
        this.adapter.removeClass(LABEL_FLOATING);
      }
    };
    MDCTextFieldFoundation2.prototype.getNativeInput_ = function() {
      var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
      return nativeInput || {
        disabled: false,
        maxLength: -1,
        required: false,
        type: "input",
        validity: {
          badInput: false,
          valid: true
        },
        value: ""
      };
    };
    return MDCTextFieldFoundation2;
  }(MDCFoundation);
  var oldModifierRegex7 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex7 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder7(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex7);
      const newModifierMatch = eventType.match(newModifierRegex7);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex7);
        const newModifierMatch = eventType.match(newModifierRegex7);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap7(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function create_default_slot$13(ctx) {
    let current;
    const default_slot_template = ctx[10].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot$13.name,
      type: "slot",
      source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
      ctx
    });
    return block;
  }
  function create_fragment$42(ctx) {
    let switch_instance;
    let switch_instance_anchor;
    let current;
    const switch_instance_spread_levels = [
      {
        use: [ctx[7], ...ctx[0]]
      },
      {
        class: classMap7({
          [ctx[1]]: true,
          [ctx[5]]: true,
          ...ctx[4]
        })
      },
      ctx[6],
      ctx[8]
    ];
    var switch_value = ctx[2];
    function switch_props(ctx2) {
      let switch_instance_props = {
        $$slots: {default: [create_default_slot$13]},
        $$scope: {ctx: ctx2}
      };
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
      return {
        props: switch_instance_props,
        $$inline: true
      };
    }
    if (switch_value) {
      switch_instance = new switch_value(switch_props(ctx));
      ctx[11](switch_instance);
    }
    const block = {
      c: function create2() {
        if (switch_instance)
          create_component(switch_instance.$$.fragment);
        switch_instance_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (switch_instance) {
          mount_component(switch_instance, target, anchor);
        }
        insert_dev(target, switch_instance_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        const switch_instance_changes = dirty & 499 ? get_spread_update(switch_instance_spread_levels, [
          dirty & 129 && {
            use: [ctx2[7], ...ctx2[0]]
          },
          dirty & 50 && {
            class: classMap7({
              [ctx2[1]]: true,
              [ctx2[5]]: true,
              ...ctx2[4]
            })
          },
          dirty & 64 && get_spread_object(ctx2[6]),
          dirty & 256 && get_spread_object(ctx2[8])
        ]) : {};
        if (dirty & 4096) {
          switch_instance_changes.$$scope = {dirty, ctx: ctx2};
        }
        if (switch_value !== (switch_value = ctx2[2])) {
          if (switch_instance) {
            group_outros();
            const old_component = switch_instance;
            transition_out(old_component.$$.fragment, 1, 0, () => {
              destroy_component(old_component, 1);
            });
            check_outros();
          }
          if (switch_value) {
            switch_instance = new switch_value(switch_props(ctx2));
            ctx2[11](switch_instance);
            create_component(switch_instance.$$.fragment);
            transition_in(switch_instance.$$.fragment, 1);
            mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
          } else {
            switch_instance = null;
          }
        } else if (switch_value) {
          switch_instance.$set(switch_instance_changes);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        if (switch_instance)
          transition_in(switch_instance.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        if (switch_instance)
          transition_out(switch_instance.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[11](null);
        if (detaching)
          detach_dev(switch_instance_anchor);
        if (switch_instance)
          destroy_component(switch_instance, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$42.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var internals5 = {
    component: null,
    class: "",
    classMap: {},
    contexts: {},
    props: {}
  };
  function instance$34($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "component", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ClassAdder", slots, ["default"]);
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let element2;
    const smuiClass = internals5.class;
    const smuiClassMap = {};
    const smuiClassUnsubscribes = [];
    const contexts = internals5.contexts;
    const props = internals5.props;
    let {component = internals5.component} = $$props;
    Object.entries(internals5.classMap).forEach(([name, context]) => {
      const store = getContext(context);
      if (store && "subscribe" in store) {
        smuiClassUnsubscribes.push(store.subscribe((value) => {
          $$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
        }));
      }
    });
    const forwardEvents = forwardEventsBuilder7(get_current_component());
    for (let context in contexts) {
      if (contexts.hasOwnProperty(context)) {
        setContext(context, contexts[context]);
      }
    }
    onDestroy(() => {
      for (const unsubscribe of smuiClassUnsubscribes) {
        unsubscribe();
      }
    });
    function getElement() {
      return element2.getElement();
    }
    function switch_instance_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(3, element2);
      });
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("component" in $$new_props)
        $$invalidate(2, component = $$new_props.component);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      internals: internals5,
      onDestroy,
      getContext,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder7,
      classMap: classMap7,
      use: use2,
      className,
      element: element2,
      smuiClass,
      smuiClassMap,
      smuiClassUnsubscribes,
      contexts,
      props,
      component,
      forwardEvents,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("element" in $$props)
        $$invalidate(3, element2 = $$new_props.element);
      if ("component" in $$props)
        $$invalidate(2, component = $$new_props.component);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      component,
      element2,
      smuiClassMap,
      smuiClass,
      props,
      forwardEvents,
      $$restProps,
      getElement,
      slots,
      switch_instance_binding,
      $$scope
    ];
  }
  var ClassAdder5 = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$34, create_fragment$42, safe_not_equal, {
        use: 0,
        class: 1,
        component: 2,
        getElement: 9
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ClassAdder",
        options,
        id: create_fragment$42.name
      });
    }
    get use() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get component() {
      throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set component(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[9];
    }
    set getElement(value) {
      throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var defaults5 = {...internals5};
  function classAdderBuilder5(props) {
    function Component(...args) {
      Object.assign(internals5, defaults5, props);
      return new ClassAdder5(...args);
    }
    Component.prototype = ClassAdder5;
    if (ClassAdder5.$$render) {
      Component.$$render = (...args) => Object.assign(internals5, defaults5, props) && ClassAdder5.$$render(...args);
    }
    if (ClassAdder5.render) {
      Component.render = (...args) => Object.assign(internals5, defaults5, props) && ClassAdder5.render(...args);
    }
    return Component;
  }
  function exclude(obj, keys) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      const cashIndex = name.indexOf("$");
      if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
        continue;
      }
      if (keys.indexOf(name) !== -1) {
        continue;
      }
      newObj[name] = obj[name];
    }
    return newObj;
  }
  function prefixFilter(obj, prefix) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      if (name.substring(0, prefix.length) === prefix) {
        newObj[name.substring(prefix.length)] = obj[name];
      }
    }
    return newObj;
  }
  function useActions6(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  function create_fragment$34(ctx) {
    let current;
    const default_slot_template = ctx[4].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
    const block = {
      c: function create2() {
        if (default_slot)
          default_slot.c();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (default_slot) {
          default_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 8)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (default_slot)
          default_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$34.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$25($$self, $$props, $$invalidate) {
    let $storeValue;
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("ContextFragment", slots, ["default"]);
    let {key} = $$props;
    let {value} = $$props;
    const storeValue = writable(value);
    validate_store(storeValue, "storeValue");
    component_subscribe($$self, storeValue, (value2) => $$invalidate(5, $storeValue = value2));
    setContext(key, storeValue);
    onDestroy(() => {
      storeValue.set(void 0);
    });
    const writable_props = ["key", "value"];
    Object.keys($$props).forEach((key2) => {
      if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
        console.warn(`<ContextFragment> was created with unknown prop '${key2}'`);
    });
    $$self.$$set = ($$props2) => {
      if ("key" in $$props2)
        $$invalidate(1, key = $$props2.key);
      if ("value" in $$props2)
        $$invalidate(2, value = $$props2.value);
      if ("$$scope" in $$props2)
        $$invalidate(3, $$scope = $$props2.$$scope);
    };
    $$self.$capture_state = () => ({
      onDestroy,
      setContext,
      writable,
      key,
      value,
      storeValue,
      $storeValue
    });
    $$self.$inject_state = ($$props2) => {
      if ("key" in $$props2)
        $$invalidate(1, key = $$props2.key);
      if ("value" in $$props2)
        $$invalidate(2, value = $$props2.value);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 4) {
        set_store_value(storeValue, $storeValue = value, $storeValue);
      }
    };
    return [storeValue, key, value, $$scope, slots];
  }
  var ContextFragment = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$25, create_fragment$34, safe_not_equal, {key: 1, value: 2});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "ContextFragment",
        options,
        id: create_fragment$34.name
      });
      const {ctx} = this.$$;
      const props = options.props || {};
      if (ctx[1] === void 0 && !("key" in props)) {
        console.warn("<ContextFragment> was created without expected prop 'key'");
      }
      if (ctx[2] === void 0 && !("value" in props)) {
        console.warn("<ContextFragment> was created without expected prop 'value'");
      }
    }
    get key() {
      throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set key(value) {
      throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var HelperLine = classAdderBuilder5({
    class: "mdc-text-field-helper-line",
    component: Div
  });
  var Prefix = classAdderBuilder5({
    class: "mdc-text-field__affix mdc-text-field__affix--prefix",
    component: Span
  });
  var Suffix = classAdderBuilder5({
    class: "mdc-text-field__affix mdc-text-field__affix--suffix",
    component: Span
  });
  var file$25 = "node_modules/@smui/textfield/Input.svelte";
  function create_fragment$26(ctx) {
    let input;
    let input_class_value;
    let useActions_action;
    let mounted;
    let dispose;
    let input_levels = [
      {
        class: input_class_value = classMap7({
          [ctx[1]]: true,
          "mdc-text-field__input": true
        })
      },
      {type: ctx[2]},
      {placeholder: ctx[3]},
      ctx[4],
      ctx[6],
      ctx[10]
    ];
    let input_data = {};
    for (let i = 0; i < input_levels.length; i += 1) {
      input_data = assign(input_data, input_levels[i]);
    }
    const block = {
      c: function create2() {
        input = element("input");
        set_attributes(input, input_data);
        add_location(input, file$25, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, input, anchor);
        if (input.autofocus)
          input.focus();
        ctx[21](input);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions6.call(null, input, ctx[0])),
            action_destroyer(ctx[7].call(null, input)),
            listen_dev(input, "change", ctx[22], false, false, false),
            listen_dev(input, "input", ctx[23], false, false, false),
            listen_dev(input, "change", ctx[9], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(input, input_data = get_spread_update(input_levels, [
          dirty & 2 && input_class_value !== (input_class_value = classMap7({
            [ctx2[1]]: true,
            "mdc-text-field__input": true
          })) && {class: input_class_value},
          dirty & 4 && {type: ctx2[2]},
          dirty & 8 && {placeholder: ctx2[3]},
          dirty & 16 && ctx2[4],
          dirty & 64 && ctx2[6],
          dirty & 1024 && ctx2[10]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 1)
          useActions_action.update.call(null, ctx2[0]);
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(input);
        ctx[21](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$26.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function toNumber(value) {
    if (value === "") {
      const nan = new Number(Number.NaN);
      nan.length = 0;
      return nan;
    }
    return +value;
  }
  function instance$15($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "type",
      "placeholder",
      "value",
      "files",
      "dirty",
      "invalid",
      "updateInvalid",
      "getAttr",
      "addAttr",
      "removeAttr",
      "focus",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Input", slots, []);
    const forwardEvents = forwardEventsBuilder7(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {type = "text"} = $$props;
    let {placeholder = " "} = $$props;
    let {value = ""} = $$props;
    let {files = void 0} = $$props;
    let {dirty = false} = $$props;
    let {invalid = false} = $$props;
    let {updateInvalid = true} = $$props;
    let element2;
    let internalAttrs = {};
    let valueProp = {};
    onMount(() => {
      if (updateInvalid) {
        $$invalidate(14, invalid = element2.matches(":invalid"));
      }
    });
    function valueUpdater(e) {
      switch (type) {
        case "number":
        case "range":
          $$invalidate(11, value = toNumber(e.target.value));
          break;
        case "file":
          $$invalidate(12, files = e.target.files);
        default:
          $$invalidate(11, value = e.target.value);
          break;
      }
    }
    function changeHandler(e) {
      $$invalidate(13, dirty = true);
      if (updateInvalid) {
        $$invalidate(14, invalid = element2.matches(":invalid"));
      }
    }
    function getAttr(name) {
      return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
    }
    function addAttr(name, value2) {
      if (internalAttrs[name] !== value2) {
        $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
      }
    }
    function removeAttr(name) {
      if (!(name in internalAttrs) || internalAttrs[name] != null) {
        $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
      }
    }
    function focus() {
      getElement().focus();
    }
    function getElement() {
      return element2;
    }
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    const change_handler = (e) => (type === "file" || type === "range") && valueUpdater(e);
    const input_handler = (e) => type !== "file" && valueUpdater(e);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("type" in $$new_props)
        $$invalidate(2, type = $$new_props.type);
      if ("placeholder" in $$new_props)
        $$invalidate(3, placeholder = $$new_props.placeholder);
      if ("value" in $$new_props)
        $$invalidate(11, value = $$new_props.value);
      if ("files" in $$new_props)
        $$invalidate(12, files = $$new_props.files);
      if ("dirty" in $$new_props)
        $$invalidate(13, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(14, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$new_props)
        $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    };
    $$self.$capture_state = () => ({
      onMount,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder7,
      classMap: classMap7,
      useActions: useActions6,
      forwardEvents,
      use: use2,
      className,
      type,
      placeholder,
      value,
      files,
      dirty,
      invalid,
      updateInvalid,
      element: element2,
      internalAttrs,
      valueProp,
      toNumber,
      valueUpdater,
      changeHandler,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("type" in $$props)
        $$invalidate(2, type = $$new_props.type);
      if ("placeholder" in $$props)
        $$invalidate(3, placeholder = $$new_props.placeholder);
      if ("value" in $$props)
        $$invalidate(11, value = $$new_props.value);
      if ("files" in $$props)
        $$invalidate(12, files = $$new_props.files);
      if ("dirty" in $$props)
        $$invalidate(13, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(14, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$props)
        $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("internalAttrs" in $$props)
        $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
      if ("valueProp" in $$props)
        $$invalidate(4, valueProp = $$new_props.valueProp);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 2068) {
        if (type === "file") {
          delete valueProp.value;
          $$invalidate(4, valueProp), $$invalidate(2, type), $$invalidate(11, value);
        } else {
          $$invalidate(4, valueProp.value = value == null ? "" : value, valueProp);
        }
      }
    };
    return [
      use2,
      className,
      type,
      placeholder,
      valueProp,
      element2,
      internalAttrs,
      forwardEvents,
      valueUpdater,
      changeHandler,
      $$restProps,
      value,
      files,
      dirty,
      invalid,
      updateInvalid,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement,
      input_binding,
      change_handler,
      input_handler
    ];
  }
  var Input = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$15, create_fragment$26, safe_not_equal, {
        use: 0,
        class: 1,
        type: 2,
        placeholder: 3,
        value: 11,
        files: 12,
        dirty: 13,
        invalid: 14,
        updateInvalid: 15,
        getAttr: 16,
        addAttr: 17,
        removeAttr: 18,
        focus: 19,
        getElement: 20
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Input",
        options,
        id: create_fragment$26.name
      });
    }
    get use() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get type() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set type(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get placeholder() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set placeholder(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get files() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set files(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getAttr() {
      return this.$$.ctx[16];
    }
    set getAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get addAttr() {
      return this.$$.ctx[17];
    }
    set addAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get removeAttr() {
      return this.$$.ctx[18];
    }
    set removeAttr(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[19];
    }
    set focus(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[20];
    }
    set getElement(value) {
      throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file$16 = "node_modules/@smui/textfield/Textarea.svelte";
  function create_fragment$16(ctx) {
    let textarea;
    let textarea_class_value;
    let textarea_style_value;
    let useActions_action;
    let mounted;
    let dispose;
    let textarea_levels = [
      {
        class: textarea_class_value = classMap7({
          [ctx[2]]: true,
          "mdc-text-field__input": true
        })
      },
      {
        style: textarea_style_value = `${ctx[4] ? "" : "resize: none; "}${ctx[3]}`
      },
      ctx[6],
      ctx[9]
    ];
    let textarea_data = {};
    for (let i = 0; i < textarea_levels.length; i += 1) {
      textarea_data = assign(textarea_data, textarea_levels[i]);
    }
    const block = {
      c: function create2() {
        textarea = element("textarea");
        set_attributes(textarea, textarea_data);
        add_location(textarea, file$16, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, textarea, anchor);
        if (textarea.autofocus)
          textarea.focus();
        ctx[18](textarea);
        set_input_value(textarea, ctx[0]);
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions6.call(null, textarea, ctx[1])),
            action_destroyer(ctx[7].call(null, textarea)),
            listen_dev(textarea, "change", ctx[8], false, false, false),
            listen_dev(textarea, "input", ctx[19])
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
          dirty & 4 && textarea_class_value !== (textarea_class_value = classMap7({
            [ctx2[2]]: true,
            "mdc-text-field__input": true
          })) && {class: textarea_class_value},
          dirty & 24 && textarea_style_value !== (textarea_style_value = `${ctx2[4] ? "" : "resize: none; "}${ctx2[3]}`) && {style: textarea_style_value},
          dirty & 64 && ctx2[6],
          dirty & 512 && ctx2[9]
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 2)
          useActions_action.update.call(null, ctx2[1]);
        if (dirty & 1) {
          set_input_value(textarea, ctx2[0]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(textarea);
        ctx[18](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$16.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance6($$self, $$props, $$invalidate) {
    const omit_props_names = [
      "use",
      "class",
      "style",
      "value",
      "dirty",
      "invalid",
      "updateInvalid",
      "resizable",
      "getAttr",
      "addAttr",
      "removeAttr",
      "focus",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Textarea", slots, []);
    const forwardEvents = forwardEventsBuilder7(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {value = ""} = $$props;
    let {dirty = false} = $$props;
    let {invalid = false} = $$props;
    let {updateInvalid = true} = $$props;
    let {resizable = true} = $$props;
    let element2;
    let internalAttrs = {};
    onMount(() => {
      if (updateInvalid) {
        $$invalidate(11, invalid = element2.matches(":invalid"));
      }
    });
    function changeHandler() {
      $$invalidate(10, dirty = true);
      if (updateInvalid) {
        $$invalidate(11, invalid = element2.matches(":invalid"));
      }
    }
    function getAttr(name) {
      return name in internalAttrs ? internalAttrs[name] : getElement().getAttribute(name);
    }
    function addAttr(name, value2) {
      if (internalAttrs[name] !== value2) {
        $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
      }
    }
    function removeAttr(name) {
      if (!(name in internalAttrs) || internalAttrs[name] != null) {
        $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
      }
    }
    function focus() {
      getElement().focus();
    }
    function getElement() {
      return element2;
    }
    function textarea_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(5, element2);
      });
    }
    function textarea_input_handler() {
      value = this.value;
      $$invalidate(0, value);
    }
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(2, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(3, style = $$new_props.style);
      if ("value" in $$new_props)
        $$invalidate(0, value = $$new_props.value);
      if ("dirty" in $$new_props)
        $$invalidate(10, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(11, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$new_props)
        $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
      if ("resizable" in $$new_props)
        $$invalidate(4, resizable = $$new_props.resizable);
    };
    $$self.$capture_state = () => ({
      onMount,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder7,
      classMap: classMap7,
      useActions: useActions6,
      forwardEvents,
      use: use2,
      className,
      style,
      value,
      dirty,
      invalid,
      updateInvalid,
      resizable,
      element: element2,
      internalAttrs,
      changeHandler,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(1, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(2, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(3, style = $$new_props.style);
      if ("value" in $$props)
        $$invalidate(0, value = $$new_props.value);
      if ("dirty" in $$props)
        $$invalidate(10, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(11, invalid = $$new_props.invalid);
      if ("updateInvalid" in $$props)
        $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
      if ("resizable" in $$props)
        $$invalidate(4, resizable = $$new_props.resizable);
      if ("element" in $$props)
        $$invalidate(5, element2 = $$new_props.element);
      if ("internalAttrs" in $$props)
        $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      value,
      use2,
      className,
      style,
      resizable,
      element2,
      internalAttrs,
      forwardEvents,
      changeHandler,
      $$restProps,
      dirty,
      invalid,
      updateInvalid,
      getAttr,
      addAttr,
      removeAttr,
      focus,
      getElement,
      textarea_binding,
      textarea_input_handler
    ];
  }
  var Textarea = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance6, create_fragment$16, safe_not_equal, {
        use: 1,
        class: 2,
        style: 3,
        value: 0,
        dirty: 10,
        invalid: 11,
        updateInvalid: 12,
        resizable: 4,
        getAttr: 13,
        addAttr: 14,
        removeAttr: 15,
        focus: 16,
        getElement: 17
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Textarea",
        options,
        id: create_fragment$16.name
      });
    }
    get use() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get resizable() {
      throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set resizable(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getAttr() {
      return this.$$.ctx[13];
    }
    set getAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get addAttr() {
      return this.$$.ctx[14];
    }
    set addAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get removeAttr() {
      return this.$$.ctx[15];
    }
    set removeAttr(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[16];
    }
    set focus(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[17];
    }
    set getElement(value) {
      throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };
  var file6 = "node_modules/@smui/textfield/Textfield.svelte";
  var get_helper_slot_changes = (dirty) => ({});
  var get_helper_slot_context = (ctx) => ({});
  var get_ripple_slot_changes = (dirty) => ({});
  var get_ripple_slot_context = (ctx) => ({});
  var get_trailingIcon_slot_changes_1 = (dirty) => ({});
  var get_trailingIcon_slot_context_1 = (ctx) => ({});
  var get_leadingIcon_slot_changes_1 = (dirty) => ({});
  var get_leadingIcon_slot_context_1 = (ctx) => ({});
  var get_label_slot_changes_2 = (dirty) => ({});
  var get_label_slot_context_2 = (ctx) => ({});
  var get_trailingIcon_slot_changes = (dirty) => ({});
  var get_trailingIcon_slot_context = (ctx) => ({});
  var get_suffix_slot_changes = (dirty) => ({});
  var get_suffix_slot_context = (ctx) => ({});
  var get_prefix_slot_changes = (dirty) => ({});
  var get_prefix_slot_context = (ctx) => ({});
  var get_internalCounter_slot_changes = (dirty) => ({});
  var get_internalCounter_slot_context = (ctx) => ({});
  var get_leadingIcon_slot_changes = (dirty) => ({});
  var get_leadingIcon_slot_context = (ctx) => ({});
  var get_label_slot_changes_1 = (dirty) => ({});
  var get_label_slot_context_1 = (ctx) => ({});
  var get_label_slot_changes = (dirty) => ({});
  var get_label_slot_context = (ctx) => ({});
  function create_else_block_1(ctx) {
    let div;
    let t0;
    let contextfragment0;
    let t1;
    let t2;
    let contextfragment1;
    let t3;
    let div_class_value;
    let div_style_value;
    let Ripple_action;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context_2);
    contextfragment0 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: true,
        $$slots: {default: [create_default_slot_9]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const default_slot_template = ctx[50].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[89], null);
    contextfragment1 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: false,
        $$slots: {default: [create_default_slot_8]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const ripple_slot_template = ctx[50].ripple;
    const ripple_slot = create_slot(ripple_slot_template, ctx, ctx[89], get_ripple_slot_context);
    let div_levels = [
      {
        class: div_class_value = classMap7({
          [ctx[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx[12],
          "mdc-text-field--textarea": ctx[14],
          "mdc-text-field--filled": ctx[15] === "filled",
          "mdc-text-field--outlined": ctx[15] === "outlined",
          "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
          "mdc-text-field--no-label": ctx[16] || !ctx[41].label,
          "mdc-text-field--with-leading-icon": ctx[41].leadingIcon,
          "mdc-text-field--with-trailing-icon": ctx[41].trailingIcon,
          "mdc-text-field--invalid": ctx[2] !== ctx[36] && ctx[2],
          ...ctx[26]
        })
      },
      {
        style: div_style_value = Object.entries(ctx[27]).map(func_12).concat([ctx[10]]).join(" ")
      },
      exclude(ctx[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (label_slot)
          label_slot.c();
        t0 = space();
        create_component(contextfragment0.$$.fragment);
        t1 = space();
        if (default_slot)
          default_slot.c();
        t2 = space();
        create_component(contextfragment1.$$.fragment);
        t3 = space();
        if (ripple_slot)
          ripple_slot.c();
        set_attributes(div, div_data);
        add_location(div, file6, 164, 2, 5265);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (label_slot) {
          label_slot.m(div, null);
        }
        append_dev(div, t0);
        mount_component(contextfragment0, div, null);
        append_dev(div, t1);
        if (default_slot) {
          default_slot.m(div, null);
        }
        append_dev(div, t2);
        mount_component(contextfragment1, div, null);
        append_dev(div, t3);
        if (ripple_slot) {
          ripple_slot.m(div, null);
        }
        ctx[79](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(Ripple_action = Ripple.call(null, div, {
              ripple: ctx[11],
              unbounded: false,
              addClass: ctx[38],
              removeClass: ctx[39],
              addStyle: ctx[40]
            })),
            action_destroyer(useActions_action = useActions6.call(null, div, ctx[8])),
            action_destroyer(ctx[35].call(null, div)),
            listen_dev(div, "SMUI:textfield:leading-icon:mount", ctx[80], false, false, false),
            listen_dev(div, "SMUI:textfield:leading-icon:unmount", ctx[81], false, false, false),
            listen_dev(div, "SMUI:textfield:trailing-icon:mount", ctx[82], false, false, false),
            listen_dev(div, "SMUI:textfield:trailing-icon:unmount", ctx[83], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes_2), get_label_slot_context_2);
          }
        }
        const contextfragment0_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment0_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment0.$set(contextfragment0_changes);
        if (default_slot) {
          if (default_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(default_slot_template, ctx2[89], dirty, null), null);
          }
        }
        const contextfragment1_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment1_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment1.$set(contextfragment1_changes);
        if (ripple_slot) {
          if (ripple_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(ripple_slot, ripple_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(ripple_slot_template, ctx2[89], dirty, get_ripple_slot_changes), get_ripple_slot_context);
          }
        }
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty[0] & 67228164 | dirty[1] & 1024 && div_class_value !== (div_class_value = classMap7({
            [ctx2[9]]: true,
            "mdc-text-field": true,
            "mdc-text-field--disabled": ctx2[12],
            "mdc-text-field--textarea": ctx2[14],
            "mdc-text-field--filled": ctx2[15] === "filled",
            "mdc-text-field--outlined": ctx2[15] === "outlined",
            "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
            "mdc-text-field--no-label": ctx2[16] || !ctx2[41].label,
            "mdc-text-field--with-leading-icon": ctx2[41].leadingIcon,
            "mdc-text-field--with-trailing-icon": ctx2[41].trailingIcon,
            "mdc-text-field--invalid": ctx2[2] !== ctx2[36] && ctx2[2],
            ...ctx2[26]
          }))) && {class: div_class_value},
          (!current || dirty[0] & 134218752 && div_style_value !== (div_style_value = Object.entries(ctx2[27]).map(func_12).concat([ctx2[10]]).join(" "))) && {style: div_style_value},
          dirty[1] & 2048 && exclude(ctx2[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
        ]));
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 2048)
          Ripple_action.update.call(null, {
            ripple: ctx2[11],
            unbounded: false,
            addClass: ctx2[38],
            removeClass: ctx2[39],
            addStyle: ctx2[40]
          });
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
          useActions_action.update.call(null, ctx2[8]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        transition_in(contextfragment0.$$.fragment, local);
        transition_in(default_slot, local);
        transition_in(contextfragment1.$$.fragment, local);
        transition_in(ripple_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        transition_out(contextfragment0.$$.fragment, local);
        transition_out(default_slot, local);
        transition_out(contextfragment1.$$.fragment, local);
        transition_out(ripple_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (label_slot)
          label_slot.d(detaching);
        destroy_component(contextfragment0);
        if (default_slot)
          default_slot.d(detaching);
        destroy_component(contextfragment1);
        if (ripple_slot)
          ripple_slot.d(detaching);
        ctx[79](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block_1.name,
      type: "else",
      source: "(164:0) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block_1(ctx) {
    let label_1;
    let t0;
    let t1;
    let contextfragment0;
    let t2;
    let t3;
    let current_block_type_index;
    let if_block2;
    let t4;
    let contextfragment1;
    let t5;
    let label_1_class_value;
    let label_1_style_value;
    let label_1_for_value;
    let Ripple_action;
    let useActions_action;
    let current;
    let mounted;
    let dispose;
    let if_block0 = !ctx[14] && ctx[15] !== "outlined" && create_if_block_8(ctx);
    let if_block1 = (ctx[14] || ctx[15] === "outlined") && create_if_block_6(ctx);
    contextfragment0 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: true,
        $$slots: {default: [create_default_slot_4]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const default_slot_template = ctx[50].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[89], null);
    const if_block_creators = [create_if_block_3, create_else_block2];
    const if_blocks = [];
    function select_block_type_1(ctx2, dirty) {
      if (ctx2[14])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type_1(ctx);
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    contextfragment1 = new ContextFragment({
      props: {
        key: "SMUI:textfield:icon:leading",
        value: false,
        $$slots: {default: [create_default_slot_1]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    let if_block3 = !ctx[14] && ctx[15] !== "outlined" && ctx[11] && create_if_block_2(ctx);
    let label_1_levels = [
      {
        class: label_1_class_value = classMap7({
          [ctx[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx[12],
          "mdc-text-field--textarea": ctx[14],
          "mdc-text-field--filled": ctx[15] === "filled",
          "mdc-text-field--outlined": ctx[15] === "outlined",
          "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
          "mdc-text-field--no-label": ctx[16] || ctx[17] == null && !ctx[41].label,
          "mdc-text-field--label-floating": ctx[29] || ctx[0] != null && ctx[0] !== "",
          "mdc-text-field--with-leading-icon": ctx[22] === ctx[36] ? ctx[41].leadingIcon : ctx[22],
          "mdc-text-field--with-trailing-icon": ctx[23] === ctx[36] ? ctx[41].trailingIcon : ctx[23],
          "mdc-text-field--with-internal-counter": ctx[14] && ctx[41].internalCounter,
          "mdc-text-field--invalid": ctx[2] !== ctx[36] && ctx[2],
          ...ctx[26]
        })
      },
      {
        style: label_1_style_value = Object.entries(ctx[27]).map(func4).concat([ctx[10]]).join(" ")
      },
      {
        for: label_1_for_value = null
      },
      exclude(ctx[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
    ];
    let label_1_data = {};
    for (let i = 0; i < label_1_levels.length; i += 1) {
      label_1_data = assign(label_1_data, label_1_levels[i]);
    }
    const block = {
      c: function create2() {
        label_1 = element("label");
        if (if_block0)
          if_block0.c();
        t0 = space();
        if (if_block1)
          if_block1.c();
        t1 = space();
        create_component(contextfragment0.$$.fragment);
        t2 = space();
        if (default_slot)
          default_slot.c();
        t3 = space();
        if_block2.c();
        t4 = space();
        create_component(contextfragment1.$$.fragment);
        t5 = space();
        if (if_block3)
          if_block3.c();
        set_attributes(label_1, label_1_data);
        add_location(label_1, file6, 1, 2, 15);
      },
      m: function mount(target, anchor) {
        insert_dev(target, label_1, anchor);
        if (if_block0)
          if_block0.m(label_1, null);
        append_dev(label_1, t0);
        if (if_block1)
          if_block1.m(label_1, null);
        append_dev(label_1, t1);
        mount_component(contextfragment0, label_1, null);
        append_dev(label_1, t2);
        if (default_slot) {
          default_slot.m(label_1, null);
        }
        append_dev(label_1, t3);
        if_blocks[current_block_type_index].m(label_1, null);
        append_dev(label_1, t4);
        mount_component(contextfragment1, label_1, null);
        append_dev(label_1, t5);
        if (if_block3)
          if_block3.m(label_1, null);
        ctx[72](label_1);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(Ripple_action = Ripple.call(null, label_1, {
              ripple: !ctx[14] && ctx[15] === "filled",
              unbounded: false,
              addClass: ctx[38],
              removeClass: ctx[39],
              addStyle: ctx[40],
              eventTarget: ctx[34],
              activeTarget: ctx[34],
              initPromise: ctx[37]
            })),
            action_destroyer(useActions_action = useActions6.call(null, label_1, ctx[8])),
            action_destroyer(ctx[35].call(null, label_1)),
            listen_dev(label_1, "SMUI:textfield:leading-icon:mount", ctx[73], false, false, false),
            listen_dev(label_1, "SMUI:textfield:leading-icon:unmount", ctx[74], false, false, false),
            listen_dev(label_1, "SMUI:textfield:trailing-icon:mount", ctx[75], false, false, false),
            listen_dev(label_1, "SMUI:textfield:trailing-icon:unmount", ctx[76], false, false, false),
            listen_dev(label_1, "SMUI:textfield:character-counter:mount", ctx[77], false, false, false),
            listen_dev(label_1, "SMUI:textfield:character-counter:unmount", ctx[78], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, dirty) {
        if (!ctx2[14] && ctx2[15] !== "outlined") {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty[0] & 49152) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_8(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(label_1, t0);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (ctx2[14] || ctx2[15] === "outlined") {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 49152) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_6(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(label_1, t1);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        const contextfragment0_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment0_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment0.$set(contextfragment0_changes);
        if (default_slot) {
          if (default_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(default_slot_template, ctx2[89], dirty, null), null);
          }
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_1(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(label_1, t4);
        }
        const contextfragment1_changes = {};
        if (dirty[2] & 134217728) {
          contextfragment1_changes.$$scope = {dirty, ctx: ctx2};
        }
        contextfragment1.$set(contextfragment1_changes);
        if (!ctx2[14] && ctx2[15] !== "outlined" && ctx2[11]) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty[0] & 51200) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_2(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(label_1, null);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
          (!current || dirty[0] & 616813061 | dirty[1] & 1024 && label_1_class_value !== (label_1_class_value = classMap7({
            [ctx2[9]]: true,
            "mdc-text-field": true,
            "mdc-text-field--disabled": ctx2[12],
            "mdc-text-field--textarea": ctx2[14],
            "mdc-text-field--filled": ctx2[15] === "filled",
            "mdc-text-field--outlined": ctx2[15] === "outlined",
            "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
            "mdc-text-field--no-label": ctx2[16] || ctx2[17] == null && !ctx2[41].label,
            "mdc-text-field--label-floating": ctx2[29] || ctx2[0] != null && ctx2[0] !== "",
            "mdc-text-field--with-leading-icon": ctx2[22] === ctx2[36] ? ctx2[41].leadingIcon : ctx2[22],
            "mdc-text-field--with-trailing-icon": ctx2[23] === ctx2[36] ? ctx2[41].trailingIcon : ctx2[23],
            "mdc-text-field--with-internal-counter": ctx2[14] && ctx2[41].internalCounter,
            "mdc-text-field--invalid": ctx2[2] !== ctx2[36] && ctx2[2],
            ...ctx2[26]
          }))) && {class: label_1_class_value},
          (!current || dirty[0] & 134218752 && label_1_style_value !== (label_1_style_value = Object.entries(ctx2[27]).map(func4).concat([ctx2[10]]).join(" "))) && {style: label_1_style_value},
          {for: label_1_for_value},
          dirty[1] & 2048 && exclude(ctx2[42], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
        ]));
        if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 49152 | dirty[1] & 8)
          Ripple_action.update.call(null, {
            ripple: !ctx2[14] && ctx2[15] === "filled",
            unbounded: false,
            addClass: ctx2[38],
            removeClass: ctx2[39],
            addStyle: ctx2[40],
            eventTarget: ctx2[34],
            activeTarget: ctx2[34],
            initPromise: ctx2[37]
          });
        if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
          useActions_action.update.call(null, ctx2[8]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(contextfragment0.$$.fragment, local);
        transition_in(default_slot, local);
        transition_in(if_block2);
        transition_in(contextfragment1.$$.fragment, local);
        transition_in(if_block3);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(contextfragment0.$$.fragment, local);
        transition_out(default_slot, local);
        transition_out(if_block2);
        transition_out(contextfragment1.$$.fragment, local);
        transition_out(if_block3);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(label_1);
        if (if_block0)
          if_block0.d();
        if (if_block1)
          if_block1.d();
        destroy_component(contextfragment0);
        if (default_slot)
          default_slot.d(detaching);
        if_blocks[current_block_type_index].d();
        destroy_component(contextfragment1);
        if (if_block3)
          if_block3.d();
        ctx[72](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_1.name,
      type: "if",
      source: "(1:0) {#if valued}",
      ctx
    });
    return block;
  }
  function create_default_slot_9(ctx) {
    let current;
    const leadingIcon_slot_template = ctx[50].leadingIcon;
    const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[89], get_leadingIcon_slot_context_1);
    const block = {
      c: function create2() {
        if (leadingIcon_slot)
          leadingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (leadingIcon_slot) {
          leadingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (leadingIcon_slot) {
          if (leadingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(leadingIcon_slot_template, ctx2[89], dirty, get_leadingIcon_slot_changes_1), get_leadingIcon_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(leadingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(leadingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (leadingIcon_slot)
          leadingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_9.name,
      type: "slot",
      source: '(209:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
      ctx
    });
    return block;
  }
  function create_default_slot_8(ctx) {
    let current;
    const trailingIcon_slot_template = ctx[50].trailingIcon;
    const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[89], get_trailingIcon_slot_context_1);
    const block = {
      c: function create2() {
        if (trailingIcon_slot)
          trailingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (trailingIcon_slot) {
          trailingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (trailingIcon_slot) {
          if (trailingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(trailingIcon_slot_template, ctx2[89], dirty, get_trailingIcon_slot_changes_1), get_trailingIcon_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(trailingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(trailingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (trailingIcon_slot)
          trailingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_8.name,
      type: "slot",
      source: '(213:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
      ctx
    });
    return block;
  }
  function create_if_block_8(ctx) {
    let t;
    let if_block1_anchor;
    let current;
    let if_block0 = ctx[15] === "filled" && create_if_block_10(ctx);
    let if_block1 = !ctx[16] && (ctx[17] != null || ctx[41].label) && create_if_block_9(ctx);
    const block = {
      c: function create2() {
        if (if_block0)
          if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (ctx2[15] === "filled") {
          if (if_block0)
            ;
          else {
            if_block0 = create_if_block_10(ctx2);
            if_block0.c();
            if_block0.m(t.parentNode, t);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        if (!ctx2[16] && (ctx2[17] != null || ctx2[41].label)) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 196608 | dirty[1] & 1024) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_9(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_8.name,
      type: "if",
      source: "(63:4) {#if !textarea && variant !== 'outlined'}",
      ctx
    });
    return block;
  }
  function create_if_block_10(ctx) {
    let span;
    const block = {
      c: function create2() {
        span = element("span");
        attr_dev(span, "class", "mdc-text-field__ripple");
        add_location(span, file6, 64, 8, 2304);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_10.name,
      type: "if",
      source: "(64:6) {#if variant === 'filled'}",
      ctx
    });
    return block;
  }
  function create_if_block_9(ctx) {
    let floatinglabel;
    let current;
    const floatinglabel_spread_levels = [
      {
        floatAbove: ctx[29] || ctx[0] != null && ctx[0] !== ""
      },
      {required: ctx[13]},
      {wrapped: true},
      prefixFilter(ctx[42], "label$")
    ];
    let floatinglabel_props = {
      $$slots: {default: [create_default_slot_7]},
      $$scope: {ctx}
    };
    for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
      floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    }
    floatinglabel = new FloatingLabel({
      props: floatinglabel_props,
      $$inline: true
    });
    ctx[51](floatinglabel);
    const block = {
      c: function create2() {
        create_component(floatinglabel.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(floatinglabel, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const floatinglabel_changes = dirty[0] & 536879105 | dirty[1] & 2048 ? get_spread_update(floatinglabel_spread_levels, [
          dirty[0] & 536870913 && {
            floatAbove: ctx2[29] || ctx2[0] != null && ctx2[0] !== ""
          },
          dirty[0] & 8192 && {required: ctx2[13]},
          floatinglabel_spread_levels[2],
          dirty[1] & 2048 && get_spread_object(prefixFilter(ctx2[42], "label$"))
        ]) : {};
        if (dirty[0] & 131072 | dirty[2] & 134217728) {
          floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
        }
        floatinglabel.$set(floatinglabel_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(floatinglabel.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(floatinglabel.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[51](null);
        destroy_component(floatinglabel, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_9.name,
      type: "if",
      source: "(67:6) {#if !noLabel && (label != null || $$slots.label)}",
      ctx
    });
    return block;
  }
  function create_default_slot_7(ctx) {
    let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
    let t;
    let current;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context);
    const block = {
      c: function create2() {
        t = text(t_value);
        if (label_slot)
          label_slot.c();
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        if (label_slot) {
          label_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
          set_data_dev(t, t_value);
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes), get_label_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (label_slot)
          label_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_7.name,
      type: "slot",
      source: "(68:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >",
      ctx
    });
    return block;
  }
  function create_if_block_6(ctx) {
    let notchedoutline;
    let current;
    const notchedoutline_spread_levels = [
      {
        noLabel: ctx[16] || ctx[17] == null && !ctx[41].label
      },
      prefixFilter(ctx[42], "outline$")
    ];
    let notchedoutline_props = {
      $$slots: {default: [create_default_slot_5]},
      $$scope: {ctx}
    };
    for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
      notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
    }
    notchedoutline = new NotchedOutline({
      props: notchedoutline_props,
      $$inline: true
    });
    ctx[53](notchedoutline);
    const block = {
      c: function create2() {
        create_component(notchedoutline.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(notchedoutline, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const notchedoutline_changes = dirty[0] & 196608 | dirty[1] & 3072 ? get_spread_update(notchedoutline_spread_levels, [
          dirty[0] & 196608 | dirty[1] & 1024 && {
            noLabel: ctx2[16] || ctx2[17] == null && !ctx2[41].label
          },
          dirty[1] & 2048 && get_spread_object(prefixFilter(ctx2[42], "outline$"))
        ]) : {};
        if (dirty[0] & 537075745 | dirty[1] & 3072 | dirty[2] & 134217728) {
          notchedoutline_changes.$$scope = {dirty, ctx: ctx2};
        }
        notchedoutline.$set(notchedoutline_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(notchedoutline.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(notchedoutline.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[53](null);
        destroy_component(notchedoutline, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_6.name,
      type: "if",
      source: "(78:4) {#if textarea || variant === 'outlined'}",
      ctx
    });
    return block;
  }
  function create_if_block_7(ctx) {
    let floatinglabel;
    let current;
    const floatinglabel_spread_levels = [
      {
        floatAbove: ctx[29] || ctx[0] != null && ctx[0] !== ""
      },
      {required: ctx[13]},
      {wrapped: true},
      prefixFilter(ctx[42], "label$")
    ];
    let floatinglabel_props = {
      $$slots: {default: [create_default_slot_6]},
      $$scope: {ctx}
    };
    for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
      floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
    }
    floatinglabel = new FloatingLabel({
      props: floatinglabel_props,
      $$inline: true
    });
    ctx[52](floatinglabel);
    const block = {
      c: function create2() {
        create_component(floatinglabel.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(floatinglabel, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const floatinglabel_changes = dirty[0] & 536879105 | dirty[1] & 2048 ? get_spread_update(floatinglabel_spread_levels, [
          dirty[0] & 536870913 && {
            floatAbove: ctx2[29] || ctx2[0] != null && ctx2[0] !== ""
          },
          dirty[0] & 8192 && {required: ctx2[13]},
          floatinglabel_spread_levels[2],
          dirty[1] & 2048 && get_spread_object(prefixFilter(ctx2[42], "label$"))
        ]) : {};
        if (dirty[0] & 131072 | dirty[2] & 134217728) {
          floatinglabel_changes.$$scope = {dirty, ctx: ctx2};
        }
        floatinglabel.$set(floatinglabel_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(floatinglabel.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(floatinglabel.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[52](null);
        destroy_component(floatinglabel, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_7.name,
      type: "if",
      source: "(84:8) {#if !noLabel && (label != null || $$slots.label)}",
      ctx
    });
    return block;
  }
  function create_default_slot_6(ctx) {
    let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
    let t;
    let current;
    const label_slot_template = ctx[50].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[89], get_label_slot_context_1);
    const block = {
      c: function create2() {
        t = text(t_value);
        if (label_slot)
          label_slot.c();
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
        if (label_slot) {
          label_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
          set_data_dev(t, t_value);
        if (label_slot) {
          if (label_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(label_slot_template, ctx2[89], dirty, get_label_slot_changes_1), get_label_slot_context_1);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
        if (label_slot)
          label_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_6.name,
      type: "slot",
      source: "(85:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >",
      ctx
    });
    return block;
  }
  function create_default_slot_5(ctx) {
    let if_block_anchor;
    let current;
    let if_block = !ctx[16] && (ctx[17] != null || ctx[41].label) && create_if_block_7(ctx);
    const block = {
      c: function create2() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (!ctx2[16] && (ctx2[17] != null || ctx2[41].label)) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty[0] & 196608 | dirty[1] & 1024) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_7(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach_dev(if_block_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_5.name,
      type: "slot",
      source: "(79:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
      ctx
    });
    return block;
  }
  function create_default_slot_4(ctx) {
    let current;
    const leadingIcon_slot_template = ctx[50].leadingIcon;
    const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[89], get_leadingIcon_slot_context);
    const block = {
      c: function create2() {
        if (leadingIcon_slot)
          leadingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (leadingIcon_slot) {
          leadingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (leadingIcon_slot) {
          if (leadingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(leadingIcon_slot, leadingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(leadingIcon_slot_template, ctx2[89], dirty, get_leadingIcon_slot_changes), get_leadingIcon_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(leadingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(leadingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (leadingIcon_slot)
          leadingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_4.name,
      type: "slot",
      source: '(96:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
      ctx
    });
    return block;
  }
  function create_else_block2(ctx) {
    let t0;
    let t1;
    let input_1;
    let updating_value;
    let updating_files;
    let updating_dirty;
    let updating_invalid;
    let t2;
    let t3;
    let current;
    const prefix_slot_template = ctx[50].prefix;
    const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[89], get_prefix_slot_context);
    let if_block0 = ctx[19] != null && create_if_block_5(ctx);
    const input_1_spread_levels = [
      {type: ctx[18]},
      {disabled: ctx[12]},
      {required: ctx[13]},
      {updateInvalid: ctx[21]},
      {"aria-controls": ctx[28]},
      {"aria-describedby": ctx[28]},
      ctx[16] && ctx[17] != null ? {placeholder: ctx[17]} : {},
      prefixFilter(ctx[42], "input$")
    ];
    function input_1_value_binding(value) {
      ctx[63](value);
    }
    function input_1_files_binding(value) {
      ctx[64](value);
    }
    function input_1_dirty_binding(value) {
      ctx[65](value);
    }
    function input_1_invalid_binding(value) {
      ctx[66](value);
    }
    let input_1_props = {};
    for (let i = 0; i < input_1_spread_levels.length; i += 1) {
      input_1_props = assign(input_1_props, input_1_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      input_1_props.value = ctx[0];
    }
    if (ctx[1] !== void 0) {
      input_1_props.files = ctx[1];
    }
    if (ctx[4] !== void 0) {
      input_1_props.dirty = ctx[4];
    }
    if (ctx[2] !== void 0) {
      input_1_props.invalid = ctx[2];
    }
    input_1 = new Input({props: input_1_props, $$inline: true});
    ctx[62](input_1);
    binding_callbacks.push(() => bind3(input_1, "value", input_1_value_binding));
    binding_callbacks.push(() => bind3(input_1, "files", input_1_files_binding));
    binding_callbacks.push(() => bind3(input_1, "dirty", input_1_dirty_binding));
    binding_callbacks.push(() => bind3(input_1, "invalid", input_1_invalid_binding));
    input_1.$on("blur", ctx[67]);
    input_1.$on("focus", ctx[68]);
    input_1.$on("blur", ctx[69]);
    input_1.$on("focus", ctx[70]);
    let if_block1 = ctx[20] != null && create_if_block_4(ctx);
    const suffix_slot_template = ctx[50].suffix;
    const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[89], get_suffix_slot_context);
    const block = {
      c: function create2() {
        if (prefix_slot)
          prefix_slot.c();
        t0 = space();
        if (if_block0)
          if_block0.c();
        t1 = space();
        create_component(input_1.$$.fragment);
        t2 = space();
        if (if_block1)
          if_block1.c();
        t3 = space();
        if (suffix_slot)
          suffix_slot.c();
      },
      m: function mount(target, anchor) {
        if (prefix_slot) {
          prefix_slot.m(target, anchor);
        }
        insert_dev(target, t0, anchor);
        if (if_block0)
          if_block0.m(target, anchor);
        insert_dev(target, t1, anchor);
        mount_component(input_1, target, anchor);
        insert_dev(target, t2, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, t3, anchor);
        if (suffix_slot) {
          suffix_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (prefix_slot) {
          if (prefix_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(prefix_slot, prefix_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(prefix_slot_template, ctx2[89], dirty, get_prefix_slot_changes), get_prefix_slot_context);
          }
        }
        if (ctx2[19] != null) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty[0] & 524288) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_5(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t1.parentNode, t1);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        const input_1_changes = dirty[0] & 271003648 | dirty[1] & 2048 ? get_spread_update(input_1_spread_levels, [
          dirty[0] & 262144 && {type: ctx2[18]},
          dirty[0] & 4096 && {disabled: ctx2[12]},
          dirty[0] & 8192 && {required: ctx2[13]},
          dirty[0] & 2097152 && {updateInvalid: ctx2[21]},
          dirty[0] & 268435456 && {"aria-controls": ctx2[28]},
          dirty[0] & 268435456 && {"aria-describedby": ctx2[28]},
          dirty[0] & 196608 && get_spread_object(ctx2[16] && ctx2[17] != null ? {placeholder: ctx2[17]} : {}),
          dirty[1] & 2048 && get_spread_object(prefixFilter(ctx2[42], "input$"))
        ]) : {};
        if (!updating_value && dirty[0] & 1) {
          updating_value = true;
          input_1_changes.value = ctx2[0];
          add_flush_callback(() => updating_value = false);
        }
        if (!updating_files && dirty[0] & 2) {
          updating_files = true;
          input_1_changes.files = ctx2[1];
          add_flush_callback(() => updating_files = false);
        }
        if (!updating_dirty && dirty[0] & 16) {
          updating_dirty = true;
          input_1_changes.dirty = ctx2[4];
          add_flush_callback(() => updating_dirty = false);
        }
        if (!updating_invalid && dirty[0] & 4) {
          updating_invalid = true;
          input_1_changes.invalid = ctx2[2];
          add_flush_callback(() => updating_invalid = false);
        }
        input_1.$set(input_1_changes);
        if (ctx2[20] != null) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[0] & 1048576) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_4(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(t3.parentNode, t3);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (suffix_slot) {
          if (suffix_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(suffix_slot, suffix_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(suffix_slot_template, ctx2[89], dirty, get_suffix_slot_changes), get_suffix_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(prefix_slot, local);
        transition_in(if_block0);
        transition_in(input_1.$$.fragment, local);
        transition_in(if_block1);
        transition_in(suffix_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(prefix_slot, local);
        transition_out(if_block0);
        transition_out(input_1.$$.fragment, local);
        transition_out(if_block1);
        transition_out(suffix_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (prefix_slot)
          prefix_slot.d(detaching);
        if (detaching)
          detach_dev(t0);
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach_dev(t1);
        ctx[62](null);
        destroy_component(input_1, detaching);
        if (detaching)
          detach_dev(t2);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(t3);
        if (suffix_slot)
          suffix_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_else_block2.name,
      type: "else",
      source: "(125:4) {:else}",
      ctx
    });
    return block;
  }
  function create_if_block_3(ctx) {
    let span;
    let textarea_1;
    let updating_value;
    let updating_dirty;
    let updating_invalid;
    let t;
    let span_class_value;
    let current;
    const textarea_1_spread_levels = [
      {disabled: ctx[12]},
      {required: ctx[13]},
      {updateInvalid: ctx[21]},
      {"aria-controls": ctx[28]},
      {"aria-describedby": ctx[28]},
      prefixFilter(ctx[42], "input$")
    ];
    function textarea_1_value_binding(value) {
      ctx[55](value);
    }
    function textarea_1_dirty_binding(value) {
      ctx[56](value);
    }
    function textarea_1_invalid_binding(value) {
      ctx[57](value);
    }
    let textarea_1_props = {};
    for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
      textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
    }
    if (ctx[0] !== void 0) {
      textarea_1_props.value = ctx[0];
    }
    if (ctx[4] !== void 0) {
      textarea_1_props.dirty = ctx[4];
    }
    if (ctx[2] !== void 0) {
      textarea_1_props.invalid = ctx[2];
    }
    textarea_1 = new Textarea({props: textarea_1_props, $$inline: true});
    ctx[54](textarea_1);
    binding_callbacks.push(() => bind3(textarea_1, "value", textarea_1_value_binding));
    binding_callbacks.push(() => bind3(textarea_1, "dirty", textarea_1_dirty_binding));
    binding_callbacks.push(() => bind3(textarea_1, "invalid", textarea_1_invalid_binding));
    textarea_1.$on("blur", ctx[58]);
    textarea_1.$on("focus", ctx[59]);
    textarea_1.$on("blur", ctx[60]);
    textarea_1.$on("focus", ctx[61]);
    const internalCounter_slot_template = ctx[50].internalCounter;
    const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, ctx[89], get_internalCounter_slot_context);
    const block = {
      c: function create2() {
        span = element("span");
        create_component(textarea_1.$$.fragment);
        t = space();
        if (internalCounter_slot)
          internalCounter_slot.c();
        attr_dev(span, "class", span_class_value = classMap7({
          "mdc-text-field__resizer": !("input$resizable" in ctx[42]) || ctx[42].input$resizable
        }));
        add_location(span, file6, 100, 6, 3548);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        mount_component(textarea_1, span, null);
        append_dev(span, t);
        if (internalCounter_slot) {
          internalCounter_slot.m(span, null);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const textarea_1_changes = dirty[0] & 270544896 | dirty[1] & 2048 ? get_spread_update(textarea_1_spread_levels, [
          dirty[0] & 4096 && {disabled: ctx2[12]},
          dirty[0] & 8192 && {required: ctx2[13]},
          dirty[0] & 2097152 && {updateInvalid: ctx2[21]},
          dirty[0] & 268435456 && {"aria-controls": ctx2[28]},
          dirty[0] & 268435456 && {"aria-describedby": ctx2[28]},
          dirty[1] & 2048 && get_spread_object(prefixFilter(ctx2[42], "input$"))
        ]) : {};
        if (!updating_value && dirty[0] & 1) {
          updating_value = true;
          textarea_1_changes.value = ctx2[0];
          add_flush_callback(() => updating_value = false);
        }
        if (!updating_dirty && dirty[0] & 16) {
          updating_dirty = true;
          textarea_1_changes.dirty = ctx2[4];
          add_flush_callback(() => updating_dirty = false);
        }
        if (!updating_invalid && dirty[0] & 4) {
          updating_invalid = true;
          textarea_1_changes.invalid = ctx2[2];
          add_flush_callback(() => updating_invalid = false);
        }
        textarea_1.$set(textarea_1_changes);
        if (internalCounter_slot) {
          if (internalCounter_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(internalCounter_slot, internalCounter_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(internalCounter_slot_template, ctx2[89], dirty, get_internalCounter_slot_changes), get_internalCounter_slot_context);
          }
        }
        if (!current || dirty[1] & 2048 && span_class_value !== (span_class_value = classMap7({
          "mdc-text-field__resizer": !("input$resizable" in ctx2[42]) || ctx2[42].input$resizable
        }))) {
          attr_dev(span, "class", span_class_value);
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(textarea_1.$$.fragment, local);
        transition_in(internalCounter_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(textarea_1.$$.fragment, local);
        transition_out(internalCounter_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(span);
        ctx[54](null);
        destroy_component(textarea_1);
        if (internalCounter_slot)
          internalCounter_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_3.name,
      type: "if",
      source: "(100:4) {#if textarea}",
      ctx
    });
    return block;
  }
  function create_if_block_5(ctx) {
    let prefix_1;
    let current;
    prefix_1 = new Prefix({
      props: {
        $$slots: {default: [create_default_slot_3]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(prefix_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(prefix_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const prefix_1_changes = {};
        if (dirty[0] & 524288 | dirty[2] & 134217728) {
          prefix_1_changes.$$scope = {dirty, ctx: ctx2};
        }
        prefix_1.$set(prefix_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(prefix_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(prefix_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(prefix_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_5.name,
      type: "if",
      source: "(127:6) {#if prefix != null}",
      ctx
    });
    return block;
  }
  function create_default_slot_3(ctx) {
    let t;
    const block = {
      c: function create2() {
        t = text(ctx[19]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 524288)
          set_data_dev(t, ctx2[19]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_3.name,
      type: "slot",
      source: "(128:8) <Prefix>",
      ctx
    });
    return block;
  }
  function create_if_block_4(ctx) {
    let suffix_1;
    let current;
    suffix_1 = new Suffix({
      props: {
        $$slots: {default: [create_default_slot_2]},
        $$scope: {ctx}
      },
      $$inline: true
    });
    const block = {
      c: function create2() {
        create_component(suffix_1.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(suffix_1, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const suffix_1_changes = {};
        if (dirty[0] & 1048576 | dirty[2] & 134217728) {
          suffix_1_changes.$$scope = {dirty, ctx: ctx2};
        }
        suffix_1.$set(suffix_1_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(suffix_1.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(suffix_1.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(suffix_1, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_4.name,
      type: "if",
      source: "(149:6) {#if suffix != null}",
      ctx
    });
    return block;
  }
  function create_default_slot_2(ctx) {
    let t;
    const block = {
      c: function create2() {
        t = text(ctx[20]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update2(ctx2, dirty) {
        if (dirty[0] & 1048576)
          set_data_dev(t, ctx2[20]);
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_2.name,
      type: "slot",
      source: "(150:8) <Suffix>",
      ctx
    });
    return block;
  }
  function create_default_slot_1(ctx) {
    let current;
    const trailingIcon_slot_template = ctx[50].trailingIcon;
    const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[89], get_trailingIcon_slot_context);
    const block = {
      c: function create2() {
        if (trailingIcon_slot)
          trailingIcon_slot.c();
      },
      m: function mount(target, anchor) {
        if (trailingIcon_slot) {
          trailingIcon_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (trailingIcon_slot) {
          if (trailingIcon_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(trailingIcon_slot, trailingIcon_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(trailingIcon_slot_template, ctx2[89], dirty, get_trailingIcon_slot_changes), get_trailingIcon_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(trailingIcon_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(trailingIcon_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (trailingIcon_slot)
          trailingIcon_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot_1.name,
      type: "slot",
      source: '(154:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
      ctx
    });
    return block;
  }
  function create_if_block_2(ctx) {
    let lineripple;
    let current;
    const lineripple_spread_levels = [prefixFilter(ctx[42], "ripple$")];
    let lineripple_props = {};
    for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
      lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
    }
    lineripple = new LineRipple({props: lineripple_props, $$inline: true});
    ctx[71](lineripple);
    const block = {
      c: function create2() {
        create_component(lineripple.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(lineripple, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const lineripple_changes = dirty[1] & 2048 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(ctx2[42], "ripple$"))]) : {};
        lineripple.$set(lineripple_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(lineripple.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(lineripple.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        ctx[71](null);
        destroy_component(lineripple, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block_2.name,
      type: "if",
      source: "(157:4) {#if !textarea && variant !== 'outlined' && ripple}",
      ctx
    });
    return block;
  }
  function create_if_block4(ctx) {
    let helperline;
    let current;
    const helperline_spread_levels = [prefixFilter(ctx[42], "helperLine$")];
    let helperline_props = {
      $$slots: {default: [create_default_slot6]},
      $$scope: {ctx}
    };
    for (let i = 0; i < helperline_spread_levels.length; i += 1) {
      helperline_props = assign(helperline_props, helperline_spread_levels[i]);
    }
    helperline = new HelperLine({props: helperline_props, $$inline: true});
    helperline.$on("SMUI:textfield:helper-text:id", ctx[84]);
    helperline.$on("SMUI:textfield:helper-text:mount", ctx[85]);
    helperline.$on("SMUI:textfield:helper-text:unmount", ctx[86]);
    helperline.$on("SMUI:textfield:character-counter:mount", ctx[87]);
    helperline.$on("SMUI:textfield:character-counter:unmount", ctx[88]);
    const block = {
      c: function create2() {
        create_component(helperline.$$.fragment);
      },
      m: function mount(target, anchor) {
        mount_component(helperline, target, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        const helperline_changes = dirty[1] & 2048 ? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter(ctx2[42], "helperLine$"))]) : {};
        if (dirty[2] & 134217728) {
          helperline_changes.$$scope = {dirty, ctx: ctx2};
        }
        helperline.$set(helperline_changes);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(helperline.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(helperline.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(helperline, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_if_block4.name,
      type: "if",
      source: "(219:0) {#if $$slots.helper}",
      ctx
    });
    return block;
  }
  function create_default_slot6(ctx) {
    let current;
    const helper_slot_template = ctx[50].helper;
    const helper_slot = create_slot(helper_slot_template, ctx, ctx[89], get_helper_slot_context);
    const block = {
      c: function create2() {
        if (helper_slot)
          helper_slot.c();
      },
      m: function mount(target, anchor) {
        if (helper_slot) {
          helper_slot.m(target, anchor);
        }
        current = true;
      },
      p: function update2(ctx2, dirty) {
        if (helper_slot) {
          if (helper_slot.p && (!current || dirty[2] & 134217728)) {
            update_slot_base(helper_slot, helper_slot_template, ctx2, ctx2[89], !current ? get_all_dirty_from_scope(ctx2[89]) : get_slot_changes(helper_slot_template, ctx2[89], dirty, get_helper_slot_changes), get_helper_slot_context);
          }
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(helper_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(helper_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (helper_slot)
          helper_slot.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_default_slot6.name,
      type: "slot",
      source: "(220:2) <HelperLine     on:SMUI:textfield:helper-text:id={(event) => (helperId = event.detail)}     on:SMUI:textfield:helper-text:mount={(event) => (helperText = event.detail)}     on:SMUI:textfield:helper-text:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUI:textfield:character-counter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUI:textfield:character-counter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >",
      ctx
    });
    return block;
  }
  function create_fragment7(ctx) {
    let current_block_type_index;
    let if_block0;
    let t;
    let if_block1_anchor;
    let current;
    const if_block_creators = [create_if_block_1, create_else_block_1];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (ctx2[24])
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    let if_block1 = ctx[41].helper && create_if_block4(ctx);
    const block = {
      c: function create2() {
        if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert_dev(target, t, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert_dev(target, if_block1_anchor, anchor);
        current = true;
      },
      p: function update2(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
        if (ctx2[41].helper) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty[1] & 1024) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block4(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if_blocks[current_block_type_index].d(detaching);
        if (detaching)
          detach_dev(t);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach_dev(if_block1_anchor);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment7.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var func4 = ([name, value]) => `${name}: ${value};`;
  var func_12 = ([name, value]) => `${name}: ${value};`;
  function instance_13($$self, $$props, $$invalidate) {
    let valued;
    let inputElement;
    const omit_props_names = [
      "use",
      "class",
      "style",
      "ripple",
      "disabled",
      "required",
      "textarea",
      "variant",
      "noLabel",
      "label",
      "type",
      "value",
      "files",
      "dirty",
      "invalid",
      "prefix",
      "suffix",
      "updateInvalid",
      "validateOnValueChange",
      "useNativeValidation",
      "withLeadingIcon",
      "withTrailingIcon",
      "input",
      "floatingLabel",
      "lineRipple",
      "notchedOutline",
      "focus",
      "layout",
      "getElement"
    ];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Textfield", slots, [
      "label",
      "leadingIcon",
      "default",
      "internalCounter",
      "prefix",
      "suffix",
      "trailingIcon",
      "ripple",
      "helper"
    ]);
    const $$slots = compute_slots(slots);
    const {applyPassive: applyPassive2} = events;
    const forwardEvents = forwardEventsBuilder7(get_current_component());
    let uninitializedValue = () => {
    };
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {style = ""} = $$props;
    let {ripple = true} = $$props;
    let {disabled = false} = $$props;
    let {required = false} = $$props;
    let {textarea = false} = $$props;
    let {variant = textarea ? "outlined" : "standard"} = $$props;
    let {noLabel = false} = $$props;
    let {label = null} = $$props;
    let {type = "text"} = $$props;
    let {value = uninitializedValue} = $$props;
    let {files = uninitializedValue} = $$props;
    let {dirty = false} = $$props;
    let {invalid = uninitializedValue} = $$props;
    let {prefix = null} = $$props;
    let {suffix = null} = $$props;
    let {updateInvalid = invalid === uninitializedValue} = $$props;
    let {validateOnValueChange = updateInvalid} = $$props;
    let {useNativeValidation = updateInvalid} = $$props;
    let {withLeadingIcon = uninitializedValue} = $$props;
    let {withTrailingIcon = uninitializedValue} = $$props;
    let {input = void 0} = $$props;
    let {floatingLabel = void 0} = $$props;
    let {lineRipple = void 0} = $$props;
    let {notchedOutline = void 0} = $$props;
    let element2;
    let instance8;
    let internalClasses = {};
    let internalStyles = {};
    let helperId;
    let focused = false;
    let addLayoutListener = getContext("SMUI:addLayoutListener");
    let removeLayoutListener;
    let initPromiseResolve;
    let initPromise = new Promise((resolve) => initPromiseResolve = resolve);
    let leadingIcon;
    let trailingIcon;
    let helperText;
    let characterCounter;
    let previousValue = value;
    if (addLayoutListener) {
      removeLayoutListener = addLayoutListener(layout);
    }
    onMount(() => {
      $$invalidate(48, instance8 = new MDCTextFieldFoundation({
        addClass,
        removeClass,
        hasClass,
        registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
        registerValidationAttributeChangeHandler: (handler) => {
          const getAttributesList = (mutationsList) => {
            return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
          };
          const observer = new MutationObserver((mutationsList) => {
            if (useNativeValidation) {
              handler(getAttributesList(mutationsList));
            }
          });
          const config = {attributes: true};
          observer.observe(input.getElement(), config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: (observer) => {
          observer.disconnect();
        },
        getNativeInput: () => input.getElement(),
        setInputAttr: (name, value2) => {
          input.addAttr(name, value2);
        },
        removeInputAttr: (name) => {
          input.removeAttr(name);
        },
        isFocused: () => document.activeElement === input.getElement(),
        registerInputInteractionHandler: (evtType, handler) => {
          input.getElement().addEventListener(evtType, handler, applyPassive2());
        },
        deregisterInputInteractionHandler: (evtType, handler) => {
          input.getElement().removeEventListener(evtType, handler, applyPassive2());
        },
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        hasLabel: () => !!floatingLabel,
        shakeLabel: (shouldShake) => floatingLabel && floatingLabel.shake(shouldShake),
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired),
        activateLineRipple: () => lineRipple && lineRipple.activate(),
        deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
        setLineRippleTransformOrigin: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth)
      }, {
        get helperText() {
          return helperText;
        },
        get characterCounter() {
          return characterCounter;
        },
        get leadingIcon() {
          return leadingIcon;
        },
        get trailingIcon() {
          return trailingIcon;
        }
      }));
      if (valued) {
        instance8.init();
      } else {
        tick().then(() => {
          instance8.init();
        });
      }
      initPromiseResolve();
      return () => {
        instance8.destroy();
      };
    });
    onDestroy(() => {
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    });
    function hasClass(className2) {
      return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
    }
    function addClass(className2) {
      if (!internalClasses[className2]) {
        $$invalidate(26, internalClasses[className2] = true, internalClasses);
      }
    }
    function removeClass(className2) {
      if (!(className2 in internalClasses) || internalClasses[className2]) {
        $$invalidate(26, internalClasses[className2] = false, internalClasses);
      }
    }
    function addStyle(name, value2) {
      if (internalStyles[name] != value2) {
        if (value2 === "" || value2 == null) {
          delete internalStyles[name];
          $$invalidate(27, internalStyles);
        } else {
          $$invalidate(27, internalStyles[name] = value2, internalStyles);
        }
      }
    }
    function focus() {
      input.focus();
    }
    function layout() {
      if (instance8) {
        const openNotch = instance8.shouldFloat;
        instance8.notchOutline(openNotch);
      }
    }
    function getElement() {
      return element2;
    }
    function floatinglabel_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        floatingLabel = $$value;
        $$invalidate(5, floatingLabel);
      });
    }
    function floatinglabel_binding_1($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        floatingLabel = $$value;
        $$invalidate(5, floatingLabel);
      });
    }
    function notchedoutline_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        notchedOutline = $$value;
        $$invalidate(7, notchedOutline);
      });
    }
    function textarea_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(3, input);
      });
    }
    function textarea_1_value_binding(value$1) {
      value = value$1;
      $$invalidate(0, value);
    }
    function textarea_1_dirty_binding(value2) {
      dirty = value2;
      $$invalidate(4, dirty);
    }
    function textarea_1_invalid_binding(value2) {
      invalid = value2;
      $$invalidate(2, invalid), $$invalidate(48, instance8), $$invalidate(21, updateInvalid);
    }
    const blur_handler_2 = () => $$invalidate(29, focused = false);
    const focus_handler_2 = () => $$invalidate(29, focused = true);
    function blur_handler(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler(event) {
      bubble.call(this, $$self, event);
    }
    function input_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        input = $$value;
        $$invalidate(3, input);
      });
    }
    function input_1_value_binding(value$1) {
      value = value$1;
      $$invalidate(0, value);
    }
    function input_1_files_binding(value2) {
      files = value2;
      $$invalidate(1, files);
    }
    function input_1_dirty_binding(value2) {
      dirty = value2;
      $$invalidate(4, dirty);
    }
    function input_1_invalid_binding(value2) {
      invalid = value2;
      $$invalidate(2, invalid), $$invalidate(48, instance8), $$invalidate(21, updateInvalid);
    }
    const blur_handler_3 = () => $$invalidate(29, focused = false);
    const focus_handler_3 = () => $$invalidate(29, focused = true);
    function blur_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function focus_handler_1(event) {
      bubble.call(this, $$self, event);
    }
    function lineripple_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        lineRipple = $$value;
        $$invalidate(6, lineRipple);
      });
    }
    function label_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(25, element2);
      });
    }
    const SMUI_textfield_leading_icon_mount_handler = (event) => $$invalidate(30, leadingIcon = event.detail);
    const SMUI_textfield_leading_icon_unmount_handler = () => $$invalidate(30, leadingIcon = void 0);
    const SMUI_textfield_trailing_icon_mount_handler = (event) => $$invalidate(31, trailingIcon = event.detail);
    const SMUI_textfield_trailing_icon_unmount_handler = () => $$invalidate(31, trailingIcon = void 0);
    const SMUI_textfield_character_counter_mount_handler = (event) => $$invalidate(33, characterCounter = event.detail);
    const SMUI_textfield_character_counter_unmount_handler = () => $$invalidate(33, characterCounter = void 0);
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(25, element2);
      });
    }
    const SMUI_textfield_leading_icon_mount_handler_1 = (event) => $$invalidate(30, leadingIcon = event.detail);
    const SMUI_textfield_leading_icon_unmount_handler_1 = () => $$invalidate(30, leadingIcon = void 0);
    const SMUI_textfield_trailing_icon_mount_handler_1 = (event) => $$invalidate(31, trailingIcon = event.detail);
    const SMUI_textfield_trailing_icon_unmount_handler_1 = () => $$invalidate(31, trailingIcon = void 0);
    const SMUI_textfield_helper_text_id_handler = (event) => $$invalidate(28, helperId = event.detail);
    const SMUI_textfield_helper_text_mount_handler = (event) => $$invalidate(32, helperText = event.detail);
    const SMUI_textfield_helper_text_unmount_handler = () => {
      $$invalidate(28, helperId = void 0);
      $$invalidate(32, helperText = void 0);
    };
    const SMUI_textfield_character_counter_mount_handler_1 = (event) => $$invalidate(33, characterCounter = event.detail);
    const SMUI_textfield_character_counter_unmount_handler_1 = () => $$invalidate(33, characterCounter = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(42, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(8, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(9, className = $$new_props.class);
      if ("style" in $$new_props)
        $$invalidate(10, style = $$new_props.style);
      if ("ripple" in $$new_props)
        $$invalidate(11, ripple = $$new_props.ripple);
      if ("disabled" in $$new_props)
        $$invalidate(12, disabled = $$new_props.disabled);
      if ("required" in $$new_props)
        $$invalidate(13, required = $$new_props.required);
      if ("textarea" in $$new_props)
        $$invalidate(14, textarea = $$new_props.textarea);
      if ("variant" in $$new_props)
        $$invalidate(15, variant = $$new_props.variant);
      if ("noLabel" in $$new_props)
        $$invalidate(16, noLabel = $$new_props.noLabel);
      if ("label" in $$new_props)
        $$invalidate(17, label = $$new_props.label);
      if ("type" in $$new_props)
        $$invalidate(18, type = $$new_props.type);
      if ("value" in $$new_props)
        $$invalidate(0, value = $$new_props.value);
      if ("files" in $$new_props)
        $$invalidate(1, files = $$new_props.files);
      if ("dirty" in $$new_props)
        $$invalidate(4, dirty = $$new_props.dirty);
      if ("invalid" in $$new_props)
        $$invalidate(2, invalid = $$new_props.invalid);
      if ("prefix" in $$new_props)
        $$invalidate(19, prefix = $$new_props.prefix);
      if ("suffix" in $$new_props)
        $$invalidate(20, suffix = $$new_props.suffix);
      if ("updateInvalid" in $$new_props)
        $$invalidate(21, updateInvalid = $$new_props.updateInvalid);
      if ("validateOnValueChange" in $$new_props)
        $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
      if ("useNativeValidation" in $$new_props)
        $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
      if ("withLeadingIcon" in $$new_props)
        $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
      if ("withTrailingIcon" in $$new_props)
        $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
      if ("input" in $$new_props)
        $$invalidate(3, input = $$new_props.input);
      if ("floatingLabel" in $$new_props)
        $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
      if ("lineRipple" in $$new_props)
        $$invalidate(6, lineRipple = $$new_props.lineRipple);
      if ("notchedOutline" in $$new_props)
        $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
      if ("$$scope" in $$new_props)
        $$invalidate(89, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      MDCTextFieldFoundation,
      events,
      onMount,
      onDestroy,
      getContext,
      tick,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder7,
      classMap: classMap7,
      exclude,
      prefixFilter,
      useActions: useActions6,
      ContextFragment,
      Ripple,
      FloatingLabel,
      LineRipple,
      NotchedOutline,
      HelperLine,
      Prefix,
      Suffix,
      Input,
      Textarea,
      applyPassive: applyPassive2,
      forwardEvents,
      uninitializedValue,
      use: use2,
      className,
      style,
      ripple,
      disabled,
      required,
      textarea,
      variant,
      noLabel,
      label,
      type,
      value,
      files,
      dirty,
      invalid,
      prefix,
      suffix,
      updateInvalid,
      validateOnValueChange,
      useNativeValidation,
      withLeadingIcon,
      withTrailingIcon,
      input,
      floatingLabel,
      lineRipple,
      notchedOutline,
      element: element2,
      instance: instance8,
      internalClasses,
      internalStyles,
      helperId,
      focused,
      addLayoutListener,
      removeLayoutListener,
      initPromiseResolve,
      initPromise,
      leadingIcon,
      trailingIcon,
      helperText,
      characterCounter,
      previousValue,
      hasClass,
      addClass,
      removeClass,
      addStyle,
      focus,
      layout,
      getElement,
      valued,
      inputElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("uninitializedValue" in $$props)
        $$invalidate(36, uninitializedValue = $$new_props.uninitializedValue);
      if ("use" in $$props)
        $$invalidate(8, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(9, className = $$new_props.className);
      if ("style" in $$props)
        $$invalidate(10, style = $$new_props.style);
      if ("ripple" in $$props)
        $$invalidate(11, ripple = $$new_props.ripple);
      if ("disabled" in $$props)
        $$invalidate(12, disabled = $$new_props.disabled);
      if ("required" in $$props)
        $$invalidate(13, required = $$new_props.required);
      if ("textarea" in $$props)
        $$invalidate(14, textarea = $$new_props.textarea);
      if ("variant" in $$props)
        $$invalidate(15, variant = $$new_props.variant);
      if ("noLabel" in $$props)
        $$invalidate(16, noLabel = $$new_props.noLabel);
      if ("label" in $$props)
        $$invalidate(17, label = $$new_props.label);
      if ("type" in $$props)
        $$invalidate(18, type = $$new_props.type);
      if ("value" in $$props)
        $$invalidate(0, value = $$new_props.value);
      if ("files" in $$props)
        $$invalidate(1, files = $$new_props.files);
      if ("dirty" in $$props)
        $$invalidate(4, dirty = $$new_props.dirty);
      if ("invalid" in $$props)
        $$invalidate(2, invalid = $$new_props.invalid);
      if ("prefix" in $$props)
        $$invalidate(19, prefix = $$new_props.prefix);
      if ("suffix" in $$props)
        $$invalidate(20, suffix = $$new_props.suffix);
      if ("updateInvalid" in $$props)
        $$invalidate(21, updateInvalid = $$new_props.updateInvalid);
      if ("validateOnValueChange" in $$props)
        $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
      if ("useNativeValidation" in $$props)
        $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
      if ("withLeadingIcon" in $$props)
        $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
      if ("withTrailingIcon" in $$props)
        $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
      if ("input" in $$props)
        $$invalidate(3, input = $$new_props.input);
      if ("floatingLabel" in $$props)
        $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
      if ("lineRipple" in $$props)
        $$invalidate(6, lineRipple = $$new_props.lineRipple);
      if ("notchedOutline" in $$props)
        $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
      if ("element" in $$props)
        $$invalidate(25, element2 = $$new_props.element);
      if ("instance" in $$props)
        $$invalidate(48, instance8 = $$new_props.instance);
      if ("internalClasses" in $$props)
        $$invalidate(26, internalClasses = $$new_props.internalClasses);
      if ("internalStyles" in $$props)
        $$invalidate(27, internalStyles = $$new_props.internalStyles);
      if ("helperId" in $$props)
        $$invalidate(28, helperId = $$new_props.helperId);
      if ("focused" in $$props)
        $$invalidate(29, focused = $$new_props.focused);
      if ("addLayoutListener" in $$props)
        addLayoutListener = $$new_props.addLayoutListener;
      if ("removeLayoutListener" in $$props)
        removeLayoutListener = $$new_props.removeLayoutListener;
      if ("initPromiseResolve" in $$props)
        initPromiseResolve = $$new_props.initPromiseResolve;
      if ("initPromise" in $$props)
        $$invalidate(37, initPromise = $$new_props.initPromise);
      if ("leadingIcon" in $$props)
        $$invalidate(30, leadingIcon = $$new_props.leadingIcon);
      if ("trailingIcon" in $$props)
        $$invalidate(31, trailingIcon = $$new_props.trailingIcon);
      if ("helperText" in $$props)
        $$invalidate(32, helperText = $$new_props.helperText);
      if ("characterCounter" in $$props)
        $$invalidate(33, characterCounter = $$new_props.characterCounter);
      if ("previousValue" in $$props)
        $$invalidate(49, previousValue = $$new_props.previousValue);
      if ("valued" in $$props)
        $$invalidate(24, valued = $$new_props.valued);
      if ("inputElement" in $$props)
        $$invalidate(34, inputElement = $$new_props.inputElement);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty[0] & 3) {
        $$invalidate(24, valued = value !== uninitializedValue || files !== uninitializedValue);
      }
      if ($$self.$$.dirty[0] & 8) {
        $$invalidate(34, inputElement = input && input.getElement());
      }
      if ($$self.$$.dirty[0] & 2097156 | $$self.$$.dirty[1] & 131072) {
        if (instance8 && instance8.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(2, invalid = !instance8.isValid());
          } else {
            instance8.setValid(!invalid);
          }
        }
      }
      if ($$self.$$.dirty[1] & 135168) {
        if (instance8 && instance8.getValidateOnValueChange() !== validateOnValueChange) {
          instance8.setValidateOnValueChange(validateOnValueChange === uninitializedValue ? false : validateOnValueChange);
        }
      }
      if ($$self.$$.dirty[1] & 139264) {
        if (instance8) {
          instance8.setUseNativeValidation(useNativeValidation);
        }
      }
      if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 131072) {
        if (instance8) {
          instance8.setDisabled(disabled);
        }
      }
      if ($$self.$$.dirty[0] & 16777217 | $$self.$$.dirty[1] & 393216) {
        if (instance8 && valued && previousValue !== value) {
          $$invalidate(49, previousValue = value);
          if (instance8.getValue() !== value) {
            instance8.setValue(value);
          }
        }
      }
    };
    return [
      value,
      files,
      invalid,
      input,
      dirty,
      floatingLabel,
      lineRipple,
      notchedOutline,
      use2,
      className,
      style,
      ripple,
      disabled,
      required,
      textarea,
      variant,
      noLabel,
      label,
      type,
      prefix,
      suffix,
      updateInvalid,
      withLeadingIcon,
      withTrailingIcon,
      valued,
      element2,
      internalClasses,
      internalStyles,
      helperId,
      focused,
      leadingIcon,
      trailingIcon,
      helperText,
      characterCounter,
      inputElement,
      forwardEvents,
      uninitializedValue,
      initPromise,
      addClass,
      removeClass,
      addStyle,
      $$slots,
      $$restProps,
      validateOnValueChange,
      useNativeValidation,
      focus,
      layout,
      getElement,
      instance8,
      previousValue,
      slots,
      floatinglabel_binding,
      floatinglabel_binding_1,
      notchedoutline_binding,
      textarea_1_binding,
      textarea_1_value_binding,
      textarea_1_dirty_binding,
      textarea_1_invalid_binding,
      blur_handler_2,
      focus_handler_2,
      blur_handler,
      focus_handler,
      input_1_binding,
      input_1_value_binding,
      input_1_files_binding,
      input_1_dirty_binding,
      input_1_invalid_binding,
      blur_handler_3,
      focus_handler_3,
      blur_handler_1,
      focus_handler_1,
      lineripple_binding,
      label_1_binding,
      SMUI_textfield_leading_icon_mount_handler,
      SMUI_textfield_leading_icon_unmount_handler,
      SMUI_textfield_trailing_icon_mount_handler,
      SMUI_textfield_trailing_icon_unmount_handler,
      SMUI_textfield_character_counter_mount_handler,
      SMUI_textfield_character_counter_unmount_handler,
      div_binding,
      SMUI_textfield_leading_icon_mount_handler_1,
      SMUI_textfield_leading_icon_unmount_handler_1,
      SMUI_textfield_trailing_icon_mount_handler_1,
      SMUI_textfield_trailing_icon_unmount_handler_1,
      SMUI_textfield_helper_text_id_handler,
      SMUI_textfield_helper_text_mount_handler,
      SMUI_textfield_helper_text_unmount_handler,
      SMUI_textfield_character_counter_mount_handler_1,
      SMUI_textfield_character_counter_unmount_handler_1,
      $$scope
    ];
  }
  var Textfield = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_13, create_fragment7, safe_not_equal, {
        use: 8,
        class: 9,
        style: 10,
        ripple: 11,
        disabled: 12,
        required: 13,
        textarea: 14,
        variant: 15,
        noLabel: 16,
        label: 17,
        type: 18,
        value: 0,
        files: 1,
        dirty: 4,
        invalid: 2,
        prefix: 19,
        suffix: 20,
        updateInvalid: 21,
        validateOnValueChange: 43,
        useNativeValidation: 44,
        withLeadingIcon: 22,
        withTrailingIcon: 23,
        input: 3,
        floatingLabel: 5,
        lineRipple: 6,
        notchedOutline: 7,
        focus: 45,
        layout: 46,
        getElement: 47
      }, null, [-1, -1, -1, -1]);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Textfield",
        options,
        id: create_fragment7.name
      });
    }
    get use() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get style() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set style(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get ripple() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set ripple(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get disabled() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set disabled(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get required() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set required(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get textarea() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set textarea(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get variant() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set variant(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noLabel() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noLabel(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get label() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set label(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get type() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set type(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get value() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set value(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get files() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set files(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get dirty() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set dirty(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get invalid() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set invalid(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get prefix() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set prefix(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get suffix() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set suffix(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get updateInvalid() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set updateInvalid(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get validateOnValueChange() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set validateOnValueChange(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get useNativeValidation() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set useNativeValidation(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get withLeadingIcon() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set withLeadingIcon(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get withTrailingIcon() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set withTrailingIcon(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get input() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set input(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get floatingLabel() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set floatingLabel(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get lineRipple() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set lineRipple(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get notchedOutline() {
      throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set notchedOutline(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get focus() {
      return this.$$.ctx[45];
    }
    set focus(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get layout() {
      return this.$$.ctx[46];
    }
    set layout(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[47];
    }
    set getElement(value) {
      throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/animationframe.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var AnimationFrame = function() {
    function AnimationFrame2() {
      this.rafIDs = new Map();
    }
    AnimationFrame2.prototype.request = function(key, callback) {
      var _this = this;
      this.cancel(key);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key);
        callback(frame);
      });
      this.rafIDs.set(key, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key) {
      var rafID = this.rafIDs.get(key);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_2, key) {
        _this.cancel(key);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue2 = [];
      this.rafIDs.forEach(function(_2, key) {
        queue2.push(key);
      });
      return queue2;
    };
    return AnimationFrame2;
  }();

  // dist/build/FormField.js
  (function(l, r) {
    if (!l || l.getElementById("livereloadscript"))
      return;
    r = l.createElement("script");
    r.async = 1;
    r.src = "//" + (self.location.host || "localhost").split(":")[0] + ":35729/livereload.js?snipver=1";
    r.id = "livereloadscript";
    l.getElementsByTagName("head")[0].appendChild(r);
  })(self.document);
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses5 = {
    ROOT: "mdc-form-field"
  };
  var strings5 = {
    LABEL_SELECTOR: ".mdc-form-field > label"
  };
  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var MDCFormFieldFoundation = function(_super) {
    __extends(MDCFormFieldFoundation2, _super);
    function MDCFormFieldFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFormFieldFoundation2.defaultAdapter), adapter)) || this;
      _this.click = function() {
        _this.handleClick();
      };
      return _this;
    }
    Object.defineProperty(MDCFormFieldFoundation2, "cssClasses", {
      get: function() {
        return cssClasses5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "strings", {
      get: function() {
        return strings5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "defaultAdapter", {
      get: function() {
        return {
          activateInputRipple: function() {
            return void 0;
          },
          deactivateInputRipple: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFormFieldFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.handleClick = function() {
      var _this = this;
      this.adapter.activateInputRipple();
      requestAnimationFrame(function() {
        _this.adapter.deactivateInputRipple();
      });
    };
    return MDCFormFieldFoundation2;
  }(MDCFoundation);
  var oldModifierRegex8 = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  var newModifierRegex8 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
  function forwardEventsBuilder8(component) {
    let $on;
    let events2 = [];
    const componentOn = component.$on;
    component.$on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let destructor = () => {
      };
      if ($on) {
        destructor = $on(eventType, callback);
      } else {
        events2.push([eventType, callback]);
      }
      const oldModifierMatch = eventType.match(oldModifierRegex8);
      const newModifierMatch = eventType.match(newModifierRegex8);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (oldModifierMatch && console) {
        console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
      }
      const componentDestructor = componentOn.call(component, eventType, callback);
      return (...args) => {
        destructor();
        return componentDestructor(...args);
      };
    };
    function forward(e) {
      bubble(component, e);
    }
    return (node) => {
      const destructors = [];
      const forwardDestructors = {};
      $on = (fullEventType, callback) => {
        let eventType = fullEventType;
        let handler = callback;
        let options = false;
        const oldModifierMatch = eventType.match(oldModifierRegex8);
        const newModifierMatch = eventType.match(newModifierRegex8);
        const modifierMatch = oldModifierMatch || newModifierMatch;
        if (modifierMatch) {
          const parts = eventType.split(oldModifierMatch ? ":" : "$");
          eventType = parts[0];
          options = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
          if (options.nonpassive) {
            options.passive = false;
            delete options.nonpassive;
          }
          if (options.preventDefault) {
            handler = prevent_default(handler);
            delete options.preventDefault;
          }
          if (options.stopPropagation) {
            handler = stop_propagation(handler);
            delete options.stopPropagation;
          }
        }
        const off = listen(node, eventType, handler, options);
        const destructor = () => {
          off();
          const idx = destructors.indexOf(destructor);
          if (idx > -1) {
            destructors.splice(idx, 1);
          }
        };
        destructors.push(destructor);
        if (!eventType in forwardDestructors) {
          forwardDestructors[eventType] = listen(node, eventType, forward);
        }
        return destructor;
      };
      for (let i = 0; i < events2.length; i++) {
        $on(events2[i][0], events2[i][1]);
      }
      return {
        destroy: () => {
          for (let i = 0; i < destructors.length; i++) {
            destructors[i]();
          }
          for (let entry of Object.entries(forwardDestructors)) {
            entry[1]();
          }
        }
      };
    };
  }
  function classMap8(classObj) {
    return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
  }
  function exclude2(obj, keys) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      const cashIndex = name.indexOf("$");
      if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
        continue;
      }
      if (keys.indexOf(name) !== -1) {
        continue;
      }
      newObj[name] = obj[name];
    }
    return newObj;
  }
  function prefixFilter2(obj, prefix) {
    let names = Object.getOwnPropertyNames(obj);
    const newObj = {};
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      if (name.substring(0, prefix.length) === prefix) {
        newObj[name.substring(prefix.length)] = obj[name];
      }
    }
    return newObj;
  }
  function useActions7(node, actions) {
    let objects = [];
    if (actions) {
      for (let i = 0; i < actions.length; i++) {
        const isArray2 = Array.isArray(actions[i]);
        const action = isArray2 ? actions[i][0] : actions[i];
        if (isArray2 && actions[i].length > 1) {
          objects.push(action(node, actions[i][1]));
        } else {
          objects.push(action(node));
        }
      }
    }
    return {
      update(actions2) {
        if ((actions2 && actions2.length || 0) != objects.length) {
          throw new Error("You must not change the length of an actions array.");
        }
        if (actions2) {
          for (let i = 0; i < actions2.length; i++) {
            if (objects[i] && "update" in objects[i]) {
              const isArray2 = Array.isArray(actions2[i]);
              if (isArray2 && actions2[i].length > 1) {
                objects[i].update(actions2[i][1]);
              } else {
                objects[i].update();
              }
            }
          }
        }
      },
      destroy() {
        for (let i = 0; i < objects.length; i++) {
          if (objects[i] && "destroy" in objects[i]) {
            objects[i].destroy();
          }
        }
      }
    };
  }
  var file7 = "node_modules/@smui/form-field/FormField.svelte";
  var get_label_slot_changes2 = (dirty) => ({});
  var get_label_slot_context2 = (ctx) => ({});
  function create_fragment8(ctx) {
    let div;
    let t;
    let label_1;
    let useActions_action;
    let div_class_value;
    let useActions_action_1;
    let current;
    let mounted;
    let dispose;
    const default_slot_template = ctx[13].default;
    const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
    const label_slot_template = ctx[13].label;
    const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context2);
    let label_1_levels = [{for: ctx[4]}, prefixFilter2(ctx[10], "label$")];
    let label_1_data = {};
    for (let i = 0; i < label_1_levels.length; i += 1) {
      label_1_data = assign(label_1_data, label_1_levels[i]);
    }
    let div_levels = [
      {
        class: div_class_value = classMap8({
          [ctx[1]]: true,
          "mdc-form-field": true,
          "mdc-form-field--align-end": ctx[2] === "end",
          "mdc-form-field--nowrap": ctx[3]
        })
      },
      exclude2(ctx[10], ["label$"])
    ];
    let div_data = {};
    for (let i = 0; i < div_levels.length; i += 1) {
      div_data = assign(div_data, div_levels[i]);
    }
    const block = {
      c: function create2() {
        div = element("div");
        if (default_slot)
          default_slot.c();
        t = space();
        label_1 = element("label");
        if (label_slot)
          label_slot.c();
        set_attributes(label_1, label_1_data);
        add_location(label_1, file7, 15, 2, 416);
        set_attributes(div, div_data);
        add_location(div, file7, 0, 0, 0);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (default_slot) {
          default_slot.m(div, null);
        }
        append_dev(div, t);
        append_dev(div, label_1);
        if (label_slot) {
          label_slot.m(label_1, null);
        }
        ctx[14](label_1);
        ctx[15](div);
        current = true;
        if (!mounted) {
          dispose = [
            action_destroyer(useActions_action = useActions7.call(null, label_1, ctx[5])),
            action_destroyer(useActions_action_1 = useActions7.call(null, div, ctx[0])),
            action_destroyer(ctx[9].call(null, div)),
            listen_dev(div, "SMUI:generic:input:mount", ctx[16], false, false, false),
            listen_dev(div, "SMUI:generic:input:unmount", ctx[17], false, false, false)
          ];
          mounted = true;
        }
      },
      p: function update2(ctx2, [dirty]) {
        if (default_slot) {
          if (default_slot.p && (!current || dirty & 4096)) {
            update_slot_base(default_slot, default_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null), null);
          }
        }
        if (label_slot) {
          if (label_slot.p && (!current || dirty & 4096)) {
            update_slot_base(label_slot, label_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes2), get_label_slot_context2);
          }
        }
        set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
          (!current || dirty & 16) && {for: ctx2[4]},
          dirty & 1024 && prefixFilter2(ctx2[10], "label$")
        ]));
        if (useActions_action && is_function(useActions_action.update) && dirty & 32)
          useActions_action.update.call(null, ctx2[5]);
        set_attributes(div, div_data = get_spread_update(div_levels, [
          (!current || dirty & 14 && div_class_value !== (div_class_value = classMap8({
            [ctx2[1]]: true,
            "mdc-form-field": true,
            "mdc-form-field--align-end": ctx2[2] === "end",
            "mdc-form-field--nowrap": ctx2[3]
          }))) && {class: div_class_value},
          dirty & 1024 && exclude2(ctx2[10], ["label$"])
        ]));
        if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & 1)
          useActions_action_1.update.call(null, ctx2[0]);
      },
      i: function intro(local) {
        if (current)
          return;
        transition_in(default_slot, local);
        transition_in(label_slot, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(default_slot, local);
        transition_out(label_slot, local);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching)
          detach_dev(div);
        if (default_slot)
          default_slot.d(detaching);
        if (label_slot)
          label_slot.d(detaching);
        ctx[14](null);
        ctx[15](null);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment8.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  var counter2 = 0;
  function instance_14($$self, $$props, $$invalidate) {
    const omit_props_names = ["use", "class", "align", "noWrap", "inputId", "label$use", "getElement"];
    let $$restProps = compute_rest_props($$props, omit_props_names);
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("FormField", slots, ["default", "label"]);
    const forwardEvents = forwardEventsBuilder8(get_current_component());
    let {use: use2 = []} = $$props;
    let {class: className = ""} = $$props;
    let {align = "start"} = $$props;
    let {noWrap = false} = $$props;
    let {inputId = "SMUI-form-field-" + counter2++} = $$props;
    let {label$use = []} = $$props;
    let element2;
    let instance8;
    let label;
    let input;
    setContext("SMUI:generic:input:props", {id: inputId});
    onMount(() => {
      instance8 = new MDCFormFieldFoundation({
        activateInputRipple: () => {
          if (input) {
            input.activateRipple();
          }
        },
        deactivateInputRipple: () => {
          if (input) {
            input.deactivateRipple();
          }
        },
        deregisterInteractionHandler: (evtType, handler) => {
          label.removeEventListener(evtType, handler);
        },
        registerInteractionHandler: (evtType, handler) => {
          label.addEventListener(evtType, handler);
        }
      });
      instance8.init();
      return () => {
        instance8.destroy();
      };
    });
    function getElement() {
      return element2;
    }
    function label_1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        label = $$value;
        $$invalidate(7, label);
      });
    }
    function div_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        element2 = $$value;
        $$invalidate(6, element2);
      });
    }
    const SMUI_generic_input_mount_handler = (event) => $$invalidate(8, input = event.detail);
    const SMUI_generic_input_unmount_handler = () => $$invalidate(8, input = void 0);
    $$self.$$set = ($$new_props) => {
      $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
      $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
      if ("use" in $$new_props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("class" in $$new_props)
        $$invalidate(1, className = $$new_props.class);
      if ("align" in $$new_props)
        $$invalidate(2, align = $$new_props.align);
      if ("noWrap" in $$new_props)
        $$invalidate(3, noWrap = $$new_props.noWrap);
      if ("inputId" in $$new_props)
        $$invalidate(4, inputId = $$new_props.inputId);
      if ("label$use" in $$new_props)
        $$invalidate(5, label$use = $$new_props.label$use);
      if ("$$scope" in $$new_props)
        $$invalidate(12, $$scope = $$new_props.$$scope);
    };
    $$self.$capture_state = () => ({
      counter: counter2,
      MDCFormFieldFoundation,
      onMount,
      setContext,
      get_current_component,
      forwardEventsBuilder: forwardEventsBuilder8,
      classMap: classMap8,
      exclude: exclude2,
      prefixFilter: prefixFilter2,
      useActions: useActions7,
      forwardEvents,
      use: use2,
      className,
      align,
      noWrap,
      inputId,
      label$use,
      element: element2,
      instance: instance8,
      label,
      input,
      getElement
    });
    $$self.$inject_state = ($$new_props) => {
      if ("use" in $$props)
        $$invalidate(0, use2 = $$new_props.use);
      if ("className" in $$props)
        $$invalidate(1, className = $$new_props.className);
      if ("align" in $$props)
        $$invalidate(2, align = $$new_props.align);
      if ("noWrap" in $$props)
        $$invalidate(3, noWrap = $$new_props.noWrap);
      if ("inputId" in $$props)
        $$invalidate(4, inputId = $$new_props.inputId);
      if ("label$use" in $$props)
        $$invalidate(5, label$use = $$new_props.label$use);
      if ("element" in $$props)
        $$invalidate(6, element2 = $$new_props.element);
      if ("instance" in $$props)
        instance8 = $$new_props.instance;
      if ("label" in $$props)
        $$invalidate(7, label = $$new_props.label);
      if ("input" in $$props)
        $$invalidate(8, input = $$new_props.input);
    };
    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }
    return [
      use2,
      className,
      align,
      noWrap,
      inputId,
      label$use,
      element2,
      label,
      input,
      forwardEvents,
      $$restProps,
      getElement,
      $$scope,
      slots,
      label_1_binding,
      div_binding,
      SMUI_generic_input_mount_handler,
      SMUI_generic_input_unmount_handler
    ];
  }
  var FormField = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance_14, create_fragment8, safe_not_equal, {
        use: 0,
        class: 1,
        align: 2,
        noWrap: 3,
        inputId: 4,
        label$use: 5,
        getElement: 11
      });
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "FormField",
        options,
        id: create_fragment8.name
      });
    }
    get use() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set use(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get class() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set class(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get align() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set align(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get noWrap() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set noWrap(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get inputId() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set inputId(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get label$use() {
      throw new Error("<FormField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    set label$use(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
    get getElement() {
      return this.$$.ctx[11];
    }
    set getElement(value) {
      throw new Error("<FormField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    }
  };

  // dist/build/main.js
  var _tree = {
    name: "_layout",
    filepath: "/_layout.svelte",
    root: true,
    ownMeta: {},
    absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/_layout.svelte",
    children: [
      {
        isFile: true,
        isDir: false,
        file: "_fallback.svelte",
        filepath: "/_fallback.svelte",
        name: "_fallback",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/_fallback.svelte",
        importPath: "../src/pages/_fallback.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: true,
        isPage: false,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/_fallback",
        id: "__fallback",
        component: () => Promise.resolve().then(() => require_fallback()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "help.svelte",
        filepath: "/help.svelte",
        name: "help",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/help.svelte",
        importPath: "../src/pages/help.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/help",
        id: "_help",
        component: () => Promise.resolve().then(() => require_help()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "index.svelte",
        filepath: "/index.svelte",
        name: "index",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/index.svelte",
        importPath: "../src/pages/index.svelte",
        isLayout: false,
        isReset: false,
        isIndex: true,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/index",
        id: "_index",
        component: () => Promise.resolve().then(() => require_index2()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "settings.svelte",
        filepath: "/settings.svelte",
        name: "settings",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/settings.svelte",
        importPath: "../src/pages/settings.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/settings",
        id: "_settings",
        component: () => Promise.resolve().then(() => require_settings()).then((m) => m.default)
      },
      {
        isFile: true,
        isDir: false,
        file: "signup.svelte",
        filepath: "/signup.svelte",
        name: "signup",
        ext: "svelte",
        badExt: false,
        absolutePath: "/Users/jonni/dev/foodsight-frontend/src/pages/signup.svelte",
        importPath: "../src/pages/signup.svelte",
        isLayout: false,
        isReset: false,
        isIndex: false,
        isFallback: false,
        isPage: true,
        ownMeta: {},
        meta: {
          recursive: true,
          preload: false,
          prerender: true
        },
        path: "/signup",
        id: "_signup",
        component: () => Promise.resolve().then(() => require_signup()).then((m) => m.default)
      }
    ],
    isLayout: true,
    isReset: false,
    isIndex: false,
    isFallback: false,
    isPage: false,
    isFile: true,
    file: "_layout.svelte",
    ext: "svelte",
    badExt: false,
    importPath: "../src/pages/_layout.svelte",
    meta: {
      recursive: true,
      preload: false,
      prerender: true
    },
    path: "/",
    id: "__layout",
    component: () => Promise.resolve().then(() => require_layout()).then((m) => m.default)
  };
  var {tree, routes} = buildClientTree(_tree);
  function add_css(target) {
    append_styles(target, "svelte-1udm2va", `*,::before,::after{box-sizing:border-box}html{-moz-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,
		-apple-system, /* Firefox supports this but not yet \`system-ui\` */
		'Segoe UI',
		Roboto,
		Helvetica,
		Arial,
		sans-serif,
		'Apple Color Emoji',
		'Segoe UI Emoji'}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,
		SFMono-Regular,
		Consolas,
		'Liberation Mono',
		Menlo,
		monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button,[type='button'],[type='reset'],[type='submit']{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type='search']{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}button{background-color:transparent;background-image:none}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";line-height:1.5}body{font-family:inherit;line-height:inherit}*,::before,::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:currentColor}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role="button"]{cursor:pointer}:-moz-focusring{outline:auto}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}pre,code,kbd,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,::before,::after{--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-transform:translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-border-opacity:1;border-color:rgba(229, 231, 235, var(--tw-border-opacity));--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);--tw-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.container{width:100%}@media(min-width: 640px){.container{max-width:640px}}@media(min-width: 768px){.container{max-width:768px}}@media(min-width: 1024px){.container{max-width:1024px}}@media(min-width: 1280px){.container{max-width:1280px}}@media(min-width: 1536px){.container{max-width:1536px}}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.-right-1{right:-0.25rem}.top-0{top:0px}.bottom-0{bottom:0px}.right-0{right:0px}.left-0{left:0px}.-right-full{right:-100%}.top-60{top:15rem}.right-full{right:100%}.right-8{right:2rem}.bottom-20{bottom:5rem}.z-40{z-index:40}.z-10{z-index:10}.z-20{z-index:20}.m-0{margin:0px}.mx-auto{margin-left:auto;margin-right:auto}.my-6{margin-top:1.5rem;margin-bottom:1.5rem}.mt-auto{margin-top:auto}.mt-12{margin-top:3rem}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.inline-table{display:inline-table}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row-group{display:table-row-group}.table-row{display:table-row}.flow-root{display:flow-root}.grid{display:grid}.inline-grid{display:inline-grid}.contents{display:contents}.list-item{display:list-item}.hidden{display:none}.h-screen{height:100vh}.h-full{height:100%}.h-96{height:24rem}.h-10{height:2.5rem}.max-h-32{max-height:8rem}.w-full{width:100%}.w-24{width:6rem}.w-screen{width:100vw}.transform{transform:var(--tw-transform)}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-4{gap:1rem}.gap-2{gap:0.5rem}.gap-8{gap:2rem}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.divide-gray-600>:not([hidden])~:not([hidden]){--tw-divide-opacity:1;border-color:rgba(75, 85, 99, var(--tw-divide-opacity))}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.whitespace-nowrap{white-space:nowrap}.break-all{word-break:break-all}.rounded-md{border-radius:0.375rem}.rounded-sm{border-radius:0.125rem}.rounded{border-radius:0.25rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-black{--tw-border-opacity:1;border-color:rgba(0, 0, 0, var(--tw-border-opacity))}.bg-green-500{--tw-bg-opacity:1;background-color:rgba(16, 185, 129, var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgba(0, 0, 0, var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity:1;background-color:rgba(255, 255, 255, var(--tw-bg-opacity))}.bg-opacity-75{--tw-bg-opacity:0.75}.p-4{padding:1rem}.p-2{padding:0.5rem}.p-0{padding:0px}.px-\\[1\\.25rem\\]{padding-left:1.25rem;padding-right:1.25rem}.px-4{padding-left:1rem;padding-right:1rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.py-16{padding-top:4rem;padding-bottom:4rem}.px-8{padding-left:2rem;padding-right:2rem}.py-4{padding-top:1rem;padding-bottom:1rem}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.capitalize{text-transform:capitalize}.italic{font-style:italic}.tracking-widest{letter-spacing:0.1em}.text-gray-200{--tw-text-opacity:1;color:rgba(229, 231, 235, var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgba(107, 114, 128, var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgba(255, 255, 255, var(--tw-text-opacity))}.text-red-500{--tw-text-opacity:1;color:rgba(239, 68, 68, var(--tw-text-opacity))}.text-blue-500{--tw-text-opacity:1;color:rgba(59, 130, 246, var(--tw-text-opacity))}.text-black{--tw-text-opacity:1;color:rgba(0, 0, 0, var(--tw-text-opacity))}.underline{text-decoration:underline}.line-through{text-decoration:line-through}.shadow-xl{--tw-shadow:0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow{--tw-shadow:0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.blur{--tw-blur:blur(8px);filter:var(--tw-filter)}.filter{filter:var(--tw-filter)}.transition{transition-property:background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input{width:auto}@media(min-width: 640px){.sm\\:flex{display:flex}}@media(min-width: 768px){.md\\:ml-auto{margin-left:auto}.md\\:w-10\\/12{width:83.333333%}.md\\:w-6\\/12{width:50%}.md\\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.md\\:flex-row{flex-direction:row}}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFpbHdpbmQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNDLENBQUEsQUFBQSxrQkNhQSxVQUFBLENBQUEsVUFBc0IsQURiUixDQUFkLEFBQUEsSUFBQSxBQUFBLENBQUEsQUNxQkEsYUFBQSxDQUFBLENBQWdCLENBQ2hCLFFBQUEsQ0FBQSxDQUFXLEFEdEJHLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBQytCQSxXQUFBLENBQUEsSUFBaUIsQ0FDakIsd0JBQUEsQ0FBQSxJQUE4QixBRGhDaEIsQ0FBZCxBQUFBLElBQUEsQUFBQSxDQUFBLEFDNkNBLE1BQUEsQ0FBQSxDQUFTLEFEN0NLLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBQ3FEQSxXQUFBOzs7Ozs7OztrQkFTaUIsQUQ5REgsQ0FBZCxBQUFBLEVBQUEsQUFBQSxDQUFBLEFDNEVBLE1BQUEsQ0FBQSxDQUFTLENBQ1QsS0FBQSxDQUFBLE9BQWMsQUQ3RUEsQ0FBZCxBQUFBLFdBQUEsQUFBQSxDQUFBLEFDMEZBLGVBQUEsQ0FBQSxTQUFBLENBQUEsTUFBaUMsQUQxRm5CLENBQWQsQUFBQSxDQUFBLEFBQUEsUUNtR0EsV0FBQSxDQUFBLE1BQW1CLEFEbkdMLENBQWQsQUFBQSxJQUFBLEFBQUEsY0MrR0EsV0FBQTs7Ozs7V0FNVSxDQUNWLFNBQUEsQ0FBQSxHQUFjLEFEdEhBLENBQWQsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBQzhIQSxTQUFBLENBQUEsR0FBYyxBRDlIQSxDQUFkLEFBQUEsR0FBQSxBQUFBLEtDdUlBLFNBQUEsQ0FBQSxHQUFjLENBQ2QsV0FBQSxDQUFBLENBQWMsQ0FDZCxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsY0FBQSxDQUFBLFFBQXdCLEFEMUlWLENBQWQsQUFBQSxHQUFBLEFBQUEsQ0FBQSxBQzhJQSxNQUFBLENBQUEsT0FBZSxBRDlJRCxDQUFkLEFBQUEsR0FBQSxBQUFBLENBQUEsQUNrSkEsR0FBQSxDQUFBLE1BQVcsQURsSkcsQ0FBZCxBQUFBLEtBQUEsQUFBQSxDQUFBLEFDZ0tBLFdBQUEsQ0FBQSxDQUFjLENBQ2QsWUFBQSxDQUFBLE9BQXFCLEFEaktQLENBQWQsQUFBQSxNQUFBLEFBQUEsZ0NDbUxBLFdBQUEsQ0FBQSxPQUFvQixDQUNwQixTQUFBLENBQUEsSUFBZSxDQUNmLFdBQUEsQ0FBQSxJQUFpQixDQUNqQixNQUFBLENBQUEsQ0FBUyxBRHRMSyxDQUFkLEFBQUEsTUFBQSxBQUFBLFFDZ01BLGNBQUEsQ0FBQSxJQUFvQixBRGhNTixDQUFkLEFBQUEsTUFBQSxBQUFBLGdEQzJNQSxrQkFBQSxDQUFBLE1BQTBCLEFEM01aLENBQWQsQUFBQSxrQkFBQSxBQUFBLENBQUEsQUNtTkEsWUFBQSxDQUFBLElBQWtCLENBQ2xCLE9BQUEsQ0FBQSxDQUFVLEFEcE5JLENBQWQsQUFBQSxlQUFBLEFBQUEsQ0FBQSxBQzROQSxPQUFBLENBQUEsR0FBQSxDQUFBLE1BQUEsQ0FBQSxVQUE4QixBRDVOaEIsQ0FBZCxBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBQ3FPQSxVQUFBLENBQUEsSUFBZ0IsQURyT0YsQ0FBZCxBQUFBLE1BQUEsQUFBQSxDQUFBLEFDNk9BLE9BQUEsQ0FBQSxDQUFVLEFEN09JLENBQWQsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBQ3FQQSxjQUFBLENBQUEsUUFBd0IsQURyUFYsQ0FBZCxBQUFBLDJCQUFBLEFBQUEsNkJDOFBBLE1BQUEsQ0FBQSxJQUFZLEFEOVBFLENBQWQsQUFBQSxlQUFBLEFBQUEsQ0FBQSxBQ3VRQSxrQkFBQSxDQUFBLFNBQTZCLENBQzdCLGNBQUEsQ0FBQSxJQUFvQixBRHhRTixDQUFkLEFBQUEsMkJBQUEsQUFBQSxDQUFBLEFDZ1JBLGtCQUFBLENBQUEsSUFBd0IsQURoUlYsQ0FBZCxBQUFBLDRCQUFBLEFBQUEsQ0FBQSxBQ3lSQSxrQkFBQSxDQUFBLE1BQTBCLENBQzFCLElBQUEsQ0FBQSxPQUFhLEFEMVJDLENBQWQsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBQ3VTQSxPQUFBLENBQUEsU0FBa0IsQUR2U0osQ0FBZCxBQUFBLFVBQUEsQUFBQSx5Q0VzQkMsTUFBQSxDQUFBLENBQVMsQUZ0QkksQ0FBZCxBQUFBLE1BQUEsQUFBQSxDQUFBLEFFMEJDLGdCQUFBLENBQUEsV0FBNkIsQ0FDN0IsZ0JBQUEsQ0FBQSxJQUFzQixBRjNCVCxDQUFkLEFBQUEsUUFBQSxBQUFBLENBQUEsQUUrQkMsTUFBQSxDQUFBLENBQVMsQ0FDVCxPQUFBLENBQUEsQ0FBVSxBRmhDRyxDQUFkLEFBQUEsRUFBQSxBQUFBLElFcUNDLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixNQUFBLENBQUEsQ0FBUyxDQUNULE9BQUEsQ0FBQSxDQUFVLEFGdkNHLENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBRXNEQyxXQUFBLENBQUEsYUFBQSxDQUFBLENBQUEsU0FBQSxDQUFBLENBQUEsYUFBQSxDQUFBLENBQUEsa0JBQUEsQ0FBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxtQkFBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQSxrQkFBc1AsQ0FDdFAsV0FBQSxDQUFBLEdBQWdCLEFGdkRILENBQWQsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBRWlFQyxXQUFBLENBQUEsT0FBb0IsQ0FDcEIsV0FBQSxDQUFBLE9BQW9CLEFGbEVQLENBQWQsQUFBQSxDQUFBLEFBQUEsa0JFa0dDLFVBQUEsQ0FBQSxVQUFzQixDQUN0QixZQUFBLENBQUEsQ0FBZSxDQUNmLFlBQUEsQ0FBQSxLQUFtQixDQUNuQixZQUFBLENBQUEsWUFBMEIsQUZyR2IsQ0FBZCxBQUFBLEVBQUEsQUFBQSxDQUFBLEFFNkdDLGdCQUFBLENBQUEsR0FBcUIsQUY3R1IsQ0FBZCxBQUFBLEdBQUEsQUFBQSxDQUFBLEFFMkhDLFlBQUEsQ0FBQSxLQUFtQixBRjNITixDQUFkLEFBQUEsUUFBQSxBQUFBLENBQUEsQUUrSEMsTUFBQSxDQUFBLFFBQWdCLEFGL0hILENBQWQsQUFBQSxrQkFBQSxBQUFBLHVCRW9JQyxPQUFBLENBQUEsQ0FBVSxDQUNWLEtBQUEsQ0FBQSxPQUF3QyxBRnJJM0IsQ0FBZCxBQUFBLE1BQUEsQUFBQSxpQkUwSUMsTUFBQSxDQUFBLE9BQWUsQUYxSUYsQ0FBZCxBQUFBLGVBQUEsQUFBQSxDQUFBLEFFc0pBLE9BQUEsQ0FBQSxJQUFhLEFGdEpDLENBQWQsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBRTBKQyxlQUFBLENBQUEsUUFBeUIsQUYxSlosQ0FBZCxBQUFBLEVBQUEsQUFBQSxnQkVtS0MsU0FBQSxDQUFBLE9BQWtCLENBQ2xCLFdBQUEsQ0FBQSxPQUFvQixBRnBLUCxDQUFkLEFBQUEsQ0FBQSxBQUFBLENBQUEsQUU2S0MsS0FBQSxDQUFBLE9BQWMsQ0FDZCxlQUFBLENBQUEsT0FBd0IsQUY5S1gsQ0FBZCxBQUFBLE1BQUEsQUFBQSxnQ0U4TEMsT0FBQSxDQUFBLENBQVUsQ0FDVixXQUFBLENBQUEsT0FBb0IsQ0FDcEIsS0FBQSxDQUFBLE9BQWMsQUZoTUQsQ0FBZCxBQUFBLEdBQUEsQUFBQSxlRThNQyxXQUFBLENBQUEsWUFBQSxDQUFBLENBQUEsY0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBLGFBQUEsQ0FBQSxDQUFBLFNBQXlJLEFGOU01SCxDQUFkLEFBQUEsR0FBQSxBQUFBLDRDRTBPQyxPQUFBLENBQUEsS0FBYyxDQUNkLGNBQUEsQ0FBQSxNQUFzQixBRjNPVCxDQUFkLEFBQUEsR0FBQSxBQUFBLE9FdVBDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQUZ4UEMsQ0FBZCxBQUFBLFFBQUEsQUFBQSxDQUFBLEFFZ1FDLE9BQUEsQ0FBQSxJQUFhLEFGaFFBLENHRGYsQUFBQSxDQUFBLEFBQUEsQ0FBQSxRQUFBLEFBQUEsQ0FBQSxPQUFBLEFBQUEsQ0FBQSxBQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBLFdBQUEsQ0FBQSxDQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBLENBQUEsWUFBQSxDQUFBLENBQUEsQ0FBQSxjQUFBLENBQUEsZ01BQUEsQ0FBQSxtQkFBQSxDQUFBLENBQUEsQ0FBQSxZQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLG1CQUFBLENBQUEsQ0FBQSxDQUFBLHVCQUFBLENBQUEsU0FBQSxDQUFBLGdCQUFBLENBQUEsU0FBQSxDQUFBLFdBQUEsQ0FBQSxTQUFBLENBQUEsU0FBQSxDQUFBLDJCQUFBLENBQUEsZUFBQSxDQUFBLDJCQUFBLENBQUEsYUFBQSxDQUFBLDJCQUFBLENBQUEsY0FBQSxDQUFBLDJCQUFBLENBQUEsZUFBQSxDQUFBLDJCQUFBLENBQUEsV0FBQSxDQUFBLDJCQUFBLENBQUEsYUFBQSxDQUFBLDJCQUFBLENBQUEsVUFBQSxDQUFBLDJCQUFBLENBQUEsZ0JBQUEsQ0FBQSwyQkFBQSxDQUFBLFdBQUEsQ0FBQSx5S0FBQSxBQ3NZQSxDSnBZQyxBQUFBLFVBQUEsQUFBQSxDQUFBLEFHRkQsS0FBQSxDQUFBLElBQUEsQUhFcUIsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLEtBQUEsQUMwWUMsQ0FBQSxBSnhZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsS0FBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLEtBQUEsQUM2WUMsQ0FBQSxBSjNZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNnWkMsQ0FBQSxBSjlZb0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNtWkMsQ0FBQSxBSmpab0IsQ0FBcEIsTUFBQSxBQUFBLFlBQUEsTUFBQSxDQUFBLEFBQUEsQ0dGRCxBQUFBLFVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE1BQUEsQUNzWkMsQ0FBQSxBSnBab0IsQ0FDcEIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxPQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxRQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFFBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsU0FBQSxBQUFBLENBQUEsQUdIRCxRQUFBLENBQUEsUUFBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxHQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLEdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxJQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELEdBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsV0FBQSxBQUFBLENBQUEsQUdIRCxLQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELE1BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsRUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLEVBQUEsQUhHb0IsQ0FBbkIsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxFQUFBLEFIR29CLENBQW5CLEFBQUEsSUFBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxZQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLE1BQUEsQ0FBQSxhQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLFFBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsS0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFlBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsWUFBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLGFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxVQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsWUFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLG1CQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxrQkFBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxlQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFVBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFNBQUEsQUhHb0IsQ0FBbkIsQUFBQSxLQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsWUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsV0FBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLFFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxTQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLEtBQUEsQUhHb0IsQ0FBbkIsQUFBQSxPQUFBLEFBQUEsQ0FBQSxBR0hELE1BQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsS0FBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxLQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsS0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELEtBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxTQUFBLENBQUEsSUFBQSxjQUFBLENBQUEsQUhHb0IsQ0FBbkIsV0FBQSxBQUFBLElBQUEsQUFBQSxDR0hELEVBQUEsQUFBQSxDQUFBLEFBQUEsU0FBQSxDQUFBLE9BQUEsTUFBQSxDQUFBLEFDdWdCQyxDQUFBLEFKcGdCbUIsQ0FBbkIsQUFBQSxhQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxJQUFBLENBQUEsRUFBQSxDQUFBLE1BQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsZUFBQSxBQUFBLENBQUEsQUdIRCxNQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQscUJBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxXQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLGVBQUEsQUFBQSxDQUFBLEFHSEQsZUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxnQkFBQSxBQUFBLENBQUEsQUdIRCxlQUFBLENBQUEsYUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsR0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxNQUFBLEFBQUEsQ0FBQSxBR0hELEdBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsTUFBQSxBQUFBLENBQUEsQUdIRCxHQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFNBQUEsQUFBQSxDQUFBLGNBQUEsQUFBQSxDQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQscUJBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxtQkFBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLHFCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxjQUFBLEFBQUEsQ0FBQSxjQUFBLEFBQUEsQ0FBQSxBR0hELG1CQUFBLENBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLElBQUEsbUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFHSEQsUUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxnQkFBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLGtCQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSxNQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFdBQUEsQUFBQSxDQUFBLEFHSEQsYUFBQSxDQUFBLFFBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGFBQUEsQ0FBQSxRQUFBLEFIR29CLENBQW5CLEFBQUEsUUFBQSxBQUFBLENBQUEsQUdIRCxhQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLEdBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELG1CQUFBLENBQUEsR0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsbUJBQUEsQ0FBQSxDQUFBLENBQUEsWUFBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxtQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxhQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEVBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxDQUFBLENBQUEsZ0JBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsZUFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxjQUFBLEFBQUEsQ0FBQSxBR0hELGVBQUEsQ0FBQSxJQUFBLEFIR29CLENBQW5CLEFBQUEsSUFBQSxBQUFBLENBQUEsQUdIRCxPQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLElBQUEsQUFBQSxDQUFBLEFHSEQsT0FBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxJQUFBLEFBQUEsQ0FBQSxBR0hELE9BQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLE9BQUEsQ0FBQSxhQUFBLENBQUEsT0FBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLElBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLE1BQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxjQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsWUFBQSxDQUFBLElBQUEsQ0FBQSxhQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLElBQUEsQ0FBQSxjQUFBLENBQUEsSUFBQSxBSEdvQixDQUFuQixBQUFBLFlBQUEsQUFBQSxDQUFBLEFHSEQsVUFBQSxDQUFBLE1BQUEsQUhHb0IsQ0FBbkIsQUFBQSxTQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxNQUFBLENBQUEsV0FBQSxDQUFBLElBQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxPQUFBLENBQUEsV0FBQSxDQUFBLE9BQUEsQUhHb0IsQ0FBbkIsQUFBQSxRQUFBLEFBQUEsQ0FBQSxBR0hELFNBQUEsQ0FBQSxRQUFBLENBQUEsV0FBQSxDQUFBLE9BQUEsQUhHb0IsQ0FBbkIsQUFBQSxZQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSxHQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxjQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLFVBQUEsQUFBQSxDQUFBLEFHSEQsY0FBQSxDQUFBLFNBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxVQUFBLEFIR29CLENBQW5CLEFBQUEsT0FBQSxBQUFBLENBQUEsQUdIRCxVQUFBLENBQUEsTUFBQSxBSEdvQixDQUFuQixBQUFBLGdCQUFBLEFBQUEsQ0FBQSxBR0hELGNBQUEsQ0FBQSxLQUFBLEFIR29CLENBQW5CLEFBQUEsY0FBQSxBQUFBLENBQUEsQUdIRCxpQkFBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsaUJBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLEtBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGlCQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsYUFBQSxBQUFBLENBQUEsQUdIRCxpQkFBQSxDQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsS0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxJQUFBLGlCQUFBLENBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLGNBQUEsQUFBQSxDQUFBLEFHSEQsaUJBQUEsQ0FBQSxDQUFBLENBQUEsS0FBQSxDQUFBLEtBQUEsRUFBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsSUFBQSxpQkFBQSxDQUFBLENBQUEsQUhHb0IsQ0FBbkIsQUFBQSxXQUFBLEFBQUEsQ0FBQSxBR0hELGlCQUFBLENBQUEsQ0FBQSxDQUFBLEtBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsaUJBQUEsQ0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsVUFBQSxBQUFBLENBQUEsQUdIRCxlQUFBLENBQUEsU0FBQSxBSEdvQixDQUFuQixBQUFBLGFBQUEsQUFBQSxDQUFBLEFHSEQsZUFBQSxDQUFBLFlBQUEsQUhHb0IsQ0FBbkIsQUFBQSxVQUFBLEFBQUEsQ0FBQSxBR0hELFdBQUEsQ0FBQSx5RUFBQSxDQUFBLFVBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLGdCQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsV0FBQSxDQUFBLCtEQUFBLENBQUEsVUFBQSxDQUFBLElBQUEsdUJBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsZ0JBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsV0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsS0FBQSxBQUFBLENBQUEsQUdIRCxTQUFBLENBQUEsU0FBQSxDQUFBLE1BQUEsQ0FBQSxJQUFBLFdBQUEsQ0FBQSxBSEdvQixDQUFuQixBQUFBLE9BQUEsQUFBQSxDQUFBLEFHSEQsTUFBQSxDQUFBLElBQUEsV0FBQSxDQUFBLEFIR29CLENBQW5CLEFBQUEsV0FBQSxBQUFBLENBQUEsQUdIRCxtQkFBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxZQUFBLENBQUEsQ0FBQSxLQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQSxNQUFBLENBQUEsQ0FBQSxlQUFBLENBQUEsMEJBQUEsQ0FBQSxhQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLG1CQUFBLENBQUEsS0FBQSxBSEdvQixDR0hwQixBQUFBLEtBQUEsQUFBQSxDQUFBLEFBQUEsS0FBQSxDQUFBLElBQUEsQUN5cEJBLENKenBCQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDR0FBLEFBQUEsU0FBQSxBQUFBLENBQUEsQUFBQSxPQUFBLENBQUEsSUFBQSxBQzJwQkMsQ0FBQSxBQUNELENKNXBCQSxNQUFBLEFBQUEsWUFBQSxLQUFBLENBQUEsQUFBQSxDR0FBLEFBQUEsWUFBQSxBQUFBLENBQUEsQUFBQSxXQUFBLENBQUEsSUFBQSxBQzhwQkMsQ0Q5cEJELEFBQUEsYUFBQSxBQUFBLENBQUEsQUFBQSxLQUFBLENBQUEsVUFBQSxBQ2dxQkMsQ0RocUJELEFBQUEsWUFBQSxBQUFBLENBQUEsQUFBQSxLQUFBLENBQUEsR0FBQSxBQ2txQkMsQ0RscUJELEFBQUEsZ0JBQUEsQUFBQSxDQUFBLEFBQUEscUJBQUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQUNvcUJDLENEcHFCRCxBQUFBLGFBQUEsQUFBQSxDQUFBLEFBQUEsY0FBQSxDQUFBLEdBQUEsQUNzcUJDLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbInNyYy9zcmMvVGFpbHdpbmQuc3ZlbHRlIiwic3JjLyUzQ2lucHV0JTIwY3NzJTIwLXBmckh5JTNFIiwic3JjLyUzQ2lucHV0JTIwY3NzJTIwZjZCLUNwJTNFIiwic3JjLyUzQ25vJTIwc291cmNlJTNFIiwic3JjL1RhaWx3aW5kLnN2ZWx0ZSJdfQ== */`);
  }
  function create_fragment$17(ctx) {
    const block = {
      c: noop,
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: noop,
      p: noop,
      i: noop,
      o: noop,
      d: noop
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment$17.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance$16($$self, $$props) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("Tailwind", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<Tailwind> was created with unknown prop '${key}'`);
    });
    return [];
  }
  var Tailwind = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance$16, create_fragment$17, safe_not_equal, {}, add_css);
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "Tailwind",
        options,
        id: create_fragment$17.name
      });
    }
  };
  function create_fragment9(ctx) {
    let serviceworker;
    let t0;
    let tailwind;
    let t1;
    let router;
    let current;
    serviceworker = new Serviceworker({$$inline: true});
    tailwind = new Tailwind({$$inline: true});
    router = new Router({props: {routes}, $$inline: true});
    const block = {
      c: function create2() {
        create_component(serviceworker.$$.fragment);
        t0 = space();
        create_component(tailwind.$$.fragment);
        t1 = space();
        create_component(router.$$.fragment);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        mount_component(serviceworker, target, anchor);
        insert_dev(target, t0, anchor);
        mount_component(tailwind, target, anchor);
        insert_dev(target, t1, anchor);
        mount_component(router, target, anchor);
        current = true;
      },
      p: noop,
      i: function intro(local) {
        if (current)
          return;
        transition_in(serviceworker.$$.fragment, local);
        transition_in(tailwind.$$.fragment, local);
        transition_in(router.$$.fragment, local);
        current = true;
      },
      o: function outro(local) {
        transition_out(serviceworker.$$.fragment, local);
        transition_out(tailwind.$$.fragment, local);
        transition_out(router.$$.fragment, local);
        current = false;
      },
      d: function destroy(detaching) {
        destroy_component(serviceworker, detaching);
        if (detaching)
          detach_dev(t0);
        destroy_component(tailwind, detaching);
        if (detaching)
          detach_dev(t1);
        destroy_component(router, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block,
      id: create_fragment9.name,
      type: "component",
      source: "",
      ctx
    });
    return block;
  }
  function instance7($$self, $$props, $$invalidate) {
    let {$$slots: slots = {}, $$scope} = $$props;
    validate_slots("App", slots, []);
    const writable_props = [];
    Object.keys($$props).forEach((key) => {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
        console.warn(`<App> was created with unknown prop '${key}'`);
    });
    $$self.$capture_state = () => ({Serviceworker, Router, routes, Tailwind});
    return [];
  }
  var App = class extends SvelteComponentDev {
    constructor(options) {
      super(options);
      init$1(this, options, instance7, create_fragment9, safe_not_equal, {});
      dispatch_dev("SvelteRegisterComponent", {
        component: this,
        tagName: "App",
        options,
        id: create_fragment9.name
      });
    }
  };
  HMR(App, {target: document.body}, "routify-app");
})();
